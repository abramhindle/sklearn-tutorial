@relation large.json
@attribute id integer
@attribute owner string
@attribute content string
@data
9010,'staticfloat','App permissions issues on OS X\nThe app bundle for OS X v0.3.2 has improper permissions. It appears that they are mostly set to uid 501 and staff group 20. This causes numerous problems on multi user systems or using network accounts. \r\n\r\nProper ownership should be root:admin and read only for others. Thanks'
9008,'andreasnoack','Optimize pinv for diagonal matrices\n\r\nIn general, the pseudoinverse is determined to only half of the machine\r\nprecision for general dense ill-conditioned matrices. For diagonal and\r\ncertain other matrices (e.g., tridiagonal matrices), the pseudoinverse\r\ncan be determined more accurately. We try to detect if the matrix is\r\ndiagonal immediately after the call to pinv and invert the diagonal elements\r\nonly without invoking ths svdfact function which is both faster and\r\nmore accurate.\r\n\r\nSince the default threshold can not be determined in advance for arbitrary\r\nmatrices, provide a user-selectable parameter tol and provide a simple\r\nscheme for automatic threshold selection.\r\n\r\npinv(A) sets the threshold tol to eps(one(T))*maximum(size(A)).\r\n\r\npinv(A,tol) sets the user-selectable threshold tol.\r\n\r\npinv(A,0) attempts to determine the threshold tol by forming two pseudoinverses\r\nfor tol=eps(one(T))*maximum(size(A)) and tol=sqrt(eps(one(T)) and estimating\r\nthe error in the first Moore-Penrose relation a*pinv(a)*a = a. This can be done with very little overhead (since svdvals is an expensive call) while using\r\nabout twice as much intermediate memory.\r\n\r\nThe following is the test script and results:\r\n\r\n\r\n```julia\r\n   function hilb(n::Integer)\r\n       a=Array(typeof(1.0),n,n)\r\n       for i=1:n\r\n         for j=1:n\r\n           a[j,i]=1.0/(i+j-1.0)\r\n         end\r\n       end\r\n       return a\r\n   end\r\n   \r\n   function onediag(m::Integer, n::Integer)\r\n       a=zeros(typeof(1.0),m,n)\r\n       for i=1:min(n,m)\r\n           a[i,i]=1.0/(i^5)\r\n       end\r\n       return a\r\n   end\r\n   \r\n   function tridiag(m::Integer, n::Integer)\r\n       a=zeros(typeof(1.0),m,n)\r\n       for i=1:min(n,m)\r\n           a[i,i]=1.0/(i^5)\r\n       end\r\n       for i=1:min(n,m)-1\r\n           a[i+1,i]=1.2/(i^5)\r\n           a[1,i+1]=1.2/(i^5)\r\n       end    \r\n       return a\r\n   end\r\n   \r\n   \r\n   function test_pinv(a)\r\n   \r\n   println("=== julia/matlab pinv, default tol=eps(1.0)*max(size(a)) ===")\r\n   @time apinv = pinv(a);\r\n   \r\n   println(vecnorm(a*apinv*a - a))\r\n   println(vecnorm(apinv*a*apinv - apinv))\r\n   println(vecnorm((a*apinv)\' - a*apinv))\r\n   println(vecnorm((apinv*a)\' - apinv*a))\r\n   x0 = randn(n); b = a*x0; x = apinv*b; \r\n   println(vecnorm(a*x-b))\r\n   \r\n   println("=== julia pinv, tol=sqrt(eps(1.0)) ===")\r\n   @time apinv = pinv(a,sqrt(eps(1.0)));\r\n   \r\n   println(vecnorm(a*apinv*a - a))\r\n   println(vecnorm(apinv*a*apinv - apinv))\r\n   println(vecnorm((a*apinv)\' - a*apinv))\r\n   println(vecnorm((apinv*a)\' - apinv*a))\r\n   x0 = randn(n); b = a*x0; x = apinv*b; \r\n   println(vecnorm(a*x-b))\r\n   \r\n   println("=== julia pinv, adaptive threshold ===")\r\n   @time apinv = pinv(a,0);\r\n   \r\n   println(vecnorm(a*apinv*a - a))\r\n   println(vecnorm(apinv*a*apinv - apinv))\r\n   println(vecnorm((a*apinv)\' - a*apinv))\r\n   println(vecnorm((apinv*a)\' - apinv*a))\r\n   x0 = randn(n); b = a*x0; x = apinv*b; \r\n   println(vecnorm(a*x-b))\r\n   \r\n   end\r\n   \r\n   \r\n   m = 100\r\n   n = 1000\r\n   \r\n   # form an ill-conditioned matrix\r\n   println("\\n--- dense ill-conditioned matrix ---\\n");\r\n   a = randn(m,n) * hilb(n);\r\n   test_pinv(a)\r\n   \r\n   println("\\n--- diagonal matrix ---\\n");\r\n   a = onediag(m,n);\r\n   test_pinv(a)\r\n   \r\n   println("\\n--- tri-diagonal matrix ---\\n");\r\n   a = tridiag(m,n);\r\n   test_pinv(a)\r\n```\r\n\r\nWe are testing the Moore-Penrose pseudoinverse criteria, all output numbers should be as small as possible:\r\n\r\n```\r\n\r\n   --- dense ill-conditioned matrix ---\r\n   \r\n   === julia/matlab pinv, default tol=eps(1.0)*max(size(a)) ===\r\n   elapsed time: 0.024110237 seconds (2979592 bytes allocated)\r\n   8.132311486154941e-5\r\n   202456.53269313014\r\n   8.717569398698316e-5\r\n   0.00042487526397591465\r\n   8.958400718585145e-6\r\n   === julia pinv, tol=sqrt(eps(1.0)) ===\r\n   elapsed time: 0.026959505 seconds (2979464 bytes allocated)\r\n   1.1318678252271499e-7\r\n   0.00044092008873858384\r\n   8.220588998363644e-9\r\n   3.41201657124137e-8\r\n   1.9379690006220722e-8\r\n   === julia pinv, adaptive threshold ===\r\n   elapsed time: 0.027885864 seconds (7306016 bytes allocated)\r\n   1.1318678252271499e-7\r\n   0.00044092008873858384\r\n   8.220588998363644e-9\r\n   3.41201657124137e-8\r\n   5.994505957502731e-8\r\n   \r\n   --- diagonal matrix ---\r\n   \r\n   === julia/matlab pinv, default tol=eps(1.0)*max(size(a)) ===\r\n   elapsed time: 0.000258462 seconds (800048 bytes allocated)\r\n   5.423670138152395e-20\r\n   1.639026212099123e-6\r\n   0.0\r\n   0.0\r\n   1.694331095701549e-21\r\n   === julia pinv, tol=sqrt(eps(1.0)) ===\r\n   elapsed time: 0.000260244 seconds (800048 bytes allocated)\r\n   5.423670138152395e-20\r\n   1.639026212099123e-6\r\n   0.0\r\n   0.0\r\n   5.43175421391522e-20\r\n   === julia pinv, adaptive threshold ===\r\n   elapsed time: 0.000233371 seconds (800048 bytes allocated)\r\n   5.423670138152395e-20\r\n   1.639026212099123e-6\r\n   0.0\r\n   0.0\r\n   2.71084145559175e-20\r\n   \r\n   --- tri-diagonal matrix ---\r\n   \r\n   === julia/matlab pinv, default tol=eps(1.0)*max(size(a)) ===\r\n   elapsed time: 0.009671382 seconds (2980904 bytes allocated)\r\n   2.6789350069963263e-15\r\n   5.6684013753107605\r\n   1.2426503022248955e-8\r\n   4.506044543963786e-5\r\n   2.0526552865923344e-15\r\n   === julia pinv, tol=sqrt(eps(1.0)) ===\r\n   elapsed time: 0.009924386 seconds (2979752 bytes allocated)\r\n   5.000380818672045e-8\r\n   0.0019228562453838195\r\n   2.2514327087865425e-10\r\n   2.4024973745285115e-9\r\n   5.212374715982636e-8\r\n   === julia pinv, adaptive threshold ===\r\n   elapsed time: 0.013035343 seconds (7307616 bytes allocated)\r\n   2.6789350069963263e-15\r\n   5.6684013753107605\r\n   1.2426503022248955e-8\r\n   4.506044543963786e-5\r\n   1.3740389626696697e-15\r\n   \r\n```'
9001,'one-more-minute','Unable to document Base methods from another module?\nI\'ve found that attempts to document methods from Base while in another module fail:\r\n\r\n```julia\r\njulia> @doc """\r\n       Foo\r\n       """ ->\r\n       function Base.sum(a::Vector{Int})\r\n           return NaN\r\n       end\r\nERROR: `doc` has no method matching doc(::Module, ::Void, ::MD, ::Expr)\r\n in anonymous at docs.jl:40\r\n```\r\n\r\nIs this a bug? Or am I using `@doc` improperly?'
8981,'one-more-minute','fix `@doc`  for abstract types\nDocumenting abstract types now works:\r\n```julia\r\n@doc "Doc abstract type" ->\r\nabstract C\r\nDocs.doc(C)\r\n# ->   Doc abstract type\r\n```\r\nI tried to add a  test for it but did not manage to compare two markdown strings.  How would I do that? `md"a"==md"a"` returns false.'
8857,'andreasnoack','SymTridiagonal backslash with integer rhs\n@andreasnoack \r\nas we discussed  T\\ (1:n) for example is currently a bug\r\n'
8851,'JeffBezanson','Odd type bug (?) related to new `call` syntax\nI haven\'t followed this carefully enough to know whether this is something I need to change in my code, or whether it\'s a bug in julia, but my preliminary investigation suggests the latter. Problem was initially reported by PkgEvaluator, https://github.com/timholy/Grid.jl/issues/51. The error message seems quite strange: in [this line](https://github.com/timholy/Grid.jl/blob/500298d4b97b39808deee8b016c3abd90542753c/test/grid.jl#L104), `y` should be a `Vector`, not an `InterpGrid{Float64,1,BCreflect,InterpNearest}`. Moreover, those same lines work fine when run at the REPL:\r\n```julia\r\njulia> ig = InterpGrid(A, BCreflect, InterpNearest)\r\n4-element InterpGrid{Float64,1,BCreflect,InterpNearest}:\r\n 1.0\r\n 2.0\r\n 3.0\r\n 4.0\r\n\r\njulia> y = ig[-3:8]\r\n12-element Array{Float64,1}:\r\n 4.0\r\n 3.0\r\n 2.0\r\n 1.0\r\n 1.0\r\n 2.0\r\n 3.0\r\n 4.0\r\n 4.0\r\n 3.0\r\n 2.0\r\n 1.0\r\n\r\njulia> @assert all(abs(y-A[[4:-1:1,1:4,4:-1:1]]) .< EPS)\r\n\r\njulia>\r\n```\r\nOnce it runs successfully this way, `Grid`\'s tests pass henceforth. However, if I just repeatedly say `include("runtests.jl")`, then it doesn\'t get to the point of running correctly.\r\n\r\n`git bisect` identifies 39dfd9282baf4b0402001149ce759c2db6c660cc as the first bad commit.\r\n'
8807,'JeffBezanson','SubVectors of SubVectors are broken\n```julia\r\njulia> sub(sub([1:5], 1:5), 1:5)\r\nERROR: N not defined\r\n in call at subarray.jl:22\r\n in sub at subarray.jl:98\r\n```\r\n\r\nPresumably a regression since #8712. Encountered in StatsBase (after patching the ArrayViews issue).'
8798,'JeffBezanson','wrong sizeof answer inside function call\n```julia\r\nconst npy_typestrs = Dict( "b1"=>Bool,\r\n                                   "i1"=>Int8,      "u1"=>Uint8,\r\n                                   "i2"=>Int16,     "u2"=>Uint16,\r\n                                   "i4"=>Int32,     "u4"=>Uint32,\r\n                                   "i8"=>Int64,     "u8"=>Uint64)\r\nfunction foo()\r\n    sizeof(npy_typestrs["i8"])\r\nend\r\nfoo(), sizeof(npy_typestrs["i8"])\r\n```\r\nreturns `(56,8)` for me with the latest Julia: clearly(?) the wrong result for the `sizeof` call inside the function  (56 is `sizeof(DataType)`).   (This appears to be the cause of stevengj/PyCall.jl#95)'
8785,'JeffBezanson','Stack overflow in type inference when using a variable `call`\nI\'m seeing a strange regression since #8712 has been merged. In some code, where I\'m using a variable `call` (I know, I know...), type inference recurses endlessly until the stack overflows. I understand that using a variable called `call` might not be the best idea ever, and #8712 merely exposes that, but the resulting behaviour doesn\'t seem proper either.\r\n\r\n~~I have a test-case, but it\'s a pretty convoluted one. Moreover, it uses the CUDA runtime library.~~\r\n**See comments below for shorter test case**\r\n```julia\r\nimmutable CuDriverError\r\n    code::Int\r\nend\r\n\r\nconst libcuda = dlopen("libcuda")\r\n\r\nmacro cucall(f, argtypes, args...)\r\n    quote\r\n        _curet = ccall(dlsym(libcuda, $f), Cint, $argtypes, $(args...))\r\n        if _curet != 0\r\n            err = CuDriverError(int(_curet))\r\n            throw(err)\r\n        end\r\n    end\r\nend\r\n\r\nimmutable CuModule\r\n    handle::Ptr{Void}\r\n\r\n    function CuModule(is_data, mod::ASCIIString)\r\n        a = Ptr{Void}[0]\r\n        call = is_data ? (:cuModuleLoadData) : (:cuModuleLoad)\r\n        @cucall(call, (Ptr{Ptr{Void}}, Ptr{Cchar}), a, mod)\r\n        new(a[1])\r\n    end\r\nend\r\n\r\n@cucall(:cuInit, (Cint,), 0)\r\n\r\na = Ptr{Void}[0]\r\n@cucall(:cuCtxCreate_v2, (Ptr{Ptr{Void}}, Cuint, Cint), a, 0, 0)\r\n\r\nmd = CuModule(true, """\r\n    .version 1.4\r\n    .target sm_10\r\n    .entry foobar() { exit; }\r\n              """)\r\n@cucall(:cuModuleGetFunction, (Ptr{Ptr{Void}}, Ptr{Void}, Ptr{Cchar}), \r\n            a, md.handle, "foobar")\r\n```\r\n\r\nRunning this code on julia master, results in the following error:\r\n```\r\nWarning: imported binding for call overwritten in module Main\r\nERROR: stack overflow\r\n in abstract_call at ./inference.jl:878\r\n in abstract_call at ./inference.jl:879 (repeats 20144 times)\r\n in abstract_call at ./inference.jl:829\r\n in abstract_eval_call at ./inference.jl:921\r\n in abstract_eval at ./inference.jl:946\r\n in abstract_interpret at ./inference.jl:1101\r\n in typeinf at ./inference.jl:1430\r\n in typeinf2407 at /usr/bin/../lib/julia/sys.so\r\n in typeinf_ext at ./inference.jl:1230\r\n in include at ./boot.jl:242\r\n in include_from_node1 at ./loading.jl:128\r\n in process_options at ./client.jl:293\r\n in _start at ./client.jl:362\r\n in _start3748 at /usr/bin/../lib/julia/sys.so\r\nwhile loading bug.jl, in expression starting on line 38\r\n```\r\nAdding some print statements before inference.jl:878, it seems like `f` contains `:cuModuleLoadData`. I\'m not familiar with the type inference code though, so my debugging efforts quickly turned hopeless..\r\n\r\nI tried to reduce the test case as much as possible, but oftentimes changing (seemingly unrelated) stuff breaks the error, presumably due to another path through the type inference mechanism. For example, the following changes hide the issue:\r\n* not throwing an error in `@cucall`, or just throwing `_curet` without going through `CuDeviceError`\r\n* putting global code in `function main()`\r\n* removing the call to `cuModuleGetFunction` -- even though in practice it is never executed\r\n* etc...'
8629,'staticfloat','Fix #8616. Check that input matrix is square in Triangular and a test.\nLet linalg error messages start with small letters.'
8619,'StefanKarpinski',"incorrect hashing of large floats\nFor `Float64`s on the interval (2^63, 2^64), the hashes don't match those of the corresponding Uints (or BigFloats):\r\n```julia\r\njulia> x = 0x1.8p63\r\n1.3835058055282164e19\r\n\r\njulia> u = convert(Uint,x)\r\n0xc000000000000000\r\n\r\njulia> hash(x)\r\n0x9815276104e1427d\r\n\r\njulia> hash(u)\r\n0xf9d22a93486bf9f9\r\n\r\njulia> hash(big(x))\r\n0xf9d22a93486bf9f9\r\n```\r\n\r\nThe problem is that on [this line](https://github.com/JuliaLang/julia/blob/e24fac0f1bb7200e1597d8e546cd445ce4fc0fc0/base/hashing.jl#L61), `fptosi` always returns `-typemin(Int64)` for all values >= 2^63 (this is the same problem as in #7517)."
8613,'ArchRobison','at-simd be messing with my for loops\nConsider the following on commit 215249d, Windows 64-bit:\r\n```julia\r\nIn  [2]: for k = 1:4\r\n    @show k\r\n    for i = 2:4\r\n        @show i\r\n        i == k && continue\r\n    end\r\nend\r\nk = 1\r\ni = 2\r\ni = 3\r\ni = 4\r\nk = 2\r\ni = 2\r\ni = 3\r\ni = 4\r\nk = 3\r\ni = 2\r\ni = 3\r\ni = 4\r\nk = 4\r\ni = 2\r\ni = 3\r\ni = 4\r\n```\r\nAnd with `@simd`\r\n```julia\r\nIn  [3]: for k = 1:4\r\n    @show k\r\n    @simd for i = 2:4\r\n        @show i\r\n        i == k && continue\r\n    end\r\nend\r\nk = 1\r\ni = 2\r\ni = 3\r\ni = 4\r\nk = 2\r\ni = 2\r\ni = 2\r\ni = 2\r\ni = 2\r\ni = 2\r\ni = 2\r\ni = 2\r\ni = 2\r\n... # until I terminate the process\r\n```\r\n@ArchRobison '
8505,'JeffBezanson','Make parametric stagedfunctions work better\n`h` gives what one wants, but it\'s not as pretty as it should be.\r\n\r\n```julia\r\nstagedfunction f{T<:FloatingPoint}(a::Vector{T})\r\n    @show a\r\n    :(println($T))\r\nend\r\n\r\nstagedfunction g(a::Vector)\r\n    T = eltype(a)\r\n    @show a\r\n    :(println($T))\r\nend\r\n\r\nstagedfunction h{T<:FloatingPoint}(a::Vector{T})\r\n    TT = eltype(a)\r\n    @show a\r\n    :(println($TT))\r\nend\r\n```\r\n\r\nTest:\r\n```julia\r\njulia> include("/tmp/params.jl")\r\nh (generic function with 1 method)\r\n\r\njulia> af = [1.0,2.0]\r\n2-element Array{Float64,1}:\r\n 1.0\r\n 2.0\r\n\r\njulia> ai = [1,2]\r\n2-element Array{Int64,1}:\r\n 1\r\n 2\r\n\r\njulia> f(af)\r\na = Array{Float64,1}\r\nERROR: T not defined\r\n in f at /tmp/params.jl:3\r\n\r\njulia> g(af)\r\na = Array{Float64,1}\r\nFloat64\r\n\r\njulia> h(af)\r\na = Array{Float64,1}\r\nFloat64\r\n\r\njulia> f(ai)\r\nERROR: `f` has no method matching f(::Array{Int64,1})\r\n\r\njulia> g(ai)\r\na = Array{Int64,1}\r\nInt64\r\n\r\njulia> h(ai)\r\nERROR: `h` has no method matching h(::Array{Int64,1})\r\n```\r\n'
8479,'jiahao',"WIP: Document tab completions\nThis PR adds a new chapter to the manual listing all currently defined tab completions for Unicode input.\r\n\r\nThe table is generated by a script that loads in `base/latex_symbols.jl` and spits out its contents to a ReST table. \r\n\r\nTo-do\r\n- [x] Where should this go? It really feels like this should be an appendix, but I'm not sure what the best layout should look like.\r\n- [x] ~~`make latexpdf` is very unhappy at the large number of Unicode characters pdflatex has to include.~~ Switched over to using LuaTeX, but it silently drops undefined glyphs from the output :angry: "
8464,'JeffBezanson','cglobal only shows result on assignment\nTrying the example in `http://julia.readthedocs.org/en/latest/manual/calling-c-and-fortran-code/#accessing-global-variables` gives on mac:\r\n````\r\njulia> cglobal((:errno, :libc), Int32)\r\n()\r\n````\r\nbut \r\n````\r\njulia> x = cglobal((:errno, :libc), Int32)\r\nPtr{Int32} @0x00007fff73f4f280\r\n````\r\n\r\nIs this a bug or does the documentation need updating?'
8436,'andreasnoack','backport for #8407, fixes to base/linalg/blas.jl\n* L42: import `BlasReal` and `BlasComplex`\r\n* L143: for `dot`: `BlasFloat` to `BlasReal`\r\n  - BLAS `dot` only applies to real numbers\r\n* L148: for `dotc`: `BlasFloat` to `BlasComplex`\r\n  - BLAS `dotc` only applies to complex numbers\r\n* L153: for `dotu`: `BlasFloat` to `BlasComplex`\r\n  - BLAS `dotu` only applies to complex numbers\r\n* L238: remove line in `iamax`\r\n  - `x` is not an input variable\r\n  - cannot compute length of a pointer\r\n* L308: fix computation of length of output vector in `gbmv`'
8434,'timholy',"`varm` is too strongly typed\nI'll try to tackle this myself, but just posting this as a reminder. See https://github.com/timholy/Images.jl/issues/187. CCing @simonster, @lindahua as the two who have most recently been improving `statistics.jl`.\r\n"
8423,'JeffBezanson','Rename None to Union() and Nothing to Void?\nIn the discussion of #8152, there was some concern about the potential existence of three "NULL"-like types in Julia:\r\n\r\n* None\r\n* Nothing\r\n* Nullable\r\n\r\nOne suggestion was to rename types to clarify their purpose. @JeffBezanson suggested renaming `None` to `Union()` and `Nothing` to `Void` to reflect their respective roles as the empty union of zero types and the result of functions that "do not return a value".\r\n\r\nI personally think this would be a great change.'
8407,'andreasnoack','fix several issues in blas.jl\n* L157: for `dot`: `BlasFloat` to `BlasReal`\r\n  - BLAS `dot` only applies to real numbers\r\n* L162: for `dotc`: `BlasFloat` to `BlasComplex`\r\n  - BLAS `dotc` only applies to complex numbers\r\n* L167: for `dotu`: `BlasFloat` to `BlasComplex`\r\n  - BLAS `dotu` only applies to complex numbers\r\n* L252: comment out line in `iamax`\r\n  - or remove line\r\n  - `x` is not an input variable\r\n  - cannot compute length of a pointer\r\n* L322: fix computation of length of output vector in `gbmv`\r\n* L369: change `cgemv_` to `chemv_` in `hemv!`'
8347,'StefanKarpinski','sortperm ERROR: stack overflow \nVersion 0.3.0 (2014-08-20 20:43 UTC)\r\nOfficial http://julialang.org/ build\r\nx86_64-w64-mingw32\r\n\r\njulia> test3=vec(readcsv("test3.txt"))\r\n5384392-element Array{Float64,1}:\r\njulia> p=sortperm(test3)\r\nERROR: stack overflow\r\n\r\njulia>\r\n\r\nFile with vector after rar has 21MB and is too bigg to atach. Where I can put this vecor for Yours tests?\r\nPaul '
8316,'ViralBShah',"Sort SparseCSC elements function and speed up sparse matrix multiplication\nA suggested addition.\r\n\r\nReplacing the dual transpose used in the sparse matrix multiplication with an in place sort of the rowval and nzval elements. This seems to outperform in particular with larger matrices. \r\n\r\n```\r\njulia> x = sprand(n, m, 0.0002);\r\n\r\njulia> s = sprand(m, k, 0.001);\r\n\r\njulia> @time y = x * s;\r\nelapsed time: 56.447965143 seconds (11903648416 bytes allocated, 0.23% gc time)\r\n\r\njulia> @time y = spmm(x, s);\r\nelapsed time: 35.558409459 seconds (13790626144 bytes allocated, 5.49% gc time)\r\n```\r\n\r\nAvoiding the gc time by improving the allocation of the two Array's would further improve performance, I did test with a if statement to avoid allocations, but that seemed to decrease perf particularly with smaller pairs of matrix.\r\n\r\nEither way, I assume a Sparse sort function would have some longer term benefit.\r\n\r\n[pao: quoting code block]"
8277,'JeffBezanson','Exception causes assignment on previous line to be ignored\nHere are two functions I\'d expect to behave identically:\r\n\r\n~~~\r\nfunction wheee0()\r\n    i = 0\r\n    while true\r\n        try\r\n            if i == 0\r\n                print(".")\r\n            end\r\n            i += 1\r\n            peakflops(1954784290346684782)\r\n        catch\r\n        end\r\n    end\r\nend\r\n\r\nfunction wheee1()\r\n    i = 0\r\n    while true\r\n        try\r\n            i += 1\r\n            if i == 1\r\n                print(".")\r\n            end\r\n            peakflops(1954784290346684782)\r\n        catch\r\n        end\r\n    end\r\nend\r\n~~~\r\n\r\nWhen I run `wheee0()`, `i` never increments and my screen gets filled with `.`. When I run `wheee1()`, I get a single `.`, as expected.\r\n\r\nAdditionally, accessing `i` inside the while loop, (either inside the catch block of after the entire try/catch expression) causes `wheee0` to behave as expected. Accessing `i` after the while loop has no effect.\r\n\r\nI ran into this while trying to create a small, reproducible, test case for some strange behavior on a bad `peakflops` call, but replacing `peakflops` with something else that throws an exception (or just throwing an exception with throw) doesn\'t seem to change the behavior here.'
8243,'andreasnoack','scalar multiplication with triangular matrix is wrong\nThe multiplication of a triangular matrix with a scalar value is wrongly implemented in triangular.jl, lines 155-172\r\n\r\nThe lines\r\nfor i = UpLo == :L ? j:n : 1:j\r\nshould say\r\nfor i = UpLo == :U ? j:n : 1:j\r\n\r\nThe method should probably also work on a copy of A instead of manipulating A itself\r\n\r\nRegards,\r\nTom'
8192,'staticfloat','Avoid warning for possibly non-existing file\n"rm -f" does not fail for a non-existing file, while a pure "rm" would.'
8156,'JeffBezanson',"Nothing field in immutable occupies nonzero space\nhttps://groups.google.com/forum/#!topic/julia-users/2uXsjXuXxn0\r\n```julia\r\nimmutable MyType{A}\r\n    a::A\r\nend\r\nsizeof(MyType(nothing))\r\n8\r\nsizeof(MyType(int8(1)))\r\n1\r\nsizeof(MyType(int16(1)))\r\n2\r\nsizeof(MyType(int32(1)))\r\n4\r\n```\r\n`sizeof(MyType(nothing))` should be `0`, shouldn't it?\r\n\r\ncc: @mlhetland"
8114,'vtjnash',"checked math by default\nas mentioned at JuliaCon, it would be good to try experimenting with a Julia mode that uses checked math (+, *, -) by default. i'm opening this as a reminder (to myself) that this should be tried someday"
8104,'andreasnoack','"randn!" not working properly\nSeem to be an issue of randmtzig_randn here:\r\nhttps://github.com/JuliaLang/julia/blob/05aa8101d1a4ad5b504bb5f4c7f1dc49e82964f4/base/dSFMT.jl#L609\r\n\r\nI am using v0.3.0-rc4.\r\n\r\n```\r\njulia> randn!(MersenneTwister(10), Array(Float64, 10))\r\n10-element Array{Float64,1}:\r\n -0.15548 \r\n  0.798024\r\n -0.682074\r\n  0.105021\r\n  0.1488  \r\n  0.227405\r\n -0.333426\r\n  1.9171  \r\n -0.617443\r\n -0.307516\r\n\r\njulia> randn!(MersenneTwister(10), Array(Float64, 100))\r\nERROR: `rand` has no method matching rand(::DSFMT_state)\r\n in randmtzig_randn at dSFMT.jl:609\r\n in randn! at random.jl:258\r\n\r\n```'
8088,'JeffBezanson','reinterpret is slow\n`reinterpret` is giving considerably slower code than plain `Base.box`.\r\n```julia\r\ntrunc_r(x::Float64) = reinterpret(Float64,reinterpret(Uint64,x) & 0xffff_ffff_f800_0000)\r\ntrunc_b(x::Float64) = Base.box(Float64,Base.box(Uint64,x) & 0xffff_ffff_f800_0000)\r\n```\r\n`trunc_r` is approximately 2.5x slower than `trunc_b`\r\n\r\nThe generated code is the following:\r\n```julia\r\njulia> @code_native trunc_b(1.0)\r\n\t.section\t__TEXT,__text,regular,pure_instructions\r\nFilename: none\r\nSource line: 1\r\n\tpush\tRBP\r\n\tmov\tRBP, RSP\r\nSource line: 1\r\n\tvmovq\tRAX, XMM0\r\n\tand\tRAX, -134217728\r\n\tvmovq\tXMM0, RAX\r\n\tpop\tRBP\r\n\tret\r\n\r\njulia> @code_native trunc_r(1.0)\r\n\t.section\t__TEXT,__text,regular,pure_instructions\r\nFilename: none\r\nSource line: 1\r\n\tpush\tRBP\r\n\tmov\tRBP, RSP\r\n\tmov\tQWORD PTR [RBP - 32], 4\r\nSource line: 1\r\n\tmovabs\tRAX, 4557739952\r\n\tmov\tRCX, QWORD PTR [RAX]\r\n\tmov\tQWORD PTR [RBP - 24], RCX\r\n\tlea\tRCX, QWORD PTR [RBP - 32]\r\n\tmov\tQWORD PTR [RAX], RCX\r\n\tvxorps\tXMM1, XMM1, XMM1\r\n\tvmovups\tXMMWORD PTR [RBP - 16], XMM1\r\nSource line: 1\r\n\tmov\tRCX, QWORD PTR [RBP - 24]\r\n\tmov\tQWORD PTR [RAX], RCX\r\n\tvmovq\tRAX, XMM0\r\n\tand\tRAX, -134217728\r\n\tvmovq\tXMM0, RAX\r\n\tpop\tRBP\r\n\tret\r\n```\r\n\r\nThis makes all the bit-twiddling fun such as the new `frexp` considerably slower.'
8067,'ivarne','Malformed help call freezes Linux machine.\nAfter starting julia in a terminal, I accidentally ran\r\n\r\n```\r\nhelp(rand, 1)\r\n```\r\n\r\nThis completely froze my linux virtual machine (kubuntu 14.04) fo about a minute. Eventually, I got enough linux life to kill off the terminal.\r\n\r\nRunning julia under strace, the problem seems to be memory related, as there are seemingly endless calls to brk()\r\n\r\nThis is user error and thus can be avoided, but the effect on the system is surprisingly aggressive. \r\n\r\nThanks\r\n\r\n```\r\njulia> versioninfo()\r\nJulia Version 0.3.0-rc4+3\r\nCommit 5d865fe (2014-08-19 08:02 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-linux-gnu)\r\n  CPU: Intel(R) Core(TM) i5-4300M CPU @ 2.60GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Nehalem)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-3.3\r\n```'
8063,'StefanKarpinski','Implement Pkg.status(::String)\n```\r\njulia> Pkg.status("BinDeps")\r\n - BinDeps                       0.3.3\r\n\r\njulia> Pkg.status()\r\n27 required packages:\r\n - Calendar                      0.4.2\r\n - Clang                         0.0.1+             master\r\n - DICOM                         0.0.0+             master (dirty)\r\n - DataStructures                0.3.1\r\n - Devectorize                   0.4.0\r\n...\r\n46 additional packages:\r\n - Arduino                       0.1.2+             fix2\r\n - ArrayViews                    0.4.6\r\n - BinDeps                       0.3.3\r\n - Cairo                         0.2.16\r\n...\r\n```'
8058,'andreasnoack',"eigfact() of a symmetric matrix when UnitRange passed causes julia  to exit\nSimilar to issue #8057.\r\n\r\nFollowing code\r\n```julia\r\nG=randn(10,10)\r\nF=eigfact(Symmetric(G*G'),5:11)\r\n```\r\ncauses julia to exit with error.\r\n```\r\n ** On entry to DSYEVR parameter number 10 had an illegal value\r\n```"
8057,'andreasnoack',"eigfact() of a symmetric matrix causes julia  to exit\nFollowing example run in REPL \r\n\r\n    G=randn(2,2)\r\n    F=eigfact(Symmetric(G'*G),4,1)\r\n\r\ncauses Julia to exit with error:\r\n\r\n    ** On entry to DSYEVR parameter number  8 had an illegal value\r\n\r\njulia version 0.3.0-rc4+20"
8034,'quinnj',"dates test failure\nAfter a `make cleanall` and on version:\r\n```\r\nJulia Version 0.4.0-dev+191\r\nCommit 685b1da* (2014-08-17 14:05 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-unknown-linux-gnu)\r\n  CPU: Intel(R) Core(TM)2 Duo CPU     E6550  @ 2.33GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Core2)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-3.3\r\n```\r\n\r\nThe dates tests are failing at `typeof(Dates.now()) <: Dates.DateTime`:\r\n\r\n```\r\n        From worker 2:       * examples\r\n        From worker 3:       * goto\r\n        From worker 3:       * llvmcall\r\n        From worker 3:       * dates\r\n        From worker 2:       * unicode\r\n        From worker 2:       * parallel\r\nWarning: imported binding for oct overwritten in module Main\r\nWarning: imported binding for dec overwritten in module Main\r\nexception on 3: ERROR: test failed: typeof(Dates.now()) <: Dates.DateTime\r\n in default_handler at test.jl:19\r\n in do_test at test.jl:39\r\n in include_string at loading.jl:97\r\n in include_from_node1 at ./loading.jl:131\r\n in runtests at /home/mike/usr/julia/test/testdefs.jl:5\r\n in anonymous at multi.jl:855\r\n in run_work_thunk at multi.jl:621\r\n in anonymous at task.jl:855\r\nwhile loading /home/mike/usr/julia/test/dates/conversions.jl, in expression starting on line 44\r\nwhile loading dates.jl, in expression starting on line 8\r\nERROR: test failed: typeof(Dates.now()) <: Dates.DateTime\r\n in anonymous at task.jl:1367\r\nwhile loading /home/mike/usr/julia/test/dates/conversions.jl, in expression starting on line 44\r\nwhile loading dates.jl, in expression starting on line 8\r\nwhile loading /home/mike/usr/julia/test/runtests.jl, in expression starting on line 36\r\n\r\nMakefile:16: recipe for target 'all' failed\r\nmake[1]: *** [all] Error 1\r\nMakefile:403: recipe for target 'testall' failed\r\nmake: *** [testall] Error 2\r\n```"
8025,'carlobaldassi','findfirst() returns nonzero values upon failure\nThe documentation does not specify what `findfirst()` should return when its argument consists only of false entries. According to https://github.com/JuliaLang/julia/pull/925, it should be 0.\r\n\r\nThe reality looks a bit different, though.\r\n\r\n```julia\r\njulia> findfirst(!,trues(10))\r\n11\r\n\r\njulia> findfirst(falses(10))\r\n0\r\n```\r\n\r\nSo what does `findfirst()` return upon failure then? `0` or `length+1`? Something else?'
8021,'stevengj','Need more \\DeclareUnicodeCharacter in julia/doc/conf.py\nAfter #7918 , there are several more ` \\DeclareUnicodeCharacter` definitions needed in `doc/conf.py` so the LaTeX PDF (`make -C doc latexpdf`) generates without errors and has these new Unicode symbols.'
7984,'Keno','Julia crashes on invalid command line argument\nQuite possibly my fault:\r\n\r\n```\r\n$julia 0x20\r\n\r\nsignal (11): Segmentation fault: 11\r\n_ZNK4llvm26DWARFDebugInfoEntryMinimal22buildAddressRangeTableEPKNS_16DWARFCompileUnitEPNS_17DWARFDebugArangesE at /Users/kfischer/Documents/julia-debug/usr/lib/libjulia.dylib (unknown line)\r\n_ZN4llvm16DWARFCompileUnit22buildAddressRangeTableEPNS_17DWARFDebugArangesEb at /Users/kfischer/Documents/julia-debug/usr/lib/libjulia.dylib (unknown line)\r\n_ZN4llvm17DWARFDebugAranges8generateEPNS_12DWARFContextE at /Users/kfischer/Documents/julia-debug/usr/lib/libjulia.dylib (unknown line)\r\n_ZN4llvm12DWARFContext15getDebugArangesEv at /Users/kfischer/Documents/julia-debug/usr/lib/libjulia.dylib (unknown line)\r\n_ZN4llvm12DWARFContext21getLineInfoForAddressEyNS_19DILineInfoSpecifierE at /Users/kfischer/Documents/julia-debug/usr/lib/libjulia.dylib (unknown line)\r\n_Z14lookup_pointerPN4llvm9DIContextEPPKcPmS4_miPi at /Users/kfischer/Documents/julia-debug/src/./debuginfo.cpp:181\r\n_Z23jl_getDylibFunctionInfoPPKcPmS1_mPii at /Users/kfischer/Documents/julia-debug/src/./debuginfo.cpp:413\r\njl_getFunctionInfo at /Users/kfischer/Documents/julia-debug/src/./debuginfo.cpp:503\r\nframe_info_from_ip at /Users/kfischer/Documents/julia-debug/src/task.c:467\r\nshow_backtrace at replutil.jl:182\r\nshow_backtrace at replutil.jl:169\r\nshowerror at replutil.jl:74\r\njl_apply at /Users/kfischer/Documents/julia-debug/src/gf.c:1416\r\nanonymous at client.jl:77\r\njl_f_apply at /Users/kfischer/Documents/julia-debug/src/builtins.c:281\r\nwith_output_color at util.jl:188\r\njl_apply at /Users/kfischer/Documents/julia-debug/src/gf.c:1416\r\ndisplay_error at client.jl:75\r\njl_apply at /Users/kfischer/Documents/julia-debug/src/gf.c:1416\r\n_start at ./client.jl:403\r\n_start at /Users/kfischer/Documents/julia-debug/usr/lib/julia/sys.dylib (unknown line)\r\njl_apply at /Users/kfischer/Documents/julia-debug/src/./julia.h:981\r\ntrue_main at /Users/kfischer/Documents/julia-debug/julia (unknown line)\r\njulia_trampoline at /Users/kfischer/Documents/julia-debug/src/init.c:1008\r\n```'
7927,'JeffBezanson','Broken pipe @parallel\nThe code \r\n```\r\naddprocs(1)\r\nversioninfo()\r\n\r\n@parallel (+) for i=1:2\r\n\tones(10^6)\r\nend\r\n```\r\nseems to have very different behavior dependent on the platform.\r\n\r\nmachine 1:\r\n```\r\njulia\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.3.0-rc1+40 (2014-07-16 04:30 UTC)\r\n _/ |\\__\'_|_|_|\\__\'_|  |  \r\n|__/                   |  x86_64-apple-darwin13.2.0\r\n\r\njulia> addprocs(1)\r\n\r\n1-element Array{Any,1}:\r\n 2\r\n\r\njulia> versioninfo()\r\nJulia Version 0.3.0-rc1+40\r\nCommit d57e5fa* (2014-07-16 04:30 UTC)\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin13.2.0)\r\n  CPU: Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (NO_AFFINITY)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n\r\njulia> @parallel (+) for i=1:2\r\n           ones(10^6)\r\n       end\r\n1000000-element Array{Float64,1}:\r\n 2.0\r\n 2.0\r\n 2.0\r\n 2.0\r\n 2.0\r\n 2.0\r\n```\r\nas I would expect.\r\n\r\n\r\nmachine 2:\r\n```\r\njulia\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" for help.\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.3.0-rc2+65 (2014-08-08 18:04 UTC)\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 10117ca (0 days old master)\r\n|__/                   |  x86_64-linux-gnu\r\n\r\njulia> addprocs(1)\r\n1-element Array{Any,1}:\r\n 2\r\n\r\njulia> versioninfo()\r\nJulia Version 0.3.0-rc2+65\r\nCommit 10117ca (2014-08-08 18:04 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-linux-gnu)\r\n  CPU: Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Sandybridge)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-3.3\r\n\r\njulia> \r\n\r\njulia> @parallel (+) for i=1:2\r\n           ones(10^6)\r\n       end\r\nWorker 2 terminated.\r\nsignal (13): Broken pipe\r\nwrite at /lib/x86_64-linux-gnu/libpthread.so.0 (unknown line)\r\nuv__write at /home/arnim/julia/deps/libuv/src/unix/stream.c:798\r\nuv__stream_io at /home/arnim/julia/deps/libuv/src/unix/stream.c:1224\r\nuv__io_poll at /home/arnim/julia/deps/libuv/src/unix/linux-core.c:237\r\nuv_run at /home/arnim/julia/deps/libuv/src/unix/core.c:295\r\nprocess_events at ./stream.jl:537\r\nwait at ./task.jl:273\r\nstream_wait at ./stream.jl:263\r\nwrite at stream.jl:788\r\nsend_msg_ at multi.jl:178\r\njlcall_send_msg_;19727 at  (unknown line)\r\njl_apply at /home/arnim/julia/src/gf.c:1429\r\nsend_msg_now at multi.jl:137\r\njl_apply at /home/arnim/julia/src/gf.c:1429\r\njl_apply at /home/arnim/julia/src/builtins.c:332\r\nsend_msg_now at multi.jl:83\r\njl_apply at /home/arnim/julia/src/gf.c:1429\r\ndeliver_result at multi.jl:794\r\njlcall_deliver_result;19724 at  (unknown line)\r\njl_apply at /home/arnim/julia/src/gf.c:1429\r\nanonymous at task.jl:856\r\nstart_task at /home/arnim/julia/src/task.c:427\r\nswitch_stack at /home/arnim/julia/src/task.c:207\r\nswitch_stack at /home/arnim/julia/src/task.c:207\r\njulia_trampoline at /home/arnim/julia/src/init.c:1005\r\nunknown function (ip: 4199789)\r\n__libc_start_main at /lib/x86_64-linux-gnu/libc.so.6 (unknown line)\r\nunknown function (ip: 4199845)\r\nERROR: ProcessExitedException()\r\n in wait at ./task.jl:284\r\n in wait at ./task.jl:194\r\n in wait_full at ./multi.jl:602\r\n in remotecall_fetch at multi.jl:704\r\n in call_on_owner at ./multi.jl:751\r\n in fetch at multi.jl:759\r\n in _mapreduce at reduce.jl:156\r\n in mapreduce at reduce.jl:176\r\n in preduce at multi.jl:1418\r\n\r\n```\r\n(ones(10^6) still works).'
7911,'Keno',"LLVM ERROR when summing Int128s\nWhen running the following command\r\n```sum([int128(1) int128(2)])```\r\nI get the error\r\n```LLVM ERROR: Do not know how to split the result of this operator!```\r\n\r\nThis does not appear to happen when using int64(). Also ```int128(1)+int128(2)``` works as it should.\r\n\r\nVersion Info:\r\nJulia Version 0.3.0-prerelease+3352\r\nCommit 7d6d8cd* (2014-05-30 21:24 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-redhat-linux)\r\n  CPU: Intel(R) Xeon(R) CPU E5-4610 0 @ 2.40GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n\r\nP.S. I'm a mathematician, not a computer scientist, so I don't really know how to obtain a backtrace, sorry! "
7897,'Keno',"mysterious assertion failure when reinterpreting subarrays\nIn my naive attempts to chase the performance rabbit, I came across this interesting case:\r\n```julia\r\nfunction breakme!(data)\r\n    data = reinterpret(Uint32, data)\r\n    a = data[1]\r\nend\r\n\r\na = ones(Uint8, 10)\r\nsa = sub(a,4:6)\r\nbreakme!(sa)\r\n```\r\n\r\nThis causes the following assertion failure:\r\n```\r\n$ julia breakme.jl \r\nAssertion failed: (jb->instance != NULL), function static_void_instance, file ./cgutils.cpp, line 1436.\r\n\r\nsignal (6): Abort trap: 6\r\n__pthread_kill at /usr/lib/system/libsystem_kernel.dylib (unknown line)\r\nAbort trap: 6\r\n```\r\n\r\nSurprisingly, if I comment out the `a = data[1]` line, I get something much more sane:\r\n```\r\n$ julia breakme.jl \r\nERROR: auto_unbox: unable to determine argument type\r\n in breakme! at /Users/sabae/breakme.jl:2\r\n in include at /usr/local/Cellar/julia/HEAD/lib/julia/sys.dylib\r\n in include_from_node1 at loading.jl:128\r\n in process_options at /usr/local/Cellar/julia/HEAD/lib/julia/sys.dylib\r\n in _start at /usr/local/Cellar/julia/HEAD/lib/julia/sys.dylib (repeats 2 times)\r\nwhile loading /Users/sabae/breakme.jl, in expression starting on line 8\r\n```\r\n\r\nAnd it's not the fact that it's trying to read in from `data` that's confusing it; it's the fact that there is an array read at all; it could be a completely different array, and Julia still throws a hissy fit:\r\n```julia \r\nfunction breakme!(data, arr)\r\n    data = reinterpret(Uint32, data)\r\n    a = arr[1]\r\nend\r\n\r\na = ones(Uint8, 10)\r\nsa = sub(a,4:6)\r\nbreakme!(sa, zeros(10))\r\n```"
7895,'Keno','more backtrace regressions\nThis is on linux with current master:\r\n\r\n```\r\njulia> sqrt(-1)\r\nERROR: DomainError\r\n in ??? at ???:140548993642550\r\n\r\njulia> using GU\r\nERROR: GU not found\r\n in require at ./loading.jl:49\r\n in ??? at ???:140549218698419\r\n```\r\n'
7845,'Keno','REPL cursor in wrong place after input with exactly-terminal-width line\nI enter this input:\r\n\r\n```\r\nbegin\r\n   print("a very very very very very very very very very very very very")\r\nend\r\n```\r\n\r\nThe key feature of it is that the final `)` on the second line is in the last possible column.\r\n\r\nNow I hit enter, then up arrow to go back to that input. I get this:\r\n\r\n```\r\njulia> begin\r\n          print("a very very very very very very very very very very very very")\r\n       end\r\na very very _ery very very very very very very very very very\r\njulia> begin\r\n          print("a very very very very very very very very very very very very")\r\n       end\r\n```\r\n\r\nThe cursor ends up exactly one line up from where it should be, marked with an `_` where a `v` should be in the output.'
7836,'JeffBezanson','unnecessary slow code generated by if-then statement\nThe function t2() below runs much more slowly than t1() apparently because a lot of extra unnecessary code is being generated by the compiler.\r\n\r\nmodule testcodegen1\r\n\r\nfunction t1(x::Float64)\r\n    s = 0.0\r\n    for i = 1 : 20000000\r\n        s += sin(x)\r\n    end\r\n    s\r\nend\r\n\r\nfunction t2(x::Float64)\r\n    s = 0.0\r\n    for i = 1 : 20000000\r\n        if true\r\n            s += sin(x)\r\n        else\r\n            s += sin(2*x)\r\n        end\r\n    end\r\n    s\r\nend\r\n\r\nend\r\n\r\n\r\njulia> tic(); testcodegen1.t1(3.0);  toc()\r\ntic(); testcodegen1.t1(3.0);  toc()\r\nelapsed time: 0.216690647 seconds\r\n0.216690647\r\n\r\njulia> tic(); testcodegen1.t2(3.0);  toc()\r\ntic(); testcodegen1.t2(3.0);  toc()\r\nelapsed time: 0.53437478 seconds\r\n0.53437478\r\n'
7821,'Keno','Backtraces are broken on OSX\nWell this is new.  Backtraces appear to be broken on OSX, but only for C code.  Example with my favorite call graph exploration utility `@profile`:\r\n\r\n```\r\njulia> @profile peakflops()\r\n1.6386590022993734e10\r\n\r\njulia> Profile.print()\r\n33 task.jl; anonymous; line: 96\r\n 32 REPL.jl; eval_user_input; line: 54\r\n  32 profile.jl; anonymous; line: 14\r\n   32 linalg/generic.jl; peakflops; line: 324\r\n    5  linalg/generic.jl; peakflops; line: 69\r\n     5 linalg/matmul.jl; gemm_wrapper!; line: 285\r\n      5 linalg/blas.jl; gemm!; line: 526\r\n    27 linalg/generic.jl; peakflops; line: 326\r\n     27 random.jl; rand!; line: 129\r\n 1  REPL.jl; eval_user_input; line: 55\r\n\r\njulia> Profile.print(C=true)\r\n...\r\n33 ???; ???; line: 92035753\r\n 33 ???; ???; line: 92041358\r\n  33 task.jl; anonymous; line: 96\r\n   33 ???; ???; line: 91703924\r\n    33 ???; ???; line: 113759015\r\n     32 REPL.jl; eval_user_input; line: 54\r\n      32 ???; ???; line: 91725559\r\n       32 ???; ???; line: 92069246\r\n        32 profile.jl; anonymous; line: 14\r\n         32 linalg/generic.jl; peakflops; line: 324\r\n          5  linalg/generic.jl; peakflops; line: 69\r\n           5 linalg/matmul.jl; gemm_wrapper!; line: 285\r\n            5 linalg/blas.jl; gemm!; line: 526\r\n             5 ???; ???; line: 131770600\r\n              5 ???; ???; line: 133001818\r\n               5 ???; ???; line: 133002515\r\n                5 ???; ???; line: 134195766\r\n                 4 ???; ???; line: 133003899\r\n                  1 ???; ???; line: 153704009\r\n                  1 ???; ???; line: 153704064\r\n                  1 ???; ???; line: 153704084\r\n...\r\n```\r\n\r\nThis is running on:\r\n```\r\njulia> versioninfo()\r\nJulia Version 0.3.0-rc1+314\r\nCommit e8e461e* (2014-08-02 21:40 UTC)\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin13.3.0)\r\n  CPU: Intel(R) Core(TM) i5-4258U CPU @ 2.40GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Haswell)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n  LLVM: libLLVM-3.3\r\n```'
7789,'staticfloat','git test fails when current user has no name\nI get this when running tests on a VM to build RPM packages. I guess this happens because the user does not have any name set. Should tests use a dummy identity so that they work in all situations,  or should I set up the identity manually to work around this?\r\n\r\n```\r\n     \x1b[1m*\x1b[0m \x1b[31mgit\x1b[0m\r\n*** Please tell me who you are.\r\nRun\r\n  git config --global user.email "you@example.com"\r\n  git config --global user.name "Your Name"\r\nto set your account\'s default identity.\r\nOmit --global to set the identity only in this repository.\r\nfatal: empty ident name (for <mockbuild@i-00011514.(none)>) not allowed\r\nexception on 1: ERROR: failed process: Process(`git commit -q --allow-empty -m \'initial empty commit\'`, ProcessExited(128)) [128]\r\n in pipeline_error at process.jl:502\r\n in anonymous at git.jl:11\r\n in cd at ./file.jl:20\r\n in anonymous at no file:8\r\n in runtests at /builddir/build/BUILD/julia-master/test/testdefs.jl:5\r\n in anonymous at multi.jl:660\r\n in run_work_thunk at multi.jl:621\r\n in remotecall_fetch at multi.jl:694\r\n in remotecall_fetch at multi.jl:709\r\n in anonymous at task.jl:1362\r\nwhile loading git.jl, in expression starting on line 8\r\nERROR: failed process: Process(`git commit -q --allow-empty -m \'initial empty commit\'`, ProcessExited(128)) [128]\r\n in pipeline_error at process.jl:502\r\n in anonymous at git.jl:11\r\n in cd at ./file.jl:20\r\n in anonymous at no file:8\r\n in runtests at /builddir/build/BUILD/julia-master/test/testdefs.jl:5\r\n in anonymous at multi.jl:660\r\n in run_work_thunk at multi.jl:621\r\n in remotecall_fetch at multi.jl:694\r\n in remotecall_fetch at multi.jl:709\r\n in anonymous at task.jl:1362\r\nwhile loading git.jl, in expression starting on line 8\r\nwhile loading /builddir/build/BUILD/julia-master/test/runtests.jl, in expression starting on line 46\r\nmake: *** [git] Error 1\r\n```\r\n'
7786,'staticfloat',"netload/ltests.jl doesn't work\n```sh\r\n~/julia/test/netload$ julia ltests.jl \r\nTesting repeated 10^5 connect/disconnects....ERROR: open_any_tcp_port not defined\r\n in include at ./boot.jl:245\r\n in include_from_node1 at loading.jl:128\r\n in process_options at ./client.jl:285\r\n in _start at ./client.jl:354\r\nwhile loading /Users/jiahao/local/src/julia/test/netload/ltests.jl, in expression starting on line 8\r\n```"
7773,'Keno','Error compiling against llvm-svn\nJulia fails to compile against svn version of LLVM with the following error\r\n```\r\nmake[4]: Entering directory `/builddir/build/BUILD/julia-test/src\'\r\n    CC src/jltypes.o\r\n    CC src/gf.o\r\n    FLISP src/julia_flisp.boot\r\n    FLISP src/julia_flisp.boot.inc\r\n    CC src/ast.o\r\n    CC src/builtins.o\r\n    CC src/module.o\r\n    CC src/codegen.o\r\ncodegen.cpp: In function ‘llvm::Function* emit_function(jl_lambda_info_t*, bool)’:\r\ncodegen.cpp:3452:80: error: no matching function for call to ‘llvm::DIBuilder::createSubroutineType(llvm::DIFile&, llvm::DIArray&)’\r\n         DICompositeType subrty = dbuilder.createSubroutineType(fil,EltTypeArray);\r\n                                                                                ^\r\ncodegen.cpp:3452:80: note: candidate is:\r\nIn file included from codegen.cpp:43:0:\r\n/builddir/build/BUILD/julia-test/usr/include/llvm/IR/DIBuilder.h:437:22: note: llvm::DISubroutineType llvm::DIBuilder::createSubroutineType(llvm::DIFile, llvm::DITypeArray, unsigned int)\r\n     DISubroutineType createSubroutineType(DIFile File,\r\n                      ^\r\n/builddir/build/BUILD/julia-test/usr/include/llvm/IR/DIBuilder.h:437:22: note:   no known conversion for argument 2 from ‘llvm::DIArray {aka llvm::DITypedArray<llvm::DIDescriptor>}’ to ‘llvm::DITypeArray {aka llvm::DITypedArray<llvm::DIRef<llvm::DIType> >}’\r\nmake[4]: *** [codegen.o] Error 1\r\nmake[4]: Leaving directory `/builddir/build/BUILD/julia-test/src\'\r\nmake[3]: *** [julia-release] Error 2\r\nmake[3]: Leaving directory `/builddir/build/BUILD/julia-test\'\r\nmake[2]: *** [release] Error 2\r\nmake[2]: Leaving directory `/builddir/build/BUILD/julia-test\'\r\nmake[1]: *** [install] Error 2\r\nmake[1]: Leaving directory `/builddir/build/BUILD/julia-test\'\r\nmake: *** [dist] Error 2\r\n```\r\n\r\nI believe, it is due to commit https://github.com/llvm-mirror/llvm/commit/3cbd21c987a84b6aaa547f61bed5eda4b4ff9cb1 https://github.com/llvm-mirror/llvm/commit/807538b567af91393264a425ed985b57bd908e71\r\n\r\nI picked changes from above commit to make julia compile. Here is my copy-paste patch (needs to be wrapped into ifdef LLVM35 I presume)\r\n```\r\ndiff --git a/src/codegen.cpp b/src/codegen.cpp\r\nindex 880152e..73a0104 100644\r\n--- a/src/codegen.cpp\r\n+++ b/src/codegen.cpp\r\n@@ -3427,7 +3427,7 @@ static Function *emit_function(jl_lambda_info_t *lam, bool cstyle)\r\n     BasicBlock *b0 = BasicBlock::Create(jl_LLVMContext, "top", f);\r\n     builder.SetInsertPoint(b0);\r\n\r\n-    llvm::DIArray EltTypeArray = dbuilder.getOrCreateArray(ArrayRef<Value*>());\r\n+    llvm::DITypeArray EltTypeArray = dbuilder.getOrCreateTypeArray(None);\r\n     //ios_printf(ios_stderr, "\\n*** compiling %s at %s:%d\\n\\n",\r\n     //           lam->name->name, filename.c_str(), lno);\r\n\r\n@@ -3449,7 +3449,7 @@ static Function *emit_function(jl_lambda_info_t *lam, bool cstyle)\r\n         assert(CU.Verify());\r\n         #endif\r\n\r\n-        DICompositeType subrty = dbuilder.createSubroutineType(fil,EltTypeArray);\r\n+        DISubroutineType subrty = dbuilder.createSubroutineType(fil,EltTypeArray);\r\n\r\n         fil = dbuilder.createFile(filename, ".");\r\n         #ifndef LLVM34\r\n```'
7740,'vtjnash','uv_backend_timeout\n`uv_backend_timeout` returns the wrong value (`0`) on windows. this is inconsistent with the behavior on unix and prevents embedding of the uv event loop.\r\n\r\n(putting this issue here as a reminder to myself to go fix this for 0.3)'
7702,'ivarne','better message for raising integer to a negative integer\nIs throwing a DomainError intended behavior when raising to a negative integer?\r\n\r\njulia> VERSION\r\nv"0.3.0-rc1+86"\r\n\r\njulia> 2^-1\r\nERROR: DomainError\r\n in power_by_squaring at intfuncs.jl:60\r\n in ^ at intfuncs.jl:84\r\n\r\njulia> 2^-1.\r\n0.5'
7693,'jiahao','Make doctests pass\nReflects lots of small changes in printouts and error messages, line numbers, etc.\r\n\r\nNontrivial changes:\r\n- Bump JuliaDoc submodule\r\n- The control flow documentation had to be reformatted slightly to make\r\n  doctests pass.  The output of Task(...) now prints out a memory\r\n  address which is clearly not reproducible, so the output is\r\n  suppressed.\r\n- Some roundoff printing issues in complex-and-rational-numbers?\r\n- isequal(NaN,NaN32) == true\r\n- ~~It also looks like sqrt(-1) no longer prints a helpful error message\r\n  about trying sqrt(complex(-1))...?~~\r\n- strings.rst, line 239: "ERROR: BoundsError() in getindex at\r\n  ascii.jl:11" no longer prints out traceback??\r\n- control-flow.rst, line 638: UndefVarError->MyUndefVarError to prevent\r\n  overwriting Base UndefVarError\r\n\r\nThe output blocks containing Unions have been demoted to ordinary code blocks instead of doctests\r\n<strike>WARNING: Because union types appear to be unsorted on output, sometimes\r\nUnion(a,b) is printed out as Union(b,a). This causes the doctests to\r\nfail nondeterministically, e.g.\r\n\r\nFailed example:\r\n    super(Union(Float64,Int64))\r\nExpected:\r\n    ERROR: `super` has no method matching super(::Type{Union(Float64,Int64)})\r\nGot:\r\n    ERROR: `super` has no method matching super(::Type{Union(Int64,Float64)})~~\r\n</strike>'
7679,'JeffBezanson','Comprehension binding regression\nComprehensions no longer get new bindings for the iteration variable for each iteration, as reported [here](https://groups.google.com/forum/#!topic/julia-users/0J9UMOWFtUI), ref #1571. This was caused by e65f31e93b8c9bcdd1d95aca66b908a5560f8852. cc @JeffBezanson '
7621,'JeffBezanson','Unable to import package after workspace()\n```julia\r\njulia> import NumericExtensions\r\nWarning: could not import Base.add! into NumericExtensions\r\n\r\njulia> workspace()\r\n\r\njulia> import NumericExtensions\r\nWarning: requiring "NumericExtensions" did not define a corresponding module.\r\n```\r\n'
7575,'staticfloat',"0.3 nightly doesn't run on OS X 10.6\nI was helping a user get Julia set up and ran into this issue:\r\n```\r\n$ exec '/Applications/Julia-0.3.0-prerelease-3e6a6c7bd8.app/Contents/Resources/julia/bin/julia'\r\ndyld: lazy symbol binding failed: Symbol not found: __dyld_find_unwind_sections\r\n  Referenced from: /Applications/Julia-0.3.0-prerelease-3e6a6c7bd8.app/Contents/Resources/julia/bin/../lib/julia/libjulia.dylib\r\n  Expected in: /usr/lib/libSystem.B.dylib\r\n\r\ndyld: Symbol not found: __dyld_find_unwind_sections\r\n  Referenced from: /Applications/Julia-0.3.0-prerelease-3e6a6c7bd8.app/Contents/Resources/julia/bin/../lib/julia/libjulia.dylib\r\n  Expected in: /usr/lib/libSystem.B.dylib\r\n```\r\nThe 0.2.1 binary starts up properly."
7574,'tkelman',"chmod() missing Julia-side\nAlongside #7573, it seems that we do indeed have a `chmod` within libuv, but it's not wrapped in Julia at all.  We should probably support that so that if we somehow manage to create a read-only file on Windows, we can make it writable so that we can delete it."
7567,'staticfloat','Sys.dllist() segfaults on current master with svn llvm\nJulia Version 0.3.0-prerelease+4143\r\nCommit 3962af2* (2014-07-11 16:43 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-unknown-linux-gnu)\r\n  CPU: Intel(R) Core(TM)2 Duo CPU     T9900  @ 3.06GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Penryn)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n\r\ncc: @staticfloat '
7549,'Keno','libuv-related? intermittent segfault at completion of certain test combinations\nThis often, but not always, exits with a segfault on my machine:\r\n```\r\n$ JULIA_CPU_CORES=1 ~/src/julia/usr/bin/julia-debug runtests.jl socket sysinfo rounding mod2pi show; echo $?\r\n     * socket\r\n     * sysinfo\r\n     * rounding\r\n     * mod2pi\r\n     * show\r\n    SUCCESS\r\nSegmentation fault (core dumped)\r\n139\r\n```\r\nIt also sometimes exits with code 1 (which is sufficient to cause Travis errors). Note that `make testall; echo $?` gives a normal exit code of 0, and the above with `runtests.jl all` does not segfault (or at least, I haven\'t seen it do so yet) but gives an exit code of 1.\r\n\r\nFrustratingly, when I run it under gdb I haven\'t been able to trigger the segfault. However, the exit code 1 seems to occur inside `uv_run`:\r\n```\r\n(gdb) b init.c:461\r\nBreakpoint 1 at 0x7ffff6e2f626: file init.c, line 461.\r\n(gdb) run runtests.jl socket sysinfo rounding mod2pi show\r\nStarting program: /home/tim/src/julia/usr/bin/julia-debug runtests.jl socket sysinfo rounding mod2pi show\r\n[Thread debugging using libthread_db enabled]\r\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\r\n[New Thread 0x7ffff1b75700 (LWP 13538)]\r\n[New Thread 0x7ffff1374700 (LWP 13539)]\r\n[New Thread 0x7fffeeb73700 (LWP 13540)]\r\n     * socket\r\n[New Thread 0x7fffe781c700 (LWP 13545)]\r\n[New Thread 0x7fffe701b700 (LWP 13546)]\r\n[New Thread 0x7fffe681a700 (LWP 13547)]\r\n[New Thread 0x7fffe6019700 (LWP 13548)]\r\n     * sysinfo\r\n     * rounding\r\n     * mod2pi\r\n     * show\r\n    SUCCESS\r\n\r\nBreakpoint 1, uv_atexit_hook () at init.c:461\r\n461         uv_run(loop,UV_RUN_DEFAULT); //let libuv spin until everything has finished closing\r\n(gdb) finish\r\nRun till exit from #0  uv_atexit_hook () at init.c:461\r\n[Thread 0x7fffe701b700 (LWP 13546) exited]\r\n[Thread 0x7fffe6019700 (LWP 13548) exited]\r\n[Thread 0x7fffe681a700 (LWP 13547) exited]\r\n[Thread 0x7fffe781c700 (LWP 13545) exited]\r\n[Thread 0x7ffff1374700 (LWP 13539) exited]\r\n[Thread 0x7ffff1b75700 (LWP 13538) exited]\r\n[Thread 0x7fffeeb73700 (LWP 13540) exited]\r\n[Inferior 1 (process 13535) exited with code 01]\r\n(gdb) run runtests.jl rounding mod2pi\r\nStarting program: /home/tim/src/julia/usr/bin/julia-debug runtests.jl rounding mod2pi\r\n[Thread debugging using libthread_db enabled]\r\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\r\n[New Thread 0x7ffff1b75700 (LWP 13551)]\r\n[New Thread 0x7ffff1374700 (LWP 13552)]\r\n[New Thread 0x7fffeeb73700 (LWP 13553)]\r\n     * rounding\r\n     * mod2pi\r\n    SUCCESS\r\n\r\nBreakpoint 1, uv_atexit_hook () at init.c:461\r\n461         uv_run(loop,UV_RUN_DEFAULT); //let libuv spin until everything has finished closing\r\n(gdb) finish\r\nRun till exit from #0  uv_atexit_hook () at init.c:461\r\n0x00007ffff4d83979 in julia__start;17052 () at client.jl:412\r\n412     client.jl: No such file or directory.\r\n(gdb) c\r\nContinuing.\r\n[Thread 0x7ffff1374700 (LWP 13552) exited]\r\n[Thread 0x7fffeeb73700 (LWP 13553) exited]\r\n[Thread 0x7ffff1b75700 (LWP 13551) exited]\r\n[Inferior 1 (process 13550) exited normally]\r\n```\r\n\r\n```\r\njulia> versioninfo()\r\nJulia Version 0.3.0-prerelease+4096\r\nCommit b43b391* (2014-07-09 08:58 UTC)\r\nDEBUG build\r\nPlatform Info:\r\n  System: Linux (x86_64-linux-gnu)\r\n  CPU: Intel(R) Core(TM) i7 CPU       L 640  @ 2.13GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Nehalem)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n```'
7441,'JeffBezanson','No InexactError for Int32\nI am running Julia Version 0.3.0-prerelease+3679. Commit d0eac34\r\non Windows with WORD_SIZE 32.\r\n\r\nThe following behavior is inconsistent:\r\n`int64(2.0^300)   # throws InexactError()`\r\n`int32(2.0^300)   # throws InexactError()`\r\nbut\r\n`int64(2.0^50)  # 1125899906842624`\r\n`int32(2.0^50)  # 0`\r\nSo for `int32` `InexactError` is not thrown when value is too big for 32-bits but less than 64-bits. I would expect Julia to consistently throw `InexactError` in such cases.\r\n\r\nThe reason for this behavior is line 81 in file float.jl:\r\n`iround(x::Float64) = int32(box(Int64,fpsiround(unbox(Float64,x))))`'
7372,'JeffBezanson','Incorrect line with "non-boolean (Int64) used in boolean context" error\nWith the function below I made a mistake and got a very explicit error. Only the line was clearly incorrect: the problem is actually `subset[i] || continue` at line 38.\r\n```julia\r\nfunction test(x::AbstractVector...;\r\n                    subset::Union(Nothing, AbstractVector{Int}, AbstractVector{Bool}, BitVector) = nothing,\r\n                    weights::Union(Nothing, AbstractVector{Number}) = nothing)\r\n    n = length(x)\r\n    l = map(length, x)\r\n    vtypes = map(eltype, x)\r\n\r\n    for i in 1:n\r\n        if l[1] != l[i]\r\n            error("arguments are not of the same length: $l")\r\n        end\r\n    end\r\n\r\n    if (isa(subset, AbstractVector{Bool}) || isa(subset, BitVector)) && length(subset) != l[1]\r\n        error("\'subset\' (length $(length(subset))) must be of the same length as vectors (length $(l[1])) when it is boolean")\r\n    end\r\n\r\n    if weights != nothing && length(weights) != l[1]\r\n        error("\'weights\' (length $(length(weights))) must be of the same length as vectors (length $(l[1]))")\r\n    end\r\n\r\n    d = cell(n)\r\n\r\n    if weights == nothing\r\n        counts = Array(Int, 0)\r\n    else\r\n        counts = Array(eltype(weights), 0)\r\n    end\r\n\r\n    a = Array(Int, (0, 0))\r\n    el = cell(n)\r\n\r\n    if subset == nothing\r\n        subset = 1:l[1]\r\n    end\r\n\r\n    for i in subset\r\n        subset[i] || continue\r\n\r\n        for j in 1:n\r\n            pos = findfirst(a, x[j][i])\r\n            if pos == 0\r\n                d = push!(d, x[j][i])\r\n                a = cat(j, a, zeros(Int, ntuple(n - 1, k -> k >= j ? k : k + 1)))\r\n                pos = length(d)\r\n            end\r\n\r\n            @inbounds el[j] = pos\r\n        end\r\n\r\n        @inbounds a[el...] += 1\r\n    end\r\nend\r\n\r\njulia> test([1:10]);\r\nERROR: type: non-boolean (Int64) used in boolean context\r\n in test at none:9\r\n```\r\n\r\nI\'ve tried making a shorter example, but the bug vanishes when removing apparently unrelated code. For example, this version prints the correct line number:\r\n```julia\r\nfunction test2(x::AbstractVector...;\r\n                    subset::Union(Nothing, AbstractVector{Int}, AbstractVector{Bool}, BitVector) = nothing,\r\n                    weights::Union(Nothing, AbstractVector{Number}) = nothing)\r\n    n = length(x)\r\n    l = map(length, x)\r\n    vtypes = map(eltype, x)\r\n\r\n    d = cell(n)\r\n\r\n    if weights == nothing\r\n        counts = Array(Int, 0)\r\n    else\r\n        counts = Array(eltype(weights), 0)\r\n    end\r\n\r\n    a = Array(Int, (0, 0))\r\n    el = cell(n)\r\n\r\n    if subset == nothing\r\n        subset = 1:l[1]\r\n    end\r\n\r\n    for i in subset\r\n        subset[i] || continue\r\n\r\n        for j in 1:n\r\n            pos = findfirst(a, x[j][i])\r\n            if pos == 0\r\n                d = push!(d, x[j][i])\r\n                a = cat(j, a, zeros(Int, ntuple(n - 1, k -> k >= j ? k : k + 1)))\r\n                pos = length(d)\r\n            end\r\n\r\n            @inbounds el[j] = pos\r\n        end\r\n\r\n        @inbounds a[el...] += 1\r\n    end\r\nend\r\n\r\njulia> test2(x)\r\nERROR: type: non-boolean (Int64) used in boolean context\r\n in test2 at none:23\r\n```\r\n\r\nFor the record, is it useful to make such reports about line numbers, or is there a well-known issue about that?\r\n\r\nEDIT: I did not paste the second function correctly.'
7307,'JeffBezanson','Return from nested try / finally\n@Keno said this was a bug so I\'m reposting this here.\r\n\r\nInner finally blocks do not execute with an explicit return.\r\n\r\n```julia\r\njulia> function test1()\r\n           try\r\n               try\r\n                   return true\r\n               finally\r\n                   println("inner")\r\n               end\r\n           finally\r\n               println("outer")\r\n           end\r\n       end\r\n\r\njulia> test1()\r\nouter\r\ntrue\r\n\r\njulia> function test2()\r\n           try\r\n               try\r\n                    true\r\n               finally\r\n                   println("inner")\r\n               end\r\n           finally\r\n               println("outer")\r\n           end\r\n       end\r\n\r\njulia> test2()\r\ninner\r\nouter\r\ntrue\r\n```\r\ncc: @JeffBezanson \r\n'
7302,'JeffBezanson','Type variables acting differently when accessed in an Array\nFrom the mailing list:https://groups.google.com/forum/#!topic/julia-users/VvVRW9Llc_0\r\n\r\n```julia\r\nimport Base.convert\r\n\r\nfunction convert{T1<:Integer, T2<:String}(totype::Type{T1}, value::T2)\r\n println("convert: $totype, $value")\r\n #parseint(totype, value)\r\nend\r\n\r\nfunction test()\r\n    @inbounds t = [Uint64][1]\r\n    @eval convert($t, "6")\r\n    convert(t, "5")\r\n    convert(Uint64, "4")\r\nend\r\n```\r\nPrints:\r\n```julia\r\nconvert: Uint64, 6\r\nconvert: Uint64, 4\r\n```'
7284,'Keno','Segfault in jl_demangle\nI\'m getting a segfault being triggered from `jl_demangle`. (I\'m doing a `Profile.retrieve()` on the result of `@profile reload("DataFrames").) What is this function supposed to do? I\'ve inserted the following debugging line:\r\n\r\n```C\r\n jl_printf(JL_STDOUT, "name %s name* %x start %x end %x ret %x len %d\\n", name, name, start, end, ret, end-start-1)\r\n```\r\n\r\nand the segfault happens right after the last line of this output:\r\n```\r\nname fl_applyn name* ffffc340 start ffffc343 end ffffc349 ret 5a3e600 len 5\r\nname jl_parse_next name* ffffc340 start ffffc343 end ffffc34d ret 5a3e2e0 len 9\r\nname jl_parse_eval_all name* 5a3e820 start 5a3e823 end 5a3e831 ret 5a3e320 len 13\r\nname julia_include_from_node1;17738 name* 59f0770 start 59f0776 end 59f0789 ret 59e76a0 len 18\r\nname jl_apply name* ffffc340 start ffffc343 end ffffc348 ret 5a3edd0 len 4\r\nname do_call name* ffffc340 start ffffc343 end ffffc347 ret 5a880b0 len 3\r\nname eval name* ffffc340 start ffffc344 end ffffc344 ret 5a88240 len -1\r\n```\r\nIt\'s pretty obvious why the segfault happens, but I don\'t know enough about what this function is supposed to be doing to understand how to fix it. It seems kinda borked to me.\r\n\r\nAdded in f28eeccb9bcac6ef745230b34a2b8da7caa75c2e. CC @ihnorton.\r\n'
7271,'StefanKarpinski','fix the rationalize function\nThis function is pretty broken and needs a bit of attention and revision.'
7252,'JeffBezanson','ternary operator ambiguous behaviour\nExpressions like\r\n`1 > 0 ? a=2 : a=3`\r\nfail with \r\n`syntax: invalid assignment location`\r\nThis can be solved by \r\n`1 > 0 ? a=2 : (a=3)`\r\nbut I think the expression is unambiguous enough to work without parantheses. '
7222,'Keno',"REPL: cannot search history for unicode symbols\nWhile in search mode, `\\latex_symbol` does not convert to unicode, and pasting (for me produces either nothing (with ctrl-v) or the following (middle mouse button on Linux):\r\n\r\n```julia\r\n(reverse-i-search)`~δ~': \r\n```"
7219,'andreasnoack','automatic conversion of triangular arrays\nPlease consider  the following  code:\r\n\r\n```julia\r\njulia> a = [1 1 1; 0 1 1; 0 0 1.0]\r\n3x3 Array{Float64,2}:\r\n 1.0  1.0  1.0\r\n 0.0  1.0  1.0\r\n 0.0  0.0  1.0\r\n\r\njulia> inv(a)\r\n3x3 Triangular{Float64,Array{Float64,2},:U,false}:\r\n 1.0  -1.0  -0.0\r\n 0.0   1.0  -1.0\r\n 0.0   0.0   1.0\r\n\r\njulia> function f(a) \r\n    b::Array{Float64,2}\r\n    b = inv(a)\r\nend\r\nf (generic function with 1 method)\r\n\r\njulia> f(a)\r\nERROR: no method convert(Type{Array{Float64,2}}, Triangular{Float64,Array{Float64,2},:U,false})\r\n in convert at base.jl:13\r\n in f at none:1\r\n```\r\n\r\nObviously , ```inv```  recognizes and chooses  a more efficient  algorithm  for triangular  arrays\r\nbut  then there  is no automatic  conversion  back to normal  arrays.\r\n(Tested  using  the latest  Ubuntu  Nightly.)'
7212,'Keno','Lost blue answer color in REPL\n````julia\r\njulia> versioninfo()\r\nJulia Version 0.3.0-prerelease+3620\r\nCommit 10f5754* (2014-06-10 18:43 UTC)\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin13.1.0)\r\n  CPU: Intel(R) Core(TM)2 Duo CPU     P7350  @ 2.00GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n\r\njulia> [1:2]\r\n2-element Array{Int64,1}:\r\n 1\r\n 2\r\n````\r\nThe result of `[1:2]` used to be blue and now it\'s white (on black background on my setup).\r\n\r\nI was messing around with `brew` installing and uninstalling `fontconfig`, so maybe has something to do with that?\r\n\r\nMy `.juliarc.jl` explicitly defines an answer color (I changed it to yellow to debug and it\'s not reading it for some odd reason).\r\n\r\n````julia\r\n#ENV["JULIA_ANSWER_COLOR"] = "blue"\r\n ENV["JULIA_ANSWER_COLOR"] = "yellow"\r\n````'
7174,'vtjnash','ReadFile is stream-blocking on windows\nFor some reason jl_is_pty (or more precisely the pNtQueryInformationFile in uv_get socketname) blocks until another character is received on stdin. '
7158,'Keno','code_native crashes for certain functions\ne.g.\r\n```\r\ncode_native(abs, (Int,))\r\n```\r\ncrashes with a segmentation fault (on MacOS 10.8.5).\r\n\r\ncc: @Keno '
7111,'Keno','repl crash in tab completion\n```julia\r\njulia> IOBuffer.name.<tab>ERROR: BoundsError()\r\n in getindex at utf8.jl:77\r\n in common_prefix at LineEdit.jl:95\r\n in complete_line at LineEdit.jl:146\r\n in complete_line at LineEdit.jl:89\r\n in anonymous at LineEdit.jl:1110\r\n in anonymous at LineEdit.jl:1119\r\n```'
7071,'JeffBezanson','Request to change default inner constructors\n#4026 changed the default inner constructor to make calls to convert, a la:\r\n```julia\r\ntype A\r\n    x::Int64\r\n    #implicit inner constructor\r\n    #A(x) = new(convert(Int64,x))\r\nend\r\n```\r\nThe problem I see with this is that it\'s too easy to "lose" your only inner constructor for your type.\r\n```julia\r\nIn  [2]: type A\r\n\ta::Int64\r\nend\r\n\r\nIn  [3]: A(1)\r\n\r\nOut [3]: A(1)\r\n\r\nIn  [4]: A(x) = A(do_my_own_fallback_conversion(x))\r\n\r\nOut [4]: A (constructor with 1 method)\r\n\r\nIn  [5]: A(1.0)\r\n\r\nOut [5]: ERROR: stack overflow\r\nwhile loading In[5], in expression starting on line 1\r\n```\r\n\r\nLuckily, it seems like there\'s a fairly easy way to make this more intuitive:\r\n```julia\r\ntype A\r\n    x::Int64\r\n    #implicit inner constructors\r\n    #A(x::Int64) = new(x)\r\n    #A(x) = new(convert(Int64,x))\r\nend\r\n```\r\nThen when a user thinks to define her own fallback constructor, things don\'t break!\r\n\r\nReference: https://groups.google.com/forum/#!searchin/julia-dev/gotcha/julia-dev/7WU_HimIsJc/5mj-ns-WN_gJ\r\n'
7062,'JeffBezanson','method dispatch error on types with unassigned typevars\nThis is possibly a method dispatch error, where it computes that `TypeVar(:N,Any) === 1`\r\n\r\n```julia\r\njulia> begin\r\n         f{t,n}(::Type{Array{t}}, ::Array{t,n}) = (t,n,1)\r\n         f{t,n}(::Type{Array{t,n}}, ::Array{t,n}) = (t,n,2)\r\n       end\r\njulia> methods(f)\r\n# 2 methods for generic function "f":\r\nf{t,n}(::Type{Array{t,n}},::Array{t,n}) at none:3\r\nf{t,n}(::Type{Array{t,N}},::Array{t,n}) at none:2\r\n\r\njulia> f(Array{Int,1}, [1,2,3])\r\n(Int32,1,2)\r\n\r\njulia> f(Array{Int}, [1,2,3])\r\n(Int32,1,2)  # I was expecting (Int32,1,1) !\r\n```\r\n\r\nhttps://groups.google.com/d/msg/julia-users/FkwQ7Uo8lmg/oV6EXSCgV1AJ'
7050,'andreasnoack','with A Triangular A_mul_B! overwrites B but Ac_mul_B! doesn\'t\n(I meant to write "but Ac_mul_B! doesn\'t".)\r\n\r\n```\r\njulia> B = fill(5.,(1,4))\r\n1x4 Array{Float64,2}:\r\n 5.0  5.0  5.0  5.0\r\n\r\njulia> A = Triangular(fill(0.723,(1,1)),:L,false)\r\n1x1 Triangular{Float64}:\r\n 0.723\r\n\r\njulia> A_mul_B!(A,B)\r\n1x4 Array{Float64,2}:\r\n 3.615  3.615  3.615  3.615\r\n\r\njulia> B\r\n1x4 Array{Float64,2}:\r\n 3.615  3.615  3.615  3.615\r\n\r\njulia> B = fill(5.,(1,4))\r\n1x4 Array{Float64,2}:\r\n 5.0  5.0  5.0  5.0\r\n\r\njulia> Ac_mul_B!(A,B)\r\n1x4 Array{Float64,2}:\r\n 3.615  3.615  3.615  3.615\r\n\r\njulia> B\r\n1x4 Array{Float64,2}:\r\n 5.0  5.0  5.0  5.0\r\n\r\njulia> versioninfo()\r\nJulia Version 0.3.0-prerelease+3341\r\nCommit c34e492* (2014-05-30 14:23 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-pc-linux-gnu)\r\n  CPU: AMD Athlon(tm) II X4 635 Processor\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (NO_LAPACK NO_LAPACKE DYNAMIC_ARCH NO_AFFINITY)\r\n  LAPACK: liblapack\r\n  LIBM: libopenlibm\r\n```'
7049,'JeffBezanson','Evanescent inference bug involving a Union of a Union via a typealias in a function keyword argument\nHere\'s another one in my series of silly bugs (I start to feel like there should be a tag for that). The problem was introduced in commit aff4f88bc9a772ee67e90afbda2984a69e08b72c (cc @JeffBezanson), and shows up as follows: I have this code in a file "ttt.jl":\r\n\r\n```\r\nmodule TTT\r\n\r\ntypealias Maybe{T} Union(T,Nothing)\r\n\r\nfunction ttt(;init::Maybe{Union(String,(Int,Char))} = nothing)\r\n    println("init=", init)\r\nend\r\n\r\nend\r\n```\r\n\r\nwhich, when loaded and called, produces an inference error the first time, and then works as expected:\r\n\r\n```\r\njulia> reload("ttt.jl")\r\n\r\njulia> TTT.ttt(init="a")\r\nERROR: type: typevar: expected Type{T<:Top}, got TypeVar\r\n in anonymous at inference.jl:412\r\n in builtin_tfunction at inference.jl:511\r\n in abstract_call at inference.jl:809\r\n in abstract_eval_call at inference.jl:885\r\n in abstract_eval at inference.jl:976\r\n in abstract_eval_arg at inference.jl:848\r\n in abstract_eval_call at inference.jl:860\r\n in abstract_eval at inference.jl:976\r\n in abstract_interpret at inference.jl:1082\r\n in typeinf at inference.jl:1332\r\n in typeinf at inference.jl:1526\r\n in typeinf_ext at inference.jl:1196\r\n\r\njulia> TTT.ttt(init="a")\r\ninit=a\r\n```\r\n\r\nThe problem disappears if:\r\n\r\n * I use `Union(Nothing,String,(Int,Char))` directly instead of passing through the `Maybe` typealias\r\n * I don\'t use a Tuple type in the Union (the types and size of the Tuple, as well as the other types involved, seem to be irrelevant)\r\n * The argument is passed as a positional argument rather then a keyword argument\r\n * The keyword argument is not passed in the function call (its default value and type is not relevant)'
7012,'JeffBezanson','Typeassert when assigning to elements of an array\nIt seems there is an issue in lowering expressions like `x[1]::T += 1`.  The code runs but doesn\'t `setindex!` x.\r\n\r\nIn addition, `x[1]::Float64 = x[1]::Float64 + 1.` fails with a syntax error.\r\n\r\nFrom the mailing list: https://groups.google.com/forum/#!msg/julia-users/N6bn0F5xVp8/yDQOtBL5qNMJ\r\n\r\n```\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.3.0-prerelease+3286 (2014-05-28 15:05 UTC)\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit c0b1281* (0 days old master)\r\n|__/                   |  x86_64-apple-darwin13.2.0\r\n\r\njulia> x=zeros(2)\r\n2-element Array{Float64,1}:\r\n 0.0\r\n 0.0\r\n\r\njulia> x[1]::Float64 += 1.\r\n1.0\r\n\r\njulia> x\r\n2-element Array{Float64,1}:\r\n 0.0\r\n 0.0\r\n\r\njulia> x[1]::Float64 = 1.\r\nERROR: syntax: invalid assignment location "x[1]"\r\n```\r\n\r\n\r\n```\r\njulia> myf(x) = x[1]::Float64 += 1\r\nmyf (generic function with 1 method)\r\n\r\njulia> code_lowered(myf,(Array,))\r\n1-element Array{Any,1}:\r\n :($(Expr(:lambda, {:x}, {{:#s37,:#s41},{{:x,:Any,0},{:#s37,:Any,18},{:#s41,:Float64,2}},{}}, :(begin  # none, line 1:\r\n        #s41 = top(typeassert)(top(convert)(Float64,getindex(x,1)),Float64)\r\n        #s37 = top(typeassert)(#s41,Float64) + 1\r\n        #s41 = top(typeassert)(top(convert)(Float64,#s37),Float64)\r\n        return #s37\r\n    end))))\r\n```\r\n\r\n'
7002,'timholy','Make sure SIGUSR1 is unblocked for profiler\nWe cannot make any assumptions about the state of the signal mask.\r\nTurns out that the USR1 signal can be blocked by parent processes and\r\nthen the profiler will not work right (gdm is an example).  Make sure\r\nthat if we are running the profiler that the USR1 signal is unblocked.'
6992,'staticfloat',"Update Mac juliarc.jl (fixes #6880)\ngit (bundled in ROOT/libexec/git-core) isn't included on the PATH used by Julia. This causes issues on OSX when using the package manager because GIT_EXEC_PATH does point to the bundled git tools. By adding git-core explicitly, all issues are fixed. The bundled git is used throughout.\r\n\r\nReference: #6880"
6980,'JeffBezanson','Method sorting bug\n```julia\r\nabstract A\r\ntype B <: A end\r\nf(::Union(Int, Float64), ::A) = false\r\nf(::Union(Int, Float64), ::B) = true\r\nf(1, B()) # returns false\r\n```'
6979,'carlobaldassi','Make splice!(::BitVector, ::Integer, ::BitVector) return a Bool\nPreviously this returned a one-element BitArray, which was inconsistent with `splice!(::Vector{Bool}, ::Integer, ::Vector{Bool})`'
6963,'ViralBShah','RFC: Reintroduce nnz and nonzeros\nReintroduce nnz and nonzeros as discussed in #6769\r\nDeprecate nfilled\r\nDeprecate nonzeros for StridedArray and BitArray\r\nfind()/findnz() over sparse matrices no longer filters out stored zeros\r\n\r\nShould `sparse()` allow stored zeros in its input, using an optional argument? Although this discussion started with ``nnz``, I feel it is leading towards better clarity on treatment of stored zeros, and overall I am feeling good about that.\r\n'
6952,'tanmaykm','readdlm issue with medium sized array\nI\'m getting a strange error when reading a medium-sized float64 array:\r\n\r\n```julia\r\njulia> a = ones(25, 120)\r\n25x120 Array{Float64,2}:\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n ⋮                        ⋮              ⋱            ⋮                      \r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n\r\njulia> io = IOBuffer()\r\nIOBuffer(Uint8[],true,true,true,false,0,9223372036854775807,1)\r\n\r\njulia> writedlm(io, a)\r\n\r\njulia> seek(io, 0)\r\nIOBuffer(Uint8[0x31,0x09,0x31,0x09,0x31,0x09,0x31,0x09,0x31,0x09  …  0x31,0x09,0x31,0x09,0x31,0x09,0x31,0x09,0x31,0x0a],true,true,true,false,6000,9223372036854775807,1)\r\n\r\njulia> b = readdlm(io)\r\n25x120 Array{Any,2}:\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0     1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n ⋮                        ⋮              ⋱            ⋮                      \r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0\r\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""  …   ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n  ""   ""   ""   ""   ""   ""   ""   ""      ""   ""   ""   ""   ""   ""   ""\r\n```\r\n\r\nSmaller arrays (even one row or one column smaller) are read fine.\r\n\r\nI\'m running on a version of Julia compiled today:\r\n```julia\r\njulia> versioninfo()\r\nJulia Version 0.3.0-prerelease+3184\r\nCommit 6e56c9d* (2014-05-23 21:28 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-linux-gnu)\r\n  CPU: Intel(R) Core(TM) i7-4500U CPU @ 1.80GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n```\r\n\r\n~~I haven\'t had time to triage yet, but possibly related to #6718.~~\r\n  cc: @tanmaykm '
6896,'JeffBezanson','A function returning LHS instead of RHS in final assignment \n`g` returns the LHS, instead of the RHS as is usual in Julia, c.f. `f`.\r\n\r\n```julia\r\njulia> g(x) = x::Int=x\r\ng (generic function with 1 method)\r\n\r\njulia> g(5.0)\r\n5\r\n\r\njulia> f(x) = y::Int=x\r\nf (generic function with 1 method)\r\n\r\njulia> f(5.0)\r\n5.0\r\n```\r\n\r\n(This cropped up in issue #6874 but that issue was really about  the manual.)'
6880,'StefanKarpinski',"Pkg not running correct git command\nWhen I try to use `Pkg`, and it attempts to clone `METADATA.jl`, `git` somehow seems to think the command `index-pack` is being run? Here's an example session, starting with the relevant statement from Pkg, and then the same statement executed directly in bash. The former fails; the latter succeeds.\r\n\r\n```\r\njulia> run(`git clone -q -b metadata-v2 git://github.com/JuliaLang/METADATA.jl METADATA`)\r\nusage: git index-pack [-v] [-o <index-file>] [--keep | --keep=<msg>] [--verify] [--strict] (<pack-file> | --stdin [--fix-thin] [<pack-file>])\r\nfatal: index-pack failed\r\nERROR: failed process: Process(`git clone -q -b metadata-v2 git://github.com/JuliaLang/METADATA.jl METADATA`, ProcessExited(128)) [128]\r\n in pipeline_error at process.jl:489\r\n in run at process.jl:466\r\n\r\njulia> ^D\r\n\r\n$ git clone -q -b metadata-v2 git://github.com/JuliaLang/METADATA.jl METADATA\r\n$ \r\n```\r\n\r\nI'm using a Julia 0.3.0 snapshot (prerelease 2eef453c29) for Mac OS X 10.9.2 (64 bit):\r\n```\r\njulia> versioninfo()\r\nJulia Version 0.3.0-prerelease+3094\r\nCommit 2eef453* (2014-05-18 10:23 UTC)\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin12.5.0)\r\n  CPU: Intel(R) Core(TM) i7-2620M CPU @ 2.70GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libgfortblas\r\n  LAPACK: liblapack\r\n  LIBM: libopenlibm\r\n```"
6869,'tanmaykm','readcsv: has_header::Bool=false => header::Integer=0\nSee https://github.com/JuliaStats/DataFrames.jl/issues/607. The idea is to specify the number of header rows, rather than just whether there is a header or not. Since `false == 0` and `true == 1` this is backwards compatible. The name change is not backwards compatible, but we could allow both keywords for a while and warn if `has_header` is used.'
6847,'staticfloat','0.3 snapshot broken on MacOS 10.9.2\nI just downloaded `Julia-0.3.0-prerelease-f4d1e94009` on a clean MacOS 10.9.2 machine, and it fails to launch as shown below:\r\n\r\n![image](https://cloud.githubusercontent.com/assets/2913679/2977920/91b09eca-dbb1-11e3-99d5-30bbff4e9cba.png)\r\n'
6833,'StefanKarpinski','manual chapter on equality and hashing\nIt used to be that `==` called `isequal`, so that packages wanting to override equality for their own types would override `isequal`.  However, commit 737ad6eba2f94a8542e9013fa84b6f4e3f5d827a silently changed this to make `isequal` call `==`.\r\n\r\nThis potentially results in subtle breakage (e.g. stevengj/PyPlot.jl#52) of a large number of packages that override `isequal`:\r\n```\r\nBioSeq\r\nBlocks\r\nCalendar\r\nDWARF\r\nDataArrays\r\nDataStructures\r\nDatetime\r\nDebug\r\nDualNumbers\r\nFixtures\r\nFunctionalCollections\r\nHDFS\r\nHyperDualNumbers\r\nJuMP\r\nLibGit2\r\nMorsel\r\nOpenCL\r\nPLX\r\nPatternDispatch\r\nPhylogenetics\r\nPyCall\r\nPyPlot\r\nTimeData\r\nTk\r\nURIParser\r\n```\r\nUnfortunately, the fix is not very clean either: in order to remain compatible with 0.2, packages will now have to override *both* `isequal` and `==`.\r\n\r\nI think it\'s clear that we need to discuss this issue a bit more thoroughly before we release this change in 0.3, hence I\'m marking it as a milestone issue.\r\n\r\n(Apologies if this was already discussed, but I\'m not seeing it anywhere right now.  e.g. @JeffBezanson wrote in #90: "I\'ve come to the conclusion that `isequal` is the more fundamental predicate [...] `==` then defaults to `isequal`".   What has changed?)\r\n\r\ncc: @StefanKarpinski, @jakebolewski'
6814,'StefanKarpinski',"Fix #6372\nThis adds the package to REQUIRE on `Pkg.clone()` if it exists in METADATA. This means that calling `Pkg.clone()` on a repo that's on an old tag will result in the package getting updated to the latest release, but that seemed preferable to making `Pkg.clone()` on a package that's on a tag result in a pinned package."
6801,'ViralBShah','RFC: the generalized eigenvalue problem (#6758)\nWIP for the generalized eigenvalue problem (#6758)\r\n'
6789,'tanmaykm',"more efficient setindex for sparsematrix\nThis implements `setindex!(A::SparseMatrixCSC, x::Number, I, J)` to be more efficient.\r\n\r\nBefore:\r\n````\r\njulia> A = sprand(10000, 10000, 0.0001);\r\n\r\njulia> @time A[1:8000, 1:8000] = 10;    # set some new indices\r\nelapsed time: 62.222216641 seconds (13574393504 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 11;    # change existing values\r\nelapsed time: 67.845266004 seconds (16635419192 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 0;     # zero existing values\r\nelapsed time: 5.030329475 seconds (2560507944 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 0;     # zero already zero'd values\r\nelapsed time: 0.709701096 seconds (512507944 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 10;    # set all new indices\r\nelapsed time: 52.267994938 seconds (13038875192 bytes allocated)\r\n````\r\n\r\nWith this patch:\r\n````\r\njulia> A = sprand(10000, 10000, 0.0001);\r\n\r\njulia> @time A[1:8000, 1:8000] = 10;    # set some new indices\r\nelapsed time: 1.84697863 seconds (1030174960 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 11;    # change existing values\r\nelapsed time: 0.792033539 seconds (96 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 0;     # zero existing values\r\nelapsed time: 5.615637808 seconds (2048139680 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 0;     # zero already zero'd values\r\nelapsed time: 0.000156263 seconds (96 bytes allocated)\r\n\r\njulia> @time A[1:8000, 1:8000] = 10;    # set all new indices\r\nelapsed time: 1.726549776 seconds (1024139680 bytes allocated)\r\n````"
6769,'ViralBShah','nnz and nonzeros\nSomeone has decided to change nnz and to remove the nonzeros command.\r\n\r\nI find this very unacceptable! \r\nIt is a bad practice to not allow for backward compatibility.\r\nMany of our codes use these commands and we have to go and replace them in all our previous versions.\r\n\r\nWe are investing a considerable amount of time, trying to develop codes in julia for geophysical inversion and truly believe that it is the way to go.\r\nIf new julia versions are not going to be backward compatible we will need to rethink\r\nour development.\r\n\r\nPlease think about this whenever you want to retire a command\r\n\r\n '
6757,'Keno',"readdlm test failure on 64-bit Fedora with LLVM 3.4\nI see this failure when running tests in my RPM package in 64-bits on a Fedora build machine. This is with git master as of today. Funnily the test passes on my machine; is it because it's been fixed in the recent hours?\r\n```\r\ncd test\r\nmake all\r\nWarning: git information unavailable; versioning information limited\r\n    \x1b[32;1mJULIA\x1b[0m \x1b[37;1mtest/all\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mlinalg1\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mlinalg3\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mlinalg2\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mcore\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mkeywordargs\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mnumbers\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mstrings\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mcollections\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mhashing\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mremote\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31miobuffer\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31marrayops\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31msimdloop\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mblas\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mfft\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mdsp\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31msparse\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mbitarray\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mrandom\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mmath\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mfunctional\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mbigint\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31msorting\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mstatistics\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mspawn\x1b[0m\r\n\tFrom worker 2:\t       \x1b[34m[stdio passthrough ok]\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mpriorityqueue\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31marpack\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mfile\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31msuitesparse\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mversion\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mresolve\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mpollfd\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mmpfr\x1b[0m\r\n\tFrom worker 4:\t     \x1b[1m*\x1b[0m \x1b[31mbroadcast\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mcomplex\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31msocket\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mfloatapprox\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mregex\x1b[0m\r\n\tFrom worker 2:\t     \x1b[1m*\x1b[0m \x1b[31mreaddlm\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mfloat16\x1b[0m\r\n\tFrom worker 3:\t     \x1b[1m*\x1b[0m \x1b[31mcombinatorics\x1b[0m\r\nexception on 2: ERROR: BoundsError()\r\nwhile loading readdlm.jl, in expression starting on line 4\r\nERROR: BoundsError()\r\nwhile loading readdlm.jl, in expression starting on line 4\r\nwhile loading /builddir/build/BUILD/julia-master/test/runtests.jl, in expression starting on line 46\r\nmake: *** [all] Error 1\r\n```"
6725,'Keno',"hide/fix line numbers for cached code\nthe line numbers in cached code are almost criminally wrong. the function name is right, but the line number for profiling type inference was pretty far off. this is likely due to the fact we JIT slightly different than we cache. I previously thought it would occur in a few function due to the fact that we emit ccalls differently in JIT vs. cache, however it doesn't seem to be limited to functions that use ccalls. i suppose llvm could be running different optimization passes?"
6716,'timholy',"feature request findmax(A,dims)\ngetting the maximum and its location in one pass is very useful. at current it's not supported along dimension `d` of an array. \r\n\r\n    A = rand(3,3,3)\r\n    now = mapslices(findmax,A,3)\r\n    #or\r\n    for i in 1:3\r\n        for j in 1:3\r\n             now[i,j] = findmax(A[i,j,:])\r\n        end\r\n    end\r\n    then = findmax(A,3)\r\n\r\nit's odd to have \r\n\r\n    max(A,dims)\r\n\r\nand not `findmax(A,dims)`"
6715,'Keno','Support JULIA_CPU_TARGET=x86\nLinux distributions packages should run on most, if not all, x86 CPUs, and currently JULIA_CPU_TARGET=core2 is too high (especially for 32-bit builds). Would it be possible to support an older CPU target, which would be slower but would work everywhere?\r\n\r\n(In the long term it could make sense to build several system images and load the best one for the current CPU.)'
6712,'StefanKarpinski','typemin(BigInt) ERROR: no method typemin(Type{BigInt})\nI understand that for BigInt there is no hard limit like for Int64 for example but the lack of a value seems to cause a problem with rationalize() at line 69 where it is not possible to get a Rational with BigInt num and den. It seems to me that line 69 of rational.jl shall special case the BigInt or that BigInt shall return something valid for typemin/typemax.\r\n\r\nat line 69:\r\n\r\nif x < typemin(T); return -one(T)//zero(T); end'
6695,'tanmaykm',"Vectorize a sparse matrix\n```\r\nX = eye(5)\r\nvec(X) #Works\r\nX = speye(5)\r\nvec(X)\r\nERROR: no method similar(SparseMatrixCSC{Float64,Int64},DataType,(Int64,))\r\n in reshape at abstractarray.jl:151\r\n in vec at abstractarray.jl:155\r\n```\r\n\r\nI'm using Julia 0.2.1. Apologies if this has already been fixed.\r\nI'm also curious how this would be handled. Would X be converted to a sparse vector or a full vector? Going along those lines, as of now, we can do ```sparsevec(X)``` neither on full matrices nor on sparse matrices. Would it make sense for sparsevec to vectorize X and make it sparse? This works: ```sparsevec([1; 1])``` but not ```sparsevec([1 1])``` or ```sparsevec([1 1]')``` and perhaps all of these can be solved together?"
6668,'StefanKarpinski',"RFC: Enable github two-factor authentication; fixes #5252\nI was getting annoyed at having to disable two-factor authentication to run `Pkg.publish()`.  Here's an attempt at fixing that.\r\n\r\n```julia\r\njulia> Pkg.publish()\r\nINFO: Validating METADATA\r\nINFO: No new package versions to publish\r\nINFO: Submitting METADATA changes\r\nINFO: Forking JuliaLang/METADATA.jl to kmsquire\r\nEnter host password for user 'kmsquire':\r\nINFO: Two-factor authentication in use.  Enter auth code.  (You may need to re-enter your password.)\r\nAuthentication code: 420442\r\nEnter host password for user 'kmsquire':\r\n\r\nINFO: Pushing changes as branch pull-request/5068ad74\r\nINFO: To create a pull-request open:\r\n\r\n  https://github.com/kmsquire/METADATA.jl/compare/pull-request/5068ad74\r\n```\r\n\r\nRemaining issues:\r\n1. Because there are two calls to curl, we have to enter our password twice. (minor)\r\n~~2. For the second password prompt, enter has to be pressed twice(!) (major)~~\r\n3. Adding more than one auth token does not seem to be possible.  For an existing token and a new machine, I get:\r\n```julia\r\n    ERROR: 422: Validation Failed -- https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization\r\n       resource:   OauthAccess\r\n       field:      description\r\n       error code: already_exists\r\n```\r\n\r\n~~Regarding 2, which is the main annoyance, I'm stumped.  I'm guessing some interaction between the repl and the spawned process is not letting curl see one of the return characters.  Or maybe running the same process twice is causing issues.~~\r\n\r\n**Edit:** I just had to reauthenticate, and found that on latest master, this is no longer a problem (or at least it worked this time without having to press enter twice.\r\n\r\nSince authenticating twice seems like a minor price to pay for having two-factor auth enabled, I think this can be merged (although I would appreciate someone else testing).\r\n\r\nCc: @StefanKarpinski, @aviks "
6659,'StefanKarpinski',"printf tweaks, fixes, and BigFloat support\n@StefanKarpinski \r\n\r\nwith Keno's tuple work, we don't need to use global values for most of these return values. Although we still use the static buffer for DIGITS, the others can be returned on the stack without impacting performance.\r\n\r\nAnd it's a net deletion of 1 LOC, uses 1 fewer macro, and (hopefully) will make adding BigFloat support more straightforward"
6647,'tanmaykm',"setindex for vectors into SparseMatrix\n```\r\nG=spzeros(2)\r\na=[1, 2]    \r\nG[:, 1] = a\r\nERROR: no method setindex!(SparseMatrixCSC{Float64,Int64},Array{Int64,1},Range1{Int64},Int64)\r\n```\r\n\r\nIf I do\r\n```\r\nG[:, 1] = a''\r\n```\r\nit works just fine. I'd assume it has something to do with the fact that ```a``` is a vector with size ```(2, )``` instead of ```(2, 1)```.\r\nAlso if I do ``` G = zeros(2,2) ```, the above code works, so I assume this is an issue with sparse matrices in particular.\r\n\r\nI'm using Julia 0.2.1. Apologies if this has already been reported or fixed."
6635,'ihnorton','code_native not working on Mac, with LLVM 3.4\nOn my mac, with LLVM 3.4, `code_native` does not work. Is this known/expected, or a bug?\r\n\r\n````\r\njulia> foo(x::Float64) = 1\r\nfoo (generic function with 1 method)\r\n\r\njulia> code_native(foo, (Float64,))\r\nWarning: Unable to find function pointer\r\nERROR: no method found for the specified argument types\r\n````\r\n'
6634,'JeffBezanson','Undefined variable when referencing type in outer scope\nNot sure the title describes the relevant aspects of this, but it\'s the latest from the code that brought you #6611 \r\n\r\n```\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.3.0-prerelease+2747 (2014-04-25 10:34 UTC)\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit db1b73e* (0 days old master)\r\n|__/                   |  x86_64-suse-linux\r\n\r\njulia> function crc(spec)\r\n           A = Uint\r\n           remainder::A = 1\r\n           function handler(append)\r\n               remainder = append ? 1 : 2\r\n           end\r\n       end\r\ncrc (generic function with 1 method)\r\n\r\njulia> \r\n\r\njulia> crc(0x1)(true)\r\nERROR: A not defined\r\n in handler at none:5\r\n```\r\n\r\nTo cut+paste:\r\n\r\n```\r\nfunction crc(spec)\r\n    A = Uint\r\n    remainder::A = 1\r\n    function handler(append)\r\n        remainder = append ? 1 : 2\r\n    end\r\nend\r\n\r\ncrc(0x1)(true)\r\n```\r\n\r\n[Insert Walter "Am I the only one around here using runtime types and first class functions?" Sobchak]'
6625,'Keno','Interrupt signal crashes Julia in emacs\nIn emacs (both ESS REPL and eshell), sending an interrupt signal ("C-c C-c" and "C-c", respectively) causes Julia to crash\r\n\r\nIn eshell:\r\n1. lauch Julia\r\n2. Press control-c\r\n\r\n```\r\n$ julia \r\n[logo]\r\njulia> 8\r\n8\r\n\r\njulia> ERROR: interrupt\r\n in stream_wait at stream.jl:252\r\n in wait_readbyte at stream.jl:298\r\n in readuntil at stream.jl:670\r\n in readuntil at io.jl:148\r\n in readuntil at Terminals.jl:160\r\n in run_frontend at REPL.jl:169\r\n in run_repl at REPL.jl:151\r\n```'
6611,'JeffBezanson','Error in inference.jl when compiling valid code\nThis seems unhealthy:\r\n\r\n```\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.3.0-prerelease+2703 (2014-04-22 18:57 UTC)\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 942ae42* (0 days old master)\r\n|__/                   |  x86_64-suse-linux\r\n\r\njulia> \r\n\r\njulia> typealias U Unsigned\r\nUnsigned\r\n\r\njulia> \r\n\r\njulia> abstract Direction{A<:U}\r\n\r\njulia> \r\n\r\njulia> immutable Backwards{A<:U}<:Direction{A}\r\n           function Backwards(spec)\r\n               new()\r\n           end\r\n       end\r\n\r\njulia> \r\n\r\njulia> immutable Forwards{A<:U}<:Direction{A}\r\n           function Forwards(spec)\r\n               new()\r\n           end\r\n       end\r\n\r\njulia> \r\n\r\njulia> abstract Tables{A<:U}\r\n\r\njulia> \r\n\r\njulia> immutable NoTables{A<:U}<:Tables{A}\r\n           NoTables(direcn::Direction{A}) = new()\r\n       end\r\n\r\njulia> \r\n\r\njulia> function crc{T<:Tables}(spec; tables::Type{T}=NoTables)\r\n           A = Uint\r\n           direcn = spec ? Backwards{A}(spec) : Forwards{A}(spec)\r\n           remainder::A = 0\r\n           tables = tables{A}(direcn)\r\n           function handler(data::Vector{Uint8}; append=false)\r\n               remainder = append ? remainder : direcn\r\n           end\r\n           handler\r\n       end\r\ncrc (generic function with 1 method)\r\n\r\njulia> \r\n\r\njulia> crc(true)(b"")\r\nERROR: type: subtype: expected Type{T<:Top}, got Symbol\r\n in tchanged at inference.jl:1081 (repeats 2 times)\r\n in stupdate at inference.jl:1148\r\n in typeinf at inference.jl:1321\r\n in typeinf at inference.jl:1497\r\n in abstract_call_gf at inference.jl:694\r\n in abstract_call at inference.jl:754\r\n in abstract_eval_call at inference.jl:876\r\n in abstract_eval at inference.jl:904\r\n in abstract_eval_arg at inference.jl:845\r\n in typeinf at inference.jl:1379\r\n in typeinf at inference.jl:1497\r\n in typeinf_ext at inference.jl:1186\r\n```\r\n\r\nCode to cut+paste (it was originally ~500 lines, I\'ve reduced it a fair bit - it occurred in working code that was otherwise OK when two functions, which sequentially called each other, were merged into a single body.  So it\'s not related to any undefined functions that are a side effect of my cutting things down to a manageable size).  If you want the original see https://github.com/andrewcooke/CRC.jl/blob/15d97c5bafbb818baa81123aa8b4c8661ce5d812/src/CRC.jl#L341 - this bug is triggered by merging the two `crc` functions (simply deleting lines 340-344 inclusive).\r\n\r\n```\r\ntypealias U Unsigned\r\n\r\nabstract Direction{A<:U}\r\n\r\nimmutable Backwards{A<:U}<:Direction{A}\r\n    function Backwards(spec)\r\n        new()\r\n    end\r\nend\r\n\r\nimmutable Forwards{A<:U}<:Direction{A}\r\n    function Forwards(spec)\r\n        new()\r\n    end\r\nend\r\n\r\nabstract Tables{A<:U}\r\n\r\nimmutable NoTables{A<:U}<:Tables{A}\r\n    NoTables(direcn::Direction{A}) = new()\r\nend\r\n\r\nfunction crc{T<:Tables}(spec; tables::Type{T}=NoTables)\r\n    A = Uint\r\n    direcn = spec ? Backwards{A}(spec) : Forwards{A}(spec)\r\n    remainder::A = 0\r\n    tables = tables{A}(direcn)\r\n    function handler(data::Vector{Uint8}; append=false)\r\n        remainder = append ? remainder : direcn\r\n    end\r\n    handler\r\nend\r\n\r\ncrc(true)(b"")\r\n```'
6604,'staticfloat',"permissions issue with Julia.app/Contents/MacOS/Julia in 0.2.1-osx10.7+\nI was installing Julia on a lab full of multi-user machines. In doing so, I ran into the problem that I was installing as the administrative user, but the permissions on Julia.app/Contents/MacOS/Julia were\r\n-rwxrwxr--  1 scfadmin  staff  109960 Jun  6  2013 Julia\r\n\r\nnamely no executable permission for 'other', so it was failing to run for our users. A simple fix, but would be helpful if this was modified in the package being distributed.\r\n\r\n----------------------------------------------------------------------------------------------\r\nChris Paciorek \r\n\r\nStatistical Computing Consultant\r\nStatistical Computing Facility and Econometrics Laboratory\r\n\r\nOffice: 495 Evans Hall                      Email: paciorek@stat.berkeley.edu\r\nMailing Address:                            Voice: 510-842-6670 \r\nDepartment of Statistics                    Fax:   510-642-7892\r\n367 Evans Hall                              Skype: cjpaciorek\r\nUniversity of California, Berkeley          WWW:   www.stat.berkeley.edu/~paciorek\r\nBerkeley, CA 94720 USA                      Permanent forward: paciorek@alumni.cmu.edu\r\n\r\n"
6595,'JeffBezanson','Add documentation about custom exceptions to the manual\nI struggled to write a custom exception type, so I figured I would add a few words to the manual.\r\n\r\nI can also add a recommendation that people create their own specific exceptions when applicable, instead of throwing too generic exceptions that cannot programmatically be catched. But I need you to confirm this is indeed the official recommendation. A word about when to add custom error messages and details could also be useful.'
6573,'ViralBShah',"Split Mersenne-Twister states between rand() and rand(N>382)\nAs reported on the [dev mailing list](https://groups.google.com/d/msg/julia-dev/EpIPeofqaIA/BHndt45m9LoJ), there's some sort of DSFMT state corruption after generating ~~odd-length~~ arrays with more than 382 elements:\r\n\r\n\tjulia> srand(0); rand(); x = rand(383);\r\n\r\n\tjulia> find(x .== x[end])\r\n\t2-element Array{Int64,1}:\r\n\t   2\r\n\t 383\r\n\r\n\tjulia> find(x .== rand())\r\n\t1-element Array{Int64,1}:\r\n\t 3\r\n\r\n\tjulia> find(x .== rand())\r\n\t1-element Array{Int64,1}:\r\n\t 4\r\n\r\nIt looks (to my novice eyes) like `rand()` (which punts to an implementation in dsfmt.h:266) and `rand(n)` (implemented in dsfmt.c:182) end up with independent DSFMT states.  ~~I'm not sure how or why, but it only seems to get triggered after calling `rand(N)` with odd N > 382... which is a very specific branch in [librandom.jl:120](https://github.com/JuliaLang/julia/blob/8fde7f4ce6a2ee4676c1e0d7b31075f2d64cc06b/base/librandom.jl#L127-L133).~~\r\n\r\nEdit: It seems to be much more general than what I stated above.  I think `rand()` and `rand(N)` are living completely split lives with separate states; N need not be odd to trigger the bug.  All that is required is that there's a call to `rand()` before doing the array generation (In the initial report, it was repeating calls of rand(N) with N odd — which satisfies the call to rand()).\r\n\r\n\tjulia> srand(0); rand()\r\n\t0.8236475079774124\r\n\r\n\tjulia> x = rand(384);\r\n\r\n\tjulia> find(x .== rand())\r\n\t1-element Array{Int64,1}:\r\n\t 4"
6561,'JeffBezanson',"NTuple as a type parameter is not invariant\nThis used to work, doesn't now.\r\n\r\n```\r\n  | | |_| | | | (_| |  |  Version 0.3.0-prerelease+2657 (2014-04-18 03:17 UTC)\r\n _/ |\\__'_|_|_|\\__'_|  |  Commit ca44f9b (0 days old master)\r\n|__/                   |  x86_64-linux-gnu\r\n\r\njulia> function foo(args::Vector{Tuple})\r\n       end\r\nfoo (generic function with 1 method)\r\n\r\njulia> foo([(1,2), (3,4)])\r\nERROR: no method foo(Array{(Int64,Int64),1})\r\n\r\n```\r\n\r\n`NTuple` instead of `Tuple` dispatches fine. \r\n"
6560,'nolta',"Bring back the nice LineEditREPL on Windows\nWindows doesn't have the TERM env var set outside of MSYS/Cygwin, so c8ae026c557 caused Windows Julia to default to the BasicREPL.\r\n\r\nThe LineEditREPL still has line duplication bugs on Windows (https://github.com/JuliaLang/julia/issues/6488), but overall it's a nicer experience than the BasicREPL.\r\n\r\nThis may un-fix https://github.com/JuliaLang/julia/issues/6428 on Windows, but I suspect Windows users are more frequently running Julia from cmd or by double-clicking than inside Emacs.\r\n"
6502,'JeffBezanson',"convert variable length tuples problem\nI have a problem with convert. Running the following\r\nconvert((Bool,Int64...,), (true,10))\r\n\r\nreturns:\r\n(true,true)\r\n\r\nIn older versions of julia it returned (true,10), which is what I would expect the behavior to be, or if variable length tuples are not supported, i would expect an error.\r\n\r\nI'm on the latest julia version:\r\nJulia Version 0.3.0-prerelease+2594\r\nCommit b8f8af5* (2014-04-11 03:18 UTC)\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin13.1.0)\r\n  CPU: Intel(R) Core(TM) i7-3615QM CPU @ 2.30GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY)\r\n  LAPACK: libopenblas\r\n  LIBM: libopenlibm\r\n\r\nThanks!\r\n\r\nStav\r\n"
6465,'ihnorton','Julia Introductory Page Clearly Written For linux or unix system\nAs a window\'s user it was a little confusing to find so much of the "Getting Started" with Julia help file to be written without explicit warning with bash script.\r\n\r\nFortunately, I have some experience with bash otherwise I probably would have given up then.\r\n\r\nhttp://docs.julialang.org/en/release-0.2/manual/getting-started/'
6441,'JeffBezanson','Fix edit() with emacs\nRemoves the detection and loading of julia-mode.el.  This never seemed\r\nto work, and most emacs users will have this set up on their own anyway.'
6426,'JeffBezanson','Method dispatch dependent upon call order\nIf I define a function with the following methods:\r\n\r\n    f(x,args...) = f(x,map(a->(isa(a,Type) ? Type{a} : typeof(a)), args))\r\n    f(x,t::(Type...)) = print(t)\r\n\r\nJulia\'s dispatch behavior is dependent upon which I call first.  Note that the first (unused) argument is required to trigger this.\r\n\r\n\t$ julia\r\n\t               _\r\n\t   _       _ _(_)_     |  A fresh approach to technical computing\r\n\t  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n\t   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n\t  | | | | | | |/ _` |  |\r\n\t  | | |_| | | | (_| |  |  Version 0.3.0-prerelease+2494 (2014-04-04 23:25 UTC)\r\n\t _/ |\\__\'_|_|_|\\__\'_|  |  Commit 7d495c0 (0 days old master)\r\n\t|__/                   |  x86_64-apple-darwin13.1.0\r\n\r\n\tjulia> f(x,args...) = f(x,map(a->(isa(a,Type) ? Type{a} : typeof(a)), args))\r\n\t       f(x,t::(Type...)) = print(t)\r\n\tf (generic function with 2 methods)\r\n\r\n\tjulia> f(1,(1,2)) # A dispatch loop to itself?\r\n\t^CERROR: interrupt\r\n\t in anonymous at none:1\r\n\t in f at none:1 (repeats 1192 times)\r\n\r\n\tjulia> exit()\r\n\r\n\t$ julia --quiet\r\n\tjulia> f(x,args...) = f(x,map(a->(isa(a,Type) ? Type{a} : typeof(a)), args))\r\n\t       f(x,t::(Type...)) = print(t)\r\n\tf (generic function with 2 methods)\r\n\r\n\tjulia> f(1,(Int,)) # Call the second method first\r\n\t(Int64,)\r\n\tjulia> f(1,(1,2)) # And now the first method works as expected!\r\n\t((Int64,Int64),)'
6404,'JeffBezanson',"Infinite loop in type inference?\nUsing Version 0.3.0-prerelease+2455 (Commit ba8b302* (0 days old master)), I get the following stack:\r\n\r\n in typeinf at inference.jl:1352\r\n in abstract_call_gf at inference.jl:639\r\n in abstract_call at inference.jl:722\r\n in abstract_eval_call at inference.jl:813\r\n in abstract_eval at inference.jl:838\r\n in abstract_eval_arg at inference.jl:769\r\n in abstract_eval_call at inference.jl:781\r\n in abstract_eval at inference.jl:838\r\n in abstract_eval_arg at inference.jl:769\r\n in typeinf at inference.jl:1352\r\n in abstract_call_gf at inference.jl:639\r\n in abstract_call at inference.jl:722\r\n in abstract_eval_call at inference.jl:813\r\n in abstract_eval at inference.jl:838\r\n in abstract_eval_arg at inference.jl:769\r\n in abstract_eval_call at inference.jl:781\r\n in abstract_eval at inference.jl:838\r\n in abstract_eval_arg at inference.jl:769\r\n in typeinf at inference.jl:1352\r\n in abstract_call_gf at inference.jl:639\r\n in abstract_call at inference.jl:722\r\n in abstract_eval_call at inference.jl:813\r\n in abstract_eval at inference.jl:838\r\n in abstract_eval_arg at inference.jl:769\r\n in abstract_eval_call at inference.jl:781\r\n in abstract_eval at inference.jl:838\r\n in abstract_eval_arg at inference.jl:769\r\n in typeinf at inference.jl:1352\r\n...\r\n\r\n(and so on)\r\n\r\nSame issue was present in a prerelease version from ~2 months ago, in case that helps. I haven't tried replicating in 0.2.1 yet, but can do so if that would be useful.\r\n"
6387,'JeffBezanson','Segfault due to string interpolation in a method\nReported at github.com/karbarcca/Datetime.jl#42.\r\nReduced case:\r\n```julia\r\nusing Datetime\r\n \r\ntypealias DateRanges Union(DateRange,DateRange1)\r\n \r\ntype ObjMember\r\n  member::DateRanges\r\nend\r\n\r\nMemorialDay = x->month(x)==May && dayofweek(x)==Monday && dayofweekinmonth(x)==daysofweekinmonth(x)\r\nday = date(2014, 04, 01)\r\nobj = ObjMember(date(2014):MemorialDay:date(2015))\r\ninterval = [obj.member]\r\n# Don\'t segfault\r\nday in interval\r\nprintln("day_in(day::Date, obj::ObjMember) <= $(typeof(day)), $(typeof(obj))($(typeof(obj.member)))")\r\n\r\nfunction day_in(day::Date, obj::ObjMember)\r\n  println("day_in(day::Date, obj::ObjMember) <= $(typeof(day)), $(typeof(obj))($(typeof(obj.member)))")\r\n  interval = [obj.member] # cool\r\n  return (day in interval) # not cool\r\nend\r\n# Does segfault\r\nday_in(day,obj)\r\n```'
6275,'staticfloat',"Profiling doesn't work at all on OS X\nIf I run the following from the documentation here: http://julia.readthedocs.org/en/latest/stdlib/profile/\r\n\r\n```\r\njulia> function myfunc()\r\n           A = rand(100, 100, 200)\r\n           max(A)\r\n       end\r\nmyfunc (generic function with 1 method)\r\n\r\njulia> myfunc()\r\nWARNING: max(x) is deprecated, use maximum(x) instead.\r\n0.9999994755239174\r\n\r\njulia> @profile myfunc()\r\nWARNING: max(x) is deprecated, use maximum(x) instead.\r\n0.9999998409036248\r\n\r\njulia> Profile.print()\r\n\r\njulia>\r\n\r\n```\r\n\r\nThis may be related to: https://github.com/JuliaLang/julia/issues/3469, as I never get any backtraces either.\r\n\r\nI'm running  Version 0.3.0-prerelease+2156 (2014-03-24 16:53 UTC), Commit c81664a* (2 days old master), x86_64-apple-darwin13.0.0. Installed through homebrew.\r\n\r\nHappy to explore, debug, but I'm relatively new to Julia so would need some pointers on where to poke around."
6274,'simonster',"inferred macro in Base.Test seems to be undocumented\nCouldn't find it here: http://docs.julialang.org/en/latest/stdlib/test/"
6227,'stevengj',"install utf8proc.h\nThis is needed by `src/flisp/julia_extensions.c`, and would be useful to have included in the binary installs.\r\n\r\nWe're currently building a static library of `libutf8proc.a`, but not installing it. That could be added as well, thoughts? The header's about 15 kb, the static library more like 550-650 kb.\r\n\r\n(Similar story for openlibm, the static library and some of its headers are used by base Julia but not getting installed.)"
6192,'jiahao','broadcasting scalar multiplication/division for UniformScaling\nMotivation: allow things like \r\n```\r\n3.0 * {I, rand(4,4)}\r\n```\r\nwhich is not currently allowed without ``3.0 .* I`` as a valid operation (it falls back to https://github.com/JuliaLang/julia/blob/master/base/abstractarray.jl#L327). '
6175,'JeffBezanson','ERROR: no method start(Nothing) in the presence of @show\nPlaying with a variant of array indexing rules:\r\n\r\n```julia\r\njulia> f()=(); f(i::Real, I...)=f(I...); f(i,I...)=tuple(length(i),f(I...)...);\r\n\r\njulia> f(1:5)\r\n(5,)\r\n\r\njulia> function g(); @show "A<", (); x=(); @show x, ">A"; x; end;\r\n\r\njulia> function g(i::Real, I...); @show "B<", i, I; x=g(I...); @show x, ">B"; x; end;\r\n\r\njulia> function g(i, I...); @show "C<", i, I; x=tuple(length(i), g(I...)...); @show x, ">C"; x; end;\r\n\r\njulia> g(1:5)\r\n("C<",i,I) => ("C<",1:5,())\r\n("A<",()) => ("A<",())\r\n(x,">A") => ((),">A")\r\nERROR: no method start(Nothing)\r\n in g at none:1\r\n\r\n```'
6161,'JeffBezanson','A very weird method dispatch bug\nThis bug is due to a recent Base update, and it causes the test failure of Distributions.jl\r\n\r\nRelated code: (https://github.com/JuliaStats/Distributions.jl/blob/master/src/univariate/categorical.jl#L225)\r\n```julia\r\nfunction fit_mle{T<:Integer}(::Type{Categorical}, k::Integer, x::Array{T}) \r\n    Categorical(normalize!(add_categorical_counts!(zeros(k), x), 1), NoArgCheck())\r\nend\r\n\r\nfit_mle{T<:Integer}(::Type{Categorical}, data::(Int, Array{T})) = \r\n      fit_mle(Categorical, data...)\r\n```\r\n\r\nThen in Julia:\r\n```julia\r\njulia> using Distributions\r\n\r\njulia> x = rand(1:3, 10);\r\n\r\njulia> fit_mle(Categorical, 3, x)\r\nCategorical( K=3 prob=[0.7000000000000001, 0.30000000000000004, 0.0] )\r\n\r\njulia> fit_mle(Categorical, (3, x))\r\nBinomial( size=3 prob=0.43333333333333335 )\r\n```\r\n\r\nHowever, it I change the last ``fit_mle`` method to \r\n```\r\nfit_mle{T<:Integer}(::Type{Categorical}, data::(Int, Array{T})) = \r\n      fit_mle(Categorical, data[1], data[2])\r\n```\r\nThen it works correctly.\r\n\r\nIt is very weird why ``fit_mle(Categorical, data...)`` calls a wrong method, while ``fit_mle(Categorical, data[1], data[2])`` is correct. \r\n\r\nRelated to https://github.com/JuliaStats/Distributions.jl/issues/198\r\n\r\ncc: @JeffBezanson @StefanKarpinski '
6142,'JeffBezanson','Method sorting bug\n```julia\r\njulia> type A <: AbstractMatrix{Float64}; end\r\n\r\njulia> +{TJ}(x::A, y::UniformScaling{TJ}) = "UniformScaling method called";\r\n\r\njulia> +(x::A, y::AbstractArray) = "AbstractArray method called";\r\n\r\njulia> A() + I\r\n"AbstractArray method called"\r\n```\r\n\r\nSwitching around the order of the definitions fixes this.'
6139,'stevengj','segfault with files which only contain non-terminating multiline comments\nI know this is silly, but writing a file which contains just `#=` segfaults julia, instead of producing the "unterminated multi-line comment" error.'
6074,'JeffBezanson','macroexpander and let block scope subtlety\nThe macro-expander de-escape function appears to be unaware of let blocks:\r\n```julia\r\njulia> macro X()\r\n         quote\r\n           global x \r\n           let x = x\r\n           println(x)\r\n       end\r\n       end\r\n       end\r\n\r\njulia> macroexpand(:(@X))\r\n:(begin  # none, line 3:\r\n        global x # line 4:\r\n        let #113#x = #113#x # line 5:\r\n            println(#113#x)\r\n        end\r\n    end)\r\n\r\njulia> macro X()         \r\n         quote\r\n           global y\r\n           let x = y\r\n           println(x)\r\n       end\r\n       end\r\n       end\r\n\r\njulia> macroexpand(:(@X))\r\n:(begin  # none, line 3:\r\n        global y # line 4:\r\n        let #114#x = y # line 5:\r\n            println(#114#x)\r\n        end\r\n    end)\r\n```'
6052,'JeffBezanson',"Running size twice on AbstractArray yields error, then correct answer\n```\r\ntype MyType{T,N,A<:AbstractArray} <: AbstractArray{T,N}\r\n    data::A\r\n    extra::Int\r\nend\r\n\r\nimport Base.size\r\nsize(obj::MyType) = size(obj.data)\r\n\r\nB = rand(1:20,3,5)\r\nS = sub(B, 2, 1:4)\r\ns = MyType{Int,2,typeof(S)}(S, 3);\r\n```\r\nNow from the REPL:\r\n```\r\njulia> size(s)\r\nERROR: type: SubArray: in I, expected I<:(Union(Range1{Int64},Int64,Range{Int64})...,), got Type{(_<:Range1{T<:Real},_<:Range1{T<:Real})}\r\n\r\njulia> size(s)\r\n(1,4)\r\n```\r\n(I didn't do anything other than run it again.)\r\n`git bisect` identifies db39be105675af0ca3285e8ff1fbf66ef55ee3de\r\nCC @JeffBezanson "
6050,'JeffBezanson','undefined reference with Dict{}\nI recompiled Julia and my code is not running anymore. I was able to isolate the problem and it gets triggered with commit db39be105675af0ca3285e8ff1fbf66ef55ee3de. This small piece of code triggers it\r\n\r\n```\r\ntypealias BBox (Range1{Int64},Range1{Int64})\r\n\r\nd = Dict{Int64, BBox}()\r\n\r\nfor i=1:500\r\n\tk = iround( rand() * 1000000 )\r\n\r\n\t@show i\r\n\td[k] = ( 1:20, 3:40 )\r\nend\r\n```\r\n\r\nOutput is\r\n```\r\ni => 1\r\ni => 2\r\ni => 3\r\ni => 4\r\ni => 5\r\ni => 6\r\ni => 7\r\ni => 8\r\ni => 9\r\ni => 10\r\ni => 11\r\n\r\nOut [8]: ERROR: access to undefined reference\r\nwhile loading /tmp/test.jl, in expression starting on line 6\r\nwhile loading In[8], in expression starting on line 1\r\n in copy! at abstractarray.jl:168\r\n in rehash at dict.jl:425\r\n in _setindex! at dict.jl:528\r\n in setindex! at dict.jl:544\r\n in anonymous at no file:10\r\n```'
6031,'JeffBezanson','Functional form of macro calls and indexing: @m(x)[3]\nWhen a macro call is written as a function, and that is immediately followed by [] for array indexing, a syntax error results. Here is an example.\r\n\r\n```julia\r\njulia> macro m(x); :( $x ); end\r\n\r\njulia> @m([1,2,3])\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 3\r\n\r\njulia> @m([1,2,3])[3]\r\nERROR: syntax: invalid macro use "@(m([1,2,3])[3])"\r\n\r\njulia> @m([1,2,3]) [3]     # add an extra space\r\n3\r\n```\r\nThe form works with an extra space between the macro call and the brackets or with parens around the macro call.\r\n'
6017,'carlobaldassi','Improperly indexed bitarrays sometimes causing stack overflow\n```julia\r\nb=randbool(5)\r\nb[[(1, 1)]]\r\nERROR: stack overflow\r\n in getindex at multidimensional.jl:235\r\n in getindex at multidimensional.jl:236 (repeats 79999 times)\r\n```'
5995,'amitmurthy','Store external ip in case of localhost addprocs\nCurrently, "127.0.0.1" is stored in the Worker struct for `addprocs(n)`. This causes the issue as reported in https://github.com/nlhepler/ClusterManagers.jl/issues/6\r\n\r\nWe should preferably store the external ip-address and broadcast the same to newer workers added.'
5959,'quinnj','Implement proper print_shortest for Float16\nAfter https://github.com/JuliaLang/julia/issues/5948 `Float16` prints 5 significant digits, to ensure that every printed `Float16` value parses back to the same value. This fix is not in line with how we print `Float32` and `Float64` and the documentation for `print_shortest`, and I think this would make a nice "up-for-graps" issue.\r\n\r\n```julia\r\njulia> float16(0.1)\r\nfloat16(0.099976)\r\n\r\njulia> float32(0.1)\r\n0.1f0\r\n\r\njulia> float64(0.1)\r\n0.1\r\n```\r\nThere might be a reason to explicitly show the horrible precision for `Float16` by default, but `print_shortest` should give the documented answer.'
5912,'JeffBezanson','bug in jl_toplevel_eval_flex\nhttps://github.com/JuliaLang/julia/blob/cabdd238bef07742ba1d24862a127eb3c9c21488/src/toplevel.c#L447\r\n\r\nat this line, `jl_toplevel_eval_flex` assumes it has an Expr, but we sometimes see a literal `nothing` during building the sysimg, or loading `Cairo.jl`\r\n\r\neasy to fix, but @JeffBezanson can you confirm that is all that is wrong\r\n\r\n(possibly related to https://github.com/JuliaLang/Gtk.jl/issues/69)'
5885,'JeffBezanson',"convert(Type{Float16}, Float32) bug\nThis doesn't work:\r\n\r\n```julia\r\njulia> convert(Float16,0) |> typeof\r\nERROR: no method convert(Type{Float16}, Float32)\r\n in convert at float.jl:13\r\n```\r\n\r\nYet if you look at the definition of this conversion, it is this:\r\n\r\n```julia\r\nconvert(::Type{Float16}, x::Union(Signed,Unsigned)) = convert(Float16, convert(Float32,x))\r\n```\r\n\r\nand doing this explicitly works just fine:\r\n\r\n```julia\r\njulia> convert(Float16,convert(Float32,0)) |> typeof\r\nFloat16\r\n```"
5877,'carlobaldassi',"Comparison operators do not broadcast\nI'm used to every operator with a `.` before it broadcasting, but this is not the case for `.==`, `.>`, etc.:\r\n\r\n```julia\r\njulia> A = ones(2, 2);\r\n\r\njulia> B = ones(2);\r\n\r\njulia> A .+ B\r\n2x2 Array{Float64,2}:\r\n 2.0  2.0\r\n 2.0  2.0\r\n\r\njulia> A .== B\r\nERROR: dimensions must match\r\n in promote_shape at operators.jl:173\r\n in .== at bitarray.jl:1184\r\n```\r\n\r\nIs there a good reason for these *not* to broadcast?"
5793,'Keno','Julia does not exit after script with tcpsocket finishes\nFile `testsrvr.jl`:\r\n````\r\nserver = listen(11111)\r\nsock = accept(server)\r\nprintln("srvr accepted conn")\r\nsleep(2)\r\nclose(sock)\r\nprintln("srvr closed conn")\r\nprintln("srvr exit")\r\n````\r\n\r\nFile `testclnt.jl`:\r\n````\r\nsock = connect("localhost", 11111)\r\nprintln("clnt connected")\r\nclose(sock)\r\nprintln("clnt closed conn")\r\nprintln("clnt exit")\r\n````\r\n\r\nRun server and client:\r\n````\r\n$ julia testsrvr.jl &\r\n[1] 65636\r\n$ julia testclnt.jl &\r\n[2] 65638\r\n$ srvr accepted conn\r\nclnt connected\r\nclnt closed conn\r\nclnt exit\r\nsrvr closed conn\r\nsrvr exit\r\n\r\n$ netstat -na | grep 11111\r\n$ \\ps -ef | grep julia\r\n  502 65636 41832   0  2:24PM ttys003    0:00.76 julia testsrvr.jl\r\n  502 65638 41832   0  2:24PM ttys003    0:00.71 julia testclnt.jl\r\n  502 65642 41832   0  2:25PM ttys003    0:00.01 grep julia\r\n````\r\n\r\nBoth Julia processes hang around even after the scripts finish execution and sockets seem to have been closed properly.\r\n'
5756,'StefanKarpinski','printf for big int/float\n```julia\r\njulia> @printf("%d", big(pi)^2000)\r\nAssertion failed: (!Double(v).IsSpecial()), function DoubleToAscii, file src/double-conversion.cc, line 365.\r\nzsh: abort      julia\r\n```'
5752,'JeffBezanson','assertion failure on uncertain ccall return type\n```julia\r\njulia> h{T}(::Type{T}) = ccall(:time, Ptr{T.parameters[1]}, (Int,), 0)+1\r\nh (generic function with 1 method)\r\n\r\njulia> h(Vector{Int})\r\nAssertion failed: ("Don\'t know how to box this type" && false), function boxed, file ./cgutils.cpp, line 1522.\r\n```\r\n\r\nThis happens because ccall returns an unboxed Ptr{Int}, but codegen doesn\'t quite know what to expect when it goes to box it (inference told it to expect `Ptr{T}`)'
5689,'JeffBezanson','Dot operator syntax warts\nThe inconsistencies between the syntax of the dot-arithmetic and dot-relational operators have tripped me up (in the REPL, where I may be too brief) more times than I care to admit.  First the positives:\r\n```\r\njulia> 1.+[0:1]\r\n2-element Array{Int64,1}:\r\n 1\r\n 2\r\n\r\njulia> 1.0.+[0:1]\r\n2-element Array{Float64,1}:\r\n 1.0\r\n 2.0\r\n```\r\nSo far, so good.  Do not try that with the relational operators:\r\n```\r\njulia> 1.<[0:1]\r\nERROR: no method isless(Float64, Array{Int64,1})\r\n in < at operators.jl:18\r\n\r\njulia> 1.0.<[0:1]\r\nERROR: syntax: invalid numeric constant "1.0."\r\n```\r\nI propose that all the dot-relational operators, two and three character, be treated in the lexer the same as the dot-arithmetic operators.  Of course it is late in the day for such a change; is it too late though?\r\n'
5577,'JeffBezanson','Strange dispatch bug with ::Type, depends on order of function evaluations\nRunning\r\n\r\n    f(::Any)=false\r\n    f(::Type)=true\r\n    @show  f((Int,String,2))\r\n    @show  f(((Int,String),String))\r\n    @show  f((Int,))\r\n    @show  f((Int,String))\r\n    @show  f(Int)\r\n\r\nin a fresh julia session gives\r\n\r\n    f((Int,String,2)) => false\r\n    f(((Int,String),String)) => false\r\n    f((Int,)) => false\r\n    f((Int,String)) => false\r\n    f(Int) => true\r\n\r\nBut if we remove `@show  f((Int,String,2))` then it works as expected:\r\n\r\n    f(::Any)=false\r\n    f(::Type)=true\r\n    @show  f(((Int,String),String))\r\n    @show  f((Int,))\r\n    @show  f((Int,String))\r\n    @show  f(Int)\r\n\r\ngives\r\n\r\n    f(((Int,String),String)) => true\r\n    f((Int,)) => true\r\n    f((Int,String)) => true\r\n    f(Int) => true\r\n\r\nIt seems like the negative result for `@show  f((Int,String,2))` somehow contaminates the further invocations.'
5575,'JeffBezanson','too many method matches for zeros(Type, ...)\nThe underlying cause of #5559 is now fixed, but this was the immediate cause. Before JuliaLang/julia@6002358b2313d32d1384dbf0656af11cb15ebc3d:\r\n\r\n```julia\r\njulia> f() = zeros(Type[Float64][1], 1);\r\n\r\njulia> code_typed(f, ())\r\n1-element Array{Any,1}:\r\n :($(Expr(:lambda, {}, {{},{},{}}, quote  # none, line 1:\r\n        return zeros(arrayref(getindex(Type,Float64)::Array{Type{T<:Top},1},1)::Type{T<:Top},1)::Array{T,1}\r\n    end)))\r\n```\r\n\r\nAfter:\r\n\r\n```julia\r\njulia> f() = zeros(Type[Float64][1], 1);\r\n\r\njulia> code_typed(f, ())\r\n1-element Array{Any,1}:\r\n :($(Expr(:lambda, {}, {{},{},{}}, quote  # none, line 1:\r\n        return zeros(arrayref(getindex(Type,Float64)::Array{Type{T<:Top},1},1)::Type{T<:Top},1)::AbstractArray{T,N}\r\n    end)))\r\n```'
5559,'JeffBezanson','non-sensical MethodError\nThe tests for DSP.jl master are currently failing with a MethodError (JuliaDSP/DSP.jl#19):\r\n\r\n```julia\r\n ERROR: no method convert(Type{Array{Complex{Float64},1}}, Array{Float64,1})\r\n```\r\n\r\nThat method definitely exists: We are importing `convert` from Base before extending it, and inserting `print(code_lowered(convert, (Type{Array{Complex{Float64},1}}, Array{Float64,1})))` above the line that throws shows the method source. `git bisect` shows that the error first appears with JuliaLang/julia@6002358b2313d32d1384dbf0656af11cb15ebc3d (cc @JeffBezanson).'
5536,'JeffBezanson','Order of definition matters for splatting functions\n```\r\nfunction test(a::Union(Real, AbstractArray)...)\r\n  println("Splatting")\r\nend\r\nfunction test(a::Union(Real, AbstractArray))\r\n  println("Non-splatting")\r\nend\r\n```\r\n```\r\njulia> test(5)\r\nSplatting\r\n```\r\nIf you switch the order of definition, it calls the non-splatting version.\r\n'
5497,'JeffBezanson',"show fails with TypeConstructor\nThis afternoon, @StefanKarpinski and @loladiro and I hit a bug.  If you type `methods(+)` in the REPL, you get:\r\n```\r\nERROR: type TypeConstructor has no field name\r\n in show at show.jl:66\r\n in argtype_decl at methodshow.jl:18\r\n in arg_decl_parts at methodshow.jl:30\r\n in show at methodshow.jl:36\r\n in show_method_table at methodshow.jl:61\r\n in show at methodshow.jl:74\r\n in anonymous at show.jl:869\r\n in showlimited at show.jl:868\r\n in writemime at repl.jl:2\r\n in display at multimedia.jl:118\r\n in display at multimedia.jl:120\r\n in display at multimedia.jl:152\r\n```\r\nThe problem seems to be that `show(x::DataType)` expects `x.name.name` to exist, but `TypeConstructor` (`x.name`?) does not have this field.  (I'm actually not even sure what `TypeConstructor` is; I can't get it to show up reliably except via `methods(+)`.)\r\n\r\nI did a `git bisect`, and it claims the problem showed up in commit 2c2d165681164dc7b77fb0d89be95dc1356a4ee9, but this seems kinda random to me."
5478,'JeffBezanson','error in remote loading code with dependencies\nFrom julia-users:\r\n\r\n```\r\nmodule MyModule\r\n\r\n\tusing DataStructures\r\n\texport foo\r\n\r\n\tfunction foo(i)\r\n\t\treturn Queue(i)\r\n\tend\r\n\r\nend # module\r\n```\r\n\r\nIf that file is loaded using `@everywhere include("module.jl")` you get errors, but `require` seems to work.'
5469,'JeffBezanson',"regression in performance of counting loops\nI was playing around with an example for the class I'm preparing and noticed a 30% performance regression in the following code from 0.2 to master:\r\n\r\n```julia\r\nfunction normAndMin(x)\r\n    n = 0.0\r\n    m = Inf\r\n    for i in 1:length(x)\r\n        n += x[i]*x[i]\r\n        if x[i] < m\r\n            m = x[i]\r\n        end\r\n    end\r\n    return sqrt(n),m\r\nend\r\n\r\nx = rand(100_000_000)\r\nnormAndMin(x) # throw away\r\nn,m = @time normAndMin(x)\r\n```\r\n\r\nJulia 0.2:\r\n``elapsed time: 0.101895311 seconds (6912 bytes allocated)``\r\n\r\nJulia master:\r\n``elapsed time: 0.135729463 seconds (6812 bytes allocated)``"
5459,'Keno',"make sys.so redistributable or generate it at install time\nBetter startup time is one of the main features of 0.3. For it to work, we need to generate sys.so on the user's machine. @loladiro and I decided the best way to do this in time for 0.3 is to generate the .so ourselves (not calling llc) after install."
5453,'Keno','Bug in countlines (or in eof, when reading from a Cmd)\nCountlines will hang when reading from a pipe.  Here is a simple example.  The first countlines returns 3, but the second one never returns.\r\n\r\n```\r\nfpath = "/tmp/testfile"\r\ndata = {"the quick brown","fox jumps over", "the lazy dog"}\r\nwritedlm(fpath, data)\r\nio = open(fpath)\r\n@show countlines(io)\r\nio = readsfrom(`cat $fpath`)[1]\r\n@show countlines(io)  # this hangs forever\r\n```\r\n\r\nI\'ve tracked this as far as the implementation of countlines, and can show that the read() does not properly set EOF when reading from a pipe, whereas readbytes! does.\r\n\r\n```\r\nusing Base.Test\r\na = Array(Uint8, 1024)\r\nio = readsfrom(`cat $fpath`)[1]\r\ntry\r\n    readbytes!(io, a, length(a))\r\nend\r\n@test eof(io)   # this test passes\r\n\r\nio = readsfrom(`cat $fpath`)[1]\r\ntry\r\n    read(io, a)\r\nend\r\n@test eof(io)   # this test fails\r\n```\r\n\r\nSeems to me a simple fix for countlines is to replace read with readbytes!.\r\n\r\nBut I do not know the underlying reason for the problem.  I tracked it into ios_readall, and then got lost.\r\n\r\nHere is my versioninfo:\r\nJulia Version 0.3.0-prerelease+688\r\nCommit f424d0a* (2013-12-25 20:04 UTC)\r\nPlatform Info:\r\n  System: Linux (x86_64-linux-gnu)\r\n  WORD_SIZE: 64\r\n  BLAS: libblas\r\n  LAPACK: liblapack\r\n  LIBM: libopenlibm\r\n\r\n\r\n'
5450,'Keno',"backtrace line number off by 2\n```\r\n _/ |\\__'_|_|_|\\__'_|  |  Commit aabd983 (0 days old master)\r\n|__/                   |  x86_64-linux-gnu\r\n\r\njulia> mmap_array(Int64, (10,10), fdio(5), 10)\r\nERROR: Illegal seek\r\n in error at error.jl:21\r\n in mmap_grow at mmap.jl:51\r\n in mmap_array at mmap.jl:120\r\n```\r\n\r\n` mmap_array at mmap.jl:120` should be ` mmap_array at mmap.jl:118`\r\n\r\n"
5406,'JeffBezanson','make sizeof a builtin\nSince the role of `sizeof` is to tell you the size of the representation of an object, it seems sensible to make it a builtin since the system itself is in the best position to know this. This is one of the few things that really should *not* be a generic function. In particular, it would be nice to be able to do things like `sizeof((1,2//3))` and get a correct answer.'
5398,'vtjnash','correct return value of _seh_exception_handler\nhttps://github.com/JuliaLang/julia/pull/5379/files#r8886140'
5388,'vtjnash','convert setjmp/longjmp to Intel syntax\n'
5375,'tanmaykm','readcsv on comma delimited file where fields contain strings that have commas fails with BoundsError()\nThis is handled fine by excel, but it causes readcsv and DataFrames\'s readtable to blow up.\r\n\r\nIf you have a file with\r\n~~~\r\n"foo","bar","baz"\r\n"foo,foo","bar","baz"\r\n~~~\r\n\r\nreadcsv will consider the comma inside "foo, foo" to be a delimiting comma. If this is a conscious decision, that\'s fine; just filing this issue in case this is something you aren\'t aware of.'
5374,'JeffBezanson',"auto_unbox error with read(io, Float64) on Julia 0.2\nHi,\r\n\r\nI think I've found a very odd bug in Julia 0.2/8123c9e (RHEL5.5).  \r\n\r\nIn different branches of an if/else in the same inner loop I have the following statement:\r\n\r\n```Julia\r\nxtype = Float64\r\nytype = Float64\r\nif something\r\n  val1 = read(io, xtype)\r\n  (snip)\r\nelse\r\n  val2 = read(io, ytype)\r\n  (snip)\r\nend\r\n```\r\n\r\nThe first `read` statement errors out with no line numbers in Base:\r\n`ERROR: auto_unbox: unable to determine argument type`\r\n\r\nWhile the second `read` to get `val2` works fine.  I tried to debug by replacing the first one with:\r\n\r\n```Julia\r\nfunction read_float64(io)\r\n    a = Base.read(io,Int64)\r\n    b = Base.unbox(Int64,a)\r\n    c = Base.box(Float64 ,b)\r\n    return c\r\nend\r\n```\r\n\r\nAnd then it works.  But the following does not:\r\n\r\n```Julia\r\nfunction read_float64(io, xtype)\r\n    a = Base.read(io,Int64)\r\n    b = Base.unbox(Int64,a)\r\n    c = Base.box(xtype,b)\r\n    return c\r\nend\r\n```\r\nI get a different error:\r\n`ERROR: error compiling read_float64: box: could not determine argument size`\r\n\r\nI tried removing the `xtype` variable by replacing it with `Float64` but I got the same errors.\r\n\r\nI'm out of ideas how to debug this.  If you have any suggestions please let me know. \r\n\r\nThanks,\r\n\r\nGlen\r\n\r\n"
5359,'JeffBezanson','Changed behaviour of AbstractVector ?\nLooks like AbstractVector changed around 5 days ago:\r\n\r\nwith Version 0.3.0-prerelease+877 (2014-01-11 09:25 UTC)\r\n```\r\njulia> type Foo\r\n           v::AbstractVector\r\n       end\r\n\r\njulia> f = Foo([1,2,3])\r\nFoo([true,true,true])\r\n\r\njulia> f.v\r\n3-element BitArray{1}:\r\n true\r\n true\r\n true\r\n```\r\n\r\nversus Version 0.3.0-prerelease+856 (2014-01-07 07:23 UTC)\r\n```\r\njulia> type Foo\r\n           v::AbstractVector\r\n       end\r\n\r\njulia> f = Foo([1,2,3])\r\nFoo([1,2,3])\r\n\r\njulia> f.v\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 3\r\n```\r\n\r\nWas this change intentional?'
5344,'vtjnash','redirect both stdout and stderr of a process to the same stream\nCurrently, there is no operator to redirect both stderr and stdout to the same target (in bash that would be `&>`), or to collapse them before redirecting (in bash: `2>&1`). I think we should come up with some general scheme for this kind of things (at some point there was an idea about using dictionaries to represent redirections), but even with what we have I was expecting to be able to do this:\r\n\r\n```julia\r\nopen("out.txt", "w") do f\r\n    run(`ls exists.txt doesnotexsist.txt` |> f .> f)\r\nend\r\n```\r\n\r\nbut this fails since it only redirects stdout.\r\nMy current workaround is this ugly hack:\r\n\r\n```julia\r\nfunction open_twice(func, fn, args...)\r\n    open(fn, args...) do f1\r\n        f2 = fdio(int32(Base.dup(RawFD(fd(f1)))), true)\r\n        try\r\n            func(f1, f2)\r\n        finally\r\n            close(f2)\r\n        end\r\n    end\r\nend\r\n\r\nopen_twice("lsout.txt", "w") do f1,f2\r\n    run(`ls exists.txt doesnotexsist.txt` |> f1 .> f2)\r\nend\r\n```\r\n\r\nCould the first attempt be made to work instead? I tried looking at the code but as soon as it goes into libuv I\'m lost. So I could make a patch and put the ugly hack in place if stdout and stderr are the same, but I suppose there is a better alternative.'
5319,'JeffBezanson',"Strange function dispatch behavior?\nI'm very confused by the following behavior, which is similar to some other function dispatch quirks I've hit up against before and never found a simple example of:\r\n\r\n\r\n    using DataFrames\r\n\r\n    adf = DataFrame(A = DataArray(Any[1, 2]))\r\n\r\n    # Fails as a function\r\n    function tighttypes!(adf::AbstractDataFrame)\r\n        nrows, ncols = size(adf)\r\n        for j in 1:ncols\r\n            T = None\r\n            col = adf[j]\r\n            for i in 1:nrows\r\n                if !isna(col[i])\r\n                    T = typejoin(T, typeof(col[i]))\r\n                end\r\n            end\r\n            adf[j] = convert(DataVector{T}, col)\r\n        end\r\n        return\r\n    end\r\n\r\n    tighttypes!(adf)\r\n    #ERROR: no method convert(Type{DataArray{Int64,1}}, DataArray{Any,1})\r\n    # in tighttypes! at none:11\r\n\r\n    # Fails outside of function body in a loop\r\n    nrows, ncols = size(adf)\r\n    for j in 1:ncols\r\n        T = None\r\n        col = adf[j]\r\n        for i in 1:nrows\r\n            if !isna(col[i])\r\n                T = typejoin(T, typeof(col[i]))\r\n            end\r\n        end\r\n        adf[j] = convert(DataVector{T}, col)\r\n    end\r\n    # ERROR: no method convert(Type{DataArray{Int64,1}}, DataArray{Any,1})\r\n    #  in anonymous at no file:9\r\n\r\n    # But this operation succeeds outside of a loop\r\n    j = 1\r\n    T = None\r\n    col = adf[j]\r\n    for i in 1:nrows\r\n        if !isna(col[i])\r\n            T = typejoin(T, typeof(col[i]))\r\n        end\r\n    end\r\n    adf[j] = convert(DataVector{T}, col)\r\n    # 2-element DataArray{Int64,1}:\r\n    # 1\r\n    # 2\r\n"
5305,'carlobaldassi','Nightlies for 0.3.0\nIIRC, we used to have nightlies for the mac at one point, and I believe that the ubuntu nightlies keep coming.\r\n\r\nIt would be nice to have the nightlies back on the downloads page.'
5262,'JeffBezanson','evalfile can\'t see eval function\nSave the following to a file "test.jl"\r\n```julia\r\nfunction f(m)\r\n    eval(m, :Int)\r\nend\r\n\r\nf(Main)\r\n```\r\n\r\nWhen we try to run it with evalfile, mysteriously `eval` is missing:\r\n```\r\njulia> evalfile("test.jl")\r\nERROR: eval not defined\r\n in f at /Volumes/Lion/Users/jameson/Documents/julia/test.jl:2\r\n in evalfile at loading.jl:162\r\nwhile loading /Volumes/Lion/Users/jameson/Documents/julia/test.jl, in expression starting on line 5\r\n```'
5254,'JeffBezanson','incorrect function type match\nI\'m pretty sure it is calling the wrong method here:\r\n```\r\njulia> f{T}(::Type{T}, b::T) = error("wrong method: $T")\r\nf (generic function with 1 methods)\r\n\r\njulia> f(a, b) = println("good")\r\nf (generic function with 2 methods)\r\n\r\njulia> f(None, 1)\r\nERROR: wrong method: None\r\n in error at error.jl:21\r\n in f at none:1\r\n\r\njulia> isa(1,None)\r\nfalse\r\n```'
5237,'vtjnash','debugging tools for win platforms\n#4925, for windows'
5227,'JeffBezanson',"WIP: Incremental GC\nThis is work I started when hitting long GC pause in a soft realtime application. No matter how low you can bring the allocation count down (and the language admittedly makes it easy), there is still a point where you must wait for tens of ms which is a pain in, e.g., render code at 60 fps.\r\n\r\nTo be clear this is only incremental marking, but incremental sweeping should be much easier.\r\nThis patch :\r\n\r\n- Adds a new gc bit on each type field of each julia object which records if it is scheduled for marking (the so called grey bit)\r\n- Adds a write barrier to all pointer stores to gc-managed slots (in C runtime and codegen)\r\n- Make the GC able to run partial marking phase\r\n- Adds a verifier which can run before each sweep to verify we did not miss a write.\r\n\r\nSome points :\r\n- The write barrier is explicit in C code. Most of it looks like :\r\n```\r\na->b = ...;\r\ngc_wb(a, a->b);\r\n```\r\nThis is ugly and could be resolved with a macro (something like ```gc_store(a, b, ...);```) but I was not sold on changing such pervasive syntax.\r\n- The current heuristics are quite bad : the collect interval is simply divided by 10 and partial markings works with an increasing timeout (1ms then 1.3*previous_timeout). I expect some low hanging fruits for efficiency here, if only because I chose those constants arbitrarily ;)\r\n- Performances : nothing is free so there is a perf hit. I believe it could be brought down as I was mainly focused on getting it correct until recently. My measurements are on running the full test suite. It takes about 10% more time to run but the pause times (for the mark phase) goes down from : max 40ms, 95% sub 30ms to max 5ms, 95% sub 2ms.\r\n- Even if low-pause is not a focus point for the julia community ATM, the write barrier can be used to make the GC generational. In fact, you could turn this PR into a poor man's generational GC simply by not reseting the marks at the end of a sweep. I did not experiment in this direction yet, but doing it properly would require the GC to support moving, which is its own can of worms.\r\n\r\nTo enable, build with -DGC_INC. GC_VERIFY enables the verifier and GC_TIME prints pause timings.\r\n\r\nOf course, feedback is much appreciated. Cheers !\r\n"
5169,'ViralBShah','sparse nonzeros behavior\nI have noticed that performing operations on CSC sparse matrices can introduce negative zero entries, which are then seen as nonzero entries. Is there any way to remove these zero entries easily from the matrix?\r\n\r\nAlso, the warn_once lines in /base/sparse/sparsematrix.jl should be Base.warn_once. Otherwise, the find command crashes because it cannot find warn_once.'
5150,'JeffBezanson','array typing bug\n```\r\njulia> f(T) = Array(Rational{T},1)\r\nf (generic function with 1 method)\r\n\r\njulia> typeof(f(Int))\r\nArray{Rational{T<:Top},1}\r\n```'
5106,'JeffBezanson','Long-running script messes up output after a while\nI have a pretty long-running script (several hours), which is responsible for invoking executables (including `julia` itself again), and capturing its output. After some hours though, the parent process manages to mess up its output, crashing in some core part library:\r\n```\r\nExecuting ../matlab/demo.m...                                                               \r\nExecuting ../c++/build/release/demo...                                                      \r\nExecuting ../cuda/build/release/demo...                                                     \r\nExecuting ../openmp/build/release/demo...                                                   \r\nExecuting ../julia/demo.jl...                                                               \r\nERROR:                                                                                      \r\n in abstract_call_gf at inference.jl:603                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_interpret at inference.jl:956                                                  \r\n in typeinf at inference.jl:1257                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in typeinf at inference.jl:1322                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_interpret at inference.jl:956                                                  \r\n in typeinf at inference.jl:1257                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_interpret at inference.jl:956                                                  \r\n in typeinf at inference.jl:1257                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_interpret at inference.jl:956                                                  \r\n in typeinf at inference.jl:1257                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in typeinf at inference.jl:1322                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in abstract_eval_call at inference.jl:755                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in abstract_eval_call at inference.jl:755                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in abstract_eval_call at inference.jl:755                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in typeinf at inference.jl:1322                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_interpret at inference.jl:956                                                  \r\n in typeinf at inference.jl:1257                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in abstract_eval_call at inference.jl:755                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_interpret at inference.jl:956                                                  \r\n in typeinf at inference.jl:1257                                                            \r\n in abstract_call_gf at inference.jl:621                                                    \r\n in abstract_call at inference.jl:699                                                       \r\n in abstract_eval_call at inference.jl:787                                                  \r\n in abstract_eval at inference.jl:812                                                       \r\n in abstract_eval_arg at inference.jl:746                                                   \r\n in typeinf at inference.jl:1322                                                            \r\n in typeinf_ext at inference.jl:1090                                                        \r\n in include at boot.jl:238                                                                  \r\n in include_from_node1 at loading.jl:114                                                    \r\n in process_options at client.jl:303                                                        \r\n in _start at client.jl:389fatal: error thrown and no exception handler available.\r\nBase.TypeError(func=:subtype, context="", expected=Type{T}, got=(Base.IOBuffer, <?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?::<?:: [snip]\r\n```\r\nThis list of `<?::`\'s goes on for quite a while (hundreds of repetitions), and then it stops. Afterwards, new `print` entries seem work again: although I don\'t see the output on my screen, they do end up in the log file `STDOUT` is redirected to (see invocation command below). This might bee a `tee` issue though.\r\n\r\nI\'m using julia 0.2 from the Debian repositories, and the script is launched as following:\r\n```\r\n./script.jl |& tee -a script.log\r\n```'
4990,'JeffBezanson','Array evaluation order\nContinuing #4982, evaluation order for arrays is also inconsistent:\r\n```\r\njulia> x=65; [x,x|=0x20]\r\n2-element Array{Int32,1}:\r\n 97\r\n 97\r\n\r\njulia> x=65; {x,x|=0x20}\r\n2-element Array{Any,1}:\r\n 65\r\n 97\r\n```'
4979,'JeffBezanson','possible macro hygiene bug\nChanging the definition of `Pkg.Entry.add(::String, ::VersionSet)` to the following works:\r\n\r\n```julia\r\nconst reqs_add = Reqs.add\r\n\r\nfunction add(pkg::String, vers::VersionSet)\r\n    @sync @async begin\r\n        if !edit(reqs_add,pkg,vers)\r\n            ispath(pkg) || error("unknown package $pkg")\r\n            info("Nothing to be done.")\r\n        end\r\n    end\r\nend\r\n```\r\n\r\nOn the other hand, this version, which should be equivalent, does not:\r\n\r\n```julia\r\nfunction add(pkg::String, vers::VersionSet)\r\n    @sync @async begin\r\n        if !edit(Reqs.add,pkg,vers)\r\n            ispath(pkg) || error("unknown package $pkg")\r\n            info("Nothing to be done.")\r\n        end\r\n    end\r\nend\r\n```\r\n\r\nThe resulting while loading this code is:\r\n\r\n```julia\r\nERROR: error in method definition: function Base.add must be explicitly imported to be extended\r\n in include at boot.jl:238\r\n in anonymous at /Users/stefan/projects/julia/base/sysimg.jl:133\r\n in anonymous at no file:11\r\n in include at boot.jl:238\r\n in anonymous at /Users/stefan/projects/julia/base/sysimg.jl:133\r\n in include at boot.jl:238\r\n in include_from_node1 at loading.jl:114\r\n in process_options at client.jl:311\r\n in _start at client.jl:399\r\nwhile loading pkg/entry.jl, in expression starting on line 43\r\nwhile loading pkg.jl, in expression starting on line 10\r\nwhile loading /Users/stefan/projects/julia/base/sysimg.jl, in expression starting on line 211\r\n```\r\n\r\nSeems likely to be a macro expansion bug.'
4976,'JeffBezanson','flisp memory error with empty symbol\n@JeffBezanson, I wasn\'t sure whether the empty string was a valid symbol, so I didn\'t fix this straight away, but passign `""` to `symbol` in flisp results in an invalid memory access:\r\n\r\n```\r\n==67004==ERROR: AddressSanitizer: global-buffer-overflow on address 0x0000013bb93f at pc 0x48b9ba bp 0x7ffffffe7480 sp 0x7ffffffe7478\r\nREAD of size 1 at 0x0000013bb93f thread T0\r\n    #0 0x48b9b9 in fl_is_keyword_name /home/kfischer/julia/src/flisp/flisp.c:259\r\n    #1 0x48c087 in mk_symbol /home/kfischer/julia/src/flisp/flisp.c:271\r\n    #2 0x48ae22 in symbol /home/kfischer/julia/src/flisp/flisp.c:307\r\n    #3 0x4d940b in peek /home/kfischer/julia/src/flisp/./read.c:402\r\n    #4 0x4d9cd4 in read_list /home/kfischer/julia/src/flisp/./read.c:560\r\n    #5 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #6 0x4b6fc0 in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:614\r\n    #7 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #8 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #9 0x4b6fc0 in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:614\r\n    #10 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #11 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #12 0x4b6fc0 in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:614\r\n    #13 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #14 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #15 0x4b6fc0 in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:614\r\n    #16 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #17 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #18 0x4b6fc0 in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:614\r\n    #19 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #20 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #21 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #22 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #23 0x4d9be8 in read_list /home/kfischer/julia/src/flisp/./read.c:557\r\n    #24 0x4b72ae in do_read_sexpr /home/kfischer/julia/src/flisp/./read.c:622\r\n    #25 0x4b6842 in fl_read_sexpr /home/kfischer/julia/src/flisp/./read.c:705\r\n    #26 0x51f080 in fl_read /home/kfischer/julia/src/flisp/iostream.c:124\r\n    #27 0x4e2dab in apply_cl /home/kfischer/julia/src/flisp/flisp.c:1159\r\n    #28 0x4fb505 in do_trycatch /home/kfischer/julia/src/flisp/flisp.c:829\r\n    #29 0x4f2f6f in apply_cl /home/kfischer/julia/src/flisp/flisp.c:1772\r\n    #30 0x4fb505 in do_trycatch /home/kfischer/julia/src/flisp/flisp.c:829\r\n    #31 0x4f2f6f in apply_cl /home/kfischer/julia/src/flisp/flisp.c:1772\r\n    #32 0x4fb505 in do_trycatch /home/kfischer/julia/src/flisp/flisp.c:829\r\n    #33 0x4f2f6f in apply_cl /home/kfischer/julia/src/flisp/flisp.c:1772\r\n    #34 0x4fb505 in do_trycatch /home/kfischer/julia/src/flisp/flisp.c:829\r\n    #35 0x4f2f6f in apply_cl /home/kfischer/julia/src/flisp/flisp.c:1772\r\n    #36 0x4b2ba3 in _applyn /home/kfischer/julia/src/flisp/flisp.c:650\r\n    #37 0x4b3657 in fl_applyn /home/kfischer/julia/src/flisp/flisp.c:695\r\n    #38 0x5284d7 in main /home/kfischer/julia/src/flisp/flmain.c:50\r\n    #39 0x7ffff6cd976c in __libc_start_main /build/buildd/eglibc-2.15/csu/libc-start.c:226\r\n    #40 0x488e7c in _start (/home/kfischer/julia/src/flisp/flisp+0x488e7c)\r\n\r\n0x0000013bb93f is located 1 bytes to the left of global variable \'buf\' from \'flisp.c\' (0x13bb940) of size 256\r\n0x0000013bb93f is located 59 bytes to the right of global variable \'toktype\' from \'flisp.c\' (0x13bb900) of size 4\r\nSUMMARY: AddressSanitizer: global-buffer-overflow /home/kfischer/julia/src/flisp/flisp.c:259 fl_is_keyword_name\r\nShadow bytes around the buggy address:\r\n  0x00008026f6d0: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f6e0: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f6f0: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f700: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f710: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n=>0x00008026f720: 04 f9 f9 f9 f9 f9 f9[f9]00 00 00 00 00 00 00 00\r\n  0x00008026f730: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\r\n  0x00008026f740: 00 00 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f750: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f760: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\n  0x00008026f770: 00 f9 f9 f9 f9 f9 f9 f9 00 f9 f9 f9 f9 f9 f9 f9\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Heap right redzone:      fb\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack partial redzone:   f4\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Contiguous container OOB:fc\r\n  ASan internal:           fe\r\n==67004==\r\n```\r\n\r\nRelevant part of the stacktrace in gdb:\r\n```\r\n#2  0x000000000048b9ba in fl_is_keyword_name (str=0x13bb940 "", len=0) at flisp.c:259\r\n#3  0x000000000048c088 in mk_symbol (str=0x13bb940 "") at flisp.c:271\r\n#4  0x000000000048ae23 in symbol (str=0x13bb940 "") at flisp.c:307\r\n#5  0x00000000004d940c in peek () at ./read.c:402\r\n```'
4974,'JeffBezanson','keyword arguments and "do" statement error\n```\r\njulia> type Foo\r\n           bar\r\n           Foo(init;kwargs...) = new (init())\r\n       end\r\n\r\njulia> function test(;kwargs...)\r\n           Foo(()->3;kwargs...)\r\n       end\r\ntest (generic function with 1 method)\r\n\r\njulia> test(;baz=3)\r\nFoo(3)\r\n\r\n```\r\n\r\nworks.\r\n\r\nBut\r\n\r\n```\r\njulia> function test(;kwargs...)\r\n           Foo(;kwargs...) do\r\n               1\r\n           end\r\n       end\r\ntest (generic function with 1 method)\r\n\r\njulia> test(;baz=3)\r\nERROR: error compiling test: unsupported or misplaced expression parameters in function test\r\n```\r\n\r\nfails.\r\n\r\n'
4960,'JeffBezanson','type inference bug\nI think I have discovered a type inference bug, but it is rather complicated to trigger it. The code in this Gist is the minimal type of construction I think is needed:\r\n\r\nhttps://gist.github.com/Jutho/7684732\r\n\r\nNote, that this code is purely written as to trigger the bug. As such, it is nor useful or optimal in any way, and probably not even consistent. It took me quite some time to be able to isolate the individual elements that were working together to fool the compiler, and I had to apply code_typed to all my functions to trace back how things went wrong. It turns out there are a number of problems working together here:\r\n\r\n1) By making the constructor of MatrixList having a args... argument, the compiler is no longer able to infer that a call MatrixList with argument Vector{Matrix{Float64}} produces a MatrixList{T,Matrix{Float64}}. Note that it is never able to infer T but without the args... in the constructor outside of the type definition it is at least able to predict the second parameter. With the args... present, code_typed(MatrixList,(Vector{Matrix{Float64}},)) seems to predict no type at all for the result. Consequently, the compiler is also not able to infer the result of one(m) or 3*m\r\n\r\n2) While (1) is the root cause of the problem, one(m) and 3*m still work, but maybe less optimal. What is causing m+3 to fail is the following. Since the type of 3*one(m) cannot be inferred, m+3 in the end results in m+3*one(m) where the type of the second argument cannot be inferred. In the best case, it is only known to be of type MatrixList for some parameters. Now, looking at\r\ncode_typed(+,(MatrixList{Float64,Matrix{Float64}},MatrixList))\r\nthe second problem becomes visible:\r\nThe definition of + uses a specialsum method which so far is only defined for two arguments of type Matrix. Since the second argument to specialsum is coming from a MatrixList with unknown second parameter, it is at best known to be an AbstractMatrix. This, apparently, causes the compiler to infer that the result of specialsum is None. From there on, it also concludes that the result of + for arguments (MatrixList{Float64,Matrix{Float64}},MatrixList) is None.'
4932,'staticfloat',"Julia's git clobbers system git on OS X\nI have installed Julia for OSX a couple of days ago. I prepended it to my PATH without thinking. Today, I go to 'git clone' something and get a weird error:\r\n\r\n```\r\nm@pro ~/tmp $ git clone https://github.com/gitfoxi/julia.git\r\nCloning into 'julia'...\r\nwarning: templates not found /Users/sabae/tmp/julia-packaging/osx/julia-master/usr/share/git-core/templates\r\nfatal: Unable to find remote helper for 'https'\r\n```\r\n\r\nAfter a minute I try:\r\n\r\n```\r\nm@pro ~/tmp $ which git\r\n/Applications/Julia-0.2.0.app/Contents/Resources/julia/bin/git\r\n```\r\n\r\nOh. It looks like Julia comes with it's own git binary which is kind of broken. May I politely suggest putting such things in a separate directory like `julia/libexec`. Meanwhile I will symlink julia to `/usr/local/bin` so as not to sign up for all the other goodies."
4919,'JeffBezanson',"quoted 'using' in modules giving strange error\n\r\n```julia\r\nmodule J\r\nmacro s()\r\n  quote\r\n    using HDF5\r\n  end\r\nend\r\nend\r\n\r\n@J.s\r\n```\r\nERROR: ?,x? not found\r\n in require at loading.jl:39\r\n\r\nBut s works if it's defined in the top-most scope rather than in a module. HDF5 is just an example: ```@J.s``` breaks with any package substituted for HDF5, although the exact gibberish string printed after ERROR: changes depending on the package.\r\n\r\n"
4912,'JeffBezanson','Better error detection for "else if"\nI mistakingly typed ``else if`` instead of ``elseif``, an error I expect many people are going to do. ;-)\r\n\r\nJulia granted me with an error that was really not helpful:\r\n```julia\r\njulia> reload("src/NamedArray.jl")\r\nERROR: syntax: incomplete: "function" at /home/milan/Dev/NamedArray/src/NamedArray.jl:278 requires end\r\n in include at boot.jl:238\r\nat /home/milan/Dev/NamedArray/src/NamedArray.jl:284\r\n```\r\n\r\n(The file itself can be found here: https://gist.github.com/nalimilan/7627363)\r\n\r\nThe syntax error does not appear to be detected until the end of the file (the ``if else`` appears at line 148), probably everything is syntactically correct until that point.\r\n\r\nI guess reporting a more useful error is hard, but do you think it would be possible to report that the incomplete function from line 278 is itself nested within the function that start at line 145? I think that\'s how the compiler will interpret my code with the ``else if``.\r\n\r\nOr maybe you could detect ``else if`` and print an error immediately? Would it be reasonable to require that nested ``if`` blocks always start on a new line when preceded by a ``else``?'
4898,'JeffBezanson',"static compile round 2\nThis is largely complete. I'll probably try to merge it piecemeal, but I thought people might like to see the status of this.\r\n\r\nBig TODO items remaining:\r\n- [x] respect the jl_set_imaging_mode flag in some essential places (currently only sys0.ji gets the benefits of this)\r\n- [x] clean-up some platform-specific code (currently targets Mac)\r\n- [x] precompile a much greater set of functions\r\n- [x] lookup all external / ccall functions at runtime\r\n- [x] add support for windows\r\n- [x] improve efficiency of ccall function lookup\r\n- [x] investigate cause of repl crash when executing the first input line\r\n- [x] enough comments to make Jeff happy\r\n- [x] jl_load_and_lookup(libname, funcname, libptrgv)\r\n- [x] reduce size of sysimg file such that this pull request doesn't affect the size of the file\r\n- [x] misc cleanup requested by Jeff"
4888,'StefanKarpinski','Pkg should not be shell-ing out\nWhy is the Julia Pkg manager trying to shell out? Window\'s doesn\'t have a shell.\r\n\r\n```julia\r\njulia> Pkg.add("Cairo")\r\nC:\\Documents and Settings\\Administrator\\My Documents\\Downloads\\julia-05c6461b55\\\r\nGit\\bin\\sh.exe: *** fork: can\'t reserve memory for stack 0x490000 - 0x690000, Wi\r\nn32 error 0\r\n      0 [main] sh 2604 sync_with_child: child 2848(0x32C) died before initializa\r\ntion with status code 0x1\r\n    238 [main] sh 2604 sync_with_child: *** child state waiting for longjmp\r\nsh: fork: Resource temporarily unavailable\r\nERROR: failed process: Process(`sh -c "cd \'C:\\Documents and Settings\\Administrat\r\nor\\.julia\\.cache\\BinDeps\' && git rev-parse --git-dir"`, ProcessExited(128)) [128\r\n]\r\n in pipeline_error at process.jl:476\r\n in success at process.jl:468\r\n in readbytes at process.jl:430\r\n```\r\n'
4882,'JeffBezanson',"Make tilde automatically quote its arguments\nIn the past we've talked about making the tilde operator do something special to make statistical functions look nicer. One simple approach would take `ex1 ~ ex2` and automatically wrap it in a quote call.\r\n\r\nThis would allow us to change clunky interfaces like `glm(:(y ~ x))` into the nicer `glm(y ~ x)`.\r\n\r\nI'd love to see something like this happen for the 0.3 release, since it will allow us to provide a cleaner (and more familiar interface) for a lot of statistical functions. I suspect it wouldn't even be a badly breaking change, since I'm not aware of anyone using the tilde operator except people doing statistics in Julia."
4861,'vtjnash','eliminate julia.bat\n`Julia.bat` does nothing. It should be replaced by some sort of symlink'
4846,'JeffBezanson',"Overly-general type inference when dealing with mixed-type tuples\nThese two equivalent functions have different inferred return types, with g's return type seemingly being too general.\r\n\r\n```julia\r\nfunction f(x)\r\ny=x[1]\r\nreturn y\r\nend\r\n\r\nfunction g(x)\r\nreturn x[1]\r\nend\r\n\r\ncode_typed(f, ((Int, Float64),))\r\n1-element Array{Any,1}:\r\n :($(Expr(:lambda, {:x}, {{:y},{{:x,(Int64,Float64),0},{:y,Int64,18}},{}}, quote  # In[1], line 2:\r\n        y = tupleref(x::(Int64,Float64),1)::Union(Float64,Int64) # line 3:\r\n        return y::Int64\r\n    end)))\r\n\r\ncode_typed(g, ((Int, Float64),))\r\n1-element Array{Any,1}:\r\n :($(Expr(:lambda, {:x}, {{},{{:x,(Int64,Float64),0}},{}}, quote  # In[2], line 2:\r\n        return tupleref(x::(Int64,Float64),1)::Union(Float64,Int64)\r\n    end)))\r\n```"
4806,'JeffBezanson',"getfield with integer index argument\nWhen I want to iterate over all the members of a type the first valid syntax that comes to mind is roughly:\r\n\r\n```\r\nmembers = names(thing)\r\nfor name in members\r\n    ...\r\nend\r\n```\r\n\r\nBut this might be pretty inefficient (I only looked deep enough to see a call to `collect`, I'm assuming it's creating a new array each time).\r\n\r\nMaybe this has been discussed before, but wouldn't it be nice if I could:\r\n\r\n```\r\nfor (name, value) in thing  # <--- treat the type like a dictionary\r\n    ...\r\nend\r\n```\r\nand count on things in the background to not allocate an array?"
4805,'JeffBezanson','In type dispatch, 1+0 != 1\n```julia\r\nabstract IT{N, T}\r\n\r\ntest0{T <: Int64}(::Type{IT{1, T}}, x) = x\r\n\r\ntest1() = test0(IT{1, Int64}, 1)\r\ntest2() = test0(IT{1+0, Int64}, 1)\r\ntest3(n) = test0(IT{n, Int64}, 1)\r\n\r\nprintln(test1()) # 1\r\nprintln(test2()) # nothing\r\nprintln(test3(1)) # nothing\r\nprintln(test0(IT{1+0, Int64}, 1)) # 1\r\n```\r\n\r\nObviously test1() and test2() should always produce the same results, test3(1) = test1() and the last line = test2(). Getting a "nothing" result at all is curious, too: with the x=x definition, one should either get an ERROR (no method) or the value passed in (which is 1 in all examples). '
4801,'JeffBezanson','keyword arg in constructor of a parametric type\n```julia\r\ntype S\r\n  S(;k=0) = new()\r\nend\r\n\r\ntype T{X}\r\n  T(;k=0) = new()\r\nend\r\n\r\nS(k=0)        # ok\r\nT{Any}(k=0)   # ERROR: function does not accept keyword arguments\r\nT{Any}()      # ok\r\nT{Any}(k=0)   # ok\r\n```'
4771,'JeffBezanson',"Macro hygiene problem with closures\nWith the latest julia, the following code\r\n\r\n    module Lib\r\n    export @make_closure\r\n    macro make_closure()\r\n        quote       \r\n            f = (x)->1\r\n        end\r\n    end\r\n    end # module\r\n\r\n    module Test\r\n    using Lib\r\n    @make_closure\r\n    end # module\r\n\r\ngives me\r\n\r\n    ERROR: syntax: malformed function arguments (. #<julia: Lib> 'x)\r\n     in include at boot.jl:238\r\n    at /home/toivo/code/julia/juliastuff/issues/closure-hygiene/test.jl:15\r\n\r\nWith julia `Commit ba9d7e5* 2013-10-15 15:00:57 UTC` it works fine. It seems that macro hygienization believes that the argument `x` in `(x)->1` is a global variable. This also seems to be the cause of https://github.com/toivoh/PatternDispatch.jl/issues/17.\r\n"
4748,'vtjnash','license of win64 setjmp and longjmp\nThe files `src/support/_setjmp.win64.S` and `src/support/_longjmp.win64.S` include the forbidden 4-clause BSD license with the advertising clause. These need to be replaced with alternatives, or we need to confirm that this code has been made available under the 3-clause BSD. I believe FreeBSD has versions covered by the 3-clause, e.g. http://fxr.watson.org/fxr/source/amd64/gen/setjmp.S?v=FREEBSD-LIBC.'
4731,'JeffBezanson',"method matches with partially-specialized types\nSee this testcase: http://nbviewer.ipython.org/7310900\r\n\r\nUnfortunately currently not very minimal since it pulls in SIUnits. I'll see if I can minimize it further."
4694,'StefanKarpinski','Pkg.publish() incorrectly states that METADATA is behind and refuses to publish\nI do have a number of unregistered packages in .julia, and a few others which are not tracking METADATA.  Likely one of these is confusing publish, or it could simply be that my .julia directory was created too long ago, in which case this issue can be closed.\r\n\r\n```julia\r\njulia> Pkg.update()\r\nINFO: Updating METADATA...\r\nINFO: Updating cache of Match...\r\nINFO: Updating Logging...\r\nINFO: Updating Sam...\r\nINFO: Updating BinDeps...\r\nINFO: Updating Zlib...\r\nINFO: Updating SortPerf...\r\nINFO: Updating Match...\r\nINFO: Updating OrderedCollections...\r\nINFO: Updating BGZF...\r\nINFO: Updating Monads...\r\nINFO: Updating XClipboard...\r\nINFO: Computing changes...\r\nINFO: Removing HTTPClient v0.0.0\r\nINFO: Removing JSON v0.2.3\r\nINFO: Removing LibCURL v0.0.0\r\n\r\njulia> Pkg.publish()\r\nERROR: METADATA is behind origin/metadata-v2 – run Pkg.update() before publishing\r\n in publish at pkg/entry.jl:259\r\n in anonymous at pkg/dir.jl:25\r\n in cd at file.jl:22\r\n in cd at pkg/dir.jl:25\r\n in publish at pkg.jl:55\r\n\r\njulia> Pkg.status()\r\nRequired packages:\r\n - ArgParse                      0.2.6\r\n - BinDeps                       0.2.12+            master\r\n - Cairo                         0.2.9\r\n - Distributions                 0.2.10\r\n - Gaston                        0.0.0\r\n - HDFS                          0.0.0\r\n - HTTP                          0.0.2\r\n - Logging                       0.0.0-             master (unregistered)\r\n - Monads                        0.0.0+             master\r\n - Nettle                        0.1.2\r\n - ODBC                          0.3.1\r\n - PyCall                        0.0.1\r\n - Winston                       0.5.1\r\nAdditional packages:\r\n - BGZF                          0.0.0-             master (unregistered)\r\n - Blocks                        0.0.0\r\n - Calendar                      0.4.0\r\n - Color                         0.2.6\r\n - DataFrames                    0.3.15\r\n - Datetime                      0.1.2\r\n - GZip                          0.2.5\r\n - ICU                           0.0.0\r\n - IniFile                       0.2.1\r\n - Match                         0.0.1              master\r\n - NumericExtensions             0.2.18\r\n - Options                       0.2.1\r\n - OrderedCollections            0.0.0-             master (unregistered)\r\n - PTools                        0.0.0\r\n - Sam                           0.0.0-             master (unregistered)\r\n - SortPerf                      0.0.0-             master (unregistered)\r\n - SortingAlgorithms             0.0.1\r\n - Stats                         0.2.8\r\n - StrPack                       0.0.0\r\n - TextWrap                      0.1.2\r\n - Tk                            0.2.8\r\n - URIParser                     0.0.0\r\n - URLParse                      0.0.0\r\n - UTF16                         0.2.0\r\n - XClipboard                    0.0.0-             master (unregistered)\r\n - Zlib                          0.1.3+             read_concat\r\n```'
4688,'JeffBezanson',"Obscure issue with redefining functions\n```julia\r\njulia> b() = false\r\nb (generic function with 1 method)\r\n\r\njulia> begin\r\n         a() = 1\r\n         let x = true\r\n           b() = x == true ? a() : a()\r\n         end\r\n       end\r\nb (generic function with 1 method)\r\n\r\njulia> b()\r\n1\r\n\r\njulia> begin\r\n         a() = 2\r\n         let x = true\r\n           b() = x == true ? a() : a()\r\n         end\r\n       end\r\nb (generic function with 1 method)\r\n\r\njulia> b()\r\n1\r\n```\r\n\r\nI wouldn't expect redefining `a()` alone to make a difference here, since `b()` is inlining it, but I would expect that redefining `a()` and then redefining `b()` should change the output of `b()`. If I modify `b()` so that it doesn't use `x` it works:\r\n\r\n```julia\r\njulia> begin\r\n         a() = 2\r\n         let x = true\r\n           b() = true == true ? a() : a()\r\n         end\r\n       end\r\nb (generic function with 1 method)\r\n\r\njulia> b()\r\n2\r\n```\r\n\r\nIf I remove the `begin`/`end` around the redefinition it also works:\r\n\r\n```julia\r\njulia> a() = 2\r\na (generic function with 1 method)\r\n\r\njulia> let x = true\r\n         b() = x == true ? a() : a()\r\n       end\r\nb (generic function with 1 method)\r\n\r\njulia> b()\r\n2\r\n```"
4681,'JeffBezanson','Small type-conversion bug in ccall can cause data corruption\nTracing this in GDB, I see that Ptr{Z} expects a `julia_value_t**`, but the convert method of z is providing a `i8*`.\r\n\r\n```julia\r\njulia> type Z\r\n         x::Ptr{Void}\r\n         Z() = new(C_NULL)\r\n       end\r\n\r\njulia> Base.convert(::Type{Ptr{Z}},b::Z) = b.x\r\nconvert (generic function with 335 methods)\r\n\r\njulia> f(z) = ccall(:printf,Int,(Ptr{Uint8},Ptr{Z}),"Got: %ld; Expected: 0\\n",z);\r\nf (generic function with 1 methods)\r\n\r\njulia> f(Z())\r\nwarning: unbox: T != typeof(x)\r\nGot: 140734799800984; Expected: 0\r\n```\r\n\r\n(note: x was supposed to be declared `Ptr{Z}` in my code -- but I only get that warning in debug mode, so it really confused me when the code just crashed.)'
4678,'JeffBezanson','remove a[5:] syntax\nJulia:\r\n```\r\njulia> a=[1:10]\r\n10-element Array{Int32,1}:\r\n  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n\r\njulia> a[5:]\r\n6-element Array{Int32,1}:\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n\r\njulia> a[:5]\r\n5\r\n\r\n```\r\n\r\nPython:\r\n```\r\n>>> a=range(1,11)\r\n>>> a\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n>>> a[5:]\r\n[6, 7, 8, 9, 10]\r\n>>> a[:5]\r\n[1, 2, 3, 4, 5]\r\n>>>\r\n```\r\n'
4677,'JeffBezanson',"Julia segfaults\nI have written code for a research project which seems to quite reliably segfault julia (Version 0.2.0-rc2+71/Commit 57700be* 2013-10-29 on Linux, julia version 0.2.0-rc1+7 on OS X where I cant build the newest version).\r\nShould I share the code for this research project with someone (I'd prefer if I don't have to post the code publicly), or what information would be helpful for you?"
4675,'JeffBezanson',"Method dispatched for parametrized union typealiases depends on order of function definition\n```julia\r\njulia> f{T}(x::StridedArray{T}...) = 2\r\nf (generic function with 1 method)\r\n\r\njulia> f(x::StridedArray...) = 1\r\nf (generic function with 2 methods)\r\n\r\njulia> f(zeros(50,50), zeros(50,50))\r\n2\r\n```\r\n\r\nAfter restarting Julia:\r\n\r\n```julia\r\njulia> f(x::StridedArray...) = 1\r\nf (generic function with 1 method)\r\n\r\njulia> f{T}(x::StridedArray{T}...) = 2\r\nf (generic function with 2 methods)\r\n\r\njulia> f(zeros(50,50), zeros(50,50))\r\n1\r\n```\r\n\r\nI think this is the reason we can't infer the element type of the array returned by `.*` (part of #4673)."
4645,'JeffBezanson',"Scope and assignment order\nThe manual says that the order of assignment does not matter in a lexical block, but the following code returns an error.\r\nLet me recall that pi is a default global variable whose value is π = 3.1415926535897...\r\njulia> let y = 0\r\n         y = pi\r\n         pi = -3.14\r\n         y\r\n       end\r\nERROR: pi not defined\r\n\r\nI would have expected a return value of 3.14... if order does not matter, or -3.14 if order does matter, but I don't see why I get an error here. \r\n"
4641,'jiahao','README.windows could be clearer\nThe windows build instructions could be cleaned up.\r\n- [x] try msys2 compile\r\n- [x] clearer step-by-step instructions about setting up Windows path and msys prompt\r\n\r\n~~I set up a brand new Win7 VM and followed all the instructions in README.windows.md. However, following the instructions to the letter brings me to the point where I can get a useable msys prompt but with no compilers. It is not clear how to proceed, since the instructions explicitly discourage obtaining the necessary compilers from the usual place at mingw.org.~~'
4631,'staticfloat','Cairo doesn\'t build on Mac OS X 10.9\nI get an error when installing Winston, Cairo doesn\'t build. The output is below.\r\n```\r\njulia> versioninfo()\r\nJulia Version 0.2.0-rc1\r\nCommit 040f3ab 2013-10-15 05:58:39 UTC\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin12.5.0)\r\n  WORD_SIZE: 64\r\n  BLAS: libgfortblas\r\n  LAPACK: liblapack\r\n  LIBM: libopenlibm\r\n\r\n-----------------\r\n\r\njulia> Pkg.build("Cairo")\r\nINFO: Building Cairo\r\nError: Operation already in progress for xz\r\nAnother active Homebrew process is already using xz.\r\nPlease wait for it to finish or terminate it to continue.\r\n========================================================[ ERROR: Cairo ]=========================================================\r\n\r\nfailed process: Process(`/Users/rene/.julia/Homebrew/deps/usr/bin/brew install staticfloat/juliadeps/glib`, ProcessExited(1)) [1]\r\nat /Users/rene/.julia/Cairo/deps/build.jl:134\r\n\r\n=================================================================================================================================\r\n\r\n========================================================[ BUILD ERRORS ]=========================================================\r\n\r\nWARNING: Cairo had build errors.\r\n\r\n - packages with build errors remain installed in /Users/rene/.julia\r\n - build a package and all its dependencies with `Pkg.build(pkg)`\r\n - build a single package by running its `deps/build.jl` script\r\n\r\n=================================================================================================================================\r\n```\r\n[jiahao: formatting]'
4616,'jiahao','Make pivoting an option for QR\nFrom #4555 \r\n\r\nHow about we just keep qr with a pivoted={true,false} optional argument?'
4560,'staticfloat',"Concern about PREFIX/etc/julia/juliarc.jl (Pull request 4351)\nDunno if it's worth, but I want to know.\r\n\r\nDue to the changes that came with https://github.com/JuliaLang/julia/pull/4351\r\nI notice the following:\r\n\r\nDepending on $PREFIX the /etc/julia/... will go there too. And if PREFIX=/usr then the resulting path for /etc isn't a standard directory declared in the FHS. Therefore exists /etc.\r\n\r\nIf I move the directory by hand, will the julia find the juliarc.jl?\r\n\r\nAnd as a possible solution, if it's considered, this should be addressed.\r\nIntroducing DESTDIR and remove the PREFIX from the /etc entry and/or adding SYSCONFDIR"
4558,'staticfloat','Pkg.add("RDatasets") reveals hardcoded "sabae" in OS X binaries\nOutput includes \'sabae\' user-name which is not present on the system. \r\n\r\n```\r\nINFO: Cloning cache of RDatasets from git://github.com/johnmyleswhite/RDatasets.jl.git\r\nwarning: templates not found /Users/sabae/tmp/julia-packaging/osx/julia-master/usr/share/git-core/templates\r\nINFO: Installing RDatasets v0.0.2\r\nwarning: templates not found /Users/sabae/tmp/julia-packaging/osx/julia-master/usr/share/git-core/templates\r\nINFO: REQUIRE updated.\r\n```'
4538,'JeffBezanson',"can't create functions with optional arguments in macro\nAm I just forgetting something? It seems like this should work:\r\n```julia\r\nmacro TEST()\r\n        quote\r\n         function test(x=1)\r\n          return x\r\n         end\r\n        end\r\n       end\r\n\r\njulia> @TEST\r\nERROR: syntax: malformed function argument (kw x 1)\r\n```\r\nAnd if I throw the whole macro result into an `$esc` call, it does work."
4518,'JeffBezanson','Variatic signatures with Union type params yield incorrect ambiguity warnings\nI found this first when defining `Base.map` for my own collections, and then experimented a bit:\r\n\r\n```jl\r\njulia> type MyColl\r\n         arr::Array\r\n       end\r\n\r\njulia> Base.map(f::Union(Function,DataType), c::MyColl) =\r\n           MyColl(map(f, c.arr))\r\nWarning: New definition\r\n    map(Union(DataType,Function),MyColl) at none:1\r\nis ambiguous with\r\n    map(Union(DataType,Function),Any...) at reduce.jl:112.\r\nMake sure\r\n    map(Union(DataType,Function),MyColl)\r\nis defined first.\r\n\r\njulia> foo(x::Int, ys...) = 1\r\nfoo (generic function with 1 method)\r\n\r\njulia> foo(x::Int, c::MyColl) = 2\r\nfoo (generic function with 2 methods)\r\n\r\njulia> bar(x::Union(Int32, Int64), ys...) = 1\r\nbar (generic function with 1 method)\r\n\r\njulia> bar(x::Union(Int32, Int64), c::MyColl) = 2\r\nWarning: New definition\r\n    bar(Union(Int64,Int32),MyColl) at none:1\r\nis ambiguous with\r\n    bar(Union(Int64,Int32),Any...) at none:1.\r\nMake sure\r\n    bar(Union(Int64,Int32),MyColl)\r\nis defined first.\r\nbar (generic function with 2 methods)\r\n```\r\n\r\n'
4505,'JeffBezanson','scoping bug for method definitions with type parameters\n```julia\r\nlet\r\n  f(::Any) = 0\r\nend\r\n\r\nlet\r\n  g{X}(::X) = 0\r\nend\r\n```\r\n\r\nHere `f` is correctly introduced in the inner scope, but `g` is incorrectly introduced in the outer (global) scope.\r\n\r\nSame problem for other scoping constructs.'
4487,'JeffBezanson','Semi-colon in parenthetical expression error\nNot sure if this should be an error or not: \r\n\r\n```\r\na = (1) # Works!\r\na = (1;) # Does not work!\r\n```'
4482,'JeffBezanson',"enumerate over tuples\nConsider the following:\r\n```\r\njulia> function foo(args)\r\n       for (i,x) in enumerate(args)\r\n       println((i,x))\r\n       end\r\n       end\r\nfoo (generic function with 1 method)\r\n\r\njulia> foo((Ptr{Void},Ptr{Void}))\r\n(1,Ptr{None})\r\n(2,Ptr{None})\r\n\r\njulia> foo((Ptr{Void},))\r\nERROR: no method Enumerate{(DataType,DataType)}((DataType,),)\r\nyou may have intended to import Base.Enumerate\r\n```\r\n\r\nIt seems like we are remembering the specialization of the Enumerate iterator when we shouldn't be, case in point:\r\n```\r\njulia> function foo(args)\r\n        for (i,x) in enumerate(args)\r\n              println((i,x))\r\n         end\r\n         end\r\nfoo (generic function with 1 method)\r\n\r\njulia> foo((Ptr{Void},))\r\n(1,Ptr{None})\r\n\r\njulia> foo((Ptr{Void},Ptr{Void}))\r\nERROR: no method Enumerate{(DataType,)}((DataType,DataType),)\r\nyou may have intended to import Base.Enumerate\r\n```"
4479,'JeffBezanson','incorrect method selection?\nI expected it to pick method (2) but it calls method (1) instead. Is this a bug?\r\n\r\n```julia\r\njulia> @which push!(r, choices[4], true)\r\npush!(grp::GtkRadioButtonGroup,label,vargs...) at /Users/jameson/.julia/Gtk/src/buttons.jl:122\r\n\r\njulia> push!|>methods\r\n...\r\npush!(grp::GtkRadioButtonGroup,label,vargs...) at /Users/jameson/.julia/Gtk/src/buttons.jl:122\r\npush!(grp::GtkRadioButtonGroup,e::GtkRadioButton,active::Bool) at /Users/jameson/.julia/Gtk/src/buttons.jl:108\r\n\r\njulia> typeof((r, choices[4], true))\r\n(GtkRadioButtonGroup,GtkRadioButton,Bool)\r\n```'
4451,'JeffBezanson','ifelse function\n@nalimilan proposed a ``.?`` operator in https://github.com/lindahua/Devectorize.jl/issues/21 for element-wise selection.\r\n\r\nI think it might be a good idea to have it in Julia base. Here is the idea:\r\n\r\n```julia\r\nr = x > a .? b : c   # r[i] = (x[i] > a[i] ? b[i] : c[i])\r\n                  # some of these arguments are allowed to be scalars.\r\n```'
4444,'vtjnash','WINDOWS: move user preferences to My Documents directory. close #4334\nPlease comment. I will merge soon if there are no objections. ref issue #4334 '
4407,'StefanKarpinski','Package creation docs out-of-date\nI\'m using `master/d5dc226*` and trying out what is documented at http://docs.julialang.org/en/latest/manual/packages/ , I can\'t create a new package with `Pkg.new("abcd")`, as it fails with `ERROR: new not defined`. I also don\'t have `Pkg1` anymore.'
4402,'vtjnash',"Newer canned windows versions crash on stack-overflow.\nNewer canned windows versions crash on stack-overflow on this machine without printing error message. This happens for newer both 32 and 64 bit versions, for example 0.2.0-prerelease+3768, Commit d6f7c7c 2013-09-18 04:01:51 UTC,  x86_64-w64-mingw32\r\n\r\nOn the other hand the older version 0.2.0-prerelease+3441, Commit dca8d76 2013-08-26 02:28:43 UTC, i686-w64-mingw32 doesn't produce this error on this machine"
4374,'JeffBezanson',"performance of + with many arguments\nI've found that just removing parenthesis in the expression significantly degrades code performance. On my machine I got runtime increase from 0.08s to 4.5s.\r\n```julia\r\nfunction func(n)\r\n  sum = 0\r\n  i = 0\r\n  while i < n\r\n    # Good performance\r\n    sum += (i) + (i+3) + (i+6) + (i+9) + (i+12) + (i+5) + (i+10)\r\n    # Poor performance (only parenthesis removed)\r\n    #sum += i + i+3 + i+6 + i+9 + i+12 + i+5 + i+10\r\n    i += 15\r\n  end\r\n  sum\r\nend\r\n\r\ntic()\r\nprintln(func(100_000_000))\r\ntoc()\r\n```"
4346,'Keno','concurrent poll_fd (different fds) fails\nThe below code\r\n\r\n```\r\nn = 100\r\npipe_fds = cell(n)\r\nfor i in 1:n\r\n    pipe_fds[i] = Array(Cint, 2)\r\n    ccall(:pipe, Cint, (Ptr{Cint},), pipe_fds[i])\r\nend\r\n\r\n\r\n# Start the concurrent readers\r\nfor i in 1:n\r\n    @spawn begin\r\n        while true\r\n            poll_fd(RawFD(pipe_fds[i][1]), 10.0; readable=true)\r\n            dout = Array(Uint8, 1)\r\n            dlen = ccall(:read, Csize_t, (Cint, Ptr{Uint8},Csize_t), pipe_fds[i][1], dout, 1)\r\n            (dlen != 1) || (dout[1] != int8(\'A\')) ? error("Expected data not found") : nothing\r\n        end\r\n    end\r\nend\r\n\r\n# Start the writer\r\nwhile true\r\n    for i in 1:n\r\n        ccall(:write, Csize_t, (Cint, Ptr{Uint8},Csize_t), pipe_fds[i][2], bytestring("A"), 1)\r\n    end\r\n    sleep(1.0)\r\nend\r\n```\r\n\r\nfails with \r\n\r\n```\r\nERROR: FD is already being watched by another watcher\r\n in FDWatcher at poll.jl:108\r\n in wait at poll.jl:187\r\n in anonymous at task.jl:81\r\n\r\n```\r\n\r\nNote that the same fd is not waited on concurrently by different tasks. '
4330,'JeffBezanson',"parallel race condition of some sort?\nThe following demo function is fine if you comment out \r\nany one of Line 1, Line 2, or Line 3\r\n\r\nAt least on julia.mit.edu if you run the code as is, the first time it's fine\r\nand the second time it always hangs.\r\n\r\n    function demo(;n=400)       \r\n\r\n\r\n    # if only one processor force 8 workers\r\n    p=workers();l=length(p);\r\n    if l==1;\r\n      addprocs(8);\r\n      p=workers();\r\n     end\r\n\r\n\r\n    # create remote random matrices\r\n    s=[@spawnat p[i] randn(n) for i=1:8 ]\r\n\r\n    # cumsum \r\n    pmap(x->cumsum(fetch(x)),s)\r\n     @time @sync begin\r\n         s[4]=@spawnat p[4] fetch(s[4]);  # Line 1 \r\n         s[4]=@spawnat p[4] fetch(s[4]);  # Line 2 \r\n         s[5]=@spawnat p[5] fetch(s[4]);  # Line 3\r\n    end\r\n    s\r\n    end"
4311,'StefanKarpinski','Pkg.add() bails out\nUsing today\'s version of julia (0.2.0-prerelease+3791) I can\'t seem to install packages anymore.  \r\n\r\nI was told to file an issue...  Hereby\r\n\r\n```\r\njulia> Pkg.add("ArgParse")\r\nWARNING: julia is fixed at 0.2.0-prerelease+3791 conflicting with requirement for WAV: [0.1.0-,0.2.0-)\r\n in requirements at pkg/query.jl:10\r\nERROR: cannot resize array with shared data\r\n in splice! at array.jl:818\r\n in filter! at array.jl:1502\r\n in intersect at pkg/types.jl:41\r\n in merge_requires! at pkg/types.jl:52\r\n in requirements at pkg/query.jl:16\r\n in _resolve at pkg.jl:220 (repeats 2 times)\r\n in anonymous at no file:34\r\n in cd at file.jl:25\r\n in cd at pkg/dir.jl:30\r\n in edit at pkg.jl:24\r\n in add at pkg.jl:21\r\n```'
4310,'vtjnash',"Windows shell error printing\nWhile running a shell command that fails (though it doesn't seem to do it for any command that fails), the same error output message is printed ~26K times (I've tried this several times).\r\n\r\n```julia\r\njulia> run(`javac nonexistent.java`)\r\njavac: file not found: nonexistent.java\r\n\r\nUsage: javac <options> <source files>\r\n\r\nuse -help for a list of possible options\r\n\r\nERROR: failed process: Process(`javac nonexistent.java`, ProcessExited(2)) [2]\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:447\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:447\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:447\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:447\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:447\r\n in error at error.jl:22\r\n...\r\n...\r\n...\r\nand this goes on and on for about 26k lines...\r\n```\r\nWindows 8, 64-bit native build."
4266,'JeffBezanson','JuMP broken by recent commit\n```\r\n$ julia .julia/JuMP/test/runtests.jl \r\nRunning tests:\r\n Test: quadmodel.jl\r\n Test: expr.jl\r\n  TODO: Collect like terms before print\r\n        e.g. 1.0 _col1*_col2 + 1.0 _col2*_col1\r\n Test: variable.jl\r\nfatal: error thrown and no exception handler available.\r\nMain.Base.TypeError(func=:typeassert, context="", expected=(Main.Core.Any..., ), got=Expr(:block, Expr(:line, 35, :/home/mlubin/.julia/JuMP/src/JuMPDict.jl)::Main.Core.Any, Expr(:escape, :##356)::Main.Core.Any = Expr(:call, :Dict)::Main.Core.Any, # line 36, Expr(:for, Expr(:tuple, :j, :k)::Main.Core.Any = Expr(:call, :enumerate, Expr(:escape, :s)::Main.Core.Any)::Main.Core.Any, Expr(:block, # line 37, Expr(:ref, Expr(:escape, :##356)::Main.Core.Any, :k)::Main.Core.Any = :j)::Main.Core.Any)::Main.Core.Any)::Main.Core.Any)\r\n```\r\n\r\nI determined via git bisect that commit 7ce77bb is the culprit. I admit that the code in ``JuMPDict.jl`` pushes the limits of readability and what one should be doing inside a macro, but it did used to work.\r\n\r\n'
4264,'JeffBezanson',"Test failure in parallel.jl\nI'm getting the following failure in the parallel.jl test.\r\n\r\nexception on 2: ERROR: test failed: :((-(max(workloads),min(workloads))<=1))\r\n in error at error.jl:21\r\n in default_handler at test.jl:21\r\n in do_test at test.jl:38\r\n in runtests at /Users/nfoti/src/julia/test/testdefs.jl:5\r\n in anonymous at multi.jl:811\r\n in run_work_thunk at multi.jl:563\r\n in anonymous at task.jl:811\r\nat parallel.jl:29\r\nERROR: test failed: :((-(max(workloads),min(workloads))<=1))\r\n in anonymous at multi.jl:1345\r\nat parallel.jl:29\r\nat /Users/nfoti/src/julia/test/runtests.jl:21\r\n\r\nThis is running on a Mac with a Core 2 Duo (maybe it has something to do with the fact that there are only two cores?) with OSX 10.8.4."
4258,'StefanKarpinski','remove Pkg1\nJust keeping track that this should be done before 0.2.'
4246,'ViralBShah','eigs(speye(21)) does not work\n`eigs` does not work on identity matrices of size 21 and higher for the default 6 eigenvalues.\r\n\r\n```\r\njulia> eigs(speye(21), nev=6)\r\nERROR: ARPACKException(3)\r\n in aupd_wrapper at linalg/arpack.jl:47\r\n in eigs at linalg/arnoldi.jl:35\r\n\r\njulia> eigs(speye(21), nev=9)\r\nERROR: ARPACKException(3)\r\n in aupd_wrapper at linalg/arpack.jl:47\r\n in eigs at linalg/arnoldi.jl:35\r\n\r\njulia> eigs(speye(21), nev=10)\r\n([1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0],\r\n21x10 Array{Float64,2}:\r\n  0.252111    -0.246736     0.0192645    0.234598    …   0.130942     0.100895   -0.0290075 \r\n  0.118993     0.190852    -0.393942    -0.232889       -0.002121     0.0280335  -0.213672  \r\n -0.00306955  -0.157261    -0.0341907   -0.182208       -0.110704    -0.158746   -0.419363  \r\n  0.0751385    0.167007     0.0305194    0.0977773      -0.00449555  -0.318633   -0.0253858 \r\n -0.0943686   -0.0731143    0.148546     0.330696        0.0214212   -0.213419   -0.0260602 \r\n  0.140182     0.00836135   0.00474463  -0.387105    …  -0.0425574   -0.111232   -0.135756  \r\n -0.256888    -0.354937    -0.482451     0.0503225       0.626875    -0.119688   -0.0743748 \r\n  0.115359     0.203424    -0.0082043    0.00844204      0.0697025   -0.31223    -0.384733  \r\n -0.0716209   -0.346583     0.529378    -0.307466        0.325135     0.238119   -0.100524  \r\n  0.132531    -0.230142    -0.0277612   -0.0306749      -0.174249     0.271229    0.244908  \r\n  0.149707     0.438754     0.286695     0.125643    …   0.42474     -0.149599   -0.0382037 \r\n -0.0220212    0.102343     0.155978    -0.232871       -0.186025     0.0696285  -0.211983  \r\n -0.163692    -0.167343    -0.0155797    0.171629       -0.261443     0.203264   -0.480922  \r\n -0.0956       0.0534561   -0.296926    -0.143689       -0.116822     0.0899562   0.00621333\r\n  0.63577     -0.422864     0.0268107   -0.0998203      -0.0911458   -0.403187    0.106614  \r\n  0.41942      0.15776     -0.034414     0.363393    …   0.0734304    0.475078   -0.205165  \r\n  0.11205     -0.0650867   -0.113777     0.0755098      -0.0801624   -0.0160499  -0.143335  \r\n -0.0523192    0.0961701    0.0374504   -0.0913321       0.0863463    0.0442572   0.211717  \r\n -0.242706    -0.0330528    0.0144394    0.226972       -0.31918     -0.267941    0.241889  \r\n  0.0206762   -0.18865     -0.0265206    0.393166       -0.061266    -0.0446505  -0.141417  \r\n -0.269261    -0.128465     0.307113     0.0916609   …  -0.0646332   -0.146322   -0.243291  )\r\n```'
4240,'vtjnash','windows encoding support\nexcept for limited usage cases, julia code on windows uses an incorrect encoding (including the clipboard code). solution: always use utf16 format. windows provides a function to make this straightforward. see `libuv/src/win/util.c` `uv_utf16_to_utf8` and `uv_utf8_to_utf16` for usage.\r\n\r\n(replaces #1919)'
4223,'Keno','typo in connect?\n```julia\r\njulia> connect("google.com",80) do\r\n       end\r\nERROR: sock not defined\r\n in connect at stream.jl:861\r\n```'
4221,'ViralBShah','Problems with GLM using Julia binary and liblapack\nWhile testing the GLM package I had the following (well known) error mentioned in another post here (Strange GLM breakages) https://groups.google.com/forum/#!msg/julia-stats/X9RKzsBIV3Y/M33nPe4DKBoJ\r\n\r\nJulia Version 0.2.0-prerelease+3610\r\nCommit 77cc4f1 2013-09-03 19:32:54 UTC\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin12.4.0)\r\n  WORD_SIZE: 64\r\n  BLAS: libgfortblas\r\n  LAPACK: liblapack\r\n  LIBM: libopenlibm\r\n\r\nThis seems to be an issue using liblapack instead of openblas '
4219,'JeffBezanson','LLVM replaces Julia\'s SIGPIPE ignore with an abort call\nNot sure what the error is, but I imagine we might be quitting before the error gets to print. \r\nConsider `test.jl`:\r\n```\r\ncmd = `false`\r\npp,p = writesto(cmd)\r\nwrite(pp,"Hello World")\r\nprintln("SUCCESS")\r\n```\r\n\r\n```\r\nKenos-MacBook-Pro:ijulia kfischer$ ~/julia/julia test.jl\r\nKenos-MacBook-Pro:ijulia kfischer$\r\n```\r\n\r\nShould have printed an error but didn\'t.'
4215,'Keno','Binary of Julia Beta v0.2-prerelease does not work on Mac OS X 10.6\nAfter installing the binary of Julia Beta v0.2-prerelease on my MacBook (Mac OS X 10.6.8), I run julia and I get the following:\r\n\r\n    exec bash -c "PATH=\'/Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/bin:/usr/bin:/bin:/usr/sbin:/sbin\' FONTCONFIG_PATH=\'/Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/etc/fonts\' GIT_EXEC_PATH=\'/Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/libexec/git-core\' GIT_TEMPLATE_DIR=\'/Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/share/git-core\' TK_LIBRARY=\'/System/Library/Frameworks/Tk.framework/Versions/8.5/Resources/Scripts\' exec \'/Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/bin/julia\'"\r\n\r\n    dyld: lazy symbol binding failed: Symbol not found: __dyld_find_unwind_sections\r\n    Referenced from: /Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/bin/../lib/julia/libjulia.dylib\r\n    Expected in: /usr/lib/libSystem.B.dylib\r\n\r\n    dyld: Symbol not found: __dyld_find_unwind_sections\r\n    Referenced from: /Applications/Julia-0.2.0-pre-c0e861a1c1.app/Contents/Resources/julia/bin/../lib/julia/libjulia.dylib\r\n    Expected in: /usr/lib/libSystem.B.dylib\r\n    \r\n    [Process completed]\r\n\r\nAny suggestions how to fix this?\r\nPlease note that the binary of Julia Release v0.1.2 works fine on my system.'
4213,'vtjnash',"crash on wine after building system image\nI thought it would be better to submit this as a separate issue in order to bring it to the attention of the wider community. Although a temporary fix for #3420 has been achieved and the Julia compilation on Windows was working fine, I get a new error after the latest update (compiling and linking works fine, the following error appears towards the end of make):\r\n\r\n```\r\nfixme:ntdll:NtFlushInstructionCache 0xffffffffffffffff 0xc80000 524288\r\n\r\nabnormal program termination\r\n*** This error is usually fixed by running 'make clean'. If the error persists, try 'make cleanall'. ***\r\nmake[1]: *** [/home/theodore/opt/julia-win64/usr/lib/julia/sys.ji] Error 1\r\nmake: *** [release] Error 2\r\n```\r\n\r\nThis is apparently a Windows specific error, since Julia updates fine on Linux."
4208,'JeffBezanson','Segmentation fault\nOn the latest julia build I get this:\r\n\r\n                   _\r\n       _       _ _(_)_     |  A fresh approach to technical computing\r\n      (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n       _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n      | | | | | | |/ _` |  |\r\n      | | |_| | | | (_| |  |  Version 0.2.0-prerelease+3619\r\n     _/ |\\__\'_|_|_|\\__\'_|  |  Commit 57a04d4* 2013-09-04 05:25:04 UTC\r\n    |__/                   |  x86_64-apple-darwin12.4.0\r\n    \r\n    julia> abstract c\r\n    \r\n    julia> type a\r\n           a::Int64\r\n           end\r\n    \r\n    julia> type b\r\n           a::Int64\r\n           end\r\n    \r\n    julia> function d(a::c)\r\n           print(a.a)\r\n           end\r\n    # methods for generic function d\r\n    d(a::c) at none:2\r\n    \r\n    julia> d(a(5))\r\n    Segmentation fault: 11\r\n\r\nShould this code work, and give me a function d that works on both a and b? My impression is that it should at least not segfault, and jeff usually fix these issues really fast.'
4201,'Keno',"Pkg: provide hooks for Pkg.update() to packages\nIt would be neat if packages could register a callback for when the user does `Pkg.update()`.  This would be a really nice solution for packages that might internally have some state that they could update (such as the formulae in the tap of my Homebrew.jl package).\r\n\r\nAs it stands, right now there is a `Homebrew.update()` function which isn't terrible, but as we get more and more packages, it would be nice to have `Pkg.update()` be able to apply to all the packages that might have such functions.  I have a dummy `deps/build.jl` file which is just:\r\n\r\n```julia\r\nusing Homebrew\r\nHomebrew.update()\r\n```\r\n\r\nBut this only gets triggered on an SHA bump of Homebrew.jl, which will likely happen far less often than I will add new formulae into [homebrew-juliadeps](https://github.com/staticfloat/homebrew-juliadeps)."
4189,'JeffBezanson','cglobal behavior changes when assigning output to variable\nWhen I assign the output of `cglobal` to a variable, I start to get pretty wild answers:\r\n```\r\njulia> cglobal(("nettle_hashes",n))\r\nPtr{Void} @0x000000010f294870\r\n\r\njulia> cglobal(("nettle_hashes",n))\r\nPtr{Void} @0x000000010f294870\r\n\r\njulia> nh = cglobal(("nettle_hashes",n))\r\nPtr{Void} @0x00007f8268c46550\r\n                                        \r\njulia> nh = cglobal(("nettle_hashes",n))\r\nPtr{Void} @0x00007f826b53e950\r\n                                        \r\njulia> nh = cglobal(("nettle_hashes",n))\r\nPtr{Void} @0x0000000000000002\r\n```\r\n\r\nIn this case, `n` is a handle to `libnettle`, obtained through `n = Nettle.nettle`, and `nettle_hashes` is a global c variable in `libnettle`.'
4165,'staticfloat','USE_QUIET=0 rule broken\n@staticfloat commit 97d8cd3338a799e9ee662a85cae2d746801fbb6c caused `USE_QUIET=0` to print nothing while building'
4162,'staticfloat','Use system blas on Mac\nI think we should use system blas on Mac at least for distribution. It seems to be equally performant and is perhaps better with threading.\n\nIf we sort out the mkl issues, that would be best but it seems unlikely.\n\nNote that Intel had given us mkl licenses for Julia distribution.'
4154,'JeffBezanson','Weird type bug\n````\r\ntype MyType{T} \r\n    a1::T\r\n    a2::Array\r\nend \r\n\r\nMyType{T}(A::T) = MyType(A, {A})\r\n\r\nfunction meth(params::MyType...)\r\n    println("typeof(params) = $(typeof(params))")\r\n    for elem in params\r\n        println("\\ttypeof(elem) = $(typeof(elem))")\r\n    end\r\nend\r\n\r\nf = ()->meth(MyType(reshape([1:1000],10,10,10)))\r\ng() = meth(MyType(reshape([1:1000],10,10,10)))\r\n````\r\n\r\nRunning both f() and g():\r\n````\r\njulia> g()\r\ntypeof(params) = (MyType{Array{Int64,3}},)\r\n\ttypeof(elem) = MyType{Array{Int64,N}}\r\n\r\njulia> f()\r\ntypeof(params) = (MyType{Array{Int64,3}},)\r\n\ttypeof(elem) = MyType{Array{Int64,3}}\r\n````\r\n\r\nWhile `f` gets the type of `elem` correctly as `MyType{Array{Int64,3}}`, method `g()` gets it as `MyType{Array{Int64,N}}`'
4151,'Keno','testsocket test doesn\'t work on windows\nThis test fragment hangs:\r\n```julia\r\nisfile("testsocket") && Base.FS.unlink("testsocket")\r\n@async begin\r\n\ts = listen("testsocket")\r\n\tBase.notify(c)\r\n\tsock = accept(s)\r\n\twrite(sock,"Hello World\\n")\r\n\tclose(s)\r\n\tclose(sock)\r\nend\r\nwait(c)\r\n@test readall(connect("testsocket")) == "Hello World\\n"\r\n```\r\n\r\nBecause the listen command fails:\r\n```\r\n     * socket\r\nERROR: Could not listen on path testsocket\r\n in listen at stream.jl:840\r\n in anonymous at multi.jl:56\r\n```'
4119,'JeffBezanson',"compiler error after type inference pass\nThis is a silly function and I can't imagine a use case for it, but perhaps it should should instead throw a run-time error? Or maybe the inference pass also needs to do dead-code prunning.\r\n```julia\r\njulia> f() = true? int128(1) : 0\r\n# methods for generic function f\r\nff() at none:1\r\n\r\njulia> f()\r\nERROR: error compiling f: unbox: T != typeof(x)\r\n\r\njulia> code_typed(f,())\r\n1-element Any Array:\r\n :($(Expr(:lambda, {}, {{},{},{}}, quote  # none, line 1:\r\n        unless true goto 0\r\n        return top(box)($(Int32),top(trunc_int)($(Int32),1))::Int32\r\n        0: \r\n        return 0\r\n    end)))\r\n\r\njulia> code_llvm(f,())\r\nERROR: error compiling f: unbox: T != typeof(x)\r\n in _dump_function at reflection.jl:108\r\n in code_llvm at reflection.jl:115\r\n\r\njulia> f()\r\n1\r\n```"
4115,'JeffBezanson','Method Dispatch Bug\nConsider the following:\r\n```\r\njulia> type Foo\r\n       end\r\n\r\njulia> typealias Foos NTuple{3,Union(Foo,Type{Foo})}\r\n(Union(Foo,Type{Foo}),Union(Foo,Type{Foo}),Union(Foo,Type{Foo}))\r\n\r\njulia> baz(x::Foos) = x\r\n# methods for generic function baz\r\nbaz(x::(Union(Foo,Type{Foo}),Union(Foo,Type{Foo}),Union(Foo,Type{Foo}))) at /home/keno/repl.jl:1\r\n\r\njulia> baz((Foo(),Foo(),Foo()))\r\n(Foo(),Foo(),Foo())\r\n\r\njulia> baz((Foo,Foo,Foo))\r\n(Foo,Foo,Foo)\r\n\r\njulia> baz((Foo,Foo,Foo()))\r\nERROR: no method baz((DataType,DataType,Foo),)\r\n\r\njulia> \r\njulia> @which baz((Foo,Foo,Foo()))\r\nbaz(x::(Union(Foo,Type{Foo}),Union(Foo,Type{Foo}),Union(Foo,Type{Foo}))) at /home/keno/repl.jl:1\r\n```\r\nNote that I get a no method error even though `@which` shows me the correct method. '
4103,'staticfloat',"Latest OS X Binary does not include Base.Random\nThe latest build `Julia-0.2.0-pre-7530d98cfd` from 2013/08/07 doesn't seem to include `Base.Random`. Any chance we can get a new build?"
4082,'StefanKarpinski','REQUIRE not updated when build script fails\nIf possible REQUIRE should be updated before running the build scripts.'
4075,'JeffBezanson','is_stable_expr is wrong sometimes\nNote the following demo code.\r\n\r\n```julia\r\nimmutable Foo                              \r\n       x::Int64\r\n       y::Float64\r\nend\r\n\r\nfunction foo(f::Foo,s::Symbol)\r\n       x = getfield(f,s)\r\n       gc()\r\n       x\r\nend\r\n```\r\n\r\nDue to an incorrect assumption in `is_stable_expr`, no box is allocated for `x` in the above, so we get the following:\r\n\r\n```\r\njulia> foo(Foo(1,2.0),:y)\r\nERROR: type: subtype: expected Type{T<:Top}, got Type{(TTY,ASCIIString,Union(Type{T<:Top},ASCIIString,UTF8String),Any...)}\r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1054\r\n in typeinf_ext at inference.jl:1031\r\n in println at string.jl:5\r\n\r\njulia> foo(Foo(1,2.0),:y)\r\nERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1054\r\n in typeinf_ext at inference.jl:1031\r\n in println at string.jl:5SYSTEM: show(lasterr) caused an error\r\nERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1054\r\n in typeinf_ext at inference.jl:1031\r\n in show_delim_array at show.jl:126\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:74\r\n in with_output_color at error.jl:53\r\n in display_error at client.jl:72SYSTEM: show(lasterr) caused an error\r\nWARNING: it is likely that something important is broken, and Julia will not be able to continue normally\r\n\r\njulia> foo(Foo(1,2.0),:y)\r\nSegmentation fault (core dumped)\r\n```\r\n\r\nMainly to remind myself and @JeffBezanson to fix this. \r\n'
4042,'JeffBezanson','Tuples made me sad (so I fixed them)\nAlright, this rabbit hole turned out to be a giant dungeon instead, but I think I have finally found the exit.\r\n\r\nBasically what this does is prevent heap allocation of tuples whenever possible, instead passing them in registers or on the stack (or wherever llvm thinks is most efficient). An easy example is this:\r\n```\r\njulia> bar() = (1,2)\r\n\r\njulia> code_llvm(bar,())\r\n\r\n; Function Attrs: sspreq\r\ndefine <2 x i64> @julia_bar714() #2 {\r\ntop:\r\n  ret <2 x i64> <i64 1, i64 2>, !dbg !3834\r\n}\r\n```\r\n\r\nwhereas before it used to heap allocate it (albeit it was smart enough to recognize that the result was constant, it only did it once, but still: (from the old version)\r\n```julia\r\njulia> bar() = (1,2)\r\n\r\njulia> code_llvm(bar,())\r\n\r\ndefine %jl_value_t* @julia_bar() {\r\ntop:\r\n  ret %jl_value_t* inttoptr (i64 62429664 to %jl_value_t*), !dbg !3407\r\n}\r\n```\r\n\r\nA perhaps more exciting and real work application is `size` on various array, e.g. \r\n\r\n```julia\r\njulia> code_llvm(size,(Array{Int64,2},))\r\n\r\n; Function Attrs: sspreq\r\ndefine <2 x i64> @julia_size(%jl_value_t*) #2 {\r\ntop:\r\n  %1 = getelementptr inbounds %jl_value_t* %0, i64 4, i32 0, !dbg !3876\r\n  %2 = load %jl_value_t** %1, align 8, !dbg !3876\r\n  %3 = ptrtoint %jl_value_t* %2 to i64, !dbg !3876\r\n  %4 = insertelement <2 x i64> undef, i64 %3, i32 0, !dbg !3881, !julia_type !3882\r\n  %5 = getelementptr inbounds %jl_value_t* %0, i64 5, i32 0, !dbg !3881\r\n  %6 = load %jl_value_t** %5, align 8, !dbg !3881\r\n  %7 = ptrtoint %jl_value_t* %6 to i64, !dbg !3881\r\n  %8 = insertelement <2 x i64> %4, i64 %7, i32 1, !dbg !3881, !julia_type !3882\r\n  ret <2 x i64> %8, !dbg !3881\r\n}\r\n```\r\n\r\nNote that there is now no allocation involved, whereas before (again from the old version):\r\n\r\n```julia\r\njulia> code_llvm(size,(Array{Int64,2},))\r\n\r\ndefine %jl_value_t* @julia_size(%jl_value_t*, %jl_value_t**, i32) {\r\ntop:\r\n  %3 = alloca [3 x %jl_value_t*], align 8\r\n  %.sub = getelementptr inbounds [3 x %jl_value_t*]* %3, i64 0, i64 0\r\n  %4 = getelementptr [3 x %jl_value_t*]* %3, i64 0, i64 2, !dbg !3419\r\n  store %jl_value_t* inttoptr (i64 2 to %jl_value_t*), %jl_value_t** %.sub, align 8\r\n  %5 = getelementptr [3 x %jl_value_t*]* %3, i64 0, i64 1, !dbg !3419\r\n  %6 = load %jl_value_t*** @jl_pgcstack, align 8, !dbg !3419\r\n  %.c = bitcast %jl_value_t** %6 to %jl_value_t*, !dbg !3419\r\n  store %jl_value_t* %.c, %jl_value_t** %5, align 8, !dbg !3419\r\n  store %jl_value_t** %.sub, %jl_value_t*** @jl_pgcstack, align 8, !dbg !3419\r\n  store %jl_value_t* null, %jl_value_t** %4, align 8\r\n  %7 = load %jl_value_t** %1, align 8, !dbg !3419\r\n  %8 = getelementptr inbounds %jl_value_t* %7, i64 4, i32 0, !dbg !3419\r\n  %9 = load %jl_value_t** %8, align 8, !dbg !3419\r\n  %10 = ptrtoint %jl_value_t* %9 to i64, !dbg !3419\r\n  %11 = call %jl_value_t* @jl_box_int64(i64 %10), !dbg !3424\r\n  store %jl_value_t* %11, %jl_value_t** %4, align 8, !dbg !3424\r\n  %12 = call %jl_value_t* @allocobj(i64 32), !dbg !3424\r\n  %13 = getelementptr inbounds %jl_value_t* %12, i64 2, i32 0, !dbg !3424\r\n  store %jl_value_t* %11, %jl_value_t** %13, align 8, !dbg !3424\r\n  %14 = getelementptr inbounds %jl_value_t* %12, i64 0, i32 0, !dbg !3424\r\n  store %jl_value_t* inttoptr (i64 28847136 to %jl_value_t*), %jl_value_t** %14, align 8, !dbg !3424\r\n  %15 = getelementptr inbounds %jl_value_t* %12, i64 1, i32 0, !dbg !3424\r\n  store %jl_value_t* inttoptr (i64 2 to %jl_value_t*), %jl_value_t** %15, align 8, !dbg !3424\r\n  %16 = getelementptr inbounds %jl_value_t* %12, i64 3, i32 0, !dbg !3424\r\n  store %jl_value_t* null, %jl_value_t** %16, align 8, !dbg !3424\r\n  store %jl_value_t* %12, %jl_value_t** %4, align 8, !dbg !3424\r\n  %17 = getelementptr inbounds %jl_value_t* %7, i64 5, i32 0, !dbg !3424\r\n  %18 = load %jl_value_t** %17, align 8, !dbg !3424\r\n  %19 = ptrtoint %jl_value_t* %18 to i64, !dbg !3424\r\n  %20 = call %jl_value_t* @jl_box_int64(i64 %19), !dbg !3424\r\n  store %jl_value_t* %20, %jl_value_t** %16, align 8, !dbg !3424\r\n  %21 = load %jl_value_t** %5, align 8, !dbg !3424\r\n  %22 = getelementptr inbounds %jl_value_t* %21, i64 0, i32 0, !dbg !3424\r\n  store %jl_value_t** %22, %jl_value_t*** @jl_pgcstack, align 8, !dbg !3424\r\n  ret %jl_value_t* %12, !dbg !3424\r\n}\r\n```\r\n\r\nAnother exciting part of this pull request that if your types happen to correspond to a machine vector type (aka SIMD type), I make it just that, allowing fun things like\r\n\r\n```julia\r\njulia> foo(x::(Int32,Int32,Int32,Int32)) = llvmcall("""%3 = add <4 x i32> %1, %0\r\n       ret <4 x i32> %3""",(Int32,Int32,Int32,Int32),((Int32,Int32,Int32,Int32),(Int32,Int32,Int32,Int32)),(int32(1),int32(2),int32(3),int32(4)),\r\n       x)\r\n# methods for generic function foo\r\nfoo(x::(Int32,Int32,Int32,Int32)) at none:1\r\n\r\njulia> code_llvm(foo,((Int32,Int32,Int32,Int32),))\r\n; Number of arguments: 2\r\ndefine <4 x i32> @julia_foo1(<4 x i32> ,<4 x i32> ) {\r\n%3 = add <4 x i32> %1, %0\r\nret <4 x i32> %3\r\n}\r\ndefine linkonce_odr <4 x i32> @julia_foo1(<4 x i32>, <4 x i32>) {\r\n  %3 = add <4 x i32> %1, %0\r\n  ret <4 x i32> %3\r\n}\r\n\r\n\r\n; Function Attrs: sspreq\r\ndefine <4 x i32> @julia_foo(<4 x i32>) #2 {\r\ntop:\r\n  %1 = add <4 x i32> %0, <i32 1, i32 2, i32 3, i32 4>\r\n  ret <4 x i32> %1, !dbg !3798\r\n}\r\n\r\njulia> code_native(foo,((Int32,Int32,Int32,Int32),))\r\n\t.text\r\nFilename: none\r\nSource line: 1\r\n\tpush\tRBP\r\n\tmov\tRBP, RSP\r\n\tsub\tRSP, 16\r\n\tmov\tRAX, QWORD PTR FS:[40]\r\n\tmov\tQWORD PTR [RBP - 8], RAX\r\n\tmov\tRAX, QWORD PTR FS:[40]\r\n\tcmp\tRAX, QWORD PTR [RBP - 8]\r\n\tjne\t20\r\n\tmovabs\tRAX, 140737297706192\r\n\tpaddd\tXMM0, XMMWORD PTR [RAX]\r\nSource line: 1\r\n\tadd\tRSP, 16\r\n\tpop\tRBP\r\n\tret\r\n\tmovabs\tRAX, 140737322375370\r\n\tcall\tRAX\r\n```\r\n\r\nNote in particular the `paddd` in the native disassembly. The `llvmcall` used here is a new intrinsic to easily embed any LLVM IR into your julia functions. It is part of this pull request for demonstration purposes mostly, but is fully featured and ready to be used, but if people would rather not have it, I can rebase it out. \r\n\r\nThe tuple unboxing currently is only enabled for immutable types due to GC considerations, but I will follow up with that patch after discussion on this one is done (it already work fine for other types if you disable the GC). \r\n\r\nFixes #2496 \r\nFixes #2299\r\n/cc @JeffBezanson '
4030,'JeffBezanson',"Need ambiguity warning when defining map?\nThe following example defines `map` in a sufficiently unspecific way that it never gets invoked.\r\n\r\n\timmutable Foo\r\n\t\tv::Vector{Int}\r\n\tend\r\n\r\n\tfunction Base.map(func, x::Foo)\r\n\t\tres = similar(x.v)\r\n\t\tfor i in 1:length(x.v)\r\n\t\t\tres[i] = func(x.v[i])\r\n\t\tend\r\n\t\treturn Foo(res)\r\n\tend\r\n\r\n\tmyfoo = Foo([1, 2, 3])\r\n\r\n\tinvoke(Base.map, (Any, Foo), i -> i + 1, myfoo)\r\n\r\n\tmap(i -> i + 1, myfoo)\r\n\r\nWould it be possible to raise an ambiguity warning for this kind of unreachable code? Based on some experiments that @zachallaun and I did, it seems that the splatting in the reduce.jl definition of `map` is the reason why we don't see any ambiguity warning here."
4026,'JeffBezanson','default inner constructors should accept any arguments\nOnce upon a time if you did this, it would work:\r\n\r\n```julia\r\ntype Foo\r\n  x::Float64\r\nend\r\n\r\njulia> Foo(1)\r\nFoo(1.0)\r\n```\r\n\r\nIt was pretty convenient. However, back then `convert` was quite aggressive and this also worked:\r\n\r\n```julia\r\ntype Bar\r\n  y::Int\r\nend\r\n\r\njulia> Bar(1.5)\r\nBar(2) # or Bar(1) depending on when you tried it\r\n```\r\n\r\nThis was deemed dangerous and confusing, so default constructors were changed to not call convert for you. Today, however, convert is far more conservative and `convert(Int,1.5)` fails with an InexactError. Therefore, I propose that we reinstate the old convenient behavior of calling convert automatically in inner constructors.'
3999,'Keno','setenv test doesn\'t work on windows\n```julia\r\n$ make -C test spawn\r\nmake: Entering directory `/c/Users/julia/Desktop/julia32/test\'\r\n    JULIA test/spawn\r\n     * spawn\r\n       [stdio passthrough ok]\r\nexception on 1: ERROR: could not start process `sh -c \'echo \\$TEST\'`: invalid argument (EINVAL)\r\n in test_success at process.jl:420\r\n in success at process.jl:428\r\n in readall at process.jl:393\r\n in readall at process.jl:390\r\n in runtests at c:\\Users\\julia\\Desktop\\julia32\\test\\testdefs.jl:5\r\n in anonymous at multi.jl:601\r\n in run_work_thunk at multi.jl:563\r\n in remotecall_fetch at multi.jl:635\r\n in remotecall_fetch at multi.jl:650\r\n in anonymous at multi.jl:1332\r\nat spawn.jl:81\r\n```\r\n\r\nNote that the setenv usage in `base/git.jl` seems OK. Furthermore, this is probably an upstream bug, because after running Pkg2.update, it suddenly started working in one particular session (but still not in future sessions):\r\n```\r\njulia> run(setenv(`sh -c \'echo \\$TEST\'`,{"TEST"=>"xx"}))\r\n$TEST\r\n\r\njulia> run(setenv(`sh -c "echo \\$TEST"`,{"TEST"=>"xx"}))\r\nxx\r\n```'
3998,'Keno',"`yes` test in spawn doesn't work on windows\nSIGPIPE isn't a thing. Although perl throws error 68864, so perhaps that's a thing."
3944,'staticfloat','Make codespeed build from fresh git clones every commit\nTo make this feasible I need to:\r\n\r\n* Copy out build-intensive `deps/` subdirectories such as `atlas` to save compile time, especially on julia.mit.edu.\r\n\r\nThis is a note to self.'
3918,'staticfloat',"Issues copying shared libraries in make install\nWhen I run `make install` after building, I get a bunch of errors like \r\n\r\n    cp: cannot stat '/usr/lib/libccolamd*.so*': No such file or directory\r\n\r\nIt seems like make is not expanding the `*` globs you put in there."
3890,'JeffBezanson',"Parametrically typed fields with parametric parameters are only parametrized once\nThe first time around, this seems to work:\r\n```\r\njulia> type A{T1}\r\n         x::Matrix{Complex{T1}}\r\n       end\r\n\r\njulia> A{Float64}.types\r\n(Array{Complex{Float64},2},)\r\n```\r\n\r\nThe second time, it doesn't seem to work:\r\n```\r\njulia> type B{T2}\r\n         x::Matrix{Complex{T2}}\r\n       end\r\n\r\njulia> B{Float64}.types\r\n(Array{Complex{T1},2},)\r\n```\r\n\r\nThis isn't just cosmetic; it also affects type inference."
3876,'JeffBezanson',"generate llvm global variables for most literal_pointer_val calls\nThis takes care of generating llvm globals for all uses of literal_pointer_val (except a few that aren't very important, unless I missed some). we still need to tell dump.c about them before static compilation will work."
3866,'JeffBezanson','@sync hangs on remote worker exit\n```@sync``` waits forever when a remote worker terminates within an ```@async``` block\r\n\r\n\r\n```\r\njulia> addprocs(1)\r\n1-element Any Array:\r\n 2\r\n\r\njulia> @sync begin\r\n           @async begin\r\n               remotecall_fetch(2, exit)\r\n           end\r\n       end\r\nWorker 2 terminated.ERROR: ProcessExitedException()\r\n in yield at multi.jl:1440\r\n in wait at task.jl:105\r\n in wait_full at multi.jl:528\r\n in remotecall_fetch at multi.jl:628\r\n in remotecall_fetch at multi.jl:633\r\n in anonymous at multi.jl:3\r\n\r\n\r\nERROR: read: end of file\r\n in yield at multi.jl:1440\r\n in wait at task.jl:105\r\n in wait_full at multi.jl:528\r\n in remotecall_fetch at multi.jl:628\r\n in remotecall_fetch at multi.jl:633\r\n in anonymous at multi.jl:3\r\n\r\n```'
3865,'staticfloat','Latest nightly crashes when starting on Ubuntu 12.04 64-bit\nI just tried installing Julia for the time from the PPA\r\n\r\n    sudo add-apt-repository ppa:staticfloat/julianightlies\r\n    sudo add-apt-repository ppa:staticfloat/julia-deps\r\n    sudo apt-get update\r\n    sudo apt-get install julia\r\n\r\nWhen I try to start it, I get this error:\r\n```\r\n$ julia\r\nOpenBLAS : Your OS does not support AVX instructions. OpenBLAS is using Nehalem kernels as a fallback, which may give poorer performance.\r\nfatal: error thrown and no exception handler available.\r\nexec: error -5\r\n```'
3852,'JeffBezanson',"illegal instruction crash\nI've run into an ``Illegal instruction (core dumped)`` crash by trying to run some old code. I can reproduce the crash on two linux 64-bit machines using 1613b3b94. \r\n\r\nI've removed much of the surrounding code to get a 150-line test case which always crashes: https://gist.github.com/mlubin/6095957. JuMP must be installed. Unfortunately I couldn't simplify it any more than this.\r\n\r\nThe GDB backtrace isn't very helpful:\r\n```\r\nProgram received signal SIGILL, Illegal instruction.\r\n0x00007ffff33061fa in ?? ()\r\n(gdb) backtrace\r\n#0  0x00007ffff33061fa in ?? ()\r\n#1  0x0000000004886cb0 in ?? ()\r\n#2  0x0000000000000040 in ?? ()\r\n#3  0x00007fffffffd360 in ?? ()\r\n#4  0x0000000004db4700 in ?? ()\r\n#5  0x0000000004db4670 in ?? ()\r\n#6  0x00000000028f4140 in ?? ()\r\n#7  0x0000000004db45b0 in ?? ()\r\n#8  0x0000000002320a40 in ?? ()\r\n#9  0x00000000068502d0 in ?? ()\r\n#10 0x0000000002bbde40 in ?? ()\r\n#11 0x0000000000000000 in ?? ()\r\n```"
3849,'Keno',"remove uv_error_t from sysinfo.jl\n@loladiro I think I've worked out the missing file and rebuild dependency links so that autoconf doesn't try to run. Can you fix the remaining usages of uv_error_t in sysinfo.jl?"
3848,'JeffBezanson','include_string (and include etc.) should return the value of the last expression\n(or `nothing` if there were no expressions evaluated).\r\n\r\nThis would be very handy for evaluating multi-line expressions (and especially for getting readable tracebacks thereof).  For example, in the IPython front-end we could really use this.\r\n\r\nLooks like a two-minute patch job to `jl_parse_eval_all` in the C source (for someone familiar therewith).  Ping @JeffBezanson, with whom I discussed this already.'
3827,'JeffBezanson',"Release Candidate plans for 0.2\nWhere better to discuss RC policy that on an issue tracker?\r\n\r\nAfter seeing https://github.com/JuliaLang/julia/issues/2597#issuecomment-21534868 and almost replying to @ViralBShah right there in the issue, I thought it might be useful to hash out how we plan to do RC's and the eventual release of `0.2`.  All my experience with RC's has been with the blender project, which has a [pretty intense set of policies](http://wiki.blender.org/index.php/Dev:Doc/Process/Release_Cycle) regarding when certain pieces of code can get merged into trunk, but I think we can adapt some of their practices to help our releases to go as smoothly as possible.\r\n\r\nI'm thinking that we should tag some commit as `0.2.0-rc1`, and then push that out to the community at large to see if they can break it.  The key here is as widespread testing as possible, followed by bugfixes only making their way into `master`, everything else happens in a topic branch.  Once a predetermined amount of time goes by (for the blender heads it's on the order of a week, I believe) where no new issues come up and we're able to squash all the showstoppers, a release is made. There are usually a few bugs that are found afterward, but unless they're something really terrible a bugfix build is usually not released.\r\n\r\nThe most important thing here is getting the community to test the RC builds on all their very inventive setups, which means probably announcing things like this on `julia-dev`, `julia-users`, etc....  The bugfix week (or however long it is) is also a really good time to focus in on documentation, but let's be honest, when is a time when we WOULDN'T say it's a good time to focus in on the docs?\r\n\r\nDiscuss!"
3823,'Keno',"need a way to redirect STDOUT/ERR/IN to Julia streams\nIn order to implement the IPython front-end (see e.g. [julia-ipython issue #5](https://github.com/JuliaLang/julia-ipython/issues/5)), we need to be able to capture stdout and stderr and redirect them to messages periodically flushed to a ZMQ socket (to send to the IPython front-end).  We also need to capture stdin read requests and turn them in to requests over ZMQ to the IPython front-end.\r\n\r\nWe can, of course, temporarily modify the variables `STDIN` etcetera (although even this seems to require some changes to `Base`, since Julia doesn't like it when code tries to change globals owned by another module).  But it would be much nicer to capture the actual file descriptors, e.g. so that we can capture output from external C libraries.\r\n\r\n@JeffBezanson suggested doing some sort of [dup](http://en.wikipedia.org/wiki/Dup_%28system_call%29) on the file descriptors (though this may be [harder on Windows](http://support.microsoft.com/kb/190351)).  @loladiro, any thoughts?"
3821,'JeffBezanson','Return value ignored\nConsider the following method in my Docker package:\r\n```\r\n\tfunction create_container(host, image, cmd::Cmd; \r\n\t\t\t\ttty = true, \r\n\t\t\t\tattachStdin  = false,\r\n\t\t\t\topenStdin    = false,\r\n     \t\t\tattachStdout = true,\r\n     \t\t\tattachStderr = true,\r\n     \t\t\tports = [])\r\n\r\n\t\turl = "http://$host/v1.3"\r\n\r\n\t\tparams =   ["Image" => image, \r\n\t\t\t\t\t"Cmd" => [cmd.exec], \r\n\t\t\t\t \t"Tty" => tty,\r\n\t\t\t\t \t"AttachStdin" \t=> attachStdin,\r\n\t\t\t\t \t"OpenStdin" \t=> openStdin,\r\n\t\t\t\t \t"AttachStdout" \t=> attachStdout,\r\n\t\t\t\t \t"AttachStderr" \t=> attachStderr,\r\n\t\t\t\t \t"PortSpecs"\t\t=> [dec(p) for p in ports], \r\n\t\t\t\t \t"Entrypoint" \t=> [],\r\n\t\t\t\t \t"Volumes"  \t\t=> ["/.julia" => Dict{String,String}()],\r\n\t\t\t\t \t"VolumesFrom"   => ""]\r\n\t\tresp = HTTPClient.post(URI("$url/containers/create"),JSON.to_json(params);headers=headers)\r\n\t\tprintln(resp)\r\n\t\treturn resp\r\n\tend\r\n```\r\nThe problem is that the return value of this function is being ignored\r\n```\r\njulia> Docker.create_container(docker_host,"51d4c6302994",\r\n                              `/bin/bash`)\r\nResponse(201 Created, 9 Headers, 21 Bytes in Body)\r\n\r\njulia> ans\r\n:(nothing)\r\n```\r\nI tried cutting it down further (the `println` isn\'t necessary but otherwise you don\'t know that `resp` is actually being assigned), but it seems that anything that makes the actual request fail makes the return work.\r\n\r\nEDIT: the `:(nothing)` is printed by my REPL, but the same thing happens with the default REPL.'
3807,'JeffBezanson','Bizarre error with macros and typeof\nI\'ve tried to distill this down to the simplest case I could, but I\'m still at a complete loss.\r\n\r\n```julia\r\nimmutable Foo\r\n    x\r\nend\r\n\r\nfunction f(foo::Foo)\r\n    println("calling f")\r\n    foo.x\r\nend\r\n\r\nmacro g(ex)\r\n    ex\r\nend\r\n\r\nfunction h()\r\n    foo = Foo(1)\r\n    @g typeof(f(foo))\r\nend\r\n\r\nh()\r\n```\r\n\r\n`f` gets called twice here somehow. It\'s weirdly specific to these circumstances: the `typeof` call, `f` returning a member of `foo`, `@g typeof(f(foo))` being within a function, etc.\r\n\r\nAlso, this broke within the last week or so.'
3796,'JeffBezanson','more inlining\nThis pull requests adds inlining and improved call site type specialization. It separates function calls of type unions and provides support for multi-line inlining. (It also attempts to inline Union, but that part is causing the tests to fail)\r\n\r\nWhile the standard inlining heuristic has not been updated, you can test the multiline inlining by forcing a function to be inlined by adding an `:inline` keyword:\r\n```julia\r\nfunction abs(x) :inline\r\n    if x > 0\r\n        x\r\n    else\r\n        -x\r\n    end\r\nend\r\n```'
3789,'JeffBezanson','trouble with array comprehension in while loop condition\nThe following seems to cause the while condition check to loop forever:\r\n````\r\nwhile(all([false for idx in 1:10]))\r\n\tprintln("sdfsd")\r\nend\r\n````\r\n'
3750,'JeffBezanson','current master fails llvm assertions\n```\r\njameson@julia:~/julia$ make cleanall && make\r\n    JULIA usr/lib/julia/sys.ji\r\nutf8.jl\r\njulia-release-readline: /home/jameson/julia/deps/llvm-3.2/lib/CodeGen/LiveVariables.cpp:114: void llvm::LiveVariables::MarkVirtRegAliveInBlock(llvm::LiveVariables::VarInfo&, llvm::MachineBasicBlock*, llvm::MachineBasicBlock*, std::vector<llvm::MachineBasicBlock*>&): Assertion `MBB != &MF->front() && "Can\'t find reaching def for virtreg"\' failed.\r\nStack dump:\r\n0.\tRunning pass \'Live Variable Analysis\' on function \'@julia_typeinf\'\r\nAborted (core dumped)\r\n*** This error is usually fixed by running \'make clean\'. If the error persists, try \'make cleanall\'. ***\r\njameson@julia:~/julia$ \r\n```\r\n(for bisection purposes, db3cf814cc21468b44c82ea01d7f0fc4ffdb775d was a good commit fbf3ed8 was bad)'
3743,'JeffBezanson','auto_unbox failure?\nAfter updating to the latest master, the following code from Stats.jl fails:\r\n\r\n    function ecdf{T}(X::AbstractVector{T})\r\n        Xs = sort(X)\r\n        isnan(Xs[end]) && error("ecdf undefined in presence of NaNs")\r\n        n = length(X)\r\n        e(x::Real) = searchsortedlast(Xs, x) / n\r\n        function e(v::Vector)\r\n            ord = sortperm(v)\r\n            m = length(v)\r\n            r = Array(T, m)\r\n            r0 = 0\r\n            i = 1\r\n            for x in Xs\r\n                if x > v[ord[i]]\r\n                    r[ord[i]] = r0\r\n                    i += 1\r\n                end\r\n                r0 += 1\r\n                if i > m break end\r\n            end\r\n            if i == m r[ord[i]] = n end\r\n            return r / n\r\n        end\r\n        return e\r\n    end\r\n\r\nWe now get this error:\r\n\r\n\tERROR: auto_unbox: unable to determine argument type\r\n\t in e at /Users/johnmyleswhite/.julia/Stats/src/Stats.jl:317\r\n\t in include_from_node1 at loading.jl:91\r\n\t in anonymous at no file:18\r\n\t in include_from_node1 at loading.jl:91\r\n\t in process_options at client.jl:274\r\n\t in _start at client.jl:347\r\n\tat /Users/johnmyleswhite/.julia/Stats/test/01.jl:40\r\n\tat /Users/johnmyleswhite/.julia/Stats/run_tests.jl:19\r\n\r\nIs this intentional?'
3739,'Keno','100% CPU after error on connect.\nAfter an error on a connect call, the Julia process was taking 100% CPU till a Ctrl-C.\r\n\r\nRunning a gc() afterwrads resulted in a seg fault.\r\n\r\n```\r\n\r\njulia> start_cluster(["localhost"])\r\nSuccessfully started tunnel on port 8500\r\nERROR: no method connect!(TcpSocket,UVError,Int64)\r\n in anonymous at no file:445\r\n in _uv_hook_getaddrinfo at socket.jl:372\r\n in process_events at stream.jl:457\r\n\r\n^CERROR: interrupt\r\n in yield at multi.jl:1435\r\n in wait at task.jl:97\r\n in wait at task.jl:28\r\n in sync_end at multi.jl:1153\r\n in start_cluster at none:1161\r\n\r\njulia> start_cluster(["localhost"])\r\nCould not start workers on node localhost : spawn: too many open files (EMFILE)\r\n\r\n in _jl_spawn at process.jl:199\r\n in spawn at process.jl:322\r\n in ssh_tunnel at none:6\r\n in anonymous at multi.jl:7\r\nSetHandle(["localhost"],``,9500,"amitm","/home/amitm/Work/julia/julia/usr/bin",[])\r\n\r\njulia> gc()\r\nSegmentation fault\r\n```  \r\n\r\nTill the Ctrl-C, ```strace``` did not print anything, I guess it was spin waiting on a non-system object.\r\n\r\nI figured there was problem with my code which did a ton of failed ```connect``` calls.\r\n\r\nThe issue really is\r\n\r\n- When the process open fd limit is reached, and an error is being shown, the Julia process takes 100% CPU till a Ctrl-C\r\n\r\n- The sockets opened as part of failed ```connect``` calls are not gc\'ed (and closed) quickly enough\r\n\r\n- results in a segfault soon after\r\n \r\n\r\n\r\n\r\n\r\n'
3723,'Keno','ccall of an immutable using any\nWhen passing an immutable object to a ccall expecting `Any`, we need to box it properly. Right now we only get an LLVM assertion failure. '
3718,'StefanKarpinski','Pkg2 rollback failure infinite recursion\nThis is a duplicate of #3695, followed by more bad behavior. This is a relatively recent `.julia` directory that has only been used with Pkg2 (AFAIK) and only has one package installed (Options).\r\n\r\n```\r\njulia> Pkg2.add("Winston")\r\nMESSAGE: Cloning BinDeps from git://github.com/loladiro/BinDeps.jl.git\r\nMESSAGE: Cloning Winston from git://github.com/nolta/Winston.jl.git\r\nMESSAGE: Cloning Cairo from git://github.com/JuliaLang/Cairo.jl.git\r\nMESSAGE: Cloning Color from git://github.com/JuliaLang/Color.jl.git\r\nMESSAGE: Cloning IniFile from git://github.com/JuliaLang/IniFile.jl.git\r\nMESSAGE: Cloning Tk from git://github.com/JuliaLang/Tk.jl.git\r\nMESSAGE: Installing BinDeps v0.2.0\r\nMESSAGE: Upgrading Options: v0.2.1- => v0.2.1\r\nfatal: reference is not a tree: f1417b80ec7f3338275b2b692f7dc33289e50935\r\nMESSAGE: Rolling back install of BinDeps\r\nMESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\nErrorException("failed process: Process(`mv BinDeps .trash/`, ProcessExited(1)) [1]")MESSAGE: Rolling back install of BinDeps\r\nmv: cannot stat `BinDeps\': No such file or directory\r\n...\r\n```'
3695,'StefanKarpinski','Pkg2 "reference is not a tree"\nAs best I can tell, this resulted from having an old copy of Options installed (via Pkg1) in my .julia directory. Running `Pkg2.update()` for the first time cloned Options into my `.cache` folder, but did not update the Options folder in my .julia directory.\r\n\r\nAs an aside, would it be better to compute the minimum required rollback to satisfy dependencies?\r\n\r\n```\r\nMESSAGE: Upgrading Options: v0.2.0 => v0.2.1\r\nfatal: reference is not a tree: f1417b80ec7f3338275b2b692f7dc33289e50935\r\nMESSAGE: Rolling back Iterators from v0.1.1 to v0.0.0\r\nMESSAGE: Rolling back Distributions from v0.1.4 to v0.1.2\r\nMESSAGE: Rolling back install of Stats\r\nERROR: failed process: Process(`git --work-tree=/home/jameson/.julia/Options --git-dir=/home/jameson/.julia/.git/modules/Options checkout -q f1417b80ec7f3338275b2b692f7dc33289e50935`, ProcessExited(128)) [128]\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:430\r\n in run at process.jl:413\r\n in run at git.jl:17\r\n in update at pkg2/write.jl:26\r\n in anonymous at no file:147\r\n in cd at file.jl:25\r\n in cd at pkg2/dir.jl:28\r\n in resolve at pkg2.jl:87\r\n in anonymous at no file:84\r\n in cd at file.jl:25\r\n in cd at pkg2/dir.jl:28\r\n in update at pkg2.jl:48\r\n```'
3660,'JeffBezanson','intermittent test failure involving broadcast\n```\r\n...\r\n\tFrom worker 5:\t     * bitarray\r\n\tFrom worker 8:\t     * random\r\n\tFrom worker 6:\t     * math\r\n\tFrom worker 8:\t     * functional\r\n\tFrom worker 2:\t     * bigint\r\n\tFrom worker 8:\t     * sorting\r\n\tFrom worker 7:\t     * statistics\r\n\tFrom worker 2:\t     * spawn\r\n\tFrom worker 2:\t       [stdio passthrough ok]\r\n\tFrom worker 3:\t     * parallel\r\n\tFrom worker 7:\t     * priorityqueue\r\n\tFrom worker 2:\t     * arpack\r\nexception on 5: ERROR: \r\n in append_any at base.jl:110\r\n in code_inner_loop at broadcast.jl:113\r\n in ##/_inner!#194 at broadcast.jl:139\r\n in ##broadcast_T_/#192 at broadcast.jl:178\r\n in ./ at broadcast.jl:275\r\n in check_bitop at bitarray.jl:13\r\n in runtests at /scratch/r/rbond/nolta/julia/test/testdefs.jl:5\r\n in anonymous at multi.jl:767\r\n in run_work_thunk at multi.jl:501\r\n in anonymous at task.jl:767ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print at string.jl:3\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:79\r\n in error_show at repl.jl:53\r\n in error_show at repl.jl:61\r\n in anonymous at no file:74\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:72\r\n in run_work_thunk at multi.jl:504\r\n in anonymous at task.jl:767ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n ...\r\n```'
3657,'JeffBezanson','dangerous type inference failure\nStart by defining a function for which it is impossible to generate exact information:\r\n```julia\r\njulia> function g()\r\n        g(i,2)\r\n       end\r\n# methods for generic function g\r\ng() at none:2\r\n\r\njulia> g(::Any,::Int) = 2\r\n# methods for generic function g\r\ng() at none:2\r\ng(::Any,::Int64) at none:1\r\n```\r\n\r\nLooking at the finfer result, we see julia has assumed too much, even though it will call jl_apply_generic and does not know the run-time return type:\r\n```julia\r\njulia> finfer(g,())\r\n:($(Expr(:lambda, {}, {{},{},{}}, quote  # none, line 2:\r\n        return g(i,2)::Int64\r\n    end)))\r\n```\r\n\r\nAnd in fact, we can break it quite easily:\r\n```\r\njulia> g(::Int,::Int) = 3.0\r\n# methods for generic function g\r\ng() at none:2\r\ng(::Int64,::Int64) at none:1\r\ng(::Any,::Int64) at none:1\r\n\r\njulia> finfer(g,())\r\n:($(Expr(:lambda, {}, {{},{},{}}, quote  # none, line 2:\r\n        return g(i,2)::Int64\r\n    end)))\r\n\r\njulia> i=1\r\n1\r\n\r\njulia> g()\r\n4613937818241073152\r\n\r\njulia> reinterpret(Float64, ans)\r\n3.0\r\n```'
3653,'JeffBezanson',"Error in typeseq at reflection.jl:42\nI recently got this error:\r\n\r\n```\r\nERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in multitaper_sfc at /home/simon/Documents/CapLim/phase_locking.jl:293SYSTEM: show(lasterr) caused an error\r\nERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:74\r\n in with_output_color at error.jl:53\r\n in display_error at client.jl:72SYSTEM: show(lasterr) caused an error\r\nWARNING: it is likely that something important is broken, and Julia will not be able to continue normally\r\n```\r\n\r\nWhile I can't provide a test case, the inferred line at `phase_locking.jl:293` is:\r\n\r\n```\r\nsetindex!(coherence::Dict{Uint64,Array{Array{Float64,3},1}},ucoherence::Array{Array{Float64,3},1},id)::Dict{Uint64,Array{Array{Float64,3},1}}\r\n```\r\n\r\nWhen I modified my code so that the type of `id` can be inferred (it's a `Uint64`), the error disappeared and everything seems to be running normally. This is the same place as some of the errors in #3593, although I don't know if it's related."
3642,'JeffBezanson','unable to build sysimg\nAfter a `make cleanall`, I get the following error:\r\n```\r\n    JULIA usr/lib/julia/sys.ji\r\nc.jl\r\nAssertion failed: (jbp == NULL), function emit_var, file codegen.cpp, line 1811.\r\n/bin/sh: line 1:  7431 Illegal instruction: 4  /Users/jameson/Documents/no-backup/julia/usr/bin/julia-release-readline -bf sysimg.jl\r\n*** This error is usually fixed by running \'make clean\'. If the error persists, try \'make cleanall\'. ***\r\n```\r\n```\r\n(lldb) bt\r\n* thread #1: tid = 0x1c03, 0x00007fff8c479212 libsystem_kernel.dylib`__pthread_kill + 10, stop reason = signal SIGABRT\r\n    frame #0: 0x00007fff8c479212 libsystem_kernel.dylib`__pthread_kill + 10\r\n    frame #1: 0x00007fff86e3ab54 libsystem_c.dylib`pthread_kill + 90\r\n    frame #2: 0x0000000100a892f6 libjulia-debug.dylib`abort + 22\r\n    frame #3: 0x0000000100a892d1 libjulia-debug.dylib`__assert_rtn + 81\r\n    frame #4: 0x000000010003819f libjulia-debug.dylib`emit_var(sym=0x0000000102b08070, ty=0x0000000103009380, ctx=0x00007fff5fbfe288, isboxed=true) + 799 at codegen.cpp:1811\r\n    frame #5: 0x00000001000359e8 libjulia-debug.dylib`emit_expr(expr=0x0000000102b08070, ctx=0x00007fff5fbfe288, isboxed=true, valuepos=true) + 152 at codegen.cpp:1883\r\n    frame #6: 0x000000010003a181 libjulia-debug.dylib`emit_assignment(l=0x0000000101407650, r=0x0000000102b08070, ctx=0x00007fff5fbfe288) + 241 at codegen.cpp:1833\r\n    frame #7: 0x000000010003649a libjulia-debug.dylib`emit_expr(expr=0x0000000102010000, ctx=0x00007fff5fbfe288, isboxed=false, valuepos=false) + 2890 at codegen.cpp:2003\r\n    frame #8: 0x000000010003277b libjulia-debug.dylib`emit_function(lam=0x0000000103060f50, cstyle=false) + 12923 at codegen.cpp:2903\r\n    frame #9: 0x00000001000279a0 libjulia-debug.dylib`to_function(li=0x0000000103060f50, cstyle=false) + 336 at codegen.cpp:214\r\n    frame #10: 0x0000000100027813 libjulia-debug.dylib`jl_compile(f=0x0000000102010040) + 83 at codegen.cpp:284\r\n    frame #11: 0x000000010002357b libjulia-debug.dylib`jl_trampoline(F=0x0000000102010040, args=0x0000000000000000, nargs=0) + 443 at builtins.c:844\r\n    frame #12: 0x000000010009daec libjulia-debug.dylib`jl_apply(f=0x0000000102010040, args=0x0000000000000000, nargs=0) + 76 at julia.h:1018\r\n    frame #13: 0x000000010009d15f libjulia-debug.dylib`jl_toplevel_eval_flex(e=0x0000000103071f20, fast=1) + 2111 at toplevel.c:391\r\n    frame #14: 0x000000010009dcf9 libjulia-debug.dylib`jl_parse_eval_all(fname=0x000000010185b730) + 377 at toplevel.c:427\r\n    frame #15: 0x000000010009dee9 libjulia-debug.dylib`jl_load(fname=0x000000010185b730) + 217 at toplevel.c:459\r\n    frame #16: 0x000000010009df8b libjulia-debug.dylib`jl_load_(str=0x0000000101854cb0) + 43 at toplevel.c:469\r\n    frame #17: 0x0000000101700b76\r\n    frame #18: 0x00000001000154fc libjulia-debug.dylib`jl_apply(f=0x000000010186aa40, args=0x00007fff5fbfeef8, nargs=1) + 76 at julia.h:1018\r\n    frame #19: 0x00000001000173c4 libjulia-debug.dylib`jl_apply_generic(F=0x0000000102004b00, args=0x00007fff5fbfeef8, nargs=1) + 532 at gf.c:1401\r\n    frame #20: 0x000000010008949c libjulia-debug.dylib`jl_apply(f=0x0000000102004b00, args=0x00007fff5fbfeef8, nargs=1) + 76 at julia.h:1018\r\n    frame #21: 0x000000010008935e libjulia-debug.dylib`do_call(f=0x0000000102004b00, args=0x000000010387ee38, nargs=1, locals=0x0000000000000000, nl=0) + 318 at interpreter.c:56\r\n    frame #22: 0x000000010008739f libjulia-debug.dylib`eval(e=0x000000010306f600, locals=0x0000000000000000, nl=0) + 1871 at interpreter.c:160\r\n    frame #23: 0x0000000100086c23 libjulia-debug.dylib`jl_interpret_toplevel_expr(e=0x000000010306f600) + 51 at interpreter.c:19\r\n    frame #24: 0x000000010009d0b0 libjulia-debug.dylib`jl_toplevel_eval_flex(e=0x00000001020061c0, fast=1) + 1936 at toplevel.c:380\r\n    frame #25: 0x000000010009c845 libjulia-debug.dylib`jl_eval_module_expr(ex=0x0000000102004d80) + 789 at toplevel.c:92\r\n    frame #26: 0x000000010009c9d7 libjulia-debug.dylib`jl_toplevel_eval_flex(e=0x0000000102004d80, fast=1) + 183 at toplevel.c:290\r\n    frame #27: 0x000000010009dcf9 libjulia-debug.dylib`jl_parse_eval_all(fname=0x00007fff5fbffc69) + 377 at toplevel.c:427\r\n    frame #28: 0x000000010009dee9 libjulia-debug.dylib`jl_load(fname=0x00007fff5fbffc69) + 217 at toplevel.c:459\r\n    frame #29: 0x0000000100002526 julia-debug-basic`exec_program + 470 at repl.c:181\r\n    frame #30: 0x0000000100002159 julia-debug-basic`true_main(argc=1, argv=0x00007fff5fbffb30) + 345 at repl.c:250\r\n    frame #31: 0x0000000100091f5f libjulia-debug.dylib`julia_trampoline(argc=1, argv=0x00007fff5fbffb30, pmain=0x0000000100002000) + 207 at init.c:647\r\n    frame #32: 0x000000010000272b julia-debug-basic`main(argc=1, argv=0x00007fff5fbffb30) + 171 at repl.c:303\r\n    frame #33: 0x00000001000016d4 julia-debug-basic`start + 52`\r\n```\r\nThis occurs while generating the anonymous function for assigning to sizeof_off_t while emitting the variable "#s34".\r\n\r\nLast git pull updated f7f6cf1..ec3311a'
3609,'JeffBezanson','erroneous ambiguous method definition warning\n```julia\r\njulia> abstract XX\r\njulia> Base.show{T<:XX}(io::IO, ::Type{T}) = 1\r\nWarning: New definition \r\n    show(IO,Type{T<:XX}) at none:1\r\nis ambiguous with \r\n    show(IO,UnionType) at show.jl:49.\r\nMake sure \r\n    show(IO,Type{T<:XX})\r\nis defined first.\r\nWarning: New definition \r\n    show(IO,Type{T<:XX}) at none:1\r\nis ambiguous with \r\n    show(IO,TypeConstructor) at show.jl:58.\r\nMake sure \r\n    show(IO,Type{T<:XX})\r\nis defined first.\r\n```'
3601,'JeffBezanson',"no error for instantiating parametric typealias with invalid parameter\nIs this a issue, or isn't possible define a range of types for a parametric typealias ?\r\n\r\n```\r\njulia> using BioSeq\r\n\r\njulia> typealias Sequence{T<:BioUnit} Array{T,1}\r\nArray{T<:BioUnit,1}\r\n\r\njulia> typealias Alignment{T<:BioUnit} Array{T,1}\r\nArray{T<:BioUnit,1}\r\n\r\njulia> Sequence{Float64}\r\nArray{Float64,1}\r\n\r\njulia> Float64 <: BioUnit\r\nfalse\r\n```\r\n\r\n"
3593,'JeffBezanson','one time failure in inference.jl\nI\'m not sure if this means anything, but I got this infinite stack trace while testing on win32. I\'m opening this in case it means anything to Jeff, otherwise it can probably just be closed as "can\'t reproduce"\r\n```\r\n     * linalg\r\nexception on 1: ERROR: \r\n in abstract_call_gf at inference.jl:564\r\n in abstract_call at inference.jl:642\r\n in abstract_eval_call at inference.jl:719\r\n in abstract_eval at inference.jl:752\r\n in abstract_interpret at inference.jl:892\r\n in typeinf at inference.jl:1193\r\n in abstract_call_gf at inference.jl:564\r\n in abstract_call at inference.jl:642 (repeats 2 times)\r\n in abstract_eval_call at inference.jl:719\r\n in abstract_eval at inference.jl:752\r\n in abstract_eval_arg at inference.jl:688\r\n in typeinf at inference.jl:1241\r\n in abstract_call_gf at inference.jl:564\r\n in abstract_call at inference.jl:642 (repeats 2 times)\r\n in abstract_eval_call at inference.jl:719\r\n in abstract_eval at inference.jl:752\r\n in abstract_eval_arg at inference.jl:688\r\n in typeinf at inference.jl:1241\r\n in abstract_call_gf at inference.jl:564\r\n in abstract_call at inference.jl:642\r\n in abstract_eval_call at inference.jl:719\r\n in abstract_eval at inference.jl:752\r\n in abstract_eval_arg at inference.jl:688\r\n in abstract_eval_call at inference.jl:697\r\n in abstract_eval at inference.jl:752\r\n in abstract_eval_arg at inference.jl:688\r\n in typeinf at inference.jl:1241\r\n in typeinf_ext at inference.jl:1025\r\n in anonymous at no file:107\r\n in runtests at Z:\\home\\jameson\\julia-win32\\test\\testdefs.jl:5\r\n in anonymous at multi.jl:539\r\n in remotecall_fetch at multi.jl:573\r\n in remotecall_fetch at multi.jl:585\r\n in anonymous at multi.jl:1260\r\n in run_work_thunk at multi.jl:503\r\n in anonymous at task.jl:59ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print at string.jl:3\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:79\r\n in error_show at repl.jl:53\r\n in error_show at repl.jl:61\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in run_work_thunk at multi.jl:506\r\n in anonymous at task.jl:59ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n in typeseq at reflection.jl:42\r\n in typeinf at inference.jl:1050\r\n in typeinf_ext at inference.jl:1025\r\n in show_delim_array at show.jl:125\r\n in print_to_string at string.jl:23\r\n in error_show at repl.jl:43\r\n in error_show at repl.jl:53\r\n in anonymous at no file:51\r\n in with_output_color at error.jl:51\r\n in display_error at client.jl:49\r\n in event_loop at multi.jl:1410\r\n in anonymous at client.jl:281ERROR: \r\n...\r\n```'
3585,'staticfloat','Performance and load tests for codespeed\nNow that we have codespeed integration for performance testing coming into place, we should start running a larger number of codes.\r\n\r\nTo start with, we should make all the stuff in `perf`, `perf2`, and `load` run uniformly and produce consistent output. Over time, we can even start including some packages as part of the performance measurement.\r\n\r\n@staticfloat What do you think?'
3582,'JeffBezanson',"allow default argument syntax with missing argument name\nNot sure if this is a 'yet to implement' or if there's actually some reason it wouldn't work (perhaps because DataTypes are singletons?)\r\n```julia\r\njulia> test{C <: FloatingPoint}(x,::Type{C}=Float32) = x*3\r\nERROR: syntax: malformed expression\r\n```"
3567,'Keno','unreferenced socket connections are not being closed on gc()\n```\r\n  | | |_| | | | (_| |  |  Version 0.2.0-2259.r688b0bbb\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 688b0bbbbd 2013-06-28 10:15:18\r\n|__/                   |  x86_64-linux-gnu\r\n\r\njulia> open_any_tcp_port(8000)\r\n(0x1f40,TcpServer(listening))\r\n\r\njulia> connect("localhost", 8000)\r\nTcpSocket(connected,0 bytes waiting)\r\n\r\njulia> gc()\r\n\r\n```\r\n\r\nnetstat still shows an existing connection to port 8000:\r\n\r\n```\r\namitm@amitm-laptop:~/Work/julia/julia$ netstat -n | grep EST | grep 8000\r\ntcp        0      0 127.0.0.1:60550         127.0.0.1:8000          ESTABLISHED\r\ntcp        0      0 127.0.0.1:8000          127.0.0.1:60550         ESTABLISHED\r\n```\r\n\r\n\r\n\r\n\r\n'
3548,'Keno','spawn.jl:27 test fails\nI\'m seeing the following on a CentOS release 6.4 (Final) machine, x86_64 (2x AMD Opteron 6128 = 16 cores), with checkout b0a45c4a1a0b5535c6dc6ac5e655ae8b5e6dfef3.\r\n\r\n```\r\n[~/optstuff/julia/test] >>= ../julia-b0a45c4a1a/bin/julia runtests.jl spawn\r\n     * spawn\r\n       [stdio passthrough ok]\r\nyes: standard output: Connection reset by peer\r\nyes: write error\r\nexception on 1: ERROR: test error during quote \r\n    run(|>(|>(@cmd "yes",@cmd "head"),SpawnNullStream()))\r\n    true\r\nend\r\nfailed process: Process(`yes`, ProcessExited(1)) [1]\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:426\r\n in pipeline_error at process.jl:439\r\n in run at process.jl:409\r\n in anonymous at test.jl:63\r\n in do_test at test.jl:36\r\n in runtests at /home/lance/optstuff/julia/test/testdefs.jl:5\r\n in anonymous at multi.jl:538\r\n in run_work_thunk at multi.jl:502\r\n in anonymous at task.jl:59\r\nat spawn.jl:27\r\n\r\nERROR: test error during quote \r\n    run(|>(|>(@cmd "yes",@cmd "head"),SpawnNullStream()))\r\n    true\r\nend\r\nfailed process: Process(`yes`, ProcessExited(1)) [1]\r\n in error at error.jl:22\r\n in pipeline_error at process.jl:426\r\n in pipeline_error at process.jl:439\r\n in run at process.jl:409\r\n in anonymous at test.jl:63\r\n in do_test at test.jl:36\r\n in runtests at /home/lance/optstuff/julia/test/testdefs.jl:5\r\n in anonymous at multi.jl:538\r\n in run_work_thunk at multi.jl:502\r\n in anonymous at task.jl:59\r\nat spawn.jl:27\r\nat /home/lance/optstuff/julia/test/runtests.jl:18\r\n```'
3516,'JeffBezanson',"update manual for changes in type system\n(EDITED) The [Types](https://julia.readthedocs.org/en/latest/manual/types/#operations-on-types) page in the manual still refers to `AbstractKind`, `BitsKind`, etc. which were removed in the recent changes to the type system, see @ViralBShah's comments below.\r\n"
3503,'JeffBezanson','RFC: Improved implementation of SubArray \nBased on the discussion in #3496 '
3489,'JeffBezanson','Type equality\n@JeffBezanson Is the following expected?\r\n```\r\njulia> typeof(Array(Range1,1)) == Array{Range1,1}\r\nfalse\r\n\r\njulia> typeof(Array(Range1,1))\r\nArray{Range1{T<:Real},1}\r\n\r\njulia> Array{Range1,1}\r\nArray{Range1{T<:Real},1}\r\n```\r\n\r\nIf so, and there is a difference, maybe they can print differently?'
3487,'JeffBezanson',"`new` not defined test error\nWe seem to be getting more intermittent test failures, both on Travis and on my OSX box.  The failure I'm speaking of is [shown here](https://travis-ci.org/JuliaLang/julia/jobs/8299709), but it is really strange that a function definition would phase into and out of existence. My guess is this is related to a parallel problem, which is why I've tagged it as parallel."
3481,'ViralBShah','Introduce addprocs_scyld and support TCP and UDP in init_stdio_handle()\nLeveraging a more natural I/O pattern with scyld required TCP and UDP support in init_stdio_handle() (which was trivial enough to add, though enforcing the read/write restrictions might require a change in libuv). The rest of the code is self-contained and self-explanatory. Compiled, tested, and run (on a cluster no less =).'
3459,'carlobaldassi','rsearch returns incorrect range in utf8 strings\n````\r\n  | | |_| | | | (_| |  |  Version 0.2.0-2106.r470db16b\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 470db16ba6 2013-06-20 00:55:52\r\n|__/                   |  x86_64-apple-darwin12.4.0\r\n\r\njulia> str1 = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |"\r\n"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |"\r\n\r\njulia> rsearch(str1, " ")\r\n28:30\r\n\r\njulia> \r\n\r\njulia> str2 = "| < δ ⇒ |"\r\n"| < δ ⇒ |"\r\n\r\njulia> rsearch(str2, " ")\r\nERROR: invalid UTF-8 character index\r\n in getindex at utf8.jl:44\r\n in next at string.jl:462\r\n in _rsearch at string.jl:232\r\n in rsearch at string.jl:255\r\n\r\njulia> rsearch(str2, "|")\r\n1:1\r\n````\r\n\r\nmaybe related to #3455 '
3456,'JeffBezanson','parsing of ... with ranges\nThis is potentially deceptive:\r\n\r\n```\r\njulia> f(x...) = dump(x)\r\n\r\njulia> f(1:2)\r\n(Range1{Int64},) (1:2,)\r\n\r\njulia> f(1:2...)\r\n(Range1{Int64},) (1:2,)\r\n\r\njulia> f((1:2)...)\r\n(Int64,Int64) (1,2)\r\n```\r\n\r\nIs there a reason why the ``...`` is ignored in the parsing of ``1:2...``?'
3455,'carlobaldassi','rsearch with utf8 data loops indefinitely\n````\r\n  | | |_| | | | (_| |  |  Version 0.2.0-2106.r470db16b\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 470db16ba6 2013-06-20 00:55:52\r\n|__/                   |  x86_64-apple-darwin12.4.0\r\n\r\njulia> str1 = "∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"\r\n"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε"\r\n\r\njulia> rsearch(str1, "∃")\r\n^CERROR: interrupt\r\n in getindex at utf8.jl:55\r\n in rsearch at utf8.jl:99\r\n in _rsearch at string.jl:230\r\n in rsearch at string.jl:255\r\n\r\njulia> rsearch(str1, "ε")\r\n^CERROR: interrupt\r\n in getindex at utf8.jl:58\r\n in rsearch at utf8.jl:99\r\n in _rsearch at string.jl:230\r\n in rsearch at string.jl:255\r\n````\r\n'
3446,'JeffBezanson','type error in declaration thrown too early\nobserved on win32 and linux32 build when doing make testall\r\n\r\n```julia\r\n     * collections\r\nexception on 1: ERROR: type: Complex: in T, expected Real, got Type{Dict{Symbol,Array{Int32,1}}}\r\n in typeinf at inference.jl:1096\r\n in abstract_call_gf at inference.jl:557\r\n in abstract_call at inference.jl:635\r\n in abstract_eval_call at inference.jl:712\r\n in abstract_eval at inference.jl:745\r\n in abstract_eval_arg at inference.jl:681\r\n in abstract_eval_call at inference.jl:690\r\n in abstract_eval at inference.jl:745\r\n in abstract_eval_arg at inference.jl:681\r\n in typeinf at inference.jl:1234\r\n in type_annotate at inference.jl:1431\r\n in typeinf at inference.jl:1289\r\n in typeinf_ext at inference.jl:1018\r\n in runtests at Z:\\home\\jameson\\julia-win32\\test\\testdefs.jl:5\r\n in anonymous at multi.jl:536\r\n in run_work_thunk at multi.jl:500\r\n in anonymous at task.jl:59\r\nat collections.jl:71\r\n```'
3445,'JeffBezanson','Macro expansion in type declaration\nThe following should be some kind of error (or should work):\r\n```julia\r\ntype Test\r\n       @windows_only a::Int\r\nend\r\n```\r\nRight now it just fails to generate the constructor.'
3444,'JeffBezanson','bad intrinsics usage can cause llvm assertion failure\nCan this bad code be prevented from crashing?\r\n\r\n```julia\r\njulia> f() = a(Intrinsics.jl_alloca(Intrinsics.unbox(Int32,int32(0))))\r\n# methods for generic function f\r\nf() at none:1\r\n\r\njulia> f()\r\nAssertion failed: (castIsValid(op, S, Ty) && "Invalid cast!"), function Create, file /Users/jameson/Documents/no-backup/julia/deps/llvm-3.2/lib/VMCore/Instructions.cpp, line 2286.\r\nIllegal instruction: 4\r\n```'
3437,'JeffBezanson','Required patch in multi.jl causes a seg fault \nThis required patch : \r\n\r\n```\r\n--- /tmp/ZAzh0S_multi.jl\r\n+++ /home/amitm/Work/julia/julia/base/multi.jl\r\n@@ -841,8 +841,7 @@\r\n                 #TODO : Notify all RemoteRefs linked to this Worker who just died....\r\n                 # How?\r\n                 \r\n-                # FIXME: Without the below throw, the main process results in a segmentation fault.\r\n-                throw("DisconnectedException")\r\n+                return nothing\r\n             else\r\n                 # TODO : Treat any exception as death of node / major screw-up and cleanup?\r\n                 rethrow(e)\r\n```\r\n\r\ncauses a seg fault on:\r\n\r\n```\r\naddprocs(5)\r\nrmprocs(2,5,6)\r\n```\r\n\r\n\r\n\r\nvalgrind output:\r\n```\r\namitm@amitm-laptop:~/Work/julia/julia$ valgrind julia\r\n==9045== Memcheck, a memory error detector\r\n==9045== Copyright (C) 2002-2012, and GNU GPL\'d, by Julian Seward et al.\r\n==9045== Using Valgrind-3.8.1 and LibVEX; rerun with -h for copyright info\r\n==9045== Command: julia\r\n==9045== \r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.2.0-2060.r57bcb34b.dirty\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 57bcb34bb3 2013-06-18 09:31:31*\r\n|__/                   |  x86_64-linux-gnu\r\n\r\njulia> addprocs(5)\r\n==9084== Warning: noted but unhandled ioctl 0x5450 with no size/direction hints\r\n==9084==    This could cause spurious value errors to appear.\r\n==9084==    See README_MISSING_SYSCALL_OR_IOCTL for guidance on writing a proper wrapper.\r\n==9085== Warning: noted but unhandled ioctl 0x5450 with no size/direction hints\r\n==9085==    This could cause spurious value errors to appear.\r\n==9085==    See README_MISSING_SYSCALL_OR_IOCTL for guidance on writing a proper wrapper.\r\n==9086== Warning: noted but unhandled ioctl 0x5450 with no size/direction hints\r\n==9086==    This could cause spurious value errors to appear.\r\n==9086==    See README_MISSING_SYSCALL_OR_IOCTL for guidance on writing a proper wrapper.\r\n==9087== Warning: noted but unhandled ioctl 0x5450 with no size/direction hints\r\n==9087==    This could cause spurious value errors to appear.\r\n==9087==    See README_MISSING_SYSCALL_OR_IOCTL for guidance on writing a proper wrapper.\r\n==9088== Warning: noted but unhandled ioctl 0x5450 with no size/direction hints\r\n==9088==    This could cause spurious value errors to appear.\r\n==9088==    See README_MISSING_SYSCALL_OR_IOCTL for guidance on writing a proper wrapper.\r\n:ok\r\n\r\njulia> rmprocs(2,5,6)\r\n\r\njulia> ==9045== Syscall param msync(start) points to uninitialised byte(s)\r\n==9045==    at 0x506B3DD: ??? (syscall-template.S:81)\r\n==9045==    by 0x5B62BE2: msync_validate (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B62D0F: validate_mem (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B62E4C: access_mem (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B60B18: dwarf_get (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B60DD2: _ULx86_64_access_reg (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B6069E: _ULx86_64_get_reg (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B65881: apply_reg_state (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B65F70: _ULx86_64_dwarf_find_save_locs (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B6231F: _ULx86_64_dwarf_step (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5B60F89: _ULx86_64_step (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5353068: rec_backtrace (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==  Address 0x7fefff000 is on thread 1\'s stack\r\n==9045== \r\nWorker 2 terminated.\r\nWorker 6 terminated.\r\n==9045== Invalid read of size 4\r\n==9045==    at 0x53811D8: uv__io_active (core.c:728)\r\n==9045==    by 0x538C5CD: uv_read_stop (stream.c:1346)\r\n==9045==    by 0x409B946: ???\r\n==9045==    by 0x531AD86: jl_apply_generic (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x409708E: ???\r\n==9045==    by 0x5352EB6: start_task (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5352F8F: start_task (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5352FE7: jl_switch_stack (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5351D48: julia_trampoline (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x403A9C: main (in /home/amitm/Work/julia/julia/usr/bin/julia-release-readline)\r\n==9045==  Address 0x98 is not stack\'d, malloc\'d or (recently) free\'d\r\n==9045== \r\n==9045== \r\n==9045== Process terminating with default action of signal 11 (SIGSEGV)\r\n==9045==  Access not within mapped region at address 0x28\r\n==9045==    at 0x53811D8: uv__io_active (core.c:728)\r\n==9045==    by 0x538C5CD: uv_read_stop (stream.c:1346)\r\n==9045==    by 0x409B946: ???\r\n==9045==    by 0x531AD86: jl_apply_generic (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x409708E: ???\r\n==9045==    by 0x5352EB6: start_task (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5352F8F: start_task (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5352FE7: jl_switch_stack (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x5351D48: julia_trampoline (in /home/amitm/Work/julia/julia/usr/lib/libjulia-release.so)\r\n==9045==    by 0x403A9C: main (in /home/amitm/Work/julia/julia/usr/bin/julia-release-readline)\r\n==9045==  If you believe this happened as a result of a stack\r\n==9045==  overflow in your program\'s main thread (unlikely but\r\n==9045==  possible), you can try to increase the size of the\r\n==9045==  main thread stack using the --main-stacksize= flag.\r\n==9045==  The main thread stack size used in this run was 8388608.\r\n==9045== \r\n==9045== HEAP SUMMARY:\r\n==9045==     in use at exit: 52,029,910 bytes in 101,328 blocks\r\n==9045==   total heap usage: 2,166,045 allocs, 2,064,717 frees, 716,242,485 bytes allocated\r\n==9045== \r\n==9045== LEAK SUMMARY:\r\n==9045==    definitely lost: 10,432 bytes in 21 blocks\r\n==9045==    indirectly lost: 4 bytes in 4 blocks\r\n==9045==      possibly lost: 1,572,080 bytes in 12,402 blocks\r\n==9045==    still reachable: 50,447,394 bytes in 88,901 blocks\r\n==9045==         suppressed: 0 bytes in 0 blocks\r\n==9045== Rerun with --leak-check=full to see details of leaked memory\r\n==9045== \r\n==9045== For counts of detected and suppressed errors, rerun with: -v\r\n==9045== Use --track-origins=yes to see where uninitialised values come from\r\n==9045== ERROR SUMMARY: 3 errors from 2 contexts (suppressed: 2 from 2)\r\nKilled\r\n```\r\n\r\n'
3436,'JeffBezanson','Internal function to cleanup RemoteRefs on worker exit required\nNeed a function \r\n\r\n```release_pidrefs (pid::Int)``` \r\n\r\nThis will \r\n- notify all local RemoteRefs referring to ```pid``` - with an exception "ProcExited"\r\n- release any references we are holding for ```pid``` to fetch/take from the current process.\r\n\r\nRequired in the context of ```rmprocs``` and the upcoming ```detach``` call.\r\n\r\nAlso, currently async calls just hang upon a remote process exit. With the above notification in place, they will return immediately with an appropriate error.\r\n\r\ncc @JeffBezanson \r\n'
3432,'JeffBezanson','f{T}(T::T) function definition\n```julia\r\njulia> function f{T}(T::T)\r\n        println(T)\r\n       end\r\n# methods for generic function f\r\nf{T}(T) at none:2\r\n\r\njulia> f(1)\r\n1\r\n```'
3418,'Keno',"Failing to build with llvm3.3\nUsing the system llvm package is failing since it got updated to 3.3\r\n\r\nsrc/codegen.cpp: julia won't find some of the headers as they got moved into a subfolder (llvm/DerivedTypes.h, LLVMContext.h, Module.h, Intrinsics.h, Attributes.h, IRBuilder.h moved into llvm/IR/)\r\n\r\nBut fixing this doesn't solve it\r\nHere is the log for the failure http://pastie.org/8050095\r\n\r\nEdit: Forgot the system info\r\n\r\nDistro: Arch Linux\r\n\r\n"
3416,'Keno','Stack corruption warnings on mac\nI am seeing these warnings on the mac with the latest build, which are a bit scary:\r\n\r\n````\r\n    JULIA test/all\r\n\tFrom worker 4:\t     * numbers\r\n\tFrom worker 3:\t     * keywordargs\r\n\tFrom worker 5:\t     * strings\r\n\tFrom worker 2:\t     * core\r\n\tFrom worker 3:\t     * unicode\r\n\tFrom worker 3:\t     * collections\r\n\tFrom worker 2:\t     * hashing\r\n\tFrom worker 5:\t     * remote\r\n\tFrom worker 5:\t     * iostring\r\n\tFrom worker 5:\t     * arrayops\r\n\tFrom worker 2:\t     * linalg\r\n\tFrom worker 3:\t     * blas\r\n\tFrom worker 3:\t     * fft\r\n\tFrom worker 5:\t     * dsp\r\n\tFrom worker 3:\t     * sparse\r\n\tFrom worker 3:\t     * bitarray\r\n\tFrom worker 5:\t     * random\r\n\tFrom worker 5:\t     * math\r\n\tFrom worker 4:\t     * functional\r\n\tFrom worker 4:\t     * bigint\r\n\tFrom worker 4:\t     * sorting\r\n\tFrom worker 5:\t     * statistics\r\n\tFrom worker 5:\t     * spawn\r\n\tFrom worker 5:\t       [stdio passthrough ok]\r\n\tFrom worker 5:\t     * parallel\r\n\tFrom worker 4:\t     * priorityqueue\r\n\tFrom worker 4:\t     * arpack\r\n\tFrom worker 4:\t     * file\r\n\tFrom worker 3:\t     * perf\r\n\tFrom worker 4:\t     * suitesparse\r\n\tFrom worker 4:\t     * version\r\n\tFrom worker 4:\t     * resolve\r\n\tFrom worker 3:\t     * pollfd\r\n\tFrom worker 3:\t     * mpfr\r\n\tFrom worker 2:\t     * broadcast\r\n\tFrom worker 3:\t     * complex\r\n\tFrom worker 4:\t     * socket\r\n    SUCCESS\r\n\r\nwarning: stack corruption detected\r\njulia-release-basic(35458,0x101a81000) malloc: *** error for object 0xeb: pointer being freed was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\nwarning: stack corruption detected\r\njulia-release-basic(35460,0x101a81000) malloc: *** error for object 0xeb: pointer being freed was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\nwarning: stack corruption detected\r\njulia-release-basic(35459,0x101b81000) malloc: *** error for object 0xeb: pointer being freed was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\nwarning: stack corruption detected\r\njulia-release-basic(35457,0x101a81000) malloc: *** error for object 0xeb: pointer being freed was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\n````'
3400,'JeffBezanson',"Inconsistent type inference for getindex(BitArray{2}, Int64, Range1{Int64})\nThere's a test in DataFrames that's intermittently failing due to something that looks like an inference bug. When I run `finfer(getindex, (BitArray{2}, Int64, Range1{Int64}))` immediately after starting Julia, I sometimes get:\r\n\r\n```julia\r\nfinfer(getindex, (BitArray{2}, Int64, Range1{Int64}))\r\n:($(Expr(:lambda, {:B, :(I::top(apply_type)(Vararg,Union(Real,AbstractVector)))}, {{:X, :Xc}, {{:B, BitArray{2}, 0}, {:I, Any, 2}, {:X, BitArray{2}, 2}, {:Xc, Array{Uint64,1}, 2}}, {{:getindex_cache, Any, 7}}}, quote  # bitarray.jl, line 471:\r\n        I = top(tuple)(indices(tupleref(I::(Int64,Range1{Int64}),1)::Union(Range1{Int64},Int64)),indices(tupleref(I::(Int64,Range1{Int64}),2)::Union(Range1{Int64},Int64)))::(Any,Any) # line 472:\r\n        X = BitArray(index_shape(top(tupleref)(I::(Any,Any),1),top(tupleref)(I::(Any,Any),2))::Union((),(Any,),(Any,Any)))::BitArray{2} # line 473:\r\n        Xc = top(getfield)(X::BitArray{2},:chunks)::Array{Uint64,1} # line 475:\r\n        unless is(getindex_cache,nothing)::Bool goto 0 # line 476:\r\n        getindex_cache = $(Dict{Any,Any})()::Dict{Any,Any}\r\n        0:  # line 478:\r\n        gen_cartesian_map(getindex_cache,$(AST(:($(Expr(:lambda, {:(ivars::Any)}, {{:#s143, :#s137}, {{:ivars, Any, 0}, {:#s143, Array{Any,1}, 2}, {:#s137, Array{Any,1}, 2}}, {}}, quote  # bitarray.jl, line 478:\r\n        #s143 = top(ccall)(:jl_alloc_array_1d,$(Array{Any,1}),top(tuple)(Any,Int)::(Type{Any},Type{Int64}),$(Array{Any,1}),0,1,0)::Array{Any,1}\r\n        top(arrayset)(#s143::Array{Any,1},:B,1)::Array{Any,1}\r\n        #s137 = #s143::Array{Any,1}\r\n        return top(Expr)(:block,top(Expr)(:line,480,:bitarray.jl)::Expr,top(Expr)(:call,:setindex_unchecked,:Xc,top(splicedexpr)(:ref,top(append_any)(#s137::Array{Any,1},ivars)::Array{Any,1})::Expr,:ind)::Expr,top(Expr)(:line,481)::Expr,top(Expr)(:+=,:ind,1)::Expr)::Expr\r\n    end))))),I::(Any,Any),top(tuple)(:B,:Xc,:ind)::(Symbol,Symbol,Symbol),B::BitArray{2},Xc::Array{Uint64,1},1) # line 483:\r\n        return X::BitArray{2}\r\n    end)))\r\n```\r\n\r\nwhich looks okay. Other times I get:\r\n\r\n```julia\r\nfinfer(getindex, (BitArray{2}, Int64, Range1{Int64}))\r\n:($(Expr(:lambda, {:B, :(I::top(apply_type)(Vararg,Union(Real,AbstractVector)))}, {{:X, :Xc}, {{:B, BitArray{2}, 0}, {:I, Any, 2}, {:X, BitArray{1}, 2}, {:Xc, Array{Uint64,1}, 2}}, {{:getindex_cache, Any, 7}}}, quote  # bitarray.jl, line 471:\r\n        I = top(tuple)(indices(tupleref(I::(Int64,Range1{Int64}),1)::Union(Int64,Range1{Int64})),indices(tupleref(I::(Int64,Range1{Int64}),2)::Union(Int64,Range1{Int64})))::(Any,Any) # line 472:\r\n        X = BitArray(index_shape(top(tupleref)(I::(Any,Any),1),top(tupleref)(I::(Any,Any),2))::Union((),(Any,Any),(Any,)))::BitArray{1} # line 473:\r\n        Xc = top(getfield)(X::BitArray{1},:chunks)::Array{Uint64,1} # line 475:\r\n        unless is(getindex_cache,nothing)::Bool goto 0 # line 476:\r\n        getindex_cache = $(Dict{Any,Any})()::Dict{Any,Any}\r\n        0:  # line 478:\r\n        gen_cartesian_map(getindex_cache,$(AST(:($(Expr(:lambda, {:(ivars::Any)}, {{:#s143, :#s137}, {{:ivars, Any, 0}, {:#s143, Array{Any,1}, 2}, {:#s137, Array{Any,1}, 2}}, {}}, quote  # bitarray.jl, line 478:\r\n        #s143 = top(ccall)(:jl_alloc_array_1d,$(Array{Any,1}),top(tuple)(Any,Int)::(Type{Any},Type{Int64}),$(Array{Any,1}),0,1,0)::Array{Any,1}\r\n        top(arrayset)(#s143::Array{Any,1},:B,1)::Array{Any,1}\r\n        #s137 = #s143::Array{Any,1}\r\n        return top(Expr)(:block,top(Expr)(:line,480,:bitarray.jl)::Expr,top(Expr)(:call,:setindex_unchecked,:Xc,top(splicedexpr)(:ref,top(append_any)(#s137::Array{Any,1},ivars)::Array{Any,1})::Expr,:ind)::Expr,top(Expr)(:line,481)::Expr,top(Expr)(:+=,:ind,1)::Expr)::Expr\r\n    end))))),I::(Any,Any),top(tuple)(:B,:Xc,:ind)::(Symbol,Symbol,Symbol),B::BitArray{2},Xc::Array{Uint64,1},1) # line 483:\r\n        return X::BitArray{1}\r\n    end)))\r\n```\r\n\r\nwhich gives the wrong return type.\r\n\r\n"
3398,'Keno','Shorthand for `cd()` in the REPL\nFollowing discussion in https://github.com/JuliaLang/julia/issues/3376, we should decide how best to integrate the ability to change the current working directory of Julia, which cannot be satisfied by shelling out.\r\n\r\n@loladiro suggests parsing in the solution of #3397 to special-case on cd.'
3397,'Keno',"convenient syntax for cd and shelling out in the REPL\nFollowing discussion in https://github.com/JuliaLang/julia/issues/3376, we should decide whether there should be a shorthand syntax for ``run(`foo`)`` in the REPL. Changing directories is similar but cannot be accomplished via shelling out since a child process cannot affect the current process's working directory.\r\n\r\nedit by @StefanKarpinski: I'm moving both the discussion of cd and shelling out here and closing #3398. These are closely related and having two separate discussions isn't helpful."
3390,'Keno','parse_ipv4 on 32-bit\n```julia\r\njulia> Base.parse_ipv4("192.0xFFF")\r\nERROR: IPv4 field too large\r\n in parse_ipv4 at socket.jl:161\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFF")\r\nIPv4(192.15.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFF")\r\nIPv4(192.255.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFFF")\r\nIPv4(207.255.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFFFF")\r\nIPv4(255.255.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFFFFF")\r\nIPv4(255.255.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFFFFFF")\r\nIPv4(255.255.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFFFFFFF")\r\nIPv4(255.255.255.255)\r\n\r\njulia> Base.parse_ipv4("192.0xFFFFFFFFFFFF")\r\nIPv4(255.255.255.255)\r\n```'
3388,'JeffBezanson','type assert line number from macro\nThe typeassert in the macro reports the line number of the previous type assertion in `test()`\r\n```julia\r\njulia> macro badline(x)\r\n        esc( quote x::Symbol end )\r\n       end\r\n\r\njulia> function test(x)\r\n         x::String\r\n         1\r\n         2\r\n         @badline(x)\r\n       end\r\n# methods for generic function test\r\ntest(x) at none:2\r\n\r\njulia> test("")\r\nERROR: type: test: in typeassert, expected Symbol, got ASCIIString\r\n in test at none:2\r\n```'
3381,'vtjnash','Tuple[]\nIs this intended?\r\n\r\n```\r\njulia> Tuple[]\r\nERROR: no method getindex((DataType,),)\r\n```\r\n\r\n``Array(Tuple,0)`` obviously works, but this seems like a gotcha for new users.'
3376,'vtjnash',"decide what to do with ls()\ncalling `ls()` has a significant performance penalty on windows. We already have `readdir()` to read directory listings and `stat` to get file information fast. What is the ideal output for a custom implementation of `ls()`? Is there consensus that it should look identical to `ls -l` or should do people prefer it to show more/less information? Should we simply deprecate the name `readdir()` and move it's functionality into the `ls()` name?"
3373,'JeffBezanson','getaddrinfo doesn\'t task switch right after errors\n@JeffBezanson \r\n```\r\njulia> run(`sleep 100`)\r\n^CERROR: interrupt\r\n\r\nERROR: interrupt\r\n in error at error.jl:19\r\n in wait at stream.jl:277\r\n in wait_success at process.jl:531\r\n in run at process.jl:390\r\n\r\njulia> Base.getaddrinfo("google.com")\r\nERROR: BoundsError()\r\n in indexed_next at tuple.jl:19\r\n in getaddrinfo at socket.jl:226\r\n```'
3361,'JeffBezanson',"auto_unbox: unable to determine argument type\nFirst, it's really hard to make a `Vector` of `(Int,Int)`:\r\n```julia\r\njulia> [(1,2),(3,1)]::Vector{(Int,Int)}\r\nERROR: type: typeassert: expected Array{(Int64,Int64),1}, got Array{(Any...,),1}\r\n\r\njulia> a = [(1,2)]\r\n1-element (Int64,Int64) Array:\r\n (1,2)\r\n\r\njulia> push!(a, (3,1))\r\n2-element (Int64,Int64) Array:\r\n (1,2)\r\n (3,1)\r\n```\r\nbut the really annoying part is this:\r\n```julia\r\njulia> [a]\r\nERROR: auto_unbox: unable to determine argument type\r\n in vcat at array.jl:1179\r\n```\r\n\r\nThis is a minimal example. What I'm actually trying to achieve is a `vcat` of two `Vector{(Int,Int)}` in a comprehension:\r\n```julia\r\n[vcat(x, y) for x=g1, y=g2]\r\n```\r\nwhere `g1` and `g2` are of type `Vector{Vector{(Int,Int)}}`, but the error is the same.\r\n\r\n* * *\r\n#### Config\r\nI reinstalled julia today with Homebrew.\r\n```\r\nVersion 0.2.0-1715.rb1a2644b.dirty\r\nCommit b1a2644b7b 2013-06-11 14:24:46*\r\n```"
3347,'Keno','Redirection with pipe causes segfault\n```\r\njulia> run(`seq 10` > "/tmp/testfile")\r\n\r\njulia> run(`seq 10` | `head -4` > "/tmp/testfile")\r\nERROR: no method convert(Type{AsyncStream},File)\r\n in spawn at process.jl:246\r\n in spawn at process.jl:234\r\n in run at process.jl:389\r\n\r\njulia> \r\n[1]    14822 segmentation fault (core dumped)  julia\r\n```'
3346,'JeffBezanson',"inconsistent parsing of curly surface syntax with keywords/parameters\nThe expression tree generated for keyword arguments changes if parameters are present or not:\r\n\r\n```julia\r\njulia> dump(:(f{a=1}))\r\nExpr \r\n  head: Symbol curly\r\n  args: Array(Any,(2,))\r\n    1: Symbol f\r\n    2: Expr \r\n      head: Symbol =\r\n      args: Array(Any,(2,))\r\n        1: Symbol a\r\n        2: Int64 1\r\n      typ: Any\r\n  typ: Any\r\n\r\njulia> dump(:(f{a=1;b=2}))\r\nExpr \r\n  head: Symbol curly\r\n  args: Array(Any,(3,))\r\n    1: Symbol f\r\n    2: Expr \r\n      head: Symbol keywords\r\n      args: Array(Any,(1,))\r\n        1: Expr \r\n          head: Symbol =\r\n          args: Array(Any,(2,))\r\n          typ: Any\r\n      typ: Any\r\n    3: Expr \r\n      head: Symbol parameters\r\n      args: Array(Any,(1,))\r\n        1: Expr \r\n          head: Symbol =\r\n          args: Array(Any,(2,))\r\n          typ: Any\r\n      typ: Any\r\n  typ: Any\r\n```\r\n\r\nThis makes it more difficult to parse inside macros. I'd actually prefer to not have the keyword arguments separate in this case, because it destroys the order and makes it impossible to parse the difference between ``f{1,y=2}`` and ``f{y=2,1}`` which is important for the syntax of MathProg, where it means something entirely different from keyword arguments."
3327,'Keno','accepting twice on one port does not error, does max out cpu\nTo repro:\r\n1. Open two Julia repls\r\n2. Start top (or the activity manager or something) to watch cpu consumption of the Julia processes\r\n3. In each, run\r\n\r\n    s = listen(8888)\r\n    c = accept(s)\r\n\r\nNotice that one will start chewing through as many cpu cycles as it can get its hands on.'
3317,'JeffBezanson','Example of code where manually inlining degrades performance\nIssue submitted as requested in #3305.\r\n\r\nThe gist with the code is [here](https://gist.github.com/carlobaldassi/5725684)\r\n\r\nExample run:\r\n\r\n```\r\njulia> include("nzipperf.jl")\r\n    \r\njulia> NZipTest.perf()\r\n5x4 DataFrame:\r\n               Function    Elapsed Relative Replications\r\n[1,]           "ziptst"    2.49119  728.793          100\r\n[2,]     "ziptstinline"    2.53212  740.766          100\r\n[3,]          "nziptst"   0.596402  174.476          100\r\n[4,]    "nziptstinline"     1.3054  381.891          100\r\n[5,]        "manualzip" 0.00341824      1.0          100\r\n \r\n \r\njulia> NZipTest.perf3()\r\n5x4 DataFrame:\r\n               Function  Elapsed Relative Replications\r\n[1,]           "ziptst"  4.60007  10.1525          100\r\n[2,]     "ziptstinline"  4.35195  9.60491          100\r\n[3,]          "nziptst"  1.31655  2.90568          100\r\n[4,]    "nziptstinline"   2.4554  5.41916          100\r\n[5,]        "manualzip" 0.453096      1.0          100\r\n```\r\n\r\nCompare `nziptst` with `nziptstinline`.'
3304,'JeffBezanson','Hang during build of sysimg.jl\n@JeffBezanson The patch in this gist hangs somewhere in type inference during show.jl:\r\nhttps://gist.github.com/loladiro/5718716'
3271,'JeffBezanson','object_id(global a) should be an error\nI experience something strange using the object_id() function.\r\n\r\n(1) Why is the object_id(global a) syntax possible at all?\r\n(2) Why does it differ from object_id(a)?\r\n\r\n```julia\r\n# variable a is global\r\njulia> a = 1\r\n\r\njulia> object_id(a)\r\n0xaaaa9508\r\njulia> object_id(a)\r\n0xaaaa9508\r\n\r\njulia> object_id(global a)\r\n0xd5fecf3e\r\njulia> object_id(global a)\r\n0xd5fecf3e\r\n```'
3254,'JeffBezanson','another missing return value\nThis bug is similar to #2997.  (Found by @aswart)\r\n\r\n- A return value can be shown inside the function but is nothing upon return. This happens only inside sufficiently complex code.\r\n- A matrix-valued variable collapses to a scalar inexplicably, also only inside sufficiently complex code.\r\n\r\nPlatform: Linux and Windows build: b4f0697\r\n\r\nThis code demonstrates the problem:\r\n\r\n    importall Base\r\n\r\n    # =====================================================================\r\n    # Stripped-down copy of DualNum\r\n    # =====================================================================\r\n    # A convenient taxonomy of numeric types \r\n    # \'Num\' should be understood as \'numeric\', which can be scalar, vector or matrix.\r\n    typealias FloatReal Union(Float64,Float32)\r\n    typealias FloatComplex Union(Complex128,Complex64)\r\n    typealias FloatScalar Union(FloatReal, FloatComplex)  # identical to Linalg.BlasFloat\r\n    typealias FloatVector{T<:FloatScalar} Array{T,1}\r\n    typealias FloatMatrix{T<:FloatScalar} Array{T,2}\r\n    typealias FloatArray{T<:FloatScalar} Union(FloatMatrix{T}, FloatVector{T})\r\n    typealias FloatNum{T<:FloatScalar} Union(T, FloatArray{T})\r\n\r\n    typealias FixReal Union(Integer,Rational)\r\n    typealias FixComplex{T<:FixReal} Complex{T}\r\n    typealias FixScalar Union(FixReal,FixComplex)\r\n    typealias FixVector{T<:FixScalar} Array{T,1}\r\n    typealias FixMatrix{T<:FixScalar} Array{T,2}\r\n    typealias FixArray{T<:FixScalar} Union(FixMatrix{T},FixVector{T})\r\n    typealias FixNum{T<:FixScalar} Union(T,FixArray{T})\r\n\r\n    typealias Numeric Union(FloatNum,FixNum) \r\n\r\n    # =====================================================================\r\n    # This is the main new type declared here. The two components can be scalar,\r\n    # vector or matrix, but must agree in type and shape.\r\n    immutable DualNum{T<:FloatNum} \r\n      st::T # standard part\r\n      di::T # differential part\r\n      function DualNum(s::T,d::T)\r\n        n=ndims(s)\r\n    \tassert(n==ndims(d)<=2,"dimension mismatch")\r\n    \tfor i=1:n;\r\n    \t  assert(size(s,i)==size(d,i),"size mismatch in dimension $i")\r\n    \tend\r\n    \treturn new(s,d)\r\n      end\r\n    end\r\n\r\n    function dualnum{T<:FloatNum}(s::T,d::T) \r\n      return DualNum{T}(s,d)  # construction given float types that agree\r\n    end\r\n\r\n    # show \r\n    function show(io::IO,x::DualNum)\r\n      print(io,"standard part: ")\r\n      show(io,x.st)  \r\n      print(io,"\\ndifferential part: ")\r\n      show(io,x.di)  \r\n    end\r\n\r\n    # binary operators\r\n    .+(x::DualNum,y::DualNum) = dualnum(x.st.+y.st, x.di.+y.di)\r\n    *(x::DualNum,y::DualNum) = dualnum(x.st*y.st, x.st*y.di + x.di*y.st)\r\n    *(x::DualNum,y::Numeric) = dualnum(x.st*y, x.di*y)\r\n    *(x::Numeric,y::DualNum) = dualnum(x*y.st, x*y.di)\r\n\r\n    # ==================================================================\r\n    # ==================================================================\r\n    # Some functions to illustrate various buggy behaviours\r\n    function bugfun1()\r\n        # returns nothing\r\n        A = dualnum(randn(2,2),randn(2,2))\r\n        B = dualnum(randn(2,2),randn(2,2))\r\n\r\n        C = A .+ B\r\n        y = C*1\r\n\r\n        println("returning:\\n$y")\r\n        return y\r\n    end \r\n\r\n    function bugfun2(ignore=None)\r\n        # may return nothing... depending on what typeof(ignore) is\r\n        A = dualnum(randn(2,2),randn(2,2))\r\n        B = dualnum(randn(2,2),randn(2,2))\r\n\r\n        C = A .+ B\r\n        y = C*1\r\n\r\n        println("returning:\\n$y")\r\n        return y\r\n    end \r\n\r\n    function bugfun3()\r\n        # multiplying by a float here produces a 1x1 DualNum, returns correctly\r\n        A = dualnum(randn(2,2),randn(2,2))\r\n        B = dualnum(randn(2,2),randn(2,2))\r\n\r\n        C = A .+ B\r\n        y = C*1.0 # scalar!?\r\n        println("Should be returning:\\n$C")\r\n        println("returning:\\n$y")\r\n        return y\r\n    end \r\n\r\n    # ===========================================================\r\n    # ===========================================================\r\n\r\n    println("\\nCorrect behaviour outside function =============")\r\n    A = dualnum(randn(2,2),randn(2,2))\r\n    B = dualnum(randn(2,2),randn(2,2))\r\n    C = A .+ B\r\n    y = C*1\r\n    println("\\nNo bug here: C*1 = \\n$y")\r\n\r\n    y = C*1.0\r\n    println("\\nNo bug here: C*1.0 = \\n$y")\r\n\r\n    println("\\nexample 1: (bug) returned value vanishes =======================")\r\n    z = bugfun1()\r\n    println("\\nReturned:\\n$z")\r\n\r\n    println("\\nexample 2: (bug) returned value vanishes =======================")\r\n    z = bugfun2(2)\r\n    println("\\nReturned:\\n$z")\r\n\r\n    println("\\ncounterexample 3: (OK) now returned value is there =================")\r\n    z = bugfun2(randn(2))\r\n    println("\\nReturned:\\n$z")\r\n\r\n    println("\\nexample3: (bug) inexplicable collapse of matrix to scalar =============")\r\n    z = bugfun3()\r\n    println("\\nReturned:\\n$z")\r\n\r\nThe output is:\r\n\r\nCorrect behaviour outside function =============\r\n\r\n    No bug here: C*1 =\r\n    standard part: 2x2 Float64 Array:\r\n      0.552178   0.585758\r\n     -0.329195  -0.0420111\r\n    differential part: 2x2 Float64 Array:\r\n     0.974976   -2.65792\r\n     0.0991329   0.0728872\r\n\r\n    No bug here: C*1.0 =\r\n    standard part: 2x2 Float64 Array:\r\n      0.552178   0.585758\r\n     -0.329195  -0.0420111\r\n    differential part: 2x2 Float64 Array:\r\n     0.974976   -2.65792\r\n     0.0991329   0.0728872\r\n\r\n    example 1: (bug) returned value vanishes ===========================\r\n    returning:\r\n    standard part: 2x2 Float64 Array:\r\n     -0.269862  0.164337\r\n     -0.041986  2.46685\r\n    differential part: 2x2 Float64 Array:\r\n     0.143382  -0.795063\r\n     0.868825   0.64295\r\n\r\n    Returned:\r\n    nothing\r\n\r\n    example 2: (bug) returned value vanishes ===========================\r\n    returning:\r\n    standard part: 2x2 Float64 Array:\r\n     -0.994362   0.798359\r\n      0.528806  -0.285397\r\n    differential part: 2x2 Float64 Array:\r\n     -1.38295   -1.03693\r\n      0.832376  -1.79867\r\n\r\n    Returned:\r\n    nothing\r\n\r\n    counterexample 3: (OK) now returned value is there ===========================\r\n    returning:\r\n    standard part: 2x2 Float64 Array:\r\n     -0.300047  -1.31415\r\n      2.95492   -1.43682\r\n    differential part: 2x2 Float64 Array:\r\n     -0.0603585  -1.48603\r\n     -0.105336    1.31012\r\n\r\n    Returned:\r\n    standard part: 2x2 Float64 Array:\r\n     -0.300047  -1.31415\r\n      2.95492   -1.43682\r\n    differential part: 2x2 Float64 Array:\r\n     -0.0603585  -1.48603\r\n     -0.105336    1.31012\r\n\r\n    example3: (bug) inexplicable collapse of matrix to scalar =============\r\n    Should be returning:\r\n    standard part: 2x2 Float64 Array:\r\n      2.65351   -0.580244\r\n     -0.593985   1.44685\r\n    differential part: 2x2 Float64 Array:\r\n     -0.063097  -0.263272\r\n      0.542484   2.71743\r\n    returning:\r\n    standard part: 1.09782604e-315\r\n    differential part: 1.097826434e-315\r\n\r\n    Returned:\r\n    standard part: 1.09782604e-315\r\n    differential part: 1.097826434e-315\r\n\r\n\r\n\r\n'
3243,'JeffBezanson',"seg fault with clean build on Mac 10.7.5 but can invoke julia\nI had been running julia fine for the last few days without any updates and then without any warning I got a segfault.  I decided to try and update (which I usually do every day or so)\r\n\r\nI did a git pull origin master, make clean && make and I got seg fault.  I then did make cleanall && make and got the same thing.  Finally, I wiped my julia folder and did a new git clone and make and got the same seg fault.  It made it almost to the end and gave the error below.  I usually keep up with the latest build but had not done so for the last couple of days.\r\n\r\nwhat is strange is that I can actually invoke julia and get it to work.   That being said, I am not sure what the segfault means.\r\n\r\n\r\nWarning: replacing module Base\r\ncollections.jl\r\n/bin/sh: line 1: 42883 Segmentation fault: 11  /Users/madmax/julia/usr/bin/julia-release-readline -f sysimg.jl\r\n*** This error is usually fixed by running 'make clean'. If the error persists, try 'make cleanall'. ***\r\n\r\n"
3235,'JeffBezanson','Improve let\nLet is not as safe or convenient as it could be.  The main issue is that with the current let behavior it is too easy to accidentally reassign variables in an outer scope instead of introducing new bindings.\r\n\r\n1) By forgetting a comma after "x = 1" below we accidentally overwrite\r\nan outer y instead of creating a local y:\r\n\r\n    y = ...\r\n    ...\r\n    let x = 1       # <- forgot a comma here\r\n        y = 1       # oops overwrote outer y\r\n      x + y\r\n    end\r\n\r\nThe above is also different from \r\n\r\n    let\r\n      x = 1\r\n      y = 1\r\n      x + y\r\n    end\r\n\r\nwhich would reassign to an outer x as well, though it looks like only a stylistic difference.\r\n\r\nIt\'s unclear in both cases above where the let bindings end and where the body starts.  An optional "in" before the body would help, see 4).\r\n\r\n2) Protecting a variable declaration inside the body of the let with "const" does not prevent reassignment to an existing variable outside the let as it usually does in other contexts.\r\n\r\nFor example, the below gives no error and reassigns the outer x instead of introducing a new variable x inside the let:\r\n\r\n    julia> function f()\r\n         x = 1 # we don\'t want this one to be modified\r\n         let\r\n           const x = 50\r\n           y = 1 + x\r\n           x+y\r\n         end\r\n         x  \r\n       end\r\n    julia> f()\r\n    50\r\n\r\nNow changing "const" to "local" does create a new binding, but const either should also or give an error (It would be nice if it implied "local" - I like to declare new unchanging variables with const so variables to be mutated stand out).\r\n\r\n3) A let bound variable cannot depend on previous ones which makes lets much less useful than they could be.  We often want to limit scope of all variables involved in a computation being built incrementally.\r\n\r\n4) Lets would be easier to read in many cases if an optional "in" were allowed between the bindings and the body.  This would also make it clear the dividing line between the body and the bindings, so the examples in 1) would give errors instead of accidentally overwriting variables in outer scopes:\r\n\r\n    let x = 1       # <- forgot a comma here\r\n        y = 1\r\n      in x + y      # error! Missing comma in bindings detected.\r\n    end\r\n\r\nI believe the optional "in" would also make many lets easier to read:\r\n\r\n    let pi = 3.14 pi*r^2 end\r\n\r\nvs\r\n\r\n    let pi = 3.14 in pi*r^2 end\r\n\r\n\r\n'
3232,'JeffBezanson','new() not defined for EachLine\nWith Version 0.2.0-1722.rb4f06977\r\n```\r\njulia> s = open("somefile.txt")\r\nIOStream(<file somefile.txt>)\r\n\r\njulia> for this in eachline(s)\r\n         println(this)\r\n       end\r\nERROR: in eachline: new not defined\r\n in eachline at io.jl:182\r\n in anonymous at no file\r\n```\r\n\r\nHowever, other things that use `new()`, like `SubArray`s, work fine. Curious.\r\n'
3206,'JeffBezanson','+ with many arguments\nThis function allocates large numbers of gc roots:\r\n```julia\r\nfunction laplace2 (del_x::Array{Float64, 3}, x::Array{Float64, 3})\r\n        \r\n               n1, n2, n3 = size (x)\r\n               for i1 = 1:n1, i2 = 1:n2, i3 = 1:n3\r\n                       del_x[i1,i2,i3] =\r\n                               x[i1,i2,i3] + x[i1,i2,i3] +\r\n                               x[i1,i2,i3] + x[i1,i2,i3] +\r\n                               x[i1,i2,i3] + x[i1,i2,i3]\r\n               end\r\n        \r\n       end\r\n```\r\n\r\nwhile this function does not:\r\n```julia\r\nfunction laplace2 (del_x::Array{Float64, 3}, x::Array{Float64, 3})\r\n        \r\n               n1, n2, n3 = size (x)\r\n               for i1 = 1:n1, i2 = 1:n2, i3 = 1:n3\r\n                       del_x[i1,i2,i3] =\r\n                               x[i1,i2,i3] + x[i1,i2,i3] +\r\n                               x[i1,i2,i3] + x[i1,i2,i3]\r\n               end\r\n        \r\n       end\r\n```'
3205,'JeffBezanson','let blocks poorly documented\nThe behavior of `let` is surprising (and possibly also annoying). The interaction of `do` and `let` with control flow should be documented in the manual:\r\nhttp://docs.julialang.org/en/latest/manual/control-flow/\r\nhttp://docs.julialang.org/en/latest/manual/variables-and-scoping/\r\n\r\n```julia\r\njulia> function f()\r\n              while true\r\n                let x=true\r\n                  println(x)\r\n                  break\r\n                end\r\n              end\r\n              end\r\n# methods for generic function f\r\nf() at none:2\r\n\r\njulia> f()\r\nERROR: error compiling anonymous: unsupported or misplaced expression break in function anonymous\r\n in f at none:3\r\n```'
3182,'JeffBezanson','erroneous method dispatch\nI get a context-sensitive method dispatch error. It matters from what context the method is called. Under some very specific circumstances, the wrong method is invoked. Some seemingly irrelevant changes can cause the right method to be invoked, or not.\r\n\r\nPlatforms: Windows and Linux, both 64-bit, today\'s build: b07b2aa.\r\n\r\nThe following example code is stripped down and does not make much sense anymore. Set `bug = true` to make it happen and `bug = false` to make it go away. \r\n\r\n    module Buggy\r\n    \r\n    bug = true\r\n\r\n    importall Base\r\n\r\n    export blocksparse\r\n\r\n    abstract Flavour\r\n      abstract DenseFlavour <: Flavour\r\n      abstract SparseFlavour <: Flavour\r\n\r\n    if bug \r\n      @eval begin\r\n        immutable CustomMatrix{F<:Flavour,E,D} #<: AbstractArray{E}\r\n            data::D\r\n            m::Int\r\n            n::Int\r\n        end\r\n        eltype{F,E}(C::CustomMatrix{F,E}) = E\r\n      end \r\n    else \r\n      @eval begin\r\n        immutable CustomMatrix{F<:Flavour,E,D} <: AbstractArray{E}\r\n            data::D\r\n            m::Int\r\n            n::Int\r\n        end\r\n      end\r\n    end\r\n\r\n    CustomMatrix{D}(F::DataType,data::D,m::Int,n::Int) = CustomMatrix{F,eltype(data),D}(data,m,n)\r\n    size(M::CustomMatrix) = (M.m,M.n)\r\n\r\n    full(M::CustomMatrix) = full(M,eltype(M))\r\n    full{F<:SparseFlavour}(M::CustomMatrix{F},elty::DataType) = zeros(elty,size(M)) #line 38\r\n\r\n    type blocksparse <: SparseFlavour end\r\n    immutable blockdata{T<:Number} \r\n      block::Matrix{T}\r\n      at::(Int,Int)\r\n    end\r\n    blockdata{T}(block::Matrix{T},at::(Int,Int)) = {T}blockdata(block,at)\r\n    eltype{T}(B::blockdata{T}) = T\r\n\r\n    function sum(B::blockdata,i::Int)\r\n        if i==1\r\n          blockdata(sum(B.block,i),(1,B.at[2]))  \r\n        elseif i==2\r\n          blockdata(sum(B.block,i),(B.at[1],1))  \r\n        else\r\n          error("bad i")\r\n        end\r\n    end\r\n\r\n    function blocksparse(block::Matrix,at::(Int,Int),sz::(Int,Int)) \r\n      for i=1:2 assert(1 <= at[i] <= sz[i] - size(block,i) + 1,\r\n        "$(size(block)) block does not fit at $at in $sz matrix") \r\n        end\r\n      return CustomMatrix(blocksparse,blockdata(block,at),sz...)\r\n    end\r\n\r\n    function sum(C::CustomMatrix{blocksparse},i::Int) \r\n        if i==1\r\n          S = CustomMatrix(blocksparse,sum(C.data,i),1,C.n)\r\n          return S\r\n        elseif i==2\r\n          S = CustomMatrix(blocksparse,sum(C.data,i),C.m,1)\r\n          return full(S)  # line 79\r\n        else\r\n          return full(C)\r\n        end\r\n    end\r\n\r\n    end # module\r\n\r\n    julia> using Buggy\r\n    julia> B = blocksparse(randn(2,2),(1,1),(3,3));\r\n    julia> sum(B,2)\r\n    ERROR: no method Array(DataType,DataType,(Int64,Int64))\r\n     in zeros at array.jl:203\r\n     in full at /home/nbrummer/julia/ad4julia/buggy.jl:38\r\n     in sum at /home/nbrummer/julia/ad4julia/buggy.jl:79\r\n\r\nThis crashes because the wrong method, `zeros(args...)`, is invoked, rather than `zeros{T}(::Type{T}, args...)`. Small changes make the problem go away. As mentioned setting `bug = false` will cure this specific example. But even with `bug = true`, the crash does not happen when taking a different route through sum(), such as `full(sum(B,1))`, or `sum(B,3)`.\r\n\r\n\r\n\r\n'
3178,'JeffBezanson',"Circular Warning ?\nI'm defining this method ( using ```reinterpret``` here gives me a 1.44x speedup )\r\n```\r\nconvert{T<:BioUnit, N}(::Type{Array{T,N}}, x::Array{T,N}) = x\r\nconvert{T<:BioUnit, N}(::Type{Array{Uint8,N}},s::Array{T,N}) = reinterpret(Uint8,s)\r\nconvert{T<:BioUnit, N}(::Type{Array{T,N}},s::Array{Uint8,N}) = reinterpret(T,s)\r\n```\r\nBut, after that I get this circular warning:\r\n```\r\nWarning: New definition \r\n    convert(Type{Array{Uint8,N}},Array{T<:BioUnit,N}) at /home/dzea/.julia/BioSeq/src/biounits.jl:80\r\nis ambiguous with \r\n    convert(Type{Array{T,n}},Array{T,n}) at array.jl:249.\r\nMake sure \r\n    convert(Type{Array{Uint8,N}},Array{T<:BioUnit,N})\r\nis defined first.\r\n```"
3177,'JeffBezanson','segfault from cat operation\n(running Version 0.2.0-1658.r81c84a9f.dirty Commit 81c84 a9f14 2013-05-22 03:59:3)  (dirty because "#define MEMDEBUG" in src/gc.c in uncommented)\r\n\r\nThis may or may not be related to a non-deterministic [bug](https://groups.google.com/forum/#!topic/julia-users/eVRwZIRTI94) I mentioned on the users mailing list on April 30.  On my machine, the following code reliably segfaults although it generally takes a few seconds or minutes.\r\n\r\n\r\n```\r\nfunction foo()\r\n    o_len = 100000\r\n    o_arr = []\r\n    for j = 1:o_len\r\n\t    o_arr =\t[o_arr, 5]                                 \r\n    end\r\nend\r\n\r\nfor j = 1:1000\r\n    println(j)\r\n    foo()\r\nend\r\n\r\n```\r\n\r\nI didn\'t get it to happen with valgrind running.  I suspect that it will, but valgrind seems to slow this code down to a pretty extreme extent.'
3163,'JeffBezanson',"weird tab completion for functions with named arguments\n```\r\njulia> module foo\r\n                    f(a;options...) = 1\r\n              end\r\n\r\njulia> foo.\r\nfoo.eval  foo.f     foo.f#g2  foo.foo\r\n```\r\n\r\n``foo.f#g2`` shouldn't be there."
3156,'Keno','sometimes a seg fault instead of "ERROR: spawn: too many open files (EMFILE)"\nIf you spawn too many processes sometimes you\'ll get a nice "ERROR: spawn: too many open files (EMFILE)"... but sometimes you just get a seg fault.\r\n\r\nThis seems to happen particularly if you stagger your spawn calls. For example, this seems to consistently give me a nice error:\r\n\r\n    things = Array(Any, 0)\r\n    for i = 1:300\r\n        push!(things, readsfrom(`/path/to/julia`))\r\n    end\r\n\r\n    ERROR: spawn: too many open files (EMFILE)\r\n     in _jl_spawn at process.jl:166\r\n     in spawn at process.jl:212\r\n     in readsfrom at process.jl:348\r\n     in anonymous at no file:2\r\n\r\nBut this seems to consistently crash:\r\n\r\n    things = Array(Any, 0)\r\n    \r\n    for i = 1:200\r\n        push!(things, readsfrom(`/path/to/julia`))\r\n    end\r\n    \r\n    for i = 1:200\r\n        push!(things, readsfrom(`/path/to/julia`))\r\n    end\r\n    \r\n    ERROR: Segmentation fault: 11\r\n'
3144,'ViralBShah',"merge distributed base file and export `spdiagm` ?\n1. I find `bitarray.jl` and `sparse.jl` are both in `/base/`  and `/base/linalg/` . Shouldn't them be merged?\r\n2. please export `spdiagm` in `/base/linalg/sparse.jl`"
3143,'JeffBezanson','Defaults reordered to end of argument list\n```julia\r\njulia> f(x=1, y) = "$x $y"\r\n# methods for generic function f\r\nf(y)\r\nf(y,x) at none:1\r\n\r\njulia> f(1, 2)\r\n"2 1"\r\n```'
3142,'JeffBezanson',"0.2 performance regressions\nI've noticed a pretty serious performance regression on my linear programming **[benchmarks]** from 0.1 (commit 120cf27b35) to 0.2 (commit fe6a52afcf). This mostly tests the performance of cache-bound low-level loops.\r\n\r\n[benchmarks]: https://github.com/mlubin/SimplexBenchmarks\r\n\r\nUnder 0.1:\r\n\r\n\tGeometric mean (relative to C++bnd):\r\n   \t\t\tJulia\tC++\t\tC++bnd\tmatlab\tPyPy\tPython\t\r\n    mtvec:\t1.47\t0.72\t1.00\t8.02\t4.29\t89.77\t\r\n    smtvec:\t1.42\t0.85\t1.00\t5.59\t5.94\t70.69\t\r\n    rto2:\t1.62\t0.87\t1.00\t5.83\t4.36\t69.76\t\r\n    srto2:\t1.63\t0.90\t1.00\t3.91\t12.05\t70.22\t\r\n    updul:\t1.44\t0.74\t1.00\t11.46\t3.31\t89.14\t\r\n    supdul:\t1.78\t0.74\t1.00\t16.90\t8.71\t86.40\r\n\r\nUnder 0.2:\r\n\r\n\tGeometric mean (relative to C++bnd):\r\n\t\t\tJulia\tC++\t\tC++bnd\tmatlab\tPyPy\tPython\t\r\n\tmtvec:\t2.26\t0.72\t1.00\t8.05\t4.35\t90.08\t\r\n\tsmtvec:\t1.28\t0.86\t1.00\t5.72\t6.21\t73.15\t\r\n\trto2:\t4.91\t0.87\t1.00\t5.82\t4.39\t70.24\t\r\n\tsrto2:\t2.85\t0.89\t1.00\t3.94\t12.29\t70.74\t\r\n\tupdul:\t3.92\t0.74\t1.00\t11.44\t3.47\t90.88\t\r\n\tsupdul:\t3.79\t0.74\t1.00\t16.95\t8.85\t87.67\r\n\r\nThere's a 2x slowdown in some cases. \r\n\r\nNote: to run the benchmark, the first run needs to be using 0.2 to generate the iteration data, then you can run ``runBenchmarks.jl`` under both 0.1 and 0.2. Unfortunately the first run takes a long time. You can also comment out ``matlab``, ``pypy``, and ``python2.7`` in ``runBenchmarks.jl`` to make the benchmark run faster. \r\n\r\nTo do a single run of the benchmark, you can do something like ``julia Julia/runbench.jl GenerateData/greenbea.gz.dump``.\r\n\r\nOn 0.1 this prints out:\r\n```\r\nProblem is 2392 by 5405 with 30877 nonzeros\r\n273 simulated iterations\r\nMatrix-transpose-vector product with non-basic columns: 0.0309751033782959 sec\r\nHyper-sparse matrix-transpose-vector product: 0.026279926300048828 sec\r\nTwo-pass dual ratio test: 0.018723487854003906 sec\r\nHyper-sparse two-pass dual ratio test: 0.011095285415649414 sec\r\nUpdate dual iterate with cost shifting: 0.016292095184326172 sec\r\nHyper-sparse update dual iterate with cost shifting: 0.008815526962280273 sec\r\n```\r\n\r\nOn 0.2:\r\n```\r\nProblem is 2392 by 5405 with 30877 nonzeros\r\n273 simulated iterations\r\nMatrix-transpose-vector product with non-basic columns: 0.04757523536682129 sec\r\nHyper-sparse matrix-transpose-vector product: 0.02564692497253418 sec\r\nTwo-pass dual ratio test: 0.04785418510437012 sec\r\nHyper-sparse two-pass dual ratio test: 0.022238492965698242 sec\r\nUpdate dual iterate with cost shifting: 0.03879880905151367 sec\r\nHyper-sparse update dual iterate with cost shifting: 0.022347688674926758 sec\r\n```"
3131,'JeffBezanson','pmap / parallel computing segfault\nThis bug has been frustrating me for weeks now, and I finally have a simple test-case which will reproduce it. Numerous calls to pmap where I send and return a small-ish sized array (or DataFrame, or Dict) eventually (semi-randomly) results in a segfault. Note this only happens with Julia v0.2.0, not with v0.1.2.\r\n\r\nHere is [my demonstration code](https://dl.dropboxusercontent.com/u/495317/test4.jl), which requires [this csv file](https://dl.dropboxusercontent.com/u/495317/test4.csv). The csv is loaded via csvread. I have had the same outcome when I load the csv into a DataFrame (see commented code).\r\n\r\nOh yeah, and obviously, run the code after starting julia with the flag "-p 2" set.'
3126,'JeffBezanson',"Ellipsis in the middle of a function declaration should throw a syntax error\nIt seems like Julia is happy to accept function definitions that look like:\r\n\r\n```julia\r\nf(a..., b) = (a, b)\r\nf(a..., b...) = (a, b)\r\n```\r\n\r\nUnless I've missed something, the use of an ellipsis in the middle of the positional arguments isn't described anywhere. These functions just seem to behave like:\r\n\r\n```julia\r\nf(a, b) = (a, b)\r\nf(a, b...) = (a, b)\r\n```\r\n\r\nbut Julia should probably throw a syntax error when they are declared."
3112,'JeffBezanson','Replace jl_show_any\nThis frequently causes issues when defining new I/O types. @JeffBezanson said it could probably be easily replace. I had a go at it, but it doesn\'t quite work:\r\n\r\n```Julia\r\nfunction show(io::IO, f::Function)\r\n    if isgeneric(f)\r\n        print(io,f.env.name)\r\n    else\r\n        print(io,"# function")\r\n    end\r\nend\r\n\r\nfunction show(io::IO, x::IntrinsicFunction)\r\n    print(io,"# intrinsic function ",ccall(:jl_intrinsic_function_no,Uint32,(Any,),x))\r\nend\r\n\r\nshow(io::IO, x::Type...) = show_delim_array(io, x, \'(\', \',\', \')\', true)\r\nfunction show_type(io::IO, x::Type)\r\n    if isa(typeof(x),UnionType)\r\n        if is(x,None)\r\n            print(io,"None")\r\n        elseif is(x,Top)\r\n            print(io,"Top")\r\n        else \r\n            print(io,"Union",typeof(x).types)\r\n        end\r\n    elseif isa(x,Tuple) \r\n        show_delim_array(io, t, \'(\', \',\', \')\', true)\r\n    elseif isvarargtype(x)\r\n        print(io,x.parameters[1],"...")\r\n    elseif isa(x,TypeConstructor)\r\n        show(io,x.body)\r\n    else\r\n        println(isa(x,DataType))\r\n        assert(isa(x,DataType))\r\n        print(io,x.name)\r\n        if length(x.parameters) > 0\r\n            show_comma_array(io,x.parameters,\'{\',\'}\')\r\n        end\r\n    end\r\nend\r\n\r\nfunction show(io::IO, x::ANY)\r\n    t = typeof(x)\r\n    assert(isa(t,DataType))\r\n    print(io,t)\r\n    print(io,\'(\')\r\n    if length(t.names) > 0\r\n        n = length(t.names)\r\n        for i=0:(n-1)\r\n            p = ccall(:jl_get_nth_field,Ptr{Void},(Any,Csize_t),x,i)\r\n            if p == C_NULL\r\n                print(io,"#undef")\r\n            else\r\n                show(io,unsafe_pointer_to_objref(p))\r\n            end\r\n            if i < n-1\r\n                print(io,\',\')\r\n            end\r\n        end\r\n    else\r\n        nb = t.size\r\n        print(io,"0x")\r\n        p = pointer_from_objref(x)+8*sizeof(Ptr{Void})\r\n        for i=nb-1:-1:0\r\n            print(io,hex(unsafe_load(convert(Ptr{Uint8},p+i*sizeof(Uint8))),2))\r\n        end\r\n    end\r\n    print(io,\')\')\r\nend\r\n```\r\n\r\nI think it would be best at this point if @JeffBezanson could have a look since I don\'t know enough about the type system at this point.'
3091,'JeffBezanson','Order of function calls changes inner constructor return value to `nothing`\nNoted first in https://github.com/HarlanH/DataFrames.jl/issues/264#issuecomment-17810665.\r\n\r\nThe code at the end of this description was distilled from the DataFrames module.  It has three types, `StackedVector`, `IndededVector`, and `Indexer`.  \r\n\r\nDepending on the order of instantiation of  `StackedVector` and `IndededVector`, a function (`.==`) which is supposed to return an `Indexer` sometimes returns `nothing` instead.  \r\n\r\nCorrect:\r\n```julia\r\njulia> import Buggy\r\n\r\njulia> a = Buggy.IndexedVector([1])\r\n1-element Int64 IndexedVector:\r\n 1\r\n\r\njulia> a .== 1\r\nFinished preprocessing Indexer constructor inputs.\r\nIndexer([1:1],[1])\r\n```\r\n\r\nIncorrect:\r\n```julia\r\njulia> import Buggy\r\n\r\njulia> Buggy.StackedVector({[1]})\r\n1-element Any StackedVector:\r\n 1\r\n\r\njulia> a = Buggy.IndexedVector([1])\r\n1-element Int64 IndexedVector:\r\n 1\r\n\r\njulia> a .== 1\r\nFinished preprocessing Indexer constructor inputs.\r\n\r\njulia> @show a .== 1\r\nFinished preprocessing Indexer constructor inputs.\r\n(a.==1) => nothing\r\n```\r\n\r\nFrom the debugging print statement, it is obvious that the constructor is still called, but an Indexer is not constructed.\r\n\r\nCode:\r\n```julia\r\n# Buggy.jl\r\nmodule Buggy\r\n\r\nimport Base: size, getindex, setindex!, length, similar\r\n\r\ntype StackedVector <: AbstractVector{Any}\r\n    components::AbstractVector\r\nend\r\nsize(v::StackedVector) = (length(v),)\r\nlength(v::StackedVector) = sum(map(length, v.components))\r\nsimilar(v::StackedVector, T, dims::Dims) = similar(v.components[1], T, dims)\r\n\r\nfunction getindex(v::StackedVector,i::Real)\r\n    lengths = [length(x)::Int for x in v.components]\r\n    cumlengths = [0, cumsum(lengths)]\r\n    j = searchsortedlast(cumlengths + 1, i)\r\n    k = i - cumlengths[j]\r\n    v.components[j][k]\r\nend\r\n\r\n###\r\n\r\ntype IndexedVector{T,S<:AbstractVector} <: AbstractVector{T}\r\n    x::S\r\n    idx::Vector{Int}\r\nend\r\nIndexedVector{T}(x::AbstractVector{T}) = IndexedVector{T,typeof(x)}(x, sortperm(x))\r\n\r\nsize(a::IndexedVector) = size(a.x)\r\nlength(a::IndexedVector) = length(a.x)\r\nsimilar(v::IndexedVector, T, dims::Dims) = similar(v.x, T, dims)\r\n\r\ngetindex(v::IndexedVector,i::Real) = v.x[i]\r\n\r\n###\r\n\r\ntype Indexer\r\n    r::Vector{Range1}\r\n    iv::IndexedVector\r\n    function Indexer(r::Vector{Range1}, iv::IndexedVector)\r\n        for i in 1:length(r)\r\n            ri = r[i]\r\n            if length(ri) < 1 || ri[1] < 1 || ri[end] > length(iv)\r\n                delete!(r, i)\r\n            end\r\n        end\r\n        println("Finished preprocessing Indexer constructor inputs.")\r\n        new(r, iv)\r\n    end\r\nend\r\n\r\n.=={T<:Number}(a::IndexedVector{T}, v::T) = Indexer(Range1[searchsortedfirst(a.x[a.idx], v) : searchsortedlast(a.x[a.idx], v)], a)\r\n\r\nend\r\n```\r\n'
3088,'Keno','Review BinDeps: Handling binary dependencies in Pkg\nWe should review the `BinDeps` approach, as it has turned out to be quite complex - even though many of the troubles faced by people are probably related to `pkg` rather than `BinDeps`.\r\n\r\nOne possibility that @StefanKarpinski has mentioned is that we only support two options, download a pre-compiled binary, or use a system provided one (through various package managers on Linux and Mac). Users should not be expected to build  libraries from source.\r\n\r\nIn such a scenario, we still need to have the ability to build libraries on all platforms, and perhaps a simple Makefile with common targets (similar to what we have in `deps`) may suffice.'
3083,'staticfloat','OSX bleeding edge builds\nI managed to get access to a OSX VM, which means I can continue my quest to speed up global warming by attempting OSX daily builds as well.  To my knowledge, our "OSX builds"  have a lot less fluff around them than our Ubuntu builds; there\'s no explict packaging, we essentially just upload the .tar.gz generated from `make dist`. Is this correct?  If so, I think it\'d be neat to have a cron job similar to what I do for Ubuntu right now; Parse travis logs for the last good commit, build it, and upload it for people to download if they want a 0.2.0 binary.\r\n\r\nThoughts?\r\n\r\nEDIT: Random notes that might be pertinent:\r\n* I\'m building this on 10.8, with `-march=corei7`, so that AVX is out of the picture.\r\n* I\'m not building this with Homebrew, as I want a completely stand-alone build\r\n'
3081,'Keno','Int128 support on Windows [llvm bug]\nWindows 64-bit segfaults when attempting `div`, `mod`, or `rem` on 128-bit numbers (it tries to call the gcc intrinsic __umodti3). This is because LLVM does not use the correct calling conventions for 128-bit numbers on windows.'
3072,'ViralBShah','MersenneTwister constructor type is too picky\nI was reading the docs on how to make a new rng. The docs say that you can construct a new MersenneTwister like so:\r\n\r\n    MersenneTwister([seed])\r\n\r\nHowever, when I try that I get an error:\r\n```julia\r\nMersenneTwister(42)\r\nERROR: no method MersenneTwister(Int64,Int64)\r\n in MersenneTwister at random.jl:25\r\n```\r\n\r\nWhen I got look at the signature of the constructor it is clear that it only accepts uInt32 and thus must be called this way:\r\n```julia\r\nMersenneTwister(uint32(42))\r\n```\r\n\r\nEither the docs need to make it explicit that a uInt32 must be passed or the constructor should be make to take any integer type (and figure out what to do in the case that a seed is negative).\r\n'
3062,'JeffBezanson','How to handle function declaration with unused parameter type?\nConsider a function declaration with an unused parametric type, e.g.:\r\n```\r\njulia> f{T<:Integer}(x::Integer,y::Integer)=x+y\r\n# methods for generic function f\r\nf{T<:Integer}(x::Integer,y::Integer) at none:1\r\n\r\njulia> f(1,2)\r\nERROR: no method f(Int64,Int64)\r\n```\r\nIt seems that either the definition should throw an error, or that the function call should match the defined method.'
3055,'JeffBezanson','BoundsError() in inlining pass\nI accidentally messed up a ccall definition, but instead of getting\r\n\r\n```\r\njulia> map(Panel,(w2,w3,w6,w4,w5))\r\nERROR: error compiling Panel: ccall: wrong number of arguments to C function\r\n in map at tuple.jl:43\r\n```\r\n\r\nwhich I got at the REPL. I got\r\n\r\n```\r\nERROR: BoundsError()\r\nin inlining_pass at inference.jl:1794\r\nin inlining_pass at inference.jl:1783 (repeats 3 times)\r\nin inlining_pass at inference.jl:1767\r\nin typeinf at inference.jl:1277\r\nin typeinf_ext at inference.jl:1008\r\nin map at tuple.jl:43\r\nin include_from_node1 at loading.jl:90\r\nat /Users/keno/Documents/src/julia/vis.jl:43\r\n```\r\nwhen called from a file.\r\nIs it perhaps not checking whether the function compiled correctly or something?'
2997,'JeffBezanson',"Returned object from function gets lost\nHere is an example where the return object from a function gets lost after it is called. The result ends up being `Nothing`.\r\n\r\nThis was found by @bsxfan who also reported that this is similar to #2161 and #2562:\r\n\r\n* https://github.com/scidom/AutoDiff.jl/issues/5\r\n\r\nHere is the shortest example I could come up with. It occurs with v0.1.2 and a just updated Julia.\r\n\r\n```julia\r\nmodule DualNumbers\r\nimport Base.show, Base.cat, Base.vcat, Base.hcat\r\nexport DualNum,dualnum\r\n\r\ntypealias FloatNum Union(Float64, Vector{Float64})\r\n\r\n# This is the main new type declared here. The two components can be scalar, vector or matrix, \r\n# but must agree in type and shape.\r\ntype DualNum{T<:FloatNum} \r\n  st::T # standard part\r\n  di::T # differential part\r\nend\r\nfunction dualnum{T<:FloatNum}(s::T,d::T) \r\n  return DualNum(s,d)  # construction given float types that agree\r\nend\r\n\r\ndualnum{T<:FloatNum}(s::T) = dualnum(s,zero(s))\r\n\r\nfunction cat(k::Integer,x::DualNum,y::DualNum)\r\n    ST = cat(k,x.st,y.st)\r\n    DI = cat(k,x.di,y.di)\r\n    D = dualnum(ST,DI)\r\n    @show D\r\n    return D\r\nend\r\n\r\nvcat(x::DualNum,y::DualNum) = cat(1,x,y)\r\nhcat(x::DualNum,y::DualNum) = cat(2,x,y)\r\n\r\nend # module\r\n\r\n# Example\r\na = DualNumbers.dualnum(1.0)\r\nb = DualNumbers.dualnum(2.0)\r\nd = [a,b]\r\n@show d   # shouldn't be Nothing\r\n\r\n```\r\n\r\n\r\n"
2984,'JeffBezanson',"macro function gensym issue\nIn a macro, a function cannot easily be extended:\r\n```julia\r\njulia> module test           \r\n       macro bad()\r\n       quote                \r\n       function Base.macroexpand() \r\n       2\r\n       end\r\n       end\r\n       end\r\n       export @bad\r\n       end\r\n\r\njulia> test.@bad\r\nERROR: syntax: invalid method name (. (. #<julia_value> 'Base) 'macroexpand)\r\n\r\njulia> macroexpand(:(test.@bad))\r\nquote  # none, line 4:\r\n    function $(test).Base.macroexpand() # none, line 5:\r\n        2\r\n    end\r\nend\r\n```\r\n\r\nA valid way to write this is:\r\n```julia\r\nmodule test\r\n       macro bad()\r\n       quote\r\n       function $(esc(:(Base.macroexpand)))()\r\n       2\r\n       end\r\n       end\r\n       end\r\n       export @bad\r\n       end\r\n```\r\n\r\nCan this be helped?"
2983,'JeffBezanson',"type initializer in macro in a module gets incorrectly gensym'd\nType initializer functions in macros in other modules don't get gensym'd correctly:\r\n\r\n```\r\njulia> module xtest\r\n       macro test(T)\r\n       quote\r\n       type T        \r\n       m::Uint32\r\n       $(esc(T))(n::Integer) = new(n)\r\n       end\r\n       end\r\n       end\r\n       export @test\r\n       end\r\nWarning: replacing module xtest\r\n\r\njulia> xtest.@test bad\r\nERROR: syntax: malformed function argument (call (top getfield) #<julia_value> 'n)\r\n\r\njulia> macroexpand(:(xtest.@test bad))\r\nquote  # none, line 4:\r\n    $(Expr(:type, true, :T, quote  # line 5:\r\n        m::$(xtest).Uint32 # line 6:\r\n        bad($(xtest).n::$(xtest).Integer) = begin  # none, line 6:\r\n                $(xtest).new($(xtest).n)\r\n            end\r\n    end))\r\nend\r\n```"
2982,'JeffBezanson','type inheritance and $esc in macros causes syntax error\nIt appears to incorrectly be a syntax error to declare a type in a macro with `$(esc())` and `<:`\r\n\r\n```julia\r\njulia> macro bad(Y)\r\n         quote\r\n           type $(esc(Y)) <: Unsigned\r\n           end\r\n         end\r\n       end\r\n\r\njulia> @bad Z\r\nERROR: syntax: invalid type signature\r\n```'
2973,'JeffBezanson','inconsistent <: behaviour for Union\nHere is an example where I use two different ways to define sets of types. The two sets have the same elements, but the <: operator does not see them as equivalent:\r\n\r\nJulia build:\r\nVersion 0.2.0\r\na6e1aa1-WINNT-i686 (2013-04-30 10:18:38)\r\n\r\nExample:\r\n\r\n    julia> abstract T1\r\n    julia> abstract T2\r\n    julia> type P{T};end\r\n    julia> typealias Set1{T<:Union(T1,T2)}  P{T}   \r\n    julia> typealias Set2 Union(P{T1},P{T2})\r\n    julia> Set1 <: Set2\r\n    false \r\n    julia> Set2 <: Set1\r\n    true\r\n\r\n'
2972,'JeffBezanson','undetected method ambiguity\nI find if the type specifier for a method argument is a Union, then method ambiguities are not detected.\r\n\r\nJulia Version: \r\nVersion 0.2.0\r\na6e1aa1-WINNT-i686 (2013-04-30 10:18:38)\r\n\r\nExample:\r\nDeclare two methods that take overlapping sets of types:\r\n\r\n    f(::Union(Integer,FloatingPoint))=1\r\n    f(::Union(Integer,Complex))=2\r\n\r\nNo ambiguity warning is given, although f is ambiguous for Integer arguments.\r\n\r\n\r\n'
2946,'Keno',"windows can't use files as stdio\nLike the old issue with linux, windows can't open files as streams for stdio. This breaks things like (a) piping /dev/null to or from julia (b) remote process spawn on wine (c) stdio redirection to or from files\r\n\r\nrelated issues:\r\nhttps://github.com/nikhilm/uvbook/issues/33\r\nhttps://github.com/JuliaLang/julia/issues/2362"
2916,'dmbates',"RFC Rename diagmm as scale\nThis suggestion came up some time ago but I can't put my hands on exactly where the discussion originated.  Methods for `scale!` for an Array and a scalar are defined in `linalg/generic.jl` and `linalg/dense.jl`.  The effect of the diagmm method for a matrix and a vector can be regarded as scaling the rows or columns of the matrix (rows if the first argument is the vector, columns if the first arg is the matrix).  The suggestion is to rename `diagmm!` as `scale!` and `diagmm` as `scale`.\r\n\r\nPart of my motivation for this suggestion is from the CHOLMOD module.  The C function cholmod_scale has the capability of\r\n\r\n- scaling a sparse matrix by a scalar constant\r\n- scaling the rows of a sparse matrix\r\n- scaling the columns of a sparse matrix\r\n- scaling the rows and columns of a symmetric sparse matrix (the logical equivalent of D*A*D where A is the symmetric matrix and D is the diagonal matrix corresponding to the scaling vector).\r\n\r\nand it makes sense to me to use multiple dispatch in Julia for a similar purpose."
2913,'JeffBezanson','Inconsistency in chained assignment\n```\r\njulia> x = (a,b,b,b,e) = (1,2,3,4,5)\r\n(1,4,4,4,5)\r\n\r\njulia> x = (a,b,b,e) = (1,2,3,4,5)\r\n(1,2,3,4,5)\r\n```\r\n\r\nAs per the discussion here https://groups.google.com/forum/?fromgroups=#!topic/julia-users/el9TNQrU--w\r\n\r\nin both cases x should be the value of the ultimate RHS'
2910,'dmbates','sparse cholesky solve\nCurrently, solving a sparse cholesky system gives a `CholmodDense` object.\r\n\r\n````\r\njulia> a = speye(100); b = rand(100);\r\njulia> r = cholfact(a);\r\njulia> x = r \\ b\r\nCHOLMOD dense:   :  100-by-1, \r\n...\r\n```\r\n\r\nI think the \\ method here should return `x.mat`, so that the julia user gets a regular dense matrix. Also, I think we should have a `dense` or `full` method for `CholmodDense` that gives a regular dense vector/matrix.\r\n\r\nOrthogonal question: I notice that we use both `dense` and `full`. I prefer using `dense` everywhere, but I suspect that `full` is a name that everyone knows coming from the matlab world.'
2908,'Keno',"mmap on windows\nmmap isn't available on windows as such, but there appear to be a class of windows functions with much the same functionality\r\n\r\nIf this wasn't GPL v2, it would probably have been useful https://code.google.com/p/mman-win32/"
2864,'Keno','Crash on writing to a Cmd that isn\'t listening\nHere\'s a contrived example, my original crash happened trying to write to a graphviz command, and was triggered by trying to interpolate an empty string, which created a loose pair of quotes, which the dot command couldn\'t parse.  It then terminated, and writing to it crashed Julia.\r\n````\r\nin, proc = writesto(`echo hello`)\r\nwrite(in, "hi")\r\n````\r\n\r\nThis may or may not be related to #2569'
2838,'vtjnash','work on sampling profile for windows\n#2597 -- so I can assign myself and not forget about this'
2830,'dmbates','Cholmod tests fail in SuiteSparse 4.1.0 \nSuiteSparse has been updated to 4.1.0. Currently, cholmod tests are failing and the tests are disabled.'
2778,'JeffBezanson','finally clause defeats return-type inference\nIncluding a `finally` clause seems to defeat Julia\'s ability to infer the return type of a function (e.g. for use in `cfunction`).   For example, if we define the following function:\r\n\r\n    function foo()\r\n        try\r\n            return 1\r\n        catch\r\n            return 0\r\n        finally\r\n            println("done")\r\n        end\r\n    end\r\n\r\nThen `cfunction(foo, Int, ())` fails with `ERROR: cfunction: return type of foo does not match`.  However, if I remove the `finally` clause then it works, even though the `finally` clause does not change the returned value.'
2776,'staticfloat','nuisance: patchelf not found on every make\nI get this every time I run `make`:\r\n\r\n```\r\n[jeff ~/src/julia]$ make\r\nmake[2]: patchelf: Command not found\r\n```\r\n'
2762,'staticfloat',"tests failing on travis due to lapack\nTests are failing on travis. I remember reading about the lapack issue somewhere, but can't quite remember."
2746,'staticfloat',"Further speedup travis build by having PPAs for patchelf and openlibm\n@staticfloat Do you think we could have PPAs for patchelf and openlibm? That should simplify the travis environment considerably. \r\n\r\nAlso, ARPACK is now at 3.1.3, but it really doesn't matter for linux."
2731,'Keno','WIP : added poll_fd and test for the same on branch kf/fdwatcher\n  added ```test/pollfd.jl```. Using a unix ```pipe()``` to simulate watchable fds. Consequently the test only works under unix currently. Tested only on Ubuntu 12.10\r\n\r\nIssues noticed:\r\n\r\n- sometimes the timer is going off earlier than expected, hence the code in ```stream.jl``` loops around the yield. This has to be removed once the issue is fixed.\r\n\r\n- ```sleep()``` in ```test/pollfd.jl``` is exiting earlier than expected.\r\n\r\n'
2712,'JeffBezanson',"syntax error causes flisp to crash\nIn attempting to create a tuple of functions, I created an meaningless function call absurdity that crashes flisp. Note that you must build flisp-debug, or the error goes unreported. (I'm aware of the missing comma in that tuple).\r\n```julia\r\njulia> (     \r\n              ()->(@assert true)\r\n              (v)->()\r\n       )\r\njulia: cvalues.c:669: sym_to_numtype: Assertion `0' failed.\r\nAborted (core dumped)\r\n```"
2703,'JeffBezanson',"Infix syntax specification for functions/operators\nThis is a follow up to a post on julia-dev about providing the ability to check containment similar to Python, Ruby, SQL, etc. \r\n\r\n'4 in [1,2,3,4,5]' -> true\r\n\r\nThis is extremely intuitive syntax and nonconflicting with our current use of 'in' while still being conceptually similar. \r\n\r\nAnd while I'm on Santa's lap and on the topic of syntax readability, can I request we use 'and' and 'or' as aliases for short circuit operators &&  and ||, a la python? I think they are keywordy enough that people avoid using them for variable names while doing much for clear, readable syntax. \r\n\r\nThoughts? \r\n\r\nUpdate: Changed title to reflect the desire for generalized infix syntax"
2702,'vtjnash',"windows 64 llvm 3.x shared library support\nllvm can't build a shared library on the mingw 64 compiler, per this upstream bug http://llvm.org/bugs/show_bug.cgi?id=12795\r\n\r\ncurrent recommended workarounds are either:\r\n(1) change --enable-shared to --disabled-shared in the llvm configure flags in deps/Makefile\r\n(2) apply the patch in the bug report above. hopefully this will make it into llvm someday\r\nI use method 1 above, I haven't tried 2\r\n\r\n```\r\nllvm[1]: Linking all LLVMLibs together for LLVM-3.2svn\r\nllvm[1]: Collecting global symbols of LLVM-3.2svn\r\nllvm[1]: Generating exports for LLVM-3.2svn\r\nllvm[1]: Generating LLVM-3.2svn.def\r\nllvm[1]: Linking Release Shared Library LLVM-3.2svn.dll\r\nCannot export Z10MakeErrMsgPSsRKSs: symbol not defined\r\nCannot export ZGVZN4llvm7hashing6detail18get_execution_seedEvE4seed: symbol not defined\r\nCannot export ZN4PBQP19HeuristicSolverImplINS_10Heuristics6BriggsEE5setupEv: symbol not defined\r\nCannot export ZN4PBQP19HeuristicSolverImplINS_10Heuristics6BriggsEE7applyR2EPNS_5Graph9NodeEntryE: symbol not defined\r\nCannot export ZN4llvm10AllocaInst12setAlignmentEj: symbol not defined\r\n```"
2693,'JeffBezanson','ERROR from a constructor has side effect of breaking another constructor\n The failing `PooledDataVector` constructor causes a side effect of breaking the `DataVector` constructor:  Although this error occurs in the DataFrames package, it seems that this behavior might be a Julia bug since it\'s a strange side effect.\r\n\r\n```\r\njulia> using DataFrames\r\n\r\njulia> DataVector["a", "b"]   # Originally, DataVector constructor works.\r\n2-element ASCIIString DataArray:\r\n "a"\r\n "b"\r\n\r\njulia> PooledDataVector["a","b"]  # Try the breaking PooledDataVector constructor.\r\nERROR: no method convert(Type{DataArray{T,1}},ASCIIString)\r\n in setindex! at array.jl:381\r\n in getindex at array.jl:155\r\n in getindex at /home/ijf0jnf/.julia/DataFrames/src/pooleddataarray.jl:171\r\n\r\njulia> DataVector["a","b"]  # DataVector constructor no longer works.\r\nERROR: no method convert(Type{DataArray{T,1}},ASCIIString)\r\n in setindex! at array.jl:381\r\n in getindex at array.jl:155\r\n```\r\n\r\nI am using DataFrames.jl master (774bef03d70676d333f4998b45b156cd4fd722e4) and the following Julia:\r\n```\r\nVersion 0.2.0-736.r54c5\r\nCommit 54c5403d21 2013-03-25 07:44:46\r\n```\r\n\r\nThis is related to https://github.com/HarlanH/DataFrames.jl/issues/220.'
2689,'ViralBShah',"install-git shouldn't be part of install target\nInstalling Git is fine as part of `make dist`, but shouldn't be in `make install`\r\n```\r\nI checked the Makefile and found that it does something special for Mac user.\r\n\r\nifeq ($(OS), Darwin)\r\n        $(MAKE) -C deps install-git\r\n        -cp -a $(BUILD)/libexec $(PREFIX)\r\n        -cp -a $(BUILD)/share $(PREFIX)\r\nendif\r\n\r\nAnd I also don't understand why julia is trying to build a whole new Git, because I use homebrew(by the way, whose julia formula also has problems)\r\nand I'm always using the latest git, and the current julia, however, is not using the latest git version.\r\n\r\nIf I comment out these lines, julia will install just fine.\r\nI think this may be a bug.\r\n```"
2655,'jiahao','linalg tests do not properly test complex matrix operations\nIt appears that test/linalg.jl samples small random matrices and vectors for the tests, but it uses the same test data for the real and complex versions of the test. Thus it seems that no operations on imaginary components of the complex data ever get tested.'
2630,'Keno','NamePipe/start_reading swallows Errors in REPL\nIf you use a `NamedPipe` to do asynchronous IO to a shell command (or probably just in general), and then in your `start_reading` callback you write code that causes an ERROR, then you will not see the error in the REPL.\r\n \r\n~~~\r\njulia> cmd = `echo "hi"`\r\n`echo hi`\r\n\r\njulia> pipe = Base.NamedPipe()\r\nNamedPipe(disconnected,0 bytes waiting)\r\n\r\njulia> p = spawn(cmd, (Base.null_handle, pipe, STDERR))\r\nProcess(`echo hi`, ProcessRunning)\r\n\r\njulia> start_reading(pipe, function(stream, nread)\r\n         value = readline(stream)\r\n         println("have value")\r\n         base(34,34,34,34,34,34) #error here\r\n         println("END")\r\n       end)\r\n\r\njulia> have value\r\n~~~\r\n\r\nThe `start_reading` call returns immediately, and then the callback immediately prints "have value" to STDOUT.\r\n\r\nI assume that right after printing "have value", the function errors, since "END" never prints and that call to `base` shouldn\'t work:\r\n~~~\r\njulia> base(34,34,34,34,34,34)\r\nERROR: no method base(Int32,Int32,Int32,Int32,Int32,Int32) \r\n~~~\r\n'
2616,'JeffBezanson',"Named functions don't act as expressions\nI believe the following should be possible:\r\n\r\n```jl\r\njulia> x = function foo(arg)\r\n         arg\r\n       end\r\nERROR: syntax: misplaced method definition for foo\r\n```"
2615,'vtjnash','gethostname on Windows crashes Julia\nFunction gethostname() at the julia prompt results in a julia window closing.'
2613,'ViralBShah','real and complex sparse matrix addition gives error\nAdding (or subtracting) a real sparse matrix to a complex sparse matrix gives error. See example below -\r\n\r\n```Julia\r\na = eye(5,5) + im * eye(5,5)\r\nb = sparse(a)\r\nb += im * speye(5,5)     # this works\r\nb += speye(5,5)          # this fails\r\nERROR: no method\r\n+(SparseMatrixCSC{Complex{Float64},Int64},SparseMatrixCSC{Float64,Int64})\r\n```'
2610,'Keno','missing redirection methods\nThere should be a way of redirecting string data to a process. This would be an obvious candidate:\r\n\r\n```julia\r\n`cat` < IOString("foo")\r\n```\r\n\r\nAnother possibility would be using a triple left shift operator for it:\r\n\r\n```julia\r\n`cat` <<< "foo"\r\n```\r\n\r\nI realize that we don\'t have a `<<<` operator at the moment, but we could add it. Another option that requires no new operator would be to come from the left:\r\n\r\n```julia\r\n"foo" >>> `cat`\r\n```\r\n\r\ncc: @astrieanna.'
2607,'JeffBezanson',"DataFrames hangs when using master commits after #12c51d7...\nThis was first observed here: https://github.com/HarlanH/DataFrames.jl/issues/216\r\n\r\nThe problem is somewhere between ````12c51d7a8da702b4a25c1774b7bebbd2aae2e21d Rename known-mean variants to stdm and varm.```` and ````c3418cb11833480138a5c476568b3eb56ed07ce7 fix #2562````\r\n\r\nThat's a pretty wide range of commits\r\n\r\n"
2606,'andreasnoack','eigvals: vh not defined error on SymTridiagonal matrices\n`eigvals()` throws a vh not defined error when using it to compute eigenvalues of a SymTridiagonal matrix. For example:\r\n\r\n    e=randn(5);\r\n    f=randn(4);\r\n    M=SymTridiagonal(e,f)\r\n    eigvals(M)\r\n    ERROR: in eigvals: vh not defined\r\n     in eigvals at linalg/tridiag.jl:50\r\n     in eigvals at linalg/tridiag.jl:51\r\n\r\n`eig(M)` works just fine, as does `eigvals(M)` for a dense matrix `M`.\r\n\r\nReported on latest HEAD version (be3835ea12), OSX 10.8.3'
2597,'timholy',"Include sampling profiler in julia Base\nInclude @timholy 's sampling profiler in julia Base. This was the general consensus in #1865  and I am opening a new issue to track this."
2593,'ViralBShah','linear algebra documentation\n@andreasnoackjensen I have made updates to the documentation on master, but it would be great if you can review it.\r\n\r\nWould it be ok to rename `eigenfact` to `eigfact` and the type to `EigenDense`, to keep the naming scheme consistent? I realized this while trying to document things. \r\n\r\n@dmbates - Yes, I know your views on consistentcy. ;-) Jokes aside, could you also take a look the dense linear algebra documentation, and make suggestions for improvement. It would be much easier to take a crack at sparse linear algebra documentation then.\r\n'
2525,'staticfloat',"Julia.app won't work from path with space character\nJulia.app doesn't work from a directory with a space in it:\r\n```\r\nPATH=/Volumes/Julia 1/Julia.app/Contents/Resources/julia/bin:/usr/bin:/bin:/usr/sbin:/sbin GIT_EXEC_PATH=/Volumes/Julia 1/Julia.app/Contents/Resources/julia/libexec/git-core GIT_TEMPLATE_DIR={ROOT}/julia/share/git-core exec '/Volumes/Julia 1/Julia.app/Contents/Resources/julia/bin/julia'\r\n-bash: 1/Julia.app/Contents/Resources/julia/bin:/usr/bin:/bin:/usr/sbin:/sbin: No such file or directory\r\n```\r\n(as observed by Alan)"
2518,'ViralBShah',"Packages will not install in the Julia.app 0.1.2 Mac OS X distribution\nIssue: Packages such as Gadfly won't install due to repeated statements such as\r\n  prefix=/Users/viral/.julia/Cairo/deps/usr (in cairo-script.pc) and\r\n  <cachedir>/Users/viral/.julia/Cairo/deps/usr/var/cache/fontconfig</cachedir> (in fonts.conf)\r\nscattered throughout numerous files in the OS X Julia.app (version 0.1.2) distribution.  The problem is that unless you happen to be user viral, the directories do not exist.\r\n\r\nPossible solution: rewrite the package configuration files in Julia.app to install packages in the Julia.app directory, say in Julia.app/Contents/Contents.  For portability (so Julia.app could be installed in a directory such as LocalApps rather than Applications), give the user a choice as to where it should be installed so the prefixes could be adjusted at install time.  In fact, the script could be written in Julia and run, not during installation, but when Julia is first run.  This would also give the user the ability to change things by rerunning the script if he or she wanted to adjust things later.\r\n"
2509,'JeffBezanson','crash on comparison of immutable\nI get this with latest julia master (x86_64 Debian GNU/Linux):\r\n\r\n    julia> immutable Foo; foo::Int; end\r\n    julia> Foo(1) == Foo(2)\r\n    UNREACHABLE executed!\r\n    Stack dump:\r\n    0.\tRunning pass \'Optimize for code generation\' on function \'@"julia_==559"\'\r\n    Aborted\r\n'
2502,'vtjnash',"Error in make with libuv with uv_rwlock_t\nHi,\r\n\r\nOn `0.1.1` tag and master I get the following make error:\r\n\r\n```\r\nIn file included from /home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:67,\r\n                 from src/unix/async.c:25:\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv-private/uv-unix.h:132: error: expected ¡=¢, ¡,¢, ¡;¢, ¡asm¢ or ¡__attribute__¢ before ¡uv_rwlock_t¢\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv-private/uv-unix.h:149: error: expected ¡=¢, ¡,¢, ¡;¢, ¡asm¢ or ¡__attribute__¢ before ¡uv_barrier_t¢\r\nIn file included from src/unix/async.c:25:\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:353: warning: ¡struct addrinfo¢ declared inside parameter list\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1856: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1857: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1858: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1859: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1860: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1861: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1862: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1863: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1898: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1899: error: expected ¡)¢ before ¡*¢ token\r\n/home/user/RedHatEnterpriseWS6/julia-master/deps/libuv/include/uv.h:1900: error: expected ¡)¢ before ¡*¢ token\r\nIn file included from src/unix/internal.h:35,\r\n                 from src/unix/async.c:26:\r\nsrc/unix/linux-syscalls.h:129: warning: type defaults to ¡int¢ in declaration of ¡sigset_t¢\r\nsrc/unix/linux-syscalls.h:129: error: expected ¡;¢, ¡,¢ or ¡)¢ before ¡*¢ token\r\nsrc/unix/async.c: In function ¡uv__async_start¢:\r\nsrc/unix/async.c:214: warning: implicit declaration of function ¡uv__make_pipe¢\r\nmake[3]: *** [src/unix/async.o] Error 1\r\nmake[2]: *** [libuv/libuv.a] Error 2\r\nmake[1]: *** [julia-release] Error 2\r\nmake: *** [release] Error 2\r\n```\r\n\r\nI tried both 1.1 branch and master and got the same error.  I tried `make -C deps/libuv clean; make` and from a fresh install which didn't work. \r\n\r\nThanks,\r\n\r\nGlen"
2496,'Keno','more efficient tuple representation\nIs there a correct syntax for doing this?\r\n\r\n```\r\njulia> immutable Iterator{1}\r\n         ni::Int\r\n       end\r\nERROR: syntax: malformed type parameter list\r\n```\r\n\r\nIf so, one could create types `Iterator{1}`, `Iterator{2}`, etc, via metaprogramming. I suspect that the alternative,\r\n```\r\nimmutable Iterator{N}\r\n    n::NTuple{N,Int}\r\nend\r\n```\r\nwill not yield the kind of benefits we might want.\r\n'
2493,'vtjnash',"Windows download filenames could be clearer\nWhen I look at our Windows filenames from a new user's perspective, it is hard to tell why I should prefer to get julia+git over just plain julia. A typical user, when starting with julia, may not even know that Julia's packaging system uses git. \r\n\r\nI think we should name the windows download as `Julia-x.y.z.zip`. The commit info is available from within the julia session if necessary. Also, it would be clearer if `Julia-x.y.z.zip` is the batteries included version. A `Julia-x.y.z-minimal.zip` with warnings could be made available, so that only people who know what they are doing will get it."
2490,'JeffBezanson','segfault in immutable constructor\nwith both ComplexPair and Rational declared as immutable types, the following constructor fails:\r\n\r\n```julia\r\njulia> ComplexPair(1//2,1)\r\nSegmentation fault: 11\r\n```'
2483,'JeffBezanson','add the ability to pass a filename to include_string\nThat way code parsed by `include_string` can have source location info.'
2482,'JeffBezanson','flisp segfault\nin pointer.jl lines 42 and 43 if both of the x are declared as `x::ANY`, flisp segfaults while reading the file during bootstrapping. test with commit e8d6ba3a7200f7a2093a60b5b585b2253d35450e or 98f57c37f70dc3a13e6ccb059f4ff13bc39322d3\r\n\r\n```julia\r\nunsafe_assign(p::Ptr{Any}, x::ANY, i::Integer) = error("cannot unsafe_assign to contents of type Any")\r\nunsafe_assign(p::Ptr{Ptr{Any}}, x::ANY, i::Integer) = pointerset(convert(Ptr{Any},p), x, int(i))\r\n```'
2463,'dmbates','segfaults in CHOLMOD calls on anj/linalg2 branch\nAn appropriate response on this issue would be "you broke it so you should fix it" except I\'m not sure where the problem is.  I have been working on `extras/suitesparse.jl` in the `db/suitesparse` branch.  As part of the effort to clean up the `extras` directory I moved the suitesparse.jl and suitesparse_h.jl files from `extras` to `base/linalg` in the `anj/linalg2` branch.  The umfpack calls for a sparse LU decomposition and solution of square, sparse linear systems still work but the CHOLMOD-based functions cause segfaults. \r\n\r\nWithout going into details the following sequence run with the anj/linalg2 branch shows that the UMFPACK calls are working.\r\n```\r\njulia> e33 = speye(3,3)\r\n3x3 sparse matrix with 3 nonzeros:\r\n\t[1, 1]  =  1.0\r\n\t[2, 2]  =  1.0\r\n\t[3, 3]  =  1.0\r\n\r\n\r\njulia> e33\\ones(3)\r\n3-element Float64 Array:\r\n 1.0\r\n 1.0\r\n 1.0\r\n```\r\nThe calls to CHOLMOD during the initialization of the Base module have also succeeded\r\n```\r\njulia> using Base.SuiteSparse\r\n\r\njulia> Base.SuiteSparse.chm_com\r\n2704-element Uint8 Array:\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x33\r\n 0x33\r\n    ⋮\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n 0x00\r\n```\r\n(It is not obvious but those 0x33 elements indicate that the initialization of the cholmod_common struct was successful - as does the fact that the initialization of Base finished.)\r\n\r\nA very simple call through ccall works\r\n```\r\njulia> ccall((:cholmod_check_common, :libcholmod), Int32, (Ptr{Uint8},), Base.SuiteSparse.chm_com)\r\n1\r\n```\r\nHowever, any other calls to CHOLMOD-based functions fail with a segfault\r\n```\r\njulia> ccall((:cholmod_check_perm, :libcholmod), Int32, (Ptr{Int32}, Csize_t, Csize_t, Ptr{Uint8},), int32([0:3]), 3, 3, Base.SuiteSparse.chm_com)\r\n\r\nProcess julia segmentation fault (core dumped) at Mon Mar  4 13:57:15 2013\r\n```\r\n\r\nRunning the db/suitesparse branch does not give a segfault on this call\r\n```\r\njulia> require("suitesparse")\r\n\r\njulia> using SuiteSparse\r\n\r\njulia> ccall((:cholmod_check_common, :libcholmod), Int32, (Ptr{Uint8},), SuiteSparse.chm_com)\r\n1\r\n\r\njulia> ccall((:cholmod_check_perm, :libcholmod), Int32, (Ptr{Int32}, Uint, Uint, Ptr{Uint8},), int32([0:3]), 4, 4, SuiteSparse.chm_com)\r\n1\r\n```\r\n'
2451,'StefanKarpinski','The 0.1.1 release\nWe should tag a 0.1.1 release by March 4 or so. This should make it possible for @sebastien-villemot to upload new debian packages, and make it possible for us to ship 0.1.1 in Ubuntu 13.04.\r\n\r\nThe major thing to do for 0.1.1 is to include commit a97bf7668c5003e57cfa38ddee74b88e2d54c915 on the `release-0.1` branch. @StefanKarpinski said this is not a breaking change and should be easy to do.\r\n\r\nThis will make it possible for Ubuntu users to pull in packages that depend on a specific version of Julia (#2315).\r\n\r\n'
2442,'ViralBShah','ldexp not exported from libopenlibm\n```\r\njameson@julia:~/julia-win32$ make test-numbers\r\n    JULIA test/numbers\r\nApplication tried to create a window, but no driver could be loaded.\r\nMake sure that your X server is running and that $DISPLAY is set correctly.\r\nerr:systray:initialize_systray Could not create tray window\r\n     * numbers\r\nERROR: test error during :((float64(int128(0))==0.0))\r\nin ldexp: ccall: could not find function ldexp in library libopenlibm\r\n in ldexp at math.jl:182\r\n in convert at float.jl:23\r\n in float64 at float.jl:45\r\n in anonymous at test.jl:49\r\n in do_test at test.jl:33\r\n in include_from_node1 at loading.jl:89\r\n in runtests at Z:\\home\\jameson\\julia-win32\\test\\runtests.jl:6\r\n in anonymous at no file:22\r\n in include_from_node1 at loading.jl:89\r\n in process_options at client.jl:250\r\n in _start at client.jl:323\r\nat Z:\\home\\jameson\\julia-win32\\test\\numbers.jl:622\r\nat Z:\\home\\jameson\\julia-win32\\test\\runtests.jl:23\r\nmake[1]: *** [numbers] Error 1\r\nmake: *** [test-numbers] Error 2\r\njameson@julia:~/julia-win32$ i686-w64-mingw32-nm usr/lib/libopenlibm.dll | grep ldexp\r\n687490a0 T ___ldexp_cexp\r\n68749210 T ___ldexp_cexpf\r\n68749040 T ___ldexp_exp\r\n687491b0 T ___ldexp_expf\r\n68757710 T _ldexp\r\n68757770 T _ldexpl\r\njameson@julia:~/julia-win32$ \r\n```\r\n\r\nadditionally:\r\n```\r\njulia> ldexp(2.f0,1)\r\nERROR: in ldexp: ccall: could not find function ldexpf in library libopenlibm\r\n in ldexp at math.jl:183\r\n```\r\n\r\non 32-bit wine (windows)'
2429,'vtjnash',"BigInt <-> float interactions\nI found the following definitions helpful for resolving various method not found errors. If they are deemed correct, I'll add them to `base/bigfloat.jl`\r\n```julia\r\npromote_rule{T<:FloatingPoint}(::Type{BigInt},::Type{T}) = BigFloat\r\n^(x::Float32, y::BigInt) = BigFloat(x)^y\r\n^(x::Float64, y::BigInt) = BigFloat(x)^y\r\n```\r\nthese make BigInt*Float64 and BigInt/Float64 and Float64^BigInt work\r\n\r\nalso potentially useful:\r\n```julia\r\nfloat(x::BigInt) = BigFloat(x)\r\n```"
2395,'vtjnash','Bundle cairo and Tk dependencies on Windows\nThe Windows binaries should include Cairo and Tk dependencies as part of the download package.'
2379,'pao',"Move Sphinx plugins and format to Python package\nRight now, if packages want to use ReadTheDocs but want to share style with mainline Julia, it's a copy-and-paste job. I did this to get the `julia` domain for the StrPack.jl docs, but it would be better just to add a submodule dependency so we can track changes made to the upstream documentation format and keep the style in sync."
2375,'JeffBezanson','import/using search order?\nIn the example below are three (top level) modules, `ModA`, `Meta`, and `ModB`. `ModB` attempts to use the other two.\r\nThe trouble is that `ModB` has an implicit `using Base`, which shadows the top level `Meta` module:\r\n\r\n    module ModA\r\n    export myvar_A\r\n    myvar_A=5\r\n    end\r\n\r\n    module Meta\r\n    export myvar_Meta\r\n    myvar_Meta=5\r\n    end\r\n\r\n    module ModB\r\n    using ModA, Meta\r\n    @show myvar_A\r\n    @show myvar_Meta\r\n    end\r\n\r\nRunning this in the repl gives me\r\n\r\n    myvar_A => 5\r\n    ERROR: myvar_Meta not defined\r\n\r\nThis behavior caused me the trouble in https://github.com/toivoh/Debug.jl/pull/35: `Debug.jl` has a sub-module `Debug.Meta`. When `Base.Meta` was added, it shadowed `Debug.Meta` for the other `Debug` sub-modules. In general, it seems to me that the current behavior with implicit `using Base` risks to break existing code each time an export is added to `Base`.\r\n\r\nMy suggestion is to change name lookup within a module according to:\r\n* No implicit `using Base` in any module\r\n* If name lookup fails within a non-bare module, a lookup is made in `Base` as a fallback.\r\n\r\nAn alternative would be to change the interpretation of `using` to provide a fallback only if an identifier is not found in any other way.'
2365,'JeffBezanson',"Interaction of Union and parametric types\nUsing Union type together with parametric types results in inconsistent behaviors.\r\n\r\nLet's consider two types, ``A`` and ``B``. Both have a field of a union type. The only difference is that ``A`` uses a specific type ``Int``, but ``B`` uses a parametric type.\r\n```julia\r\ntype A\r\n    v::Union(Int, Nothing)\r\nend\r\n\r\ntype B{T}\r\n     v::Union(T, Nothing)\r\nend\r\n```\r\n\r\nThe following statements reveal inconsistent behaviors of A and B:\r\n```julia\r\na1 = A(10)  # works ok ==> gets A(10)\r\ntypeof(a1.v)  # works ok ==> gets Int64\r\n\r\na2 = A(nothing)  # works ok ==> gets A(nothing)\r\ntypeof(a2.v)  # works ok ==> gets Nothing\r\n\r\nb1 = B{Int}(10)  # works ok ==> gets B(10)\r\nb2 = B{Int}(nothing)  # ERROR: no method convert(Type{Int64},Nothing)\r\n```\r\n\r\nBasically, for ``A``, Julia correctly resolved the type of the field ``v`` at run-time depending on the input. But for ``B``, Julia (unexpectedly) insists that the value set to the field must be an ``Int`` (and not allowed to be ``nothing``).\r\n\r\nMore delicate behavior is observed when using more than one parametric types with Union.\r\n\r\n```julia\r\ntype C{T1, T2}\r\n    c::Union(T1, T2)\r\nend\r\n\r\nc1 = C{Int, Nothing}(10)  # ==> ERROR: no method convert(Type{Nothing},Int64)\r\nc2 = C{Int, Nothing}(nothing) # ==> ok, gets C{Int64,Nothing}(nothing)\r\nc3 = C{Nothing, Int}(10) # ==> ok, gets C{Nothing,Int64}(10)\r\nc4 = C{Nothing, Int}(nothing) # ==> ERROR: no method convert(Type{Int64},Nothing)\r\nc5 = C{Int, Char}(10) # ==> gets C{Int64,Char}('\\n')\r\n```\r\nIt seem that the type of the field is always resolved to whatever I put as T2, no matter what the input to the constructor is.\r\n\r\nAccording to current documentation, the expected behavior should be that the actual type of the field should be resolved to the type of the value that is assigned to it. Without using parametric types, things behave as expected. But when the parametric types factor in, it becomes weird.\r\n\r\nI believe that something at the type resolution process should be related to such inconsistent behaviors.\r\n"
2364,'JeffBezanson','macros in the REPL can define types, but not macros inside modules\nI am running into a weird inconsistency: a macro defined in the REPL can define a type, but not the identical macro if it was defined inside a module.  For example, the following macro\r\n\r\n    macro foo(T)\r\n        quote\r\n\t    type $T\r\n                bar\r\n            end\r\n        end\r\n    end\r\n\r\nworks fine if I paste it into at the `julia>` REPL prompt (so that `@foo Bar` defines a type `Bar`), but exactly the same macro defined within a module:\r\n\r\n    module Foo\r\n    using Base\r\n    export @foo \r\n    macro foo(T)\r\n           ....\r\n    end\r\n    end\r\n\r\ngives an error:\r\n\r\n    julia> using Foo\r\n    julia> @foo Bar\r\n    ERROR: syntax: invalid type signature\r\n\r\nThis seems like a bug to me, and is preventing some very useful functionality.  (In my PyCall package, I want to have `@pyimport math` define a struct so that `math.sin` etcetera works for functions in the module.)'
2362,'vtjnash','spawn of addprocs_local on wine fails\n```\r\n$ make run-julia DEFAULT_REPL=basic\r\n#winedbg --gdb\r\n/home/jameson/julia-win32/usr/bin/julia-release-basic.exe\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.1.0\r\n _/ |\\__\'_|_|_|\\__\'_|  |  b3d0200-WINNT-i686 (2013-02-19 15:24:48)\r\n|__/                   |\r\n\r\njulia> addprocs_local(1)\r\nAssertion failed!\r\n\r\nProgram: Z:\\home\\jameson\\julia-win32\\usr\\bin\\julia-release-basic.exe\r\nFile: src/win/pipe.c, Line 1210\r\n\r\nExpression: handle->handle != INVALID_HANDLE_VALUE\r\n\r\nabnormal program termination\r\n```\r\n\r\n(looks like this may be coming from the remote worker, since the REPL eventually comes back)'
2361,'JeffBezanson','forgetting commas in export.jl may cause compiler to hang\nIf you add a macro to the bottom of exports.jl and forget to put a comma before it the compiler will hang... I guess because it can see the macro, tries to execute it, but needs parameters maybe.\r\n\r\n    ...\r\n    @show,\r\n    @printf,\r\n    @sprintf\r\n    @new_fun\r\n\r\nNot a huge deal, but kind of funny'
2355,'Keno','process file redirection is leaking handles\n`` run(`this` > "file") `` is leaking a file handle. it should at least close it when the CmdRedirect is gc\'d(), in this case. or maybe it should be lazy opening the file (and closing it immediately)'
2353,'JeffBezanson','macro arguments should be purely Expr types\n    macro foo(ex)\r\n       quote\r\n           $(typeof(ex))\r\n       end\r\n    end\r\n    @foo :Foo \r\n\r\nprints `QuoteNode`, which is an undocumented internal type, rather than the expected `Expr` which is returned by `typeof(:(:Foo))`. '
2351,'JeffBezanson','error introduced by e6800c4f1ca130f6ce32e3901ec337990c149bb9\n```julia\r\njulia> union\r\n# methods for generic function union\r\nunion(s1::IntSet,s2::IntSet) at intset.jl:183\r\nunion() at set.jl:45\r\nunion(s::Set{T}) at set.jl:46\r\nunionError showing value of type Function:\r\nERROR: no method clean_gensym(Expr,)\r\n in argtype_decl_string at show.jl:322\r\n in map at cell.jl:20\r\n in show at show.jl:343\r\n in show at show.jl:358\r\n in repl_show at repl.jl:16\r\n\r\njulia> \r\n```'
2344,'JeffBezanson','Calling string in a function\nHere\'s a function that tries to turn a string into a symbol or\r\nstring, depending on the type of an Associative type:\r\n\r\n```julia\r\nbestkey(d, key) = key\r\nbestkey{K<:String,V}(d::Associative{K,V}, key) = string(key)\r\n```\r\n\r\nIt seems to work at the REPL when called directly, but I get a strange answer when it\'s used in a function:,\r\n\r\n```julia\r\njulia> bestkey(["x" => [1,2,5]], :y)    # right\r\n"y"\r\n\r\njulia> bestkey([:x => [1,2,5]], :y)      # right\r\n:y\r\n\r\njulia> bar(x) = bestkey(x, :y)\r\n# method added to generic function bar\r\n\r\njulia> bar([:x => [1,2,5]])           # right\r\n:y\r\n\r\njulia> bar(["x" => [1,2,5]])        # wrong\r\n":xs"\r\n```'
2335,'ViralBShah',"hist bins\nMatlab's hist function also returns the positions of the bins, which is very useful for plotting. Can this be done now? Or can the return value be trivially altered?\r\n\r\nalso, there is one remaining use of (deprecated) histc in base."
2331,'vtjnash','hang on exit after listen()\nIf I type this:\r\n\r\n```\r\njulia> listen(9008) do sock,s\r\n        s = accept(sock)\r\n       s.readcb = (args...)->(l=readline(s);write(s,l);true)\r\n       start_reading(s)\r\n       end\r\nTcpSocket(connected,0 bytes waiting)\r\n```\r\n\r\nand then quit the repl, julia hangs. Here is a stacktrace during the hang:\r\n\r\n```\r\n^C\r\nProgram received signal SIGINT, Interrupt.\r\n0x00007ffff5b36df9 in syscall () from /lib/libc.so.6\r\n(gdb) bt\r\n#0  0x00007ffff5b36df9 in syscall () from /lib/libc.so.6\r\n#1  0x00007ffff675bf26 in uv__epoll_wait (epfd=9, events=0x7fffffffb030, \r\n    nevents=1024, timeout=-1) at src/unix/linux/syscalls.c:282\r\n#2  0x00007ffff6758c8c in uv__io_poll (loop=0x7ffff7756420, timeout=-1)\r\n    at src/unix/linux/linux-core.c:184\r\n#3  0x00007ffff6743b72 in uv__run (loop=0x7ffff7756420) at src/unix/core.c:271\r\n#4  0x00007ffff6743bd1 in uv_run (loop=0x7ffff7756420) at src/unix/core.c:279\r\n#5  0x00007ffff67164f6 in uv_atexit_hook () at init.c:289\r\n```\r\n'
2270,'Keno','Tests failing in spawn\nI am currently getting test failure in spawn on OS X 10.7.5. I have already done a make cleanall and wiped my usr/ directory.\r\n\r\n````\r\n     * spawn\r\nERROR: test error during :((readall(|(@cmd "echo hello",@cmd "sort"))=="hello\\n"))\r\nErrorException("in spawn: new not defined")\r\n in default_handler at test.jl:19\r\n in do_test at test.jl:27\r\n in include_from_node1 at loading.jl:76\r\n in runtests at /Users/viral/julia/test/runtests.jl:6\r\n in include_from_node1 at loading.jl:76\r\n in include_from_node1 at loading.jl:76\r\n in runtests at /Users/viral/julia/test/runtests.jl:6\r\n in anonymous at no file:22\r\n in include_from_node1 at loading.jl:76\r\n in process_options at client.jl:255\r\n in _start at client.jl:318\r\nat /Users/viral/julia/test/spawn.jl:16\r\n/bin/sh: line 1: 36328 Segmentation fault: 11  /Users/viral/julia/julia ./runtests.jl all\r\nmake[1]: *** [all] Error 139\r\nmake: *** [testall] Error 2\r\n````'
2264,'vtjnash',"Arrow keys don't work on windows anymore. \nPossibly related to the terminal being in cooked mode - /cc @vtjnash "
2256,'vtjnash',"terminal problems with julia-d8a5dc1753-WINNT-i686.zip \nToday I was using the new binaries julia-d8a5dc1753-WINNT-i686.zip  on vista\r\n\r\ncan't use the up arrow ,or copy and paste from the window\r\n\r\ndidn't have these problems before"
2241,'JeffBezanson','>> and << with large shift amounts\n```\r\njulia> 0xdeadbeef>>32\r\n0xdeadbeef\r\n```\r\n\r\nShift amounts greater than the type size give undefined behavior in LLVM. I suggest we either throw an error, or give 0 or -1 depending on sign extension.'
2239,'JeffBezanson',"Compiler crashes on very large expressions\nDon't ask why I'm trying to do this, but the compiler fails/crashes for me in the following two examples:\r\n\r\n```julia\r\nfunction crash1()\r\n    N = 10000000\r\n    arr = Array(Any,N)\r\n    for i in 1:N\r\n        arr[i] = :($i+1)\r\n    end\r\n    eval(expr(:vcat,arr))\r\n    return\r\nend\r\n\r\njulia> crash1()\r\nERROR: syntax: malformed expression\r\n in crash1 at none:38\r\n```\r\n\r\n```julia\r\nfunction crash2()\r\n    N = 100000\r\n    code = quote\r\n        arr = Array(Any,$N)\r\n    end\r\n    for i in 1:N\r\n        push!(code.args,:(arr[$i] = $i+1))\r\n    end\r\n    eval(code)\r\n    return\r\nend\r\n\r\njulia> crash2()\r\nSegmentation fault (core dumped)\r\n```\r\n\r\nFor smaller values of ``N``, both functions work.\r\n\r\nHere's the backtrace from ``crash2``:\r\n```\r\nProgram received signal SIGSEGV, Segmentation fault.\r\n0x00007ffff6b72308 in fl_map1 () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n(gdb) backtrace\r\n#0  0x00007ffff6b72308 in fl_map1 () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#1  0x00007ffff6b6fe8d in apply_cl () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#2  0x00007ffff6b727e0 in do_trycatch () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#3  0x00007ffff6b6fc95 in apply_cl () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#4  0x00007ffff6b727e0 in do_trycatch () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#5  0x00007ffff6b6fc95 in apply_cl () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#6  0x00007ffff6b71ef8 in _applyn () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#7  0x00007ffff6b7265b in fl_applyn () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#8  0x00007ffff6b26542 in jl_expand () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#9  0x00007ffff6b5fcdf in jl_toplevel_eval_flex.part.4 ()\r\n   from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n#10 0x00007ffff6b287a4 in jl_f_top_eval () from /mnt/hdd/mlubin/julia/usr/bin/../lib/libjulia-release.so\r\n```\r\n\r\nFor ``crash1``, Julia uses close to 4gb of ram before it gives the error message. Could it be an overflow?"
2211,'JeffBezanson','anonymous things created by `eval` calls disappear\nEval-ing in a module seems to work differently than outside, and I\'m not quite sure why.\r\n\r\nConsider the function: \r\n\r\n    function myeval(code)\r\n      try\r\n        expr = parse_input_line(code)\r\n        result = eval(expr)\r\n        println(result)\r\n    \r\n      catch error\r\n        println(error)\r\n      end\r\n    end\r\n\r\nDefined outside of a module and called like so:\r\n\r\n    julia> myeval("a = [i + rand() for i = 1:10]")\r\n    [1.8569, 2.6153, 3.58617, 4.00185  ...  7.5571, 8.65708, 9.22999, 10.7174]\r\n\r\n    julia> myeval("a")\r\n    [1.8569, 2.6153, 3.58617, 4.00185  ...  7.5571, 8.65708, 9.22999, 10.7174]\r\n\r\nHere, `a` hangs around for use later. But place the function inside module mymodule, and call like so:\r\n\r\n    julia> mymodule.myeval("a = [i + rand() for i = 1:10]")\r\n    [1.50793, 2.60217, 3.15404, 4.78595  ...  7.47104, 8.67797, 9.18002, 10.5204]\r\n\r\n    julia> mymodule.myeval("a")\r\n    a not defined\r\n\r\nIn both examples `a` is defined at the global scope (you can see that if you just type `a` instead of `myeval("a")`)\r\n\r\nI think the revealing thing, and the reason I\'d count this as a bug, is that if I define the function inside a module and say\r\n\r\n    julia> mymodule.myeval("a = 22")\r\n    22\r\n\r\n    julia> mymodule.myeval("a")\r\n    22\r\n\r\neverything works fine... so it seems to be that the anonymous things I\'m referencing are disappearing.'
2210,'StefanKarpinski','finalize sorting API\n'
2204,'JeffBezanson','remove amap, each_row etc.\nWe have `amap`, `each_row`, `each_col`, and `each_vec`, all of which can be combined into a single function that applies a function over some dimension. Let the bikeshedding begin.'
2200,'StefanKarpinski',"stats function triage\nWent through `base/statistics.jl` yesterday, trying to figure out what should stay in base and what should go into a hypothetical new `Stats.jl` package for basic statistics functionality that doesn't go into base. The reason for this is twofold: some stats stuff probably just doesn't belong in the base; putting it in a package allows us to continue to evolve the stats API with more flexibility while still stabilizing the core language. Here's what I came up with:\r\n\r\n```\r\nkeep:\r\n\tmean\r\n\tmedian\r\n\tvar\r\n\tstd\r\n\thist\r\n\tautocor\r\n\tcov (pearson; delete the alias)\r\n\tcor (pearson; delete the alias)\r\n\tquantile\r\n\tpercentile\r\n\tquartile\r\n\tquintile\r\n\tdecile\r\n\tiqr\r\n\r\nrename:\r\n\tdist => distmatrix?\r\n\thistc => hist (unify)\r\n\r\nmove in to Stats.jl:\r\n\tmad\r\n\tskewness\r\n\tkurtosis\r\n\ttiedrank\r\n\tcov_spearman\r\n\tcor_spearman\r\n\trle\r\n\tirle\r\n```\r\n\r\nWanted to get this out there for people more knowledgable about basic status usage than me to comment on.\r\n\r\ncc: @dmbates, @johnmyleswhite, @HarlanH."
2169,'JeffBezanson','Reading Arrays of composite struct\nI think this should work:\r\n```\r\njulia> cd("dir")\r\n\r\njulia> type Foo{T}\r\n       a::T\r\n       end\r\n\r\njulia> import Base.read\r\n\r\njulia> read{T}(io::IO,::Type{Foo{T}}) = Foo(read(io,a))\r\n\r\njulia> fd=open("file");\r\n\r\njulia> read(fd,Array(Foo{Float64},1))\r\nno method read(IOStream,TypeVar)\r\n in read at io.jl:108\r\n in read at io.jl:369\r\n```\r\n\r\nchanging \r\n\r\n```\r\nfunction read{T}(s::IO, a::Array{T})\r\n    for i = 1:length(a)\r\n        a[i] = read(s, T)\r\n    end\r\n    return a\r\nend\r\n```\r\n\r\nto \r\n\r\n```\r\nfunction read{T}(s::IO, a::Array{T})\r\n    for i = 1:length(a)\r\n        a[i] = read(s, eltype(a))\r\n    end\r\n    return a\r\nend\r\n```\r\n\r\nworks, but it doesn\'t seem like that should be necessary. Maybe some kind of type inference issue? @JeffBezanson '
2161,'JeffBezanson',"Constructor returns nothing\nThe following test fails on the second to last line.  Maybe I'm an idiot, but this behavior seems really weird if it's not a bug.  Running bda9432 on a 32-bit machine in case that matters.  The commented out version of the constructor ABCD seems to make things work.\r\n\r\n```Julia\r\ntype AB{T<:Real}\r\n    a::T\r\n    b::T\r\nend\r\nAB{T<:Real}(a::T, b::T) = AB{T}(a, b)\r\nAB(a::Real, b::Real) = AB(promote(a, b)...)\r\n@test typeof(AB(0.0, 0)) != Nothing\r\n@test typeof(AB(0, 0.0)) != Nothing\r\n\r\ntype ABC{T<:Real}\r\n    a::T\r\n    b::T\r\n    c::T\r\nend\r\nABC{T<:Real}(a::T, b::T, c::T) = ABC{T}(a, b, c)\r\nABC(a::Real, b::Real, c::Real) = ABC(promote(a, b, c)...)\r\n@test typeof(ABC(0.0, 0, 0)) != Nothing\r\n@test typeof(ABC(0, 0.0, 0)) != Nothing\r\n@test typeof(ABC(0, 0, 0.0)) != Nothing\r\n\r\ntype ABCD{T<:Real}\r\n    a::T\r\n    b::T\r\n    c::T\r\n    d::T\r\nend\r\nABCD{T<:Real}(a::T, b::T, c::T, d::T) = ABCD{T}(a, b, c, d)\r\nABCD(a::Real, b::Real, c::Real, d::Real) = ABCD(promote(a, b, c, d)...)\r\n#ABCD(a::Real, b::Real, c::Real, d::Real) = ABCD(promote(a, promote(b, promote(c, d)...)...)...)\r\n\r\n@test typeof(ABCD(0.0, 0, 0, 0)) != Nothing\r\n@test typeof(ABCD(0, 0.0, 0, 0)) != Nothing\r\n@test typeof(ABCD(0, 0, 0.0, 0)) != Nothing # fails here\r\n@test typeof(ABCD(0, 0, 0, 0.0)) != Nothing\r\n```\r\n\r\n[pao: formatting, note that `@test` (or any Julia macro call) outside a quote block in an issue will ping that user on GitHub, who must be very cross with us by now]"
2153,'vtjnash','Better printing of errors when type parameters are missing.\nI see this warning when I forget to include the type parameter in a function. Note the spelling: `linalg_dense.jlT` - a space after the filename would help.\r\n\r\n````\r\nWarning: replacing module Base\r\n linalg_dense.jlT not defined\r\n in include at boot.jl:248\r\n in include_from_node1 at loading.jl:76\r\n in process_options at client.jl:259\r\n in _start at client.jl:322\r\nat linalg_dense.jl:408\r\n````'
2149,'Keno','struct passing bug(?)\n@vtjnash knows what I am talking about from IRC. Struct return seems to be working, but struct passing is problematic.\r\n\r\ndebugging lines:\r\nhttps://github.com/ihnorton/CIndex.jl/blob/purejl/lib/wrapcindex.cpp#L79-L89\r\n\r\ndebugging output:\r\nhttps://gist.github.com/4653523#file-gist1-L4-L12\r\n\r\nall of the hashes should match.\r\n\r\nthe branch with attempt to use pure julia structs is here:\r\nhttps://github.com/ihnorton/CIndex.jl/tree/purejl'
2145,'vtjnash','update ccall documentation\nStruct support has been merged -- documentation needs to be updated accordingly'
2139,'vtjnash',"reinstall SIGFPE handler on windows\nWhile spelunking around Julia this evening, I ran into an interesting bug.\r\n\r\n```\r\njulia> mod(10,0)\r\n0x00A9C50A (0x0000000A 0x00000000 0x0028F958 0x6F40B42D) <unknown module>\r\n0x00A9C4E0 (0x0402E2D0 0x0028F97C 0x00000002 0x6F411858) <unknown module>\r\n0x6F40B42D (0x02D1CC10 0x0028F97C 0x00000002 0x00000000), jl_apply_generic() + 0x5D bytes(s)\r\n0x6F43D684 (0x00000000 0x00000000 0x0028FA18 0x6F44706F), jl_dump_function() + 0xF64 bytes(s)\r\n0x6F43D07B (0x0402E2B0 0x00000800 0x00000004 0x03A85A70), jl_dump_function() + 0x95B bytes(s)\r\n0x6F4475CB (0x0404C600 0x0028FAE0 0x00000002 0x0297FEC0), jl_uncompress_ast() + 0x1AEB bytes(s)\r\n0x6F40F08B (0x00B30000 0x00000000 0x77179B10 0x5A551101), jl_enter_handler() + 0x18B bytes(s)\r\n0x77179B03 (0x02FBEC98 0x0028FCB4 0x00000002 0x031DA360), free() + 0x39 bytes(s)\r\n0x6F40B42D (0x022F9700 0x0028FC94 0x03356390 0x0028FD00), jl_apply_generic() + 0x5D bytes(s)\r\n0x6F40E797 (0x6FC13CD5 0x0346DF40 0x0299DCBC 0x0299DC5C), jl_prepare_ast() + 0x12C7 bytes(s)\r\n0x77179B10 (0x0346DF40 0x0299DCBC 0x0299DC5C 0x0324AA40), free() + 0x46 bytes(s)\r\n0x6FC13CD5 (0x03201800 0x00000000 0x00000000 0x00000000), LLVMDisposePassManager() + 0x11095 bytes(s)\r\n0x6F40B42D (0x032017B0 0x00000000 0x00000000 0x7719C265), jl_apply_generic() + 0x5D bytes(s)\r\n0x00401888 (0x00000000 0x00B376AC 0x76C9ED5E 0x00000004)\r\n0x6F44068F (0x00000000 0x00B376AC 0x00401760 0x00B304D0), julia_trampoline() + 0x4F bytes(s)\r\n0x0041A525 (0x00000000 0x00B376AC 0x00B32188 0x00000000), jl_clear_input() + 0x16AB5 bytes(s)\r\n0x004013EA (0x7FFDE000 0x0028FFD4 0x7792AC69 0x7FFDE000)\r\n0x761D8543 (0x7FFDE000 0x5AEE1C1A 0x00000000 0x00000000), BaseThreadInitThunk() + 0xE bytes(s)\r\n0x7792AC69 (0x004014D0 0x7FFDE000 0xFFFFFFFF 0x779A1D86), RtlInitializeExceptionChain() + 0x85 bytes(s)\r\n0x7792AC3C (0x004014D0 0x7FFDE000 0x00000000 0x78746341), RtlInitializeExceptionChain() + 0x58 bytes(s)\r\nUnexpected FPE Error\r\n```\r\n\r\nI'm pretty sure this scares the pants off most people, so I'm wondering if this needs to be caught and return Inf, -Inf, NaN, etc.\r\n\r\nJust thought I'd bring it up.\r\n\r\nCheers.\r\n\r\n-Jacob\r\n\r\n[pao: formatted error block]"
2134,'ViralBShah','rand(Int,dims...)\n```julia\r\njulia> rand(Int)\r\n8842904633933359347\r\n\r\njulia> rand(Int,10)\r\nno method rand(BitsKind,Int64)\r\n```'
2133,'vtjnash',"Building Julia ignores value of USE_SYSTEM_NGINX\nWhen building Julia using\r\n```\r\nmake USE_SYSTEM_NGINX=1 [...]\r\nmake install USE_SYSTEM_NGINX=1 [...]\r\n```\r\nnginx gets built and installed no matter what the value of USE_SYSTEM_NGINX. This is obviously because it isn't checked anywhere.\r\n\r\nI think this is related to commits e5af8eb and 5a64a64 : `make install` depends on target webrepl, which in turn installs nginx unconditionally."
2129,'Keno','error in getaddrinfo\n```\r\njulia> Base.getaddrinfo("mit.edu")\r\nin getaddrinfo_callback: addrinfo_list not defined\r\n in getaddrinfo_callback at socket.jl:178\r\n in anonymous at socket.jl:186\r\n in event_loop at multi.jl:1398\r\n in anonymous at client.jl:304\r\n```\r\n'
2128,'Keno','parallel regression\nRight now I am unable to start julia in parallel. I get\r\n```\r\nAndreass-MacBook-Pro:julia andreasnoackjensen$ julia -p 2\r\nUsing pipes/files as STDIN is not yet supported. Proceed with caution!\r\n\r\n```\r\nand nothing happens. I have the same problem on Ubuntu.'
2125,'Keno','I/O metaissuse\n1. [x] Bikeshed socket API\r\n2. [ ] Write buffering\r\n3. [ ] Performance improvements for reading (probably needs I/O benchmarks)\r\n4. [x] Complete UV based file API (preferably after Struct patch merge)\r\n5. [x] Move initial I/O detection into julia and make STDIO object appropriate julia objects accordingly (depends on 4)\r\n'
2119,'Keno','spawn test failures on centos\njulia 1c10b5ceeeea6cf63f7cbcda0e8f1a01860fe64e\r\n\r\n**On centos6.2 (gcc 4.6.1)**\r\n\r\n```\r\n$ make testall\r\n...\r\n     * iostring\r\n     * spawn\r\ntest error during :((readall(@cmd "echo hello | sort")=="hello | sort\\n"))\r\nfailed process: Process(`echo hello | sort`, ProcessSignaled(11)) [-1]\r\n in default_handler at test.jl:19\r\n in do_test at test.jl:27\r\n in include at boot.jl:248\r\nat /scratch/r/rbond/nolta/julia/test/spawn.jl:15\r\nmake[1]: *** [all] Error 1\r\nmake: *** [testall] Error 2\r\n```\r\n\r\nBut the test passes if run on its own:\r\n\r\n```\r\n$ make test-spawn\r\n    JULIA test/spawn\r\n     * spawn\r\n       [stdio passthrough ok]\r\n    SUCCESS\r\n```\r\n\r\n**On centos 5.8 (gcc 4.4.6)**\r\n\r\n```\r\n$ make test-spawn\r\n    JULIA test/spawn\r\n     * spawn\r\ntest failed: :((search(out,"world")!=(0,0)))\r\n in default_handler at test.jl:18\r\n in do_test at test.jl:27\r\n in include at boot.jl:248\r\nat /home/nolta/julia/test/spawn.jl:19\r\n```\r\n\r\n'
2117,'vtjnash','strtok_s entry point not found on Windows Server 2003\nI tried to run the latest Windows Julia on our old Windows server and got the error\r\n\r\n"The procedure entry point strtok_s could not be located in the dynamic link library msvcrt.dll"\r\n\r\nI don\'t know if the problem is Windows or Julia.'
2101,'StefanKarpinski',"Consistent alignment for vector printing\nIt would be nice if the horizontal alignment for printing vectors didn't shift as the size of the entries grows:\r\n\r\n    julia> v = [161490.0, 19979.8, 826720.0, 1.62837e6]\r\n    4-element Float64 Array:\r\n     161490.0      \r\n      19979.8      \r\n     826720.0      \r\n          1.62837e6\r\n"
2100,'JeffBezanson',"Add language keywords to REPL auto-complete?\nWhat do people think of the idea of adding Julia's keywords to the list of auto-completes offered at the REPL? Right now, `quot\\t` produces the suggestion `quote_string` and does not suggest `quote`. Adding keywords like `quote` might be helpful."
2098,'JeffBezanson','Strange range corruption\nI have this piece of code which creates a Range from 1 to some Float value, ending up with a completely bogus vector when some (seemingly harmless) operation is executed on some vaguely related object.\r\n\r\nThe code is as follows:\r\n```julia\r\nfunction main()\r\n        image = Array(Float64, 150, 150)\r\n        println("Size before squeeze: ", size(image))\r\n\r\n        image = squeeze(image)\r\n        println("Size after squeeze: ", size(image))\r\n\r\n        diagonal = hypot(size(image)...)\r\n        println("Diagonal (", typeof(diagonal), "): ", diagonal)\r\n\r\n        distances::Vector = [1:1:diagonal]\r\n        println("Range: ", distances)\r\nend\r\nmain()\r\n```\r\n\r\nThe squeeze is there because in real life the input image can have a third dimension, which I want to strip in case its singular (e.g. Array(T, 150, 150, 1) => Array(T, 150, 150)).\r\nRunning the code results in:\r\n```\r\n$ julia testcase.jl \r\nSize before squeeze: (150,150)\r\nSize after squeeze: (150,150)\r\nDiagonal (Float64): 212.13203435596427\r\nRange: [4607182418800017408, 9214364837600034816  …  -954763121002545152]\r\n```\r\n\r\nThe resulting distances range is completely bogus...\r\n\r\nIf however I comment the squeeze, which should do nothing in this testcase anyhow, I get:\r\n```\r\n$ julia testcase.jl \r\nSize before squeeze: (150,150)\r\nDiagonal (Float64): 212.13203435596427\r\nRange: [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0  …  208.0, 209.0, 210.0, 211.0, 212.0]\r\n```\r\nWhich is valid.\r\n\r\nAnother way of "fixing" the issue is to itrunc the diagonal in the range constructor, which then gives a valid (although integer) range again.\r\n\r\nRun on git master (8261a291340405f3d6c82f3b6d741333d6375d26), with make testall reporting no error whatsoever.'
2092,'JeffBezanson','Error message for malformed type name in function definition\nConsider:\r\n\r\n    function badFunc(typeOK::Int, typeBad::int)\r\n      println("Painful error message ahead")\r\n    end\r\n    \r\n    badFun(2,3)\r\n\r\n\r\nI made this mistake just now (int instead of Int), and the error message is\r\n\r\n```type error: badFunc: in method definition, expected Type{T<:Top}, got Function\r\nat C:\\.......\\bad.jl:3```\r\n\r\nSo "type error" and "method definition" are useful, but the rest is pretty scary, and to be honest I don\'t understand it. Is there any way to make it more understandable?'
2086,'Keno','assertion failure on Ctl-C during output\nAs reported by @staticfloat:\r\n\r\n```\r\njulia> while true; print ("x"); end\r\nxxxxxxxxx\r\n...\r\nxxxxxxx^CxxxxAssertion failed: (!(stream->flags & UV_STREAM_BLOCKING)), function uv_write2, file src/unix/stream.c, line 960.\r\nIllegal instruction: 4\r\n```\r\n\r\nI get this too.'
2080,'Keno','Dll missing extension on windows\nOpened issue as a reminder for me and @vtjnash '
2073,'staticfloat',"undefined lzma symbols on x64 arch linux\nI am still getting:\r\n\r\n```\r\n    LINK usr/bin/julia-release-basic\r\n/home/jeff/src/julia2/julia/usr/lib/libjulia-release.so: undefined reference to `lzma_index_size'\r\n/home/jeff/src/julia2/julia/usr/lib/libjulia-release.so: undefined reference to `lzma_stream_buffer_decode'\r\n/home/jeff/src/julia2/julia/usr/lib/libjulia-release.so: undefined reference to `lzma_index_end'\r\n/home/jeff/src/julia2/julia/usr/lib/libjulia-release.so: undefined reference to `lzma_stream_footer_decode'\r\n/home/jeff/src/julia2/julia/usr/lib/libjulia-release.so: undefined reference to `lzma_index_uncompressed_size'\r\n/home/jeff/src/julia2/julia/usr/lib/libjulia-release.so: undefined reference to `lzma_index_buffer_decode'\r\ncollect2: error: ld returned 1 exit status\r\n```\r\n\r\ndespite `--disable-minidebuginfo` in the libunwind build. `make distclean-unwind` doesn't fix it. It works on `julia.mit.edu`, but not on my arch linux desktop."
2054,'JeffBezanson','Raise warning for failed exports?\nIt would be helpful if a warning were issued whenever an export fails because an exported name already exists in Main. This occurs frequently when using RDatasets:\r\n\r\n    julia> data = [1, 2]\r\n    2-element Int64 Array:\r\n     1\r\n     2\r\n    \r\n    julia> using RDatasets\r\n    \r\n    julia> data("datasets", "iris")\r\n    type error: apply: expected Function, got Array{Int64,1}\r\n'
2052,'StefanKarpinski','Handling errors in unrelated packages while adding\nWhile #2046 was open, I tried installing an unrelated package. \r\n\r\n```jlcon\r\njulia> Pkg.add("UTF16")\r\nUpgrading ArgParse: v0.0.0 => v0.0.0\r\nfatal: reference is not a tree: ca082aa2ac46b2668428808c2fb570db23db64bc\r\nfailed process: Process(`git checkout -q ca082aa2ac46b2668428808c2fb570db23db64bc`, ProcessExited(128)) [128]\r\n in pipeline_error at process.jl:385\r\n in run at process.jl:374\r\n in anonymous at no file:226\r\n in cd at file.jl:22\r\n in _resolve at pkg.jl:225\r\n in anonymous at no file:123\r\n in cd at file.jl:22\r\n in cd_pkgdir at pkg.jl:28\r\n in add at pkg.jl:105\r\n in add at pkg.jl:130\r\n```\r\n\r\nWhile I appreciate that we want a consistent set of packages at all times, I think this will create huge problems as the number of packages grow. When we have hundreds or thousands of packages, the probability that one of them will fail is non-trivial. We should be able to gracefully handle issues in packages that are not currently dependent on the packages we are installing. '
2038,'Keno',"Error while initializing default package repo\nI've been looking a little at this but I haven't quite figured out what's happening. Maybe it's simply failing because that directory doesn't exist? In which case it should probably not error and just keep going?\r\n\r\n    WARNING: Initializing default package repository C:\\Users\\wes\\AppData\\Roaming\\julia\\packages.\r\n    failed process: Process(`rm -rf 'C:\\Users\\wes\\AppData\\Roaming\\julia\\packages'`, ProcessExited(-1)) [-1]"
2027,'Keno','git error after adding a few packages\nThis happened to me on more than a couple of occasions. @loladiro Is this is a libuv related issue?\r\n\r\n````\r\njulia> Pkg.add("Debug")\r\npackage already required: VersionSet("Debug",[])\r\n in anonymous at no file:112\r\n in cd at file.jl:22\r\n in cd_pkgdir at pkg.jl:28\r\n in add at pkg.jl:105\r\n in add at pkg.jl:130\r\n\r\njulia> Pkg.rm("Debug")\r\n\r\njulia> Pkg.add("Debug")\r\nInstalling Debug: v0.0.0\r\nCloning into \'Debug\'...\r\nremote: Counting objects: 1274, done.\r\nremote: Compressing objects: 100% (468/468), done.\r\nremote: Total 1274 (delta 813), reused 1242 (delta 784)\r\nReceiving objects: 100% (1274/1274), 190.63 KiB, done.\r\nResolving deltas: 100% (813/813), done.\r\n\r\njulia> Pkg.add("Profile")\r\nInstalling Profile: v0.0.0\r\nCloning into \'Profile\'...\r\nremote: Counting objects: 82, done.\r\nremote: Compressing objects: 100% (62/62), done.\r\nremote: Total 82 (delta 35), reused 58 (delta 14)\r\nReceiving objects: 100% (82/82), 21.22 KiB, done.\r\nResolving deltas: 100% (35/35), done.\r\n\r\njulia> Pkg.add("Gadfly")\r\npackage already required: VersionSet("Gadfly",[])\r\n in anonymous at no file:112\r\n in cd at file.jl:22\r\n in cd_pkgdir at pkg.jl:28\r\n in add at pkg.jl:105\r\n in add at pkg.jl:130\r\n\r\njulia> Pkg.add("Graphs")\r\nInstalling Graphs: v0.0.0\r\nCloning into \'Graphs\'...\r\nremote: Counting objects: 102, done.\r\nremote: Compressing objects: 100% (77/77), done.\r\nremote: Total 102 (delta 48), reused 73 (delta 19)\r\nReceiving objects: 100% (102/102), 19.59 KiB, done.\r\nResolving deltas: 100% (48/48), done.\r\n\r\njulia> Pkg.add("HDF5")\r\nFailed to create process git: -1\r\n in _jl_spawn at process.jl:154\r\n in spawn at process.jl:200\r\n in spawn at process.jl:221\r\n in attached at git.jl:18\r\n in cd at file.jl:22\r\n in anonymous at no file:201\r\n in anonymous at no file:38\r\n in cd at file.jl:22\r\n in each_submodule at git.jl:37\r\n in _resolve at pkg.jl:198\r\n in anonymous at no file:123\r\n in cd at file.jl:22\r\n in cd_pkgdir at pkg.jl:28\r\n in add at pkg.jl:105\r\n in add at pkg.jl:130\r\n\r\njulia> Pkg.add("GLM")\r\nopen: Too many open files\r\n in system_error at error.jl:22\r\n in cd at file.jl:19\r\n in cd_pkgdir at pkg.jl:28\r\n in add at pkg.jl:105\r\n in add at pkg.jl:130\r\n````'
2026,'JeffBezanson','Reproducible segfault\nThis is not ideal as a bug report (it\'s a little complicated), but it does lead to a reproducible segfault. Given the upcoming demo and the fact that I won\'t have a lot of time to dig into this further myself, I thought I\'d at least report it.\r\n\r\nFor this test, you need the budding SymbolicLP package: https://github.com/timholy/SymbolicLP.jl\r\n\r\nNow, here\'s a test script:\r\n```julia\r\nrequire("SymbolicLP")\r\nusing SymbolicLP\r\nlpb = LPBlock([:left, :middle, :right])\r\naddconstraints(lpb, :(left < middle < right))\r\naddconstraints(lpb, :(left == 0), :(right == 100))\r\naddconstraints(lpb, :(middle-left==right-middle))\r\n# z, x, flag = lpsolve(lpb);\r\nlpp, chunks = lpparse(Float64, lpb)\r\nlpd = lpeval(lpp)\r\nz, x, flag = lpsolve(lpd)\r\nx = x[chunks[1]]\r\nz, x, flag\r\n```\r\nFor me on my machine, running this test script works. However, executing the commented-out line causes a segfault. This is despite the fact that the code after the comment is essentially identical (except for the `pv...`) to the contents of the commented-out line.\r\n'
2024,'ViralBShah',"sporadic dct test failure\nThis seems like a possible memory issue since it doesn't happen all the time, but I occasionally get this during `make testall`:\r\n\r\n```\r\n    JULIA usr/lib/julia/sys.ji\r\nWarning: replacing module Base\r\n    JULIA test/all\r\n     * all\r\n     * core\r\n     * numbers\r\n     * strings\r\n     * unicode\r\n     * corelib\r\n     * hashing\r\n     * remote\r\n     * iostring\r\n     * arrayops\r\n     * linalg\r\n     * fft\r\n     * dct\r\nmake[1]: *** [all] Error 1\r\nmake: *** [testall] Error 2\r\n```\r\n\r\nJust running `make testall` again will then pass, so it's a non-deterministic issue."
2022,'Keno','Ctrl-z for backgrounding does not work anymore\nI used to be able to do Ctrl-z and background the process any time while waiting at the julia prompt. Now, I can do that when julia starts up. Once I run some code, like say `rand(20)` , Ctrl-z does not work any more.\r\n'
2020,'Keno',"flush(OUTPUT_STREAM) is broken\nUsing commit 41658f388a\r\n\r\njulia> flush\r\nMethods for generic function flush\r\nflush(IOStream,) at io.jl:237\r\n\r\njulia> OUTPUT_STREAM\r\nTTY(connected,0 bytes waiting)\r\n\r\njulia> flush(OUTPUT_STREAM)\r\nno method flush(TTY,)\r\n\r\nI haven't followed the reorganization of the streams at all, so I hesitate to tromp in here."
2002,'JeffBezanson',"remaining module refinements\nThese things need to happen to finish off module usability:\r\n\r\n- [x] allow `Mod.foo(x) = x` to add methods to `Mod.foo` without importing\r\n- [x] import everything which `Mod` exports via `importall Mod`\r\n- [x] non-bare modules import all operators by default\r\n- [ ] allow modules to export a type of the same name\r\n\r\nThe last change is strictly breaking but I don't think anyone is relying on it."
1995,'vtjnash','getlocalip should correctly filter out local addresses\nsrc/wrapper.c::544 `if (strcmp(buf,"127.0.0.1")) //TODO: use (ifa.internal == false)`'
1994,'ViralBShah','Add missing sparse array method: A[1:end .!= 3,1:end .!= 2]\nThe following works with dense arrays but not with sparse arrays:\r\n\r\n```Julia\r\nA=spzeros(Float64, 3)\r\nA[1,1] = 0.11\r\nA[2,2] = 0.22\r\nA[3,3] = 0.33\r\nB = A[1:end .!= 3,1:end .!= 2]\r\n```\r\n`no method ref_general(SparseMatrixCSC{Float64,Int64},BitArray{1},BitArray{1})`\r\n\r\n'
1990,'JeffBezanson','document avoiding gc issues with ccall pointers \nit should be documented how to avoid gc mistakes in ccalls\r\n\r\nwhether making a local variable is always sufficient. or just never use pointer() on userland code directly (instead write convert methods)'
1976,'Keno','elide more tuple allocations\nOne hope with the sampling profiler is making our code more efficient; the curse may be that it will trigger questions about things that don\'t actually matter.\r\n\r\nIn that spirit, I\'ve gotten the impression that anytime a tuple is involved, there\'s a likelihood of triggering the garbage collector. It\'s interesting to run the sampling profiler on the following function:\r\n\r\n```julia\r\nfunction myfunc(B::Matrix, n::Int)\r\n    local C\r\n    for i = 1:n\r\n        C = chold(B)\r\n    end\r\n    C\r\nend\r\nA = randn(20, 40);\r\nB = A*A\';\r\n@sprofile myfunc(B, 200000)\r\n```\r\nA large fraction of the samples are taken inside the garbage collector. But at least on my machine, they\'re not where I expected: they seem to occur inside chkstride1.\r\n\r\nI can eliminate many of these "weird" garbage collection events by defining additional functions:\r\n```\r\nfunction chkstride1(A::StridedVecOrMat)\r\n    if stride(A,1) != 1\r\n        error("LAPACK: Matrix must have contiguous columns")\r\n    end\r\nend\r\nfunction chksquare(A::Matrix)\r\n    if size(A, 1) != size(A, 2)\r\n        error("LAPACK: Matrix must be square")\r\n    end\r\nend\r\n```\r\nThen there are still plenty of garbage collection events (so I think this doesn\'t change performance), but this time they\'re in a place that seems to make more sense, `jl_alloc_array_1d`.\r\n\r\nIf we get to a point where we can re-use memory in assignments, I wonder if the tuple behavior will become a source of trouble?\r\n\r\nI\'m asking this in part because I noticed, long ago, that gc was the main bottleneck for the Grid module. At the time, I found this very weird because I designed it to do as little memory allocation as possible. I haven\'t had time to follow this up recently, however.\r\n\r\nAnyway, it was something I found curious, and felt I\'d ask about it.\r\n'
1971,'vtjnash',"_resetstkoflw\nlooks like this should be useful on windows for properly cleaning up after a stack overflow exception (also: stack overflow exception isn't even being handled currently)"
1970,'JeffBezanson','undefined value bug\nThis obviously bad function definition caused segfaults and other badness.\r\n\r\n```julia\r\nfunction quantile!(v::AbstractVector, qs::AbstractVector)\r\n    # make sure the quantiles are in [0,1]\r\n    qs = bound_quantiles(qs)\r\n\r\n    isempty(v)  && error("quantile: empty data array")\r\n    isempty(lq) && error("quantile: empty quantile array")\r\n\r\n    lv = length(v)\r\n    lq = length(qs)\r\n\r\n    index = 1 + (lv-1)*qs\r\n    lo = ifloor(index)\r\n    hi = iceil(index)\r\n    sort!(v)\r\n    isnan(v[end]) && error("quantiles are undefined in presence of NaNs")\r\n    i = index .> lo\r\n    f = float(v[lo])\r\n    i = [1:length(i)][i]\r\n    h = (index - lo)[i]\r\n    f[i] = (1-h).*f[i] + h.*v[hi[i]]\r\nend\r\n```'
1964,'Keno','parallel julia broken with more than 2 processes\n```\r\n$ julia -p 2\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+106756954.rb025\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit b025ac026e (2013-01-09 13:21:40)\r\n|__/                   |\r\n\r\njulia>\r\n```\r\n\r\n```\r\n$ julia -p 3\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+106756954.rb025\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit b025ac026e (2013-01-09 13:21:40)\r\n|__/                   |\r\n\r\njulia> \tFrom worker 3:\texception on 3: type error: getfield: expected CompositeKind, got (ASCIIString,Uint16)\r\n\tFrom worker 3:\t in anonymous at no file:799\r\n```\r\n\r\n```\r\n$ julia -p 4\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\n               _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+106756954.rb025\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit b025ac026e (2013-01-09 13:21:40)\r\n|__/                   |\r\n\r\njulia> \tFrom worker 3:\texception on 3: type error: getfield: expected CompositeKind, got (ASCIIString,Uint16)\r\n\tFrom worker 3:\t in anonymous at no file:799\r\n\tFrom worker 4:\texception on 4: type error: getfield: expected CompositeKind, got (ASCIIString,Uint16)\r\n\tFrom worker 4:\t in anonymous at no file:799\r\n```\r\n\r\nThis is on my laptop and julia.mit.edu, latest pull.'
1961,'vtjnash','event filtering code cleanup\nThe code for the filtering mechanism in stream.jl is really messy.\r\n\r\n* We should remove filtering on a vector of streams, since it is not used anywhere.\r\n* There is also copy&pasted code in there.\r\n* A `WaitTask` is constructed unconditionally, which may be a performance problem.\r\n* I suggest we remove the "soft" events like waiting for a line since they are fairly ad-hoc.\r\n\r\n'
1960,'JeffBezanson','need the ability to detach a child process (setpgid)\nThis blocks multiprocessing.\r\nCtrl-C is being propagated to child processes. This works in the case of workers started via `exec`, but it kills the SSH processes of workers started via SSH:\r\n\r\n```\r\njulia> addprocs_ssh({"localhost"})\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nUsing pipes/files as STDIO is not yet supported. Proceed with caution!\r\nok\r\n\r\njulia> @everywhere println(myid())\r\n1\r\n\tFrom worker 2:\t2\r\n\r\njulia> while true end\r\n^CKilled by signal 2.\r\n\r\n in anonymous at no file\r\n\r\njulia> @everywhere println(myid())\r\n1\r\nexception on 1: read: end of file\r\n```\r\n\r\nFor now, we should detach these SSH processes, and then add the ability to safely propagate the Ctrl-C, if we want it to interrupt the world.'
1954,'ViralBShah','Fix randbeta to use the same algorithm for all methods\nThe methods ```randbeta(Real,Real)``` and ```randbeta!(Real,Real,Array)``` used two different algorithms to generate the variates and the former accepted positive parameters whereas the latter only accepted parameters larger than one.'
1952,'JeffBezanson','exception and backtrace behavior\nThe current approach to getting backtraces from errors is not great. There are basically two options for improvement:\r\n\r\n1. Wrap everything thrown in an `Error` type that includes a `backtrace` field, and maybe a `prev` field for the last error, in case this error was thrown during handling of another.\r\n2. Have a convention that subtypes of `Exception` must have those fields, and store the info in the thrown object.\r\n\r\nWe are leaning towards option 2, since that way the type of an exception will match what was thrown.'
1942,'vtjnash','bug in IOString maxsize\n```\r\njulia> m=IOString(100)\r\nIOString([0x00, 0x00, 0x00, 0x00, 0x00, 0x00  …  0x00, 0x00, 0x00, 0x00, 0x00, 0x00],true,true,true,false,0,100,1)\r\n\r\njulia> takebuf_string(m)\r\n"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0"\r\n```\r\n\r\nMaxsize should not affect the contents. The IOString code does not seem to be consistent about whether the underlying vector size equals the valid data size. It could fully rely on Array to handle growing/shrinking but that\'s optional.'
1934,'Keno','jl_putc\nfunction signature jl_putc(unsigned char, void*) does match usage (int32, void*) in base.'
1930,'Keno','Echoing input line in julia-release-basic\nI use ESS for running Julia within emacs.  Starting today with \r\n\r\nCommit 6ce7d4dff4 (2013-01-08 04:41:38)\r\n\r\njulia-release-basic seems to be echoing input lines which results in the lines appearing twice in the buffer.  How do I turn this off?  (I am assuming that this is due to a change in Julia and not in ESS because I updated Julia but not ESS.)\r\n'
1924,'Keno','replace errno() with libuv version\n- [ ] convert errno() -> uv_last_error()\r\n- [ ] convert E_codes -> libuv E_codes\r\n- [ ] make useful: uv_strerror() / uv_err_name()'
1923,'vtjnash','more specific stream.open status\nstream.open should be more specific about whether the stream is not open but may be in the future, or not open because it is closed / error / EOF. this will allow better error conditioning in wait_*() methods\r\n\r\nroughly, these states may be not-open, open, active, (closing,) and closed\r\n'
1922,'vtjnash','rename wrapper.c\nstream.jl contains all of the libuv interface code, it should be split into the appropriate files (io.jl / stream.jl / process.jl / file.jl)'
1920,'Keno',"UDPStream\nUDP streams aren't actually functional since the functions available on them are wrong"
1919,'Keno','resolve usage of WindowsCallA vs WindowsCallW functions\nCurrent windows calls should probably only apply to ASCII strings'
1917,'JeffBezanson',"Cartesian Product iteration\nThis is a follow-up to the discussion on the julia-users mailing list [here](https://groups.google.com/d/topic/julia-users/dtl--SyFgwY/discussion).\r\n\r\nThere seemed to be good progress but I didn't see any code committed.  "
1908,'StefanKarpinski',"BoundsError in Pkg.update()\nHi, I just upgraded my Julia from a few weeks old version and when I did `Pkg.update()`, it eventually failed with a `BoundsError()`. \r\n\r\nMy `.julia/REQUIRE` contains\r\n```\r\nArgParse\r\nWinston\r\nMCMC\r\n```\r\n\r\n\r\n\r\nHere's the full output:\r\n\r\n```\r\njulia> Pkg.update()\r\nremote: Counting objects: 614, done.\r\nremote: Compressing objects: 100% (276/276), done.\r\nremote: Total 590 (delta 79), reused 577 (delta 66)\r\nReceiving objects: 100% (590/590), 47.31 KiB, done.\r\nResolving deltas: 100% (79/79), completed with 1 local objects.\r\nFrom git://github.com/JuliaLang/METADATA.jl\r\n   12d9f2e..c8bbaa8  master     -> origin/master\r\nUpdating 12d9f2e..c8bbaa8\r\nFast-forward\r\n .gitattributes                          |    1 +\r\n .gitignore                              |    1 +\r\n Cairo/versions/0.0.0/sha1               |    2 +-\r\n Calculus/url                            |    1 +\r\n Calculus/versions/0.0.0/sha1            |    1 +\r\n Calendar/url                            |    1 +\r\n Calendar/versions/0.0.0/requires        |    1 +\r\n Calendar/versions/0.0.0/sha1            |    1 +\r\n Compose/url                             |    1 +\r\n Compose/versions/0.0.0/sha1             |    1 +\r\n DataFrames/versions/0.0.0/sha1          |    2 +-\r\n Debug/versions/0.0.0/sha1               |    2 +-\r\n Distributions/versions/0.0.0/sha1       |    2 +-\r\n FITSIO/url                              |    1 +\r\n FITSIO/versions/0.0.0/sha1              |    1 +\r\n GLU/url                                 |    1 +\r\n GLU/versions/0.0.0/requires             |    1 +\r\n GLU/versions/0.0.0/sha1                 |    1 +\r\n GLUT/url                                |    1 +\r\n GLUT/versions/0.0.0/requires            |    3 +++\r\n GLUT/versions/0.0.0/sha1                |    1 +\r\n Gadfly/url                              |    1 +\r\n Gadfly/versions/0.0.0/requires          |    4 ++++\r\n Gadfly/versions/0.0.0/sha1              |    1 +\r\n GetC/url                                |    1 +\r\n GetC/versions/0.0.0/sha1                |    1 +\r\n Graphs/url                              |    1 +\r\n Graphs/versions/0.0.0/requires          |    1 +\r\n Graphs/versions/0.0.0/sha1              |    1 +\r\n Grid/url                                |    1 +\r\n Grid/versions/0.0.0/sha1                |    1 +\r\n HDF5/url                                |    1 +\r\n HDF5/versions/0.0.0/sha1                |    1 +\r\n HypothesisTests/url                     |    1 +\r\n HypothesisTests/versions/0.0.0/sha1     |    1 +\r\n Ito/url                                 |    1 +\r\n Ito/versions/0.0.0/requires             |    2 ++\r\n Ito/versions/0.0.0/sha1                 |    1 +\r\n JSON/versions/0.0.0/sha1                |    2 +-\r\n Languages/url                           |    1 +\r\n Languages/versions/0.0.0/sha1           |    1 +\r\n Loss/url                                |    1 +\r\n Loss/versions/0.0.0/sha1                |    1 +\r\n MAT/url                                 |    1 +\r\n MAT/versions/0.0.0/requires             |    1 +\r\n MAT/versions/0.0.0/sha1                 |    1 +\r\n OpenGL/url                              |    1 +\r\n OpenGL/versions/0.0.0/requires          |    1 +\r\n OpenGL/versions/0.0.0/sha1              |    1 +\r\n Optim/versions/0.0.0/requires           |    3 +++\r\n Optim/versions/0.0.0/sha1               |    2 +-\r\n Options/versions/0.0.0/sha1             |    2 +-\r\n PLX/url                                 |    1 +\r\n PLX/versions/0.0.0/sha1                 |    1 +\r\n PatternDispatch/url                     |    1 +\r\n PatternDispatch/versions/0.0.0/sha1     |    1 +\r\n ProjectTemplate/url                     |    1 +\r\n ProjectTemplate/versions/0.0.0/requires |    2 ++\r\n ProjectTemplate/versions/0.0.0/sha1     |    1 +\r\n RDatasets/versions/0.0.0/sha1           |    2 +-\r\n README.md                               |   44 +++++++++++++++++++++++++++++++++++---------\r\n Rif/url                                 |    1 +\r\n Rif/versions/0.0.0/sha1                 |    1 +\r\n SDL/url                                 |    1 +\r\n SDL/versions/0.0.0/requires             |    3 +++\r\n SDL/versions/0.0.0/sha1                 |    1 +\r\n TextAnalysis/url                        |    1 +\r\n TextAnalysis/versions/0.0.0/requires    |    3 +++\r\n TextAnalysis/versions/0.0.0/sha1        |    1 +\r\n Tk/versions/0.0.0/sha1                  |    2 +-\r\n Winston/versions/0.0.0/sha1             |    2 +-\r\n 71 files changed, 118 insertions(+), 19 deletions(-)\r\n create mode 100644 .gitattributes\r\n create mode 100644 Calculus/url\r\n create mode 100644 Calculus/versions/0.0.0/requires\r\n create mode 100644 Calculus/versions/0.0.0/sha1\r\n create mode 100644 Calendar/url\r\n create mode 100644 Calendar/versions/0.0.0/requires\r\n create mode 100644 Calendar/versions/0.0.0/sha1\r\n create mode 100644 Compose/url\r\n create mode 100644 Compose/versions/0.0.0/requires\r\n create mode 100644 Compose/versions/0.0.0/sha1\r\n create mode 100644 FITSIO/url\r\n create mode 100644 FITSIO/versions/0.0.0/sha1\r\n create mode 100644 GLU/url\r\n create mode 100644 GLU/versions/0.0.0/requires\r\n create mode 100644 GLU/versions/0.0.0/sha1\r\n create mode 100644 GLUT/url\r\n create mode 100644 GLUT/versions/0.0.0/requires\r\n create mode 100644 GLUT/versions/0.0.0/sha1\r\n create mode 100644 Gadfly/url\r\n create mode 100644 Gadfly/versions/0.0.0/requires\r\n create mode 100644 Gadfly/versions/0.0.0/sha1\r\n create mode 100644 GetC/url\r\n create mode 100644 GetC/versions/0.0.0/requires\r\n create mode 100644 GetC/versions/0.0.0/sha1\r\n create mode 100644 Graphs/url\r\n create mode 100644 Graphs/versions/0.0.0/requires\r\n create mode 100644 Graphs/versions/0.0.0/sha1\r\n create mode 100644 Grid/url\r\n create mode 100644 Grid/versions/0.0.0/sha1\r\n create mode 100644 HDF5/url\r\n create mode 100644 HDF5/versions/0.0.0/sha1\r\n create mode 100644 HypothesisTests/url\r\n create mode 100644 HypothesisTests/versions/0.0.0/sha1\r\n create mode 100644 Ito/url\r\n create mode 100644 Ito/versions/0.0.0/requires\r\n create mode 100644 Ito/versions/0.0.0/sha1\r\n create mode 100644 Languages/url\r\n create mode 100644 Languages/versions/0.0.0/sha1\r\n create mode 100644 Loss/url\r\n create mode 100644 Loss/versions/0.0.0/sha1\r\n create mode 100644 MAT/url\r\n create mode 100644 MAT/versions/0.0.0/requires\r\n create mode 100644 MAT/versions/0.0.0/sha1\r\n create mode 100644 OpenGL/url\r\n create mode 100644 OpenGL/versions/0.0.0/requires\r\n create mode 100644 OpenGL/versions/0.0.0/sha1\r\n create mode 100644 Optim/versions/0.0.0/requires\r\n create mode 100644 PLX/url\r\n create mode 100644 PLX/versions/0.0.0/requires\r\n create mode 100644 PLX/versions/0.0.0/sha1\r\n create mode 100644 PatternDispatch/url\r\n create mode 100644 PatternDispatch/versions/0.0.0/sha1\r\n create mode 100644 ProjectTemplate/url\r\n create mode 100644 ProjectTemplate/versions/0.0.0/requires\r\n create mode 100644 ProjectTemplate/versions/0.0.0/sha1\r\n create mode 100644 Rif/url\r\n create mode 100644 Rif/versions/0.0.0/requires\r\n create mode 100644 Rif/versions/0.0.0/sha1\r\n create mode 100644 SDL/url\r\n create mode 100644 SDL/versions/0.0.0/requires\r\n create mode 100644 SDL/versions/0.0.0/sha1\r\n create mode 100644 TextAnalysis/url\r\n create mode 100644 TextAnalysis/versions/0.0.0/requires\r\n create mode 100644 TextAnalysis/versions/0.0.0/sha1\r\nBoundsError()\r\n in resolve at /Users/owilkman/julia/usr/share/julia/base/pkgmetadata.jl:181\r\n in _resolve at /Users/owilkman/julia/usr/share/julia/base/pkg.jl:193\r\n in anonymous at no file:455\r\n in cd at file.jl:19\r\n in cd_pkgdir at /Users/owilkman/julia/usr/share/julia/base/pkg.jl:22\r\n in update at /Users/owilkman/julia/usr/share/julia/base/pkg.jl:430\r\n```\r\n"
1902,'StefanKarpinski',"RFC: Methods for checking required() and installed() packages\nSee #1888\r\n\r\nI tried returning an empty vector in required(pkg_name) but packages can be added without a specific version being listed. In other words, if I return an empty vector I can't tell the difference between a package that isn't required at all and one that was added without a specific version."
1895,'JeffBezanson','Working with ancestors in the type hierarchy?\nThere are times when it would be helpful to have functions for working with the ancestors of a type: for example, determining the tightest typed array that could hold a set of values. The code below is a quick demo of this sort of functionality:\r\n\r\n\tfunction ancestors(t::Type)\r\n\t\ta = {t}\r\n\t\twhile t != Any\r\n\t\t\tt = super(t)\r\n\t\t\tpush(a, t)\r\n\t\tend\r\n\t\treturn a\r\n\tend\r\n\r\n\tfunction common_ancestors(s::Type, t::Type)\r\n\t\treturn filter(e -> contains(ancestors(s), e), ancestors(t))\r\n\tend\r\n\r\n\tearliest_common_ancestor(s::Type, t::Type) = first(common_ancestors(s, t))\r\n\r\n\t@assert isequal(earliest_common_ancestor(Bool, Real), Real)\r\n\t@assert isequal(earliest_common_ancestor(Bool, String), Any)\r\n\t@assert isequal(earliest_common_ancestor(Char, String), Any)\r\n'
1892,'StefanKarpinski','Package manager: use regular git repositories rather than submodules?\nStefan, can you remind us, what is the advantage of using submodules for the package manager? In practice I _think_ I\'ve seen a number of disadvantages to submodules:\r\n\r\n1. They\'re hard to delete. git does not even provide a "git submodule rm" command, and from googling it seems that people struggle with this issue.\r\n2. Submodules seem harder to develop with, although I\'ve noticed that I have less trouble with submodules I add manually from the command line ("git submodule add repo.jl repo") than ones I add using the package manager. I can\'t remember exactly why I find this to be true, because I\'ve slowly switched to manually adding all of my packages (which defeats the purpose of the package manager). Since these days packages are developed with assumptions about search paths, it\'s just easier to do your development inside .julia.\r\n3. Not sure if it\'s related to submodules, but the problem of a corrupted .julia repository might be exacerbated by the fact that it\'s all one giant git repository. If .julia were simply a directory containing a bunch of independent git repositories, then maybe the system would be less fragile?\r\n\r\nMy git-fu is not currently up to fixing these issues on my own, unfortunately.\r\n\r\nI\'m not sure whether switching to regular repositories (including a git repository for METADATA) would make these problems go away, but I\'m just trying to throw something out there that might help. I guess I\'m wondering whether METADATA could basically exist as a list of urls and sha1s (and eventually keywords, documentation pointers, etc) that say where HEAD should be for each package.'
1876,'JeffBezanson',"1:end indexing doesn't work in some cases\n`x[1:end] ` for arrays `x` gives an error unexpectedly in certain contexts.  e.g.\r\n\r\n    x[1:end] *= 2\r\n\r\nfails with `end not defined`."
1855,'JeffBezanson','clearer error message for :< instead of <:\nThe error message if one accidentally types `:<` instead of `<:` is somewhat confusing:\r\n\r\n    julia> foo{T:<Real}(x::Array{T}) = x\r\n    syntax error: missing comma or } in argument list\r\n\r\nWould be nice to have something more informative.'
1841,'ViralBShah','missing parallel routines (for DArray)\nThe windows binary julia-abee016452 (0.0.0-win32-4) is missing:  \r\n\r\ndzeros(), darray(), dones(), dcell(), dfill(), distribute()\r\n\r\nversion() is also missing'
1831,'JeffBezanson','RFC: ccall with julia types as structs\nThis adds syntax and support for passing julia types to ccall functions, either as StructTypes (by-value) or Pointers to StructTypes (by-reference).\r\n\r\nSome example/test code:\r\n```julia\r\nccall((:cptest,"ztest"), Void, (StructPtr{ComplexPair{Int}},), ComplexPair(122,3))\r\nccall((:cptest,"ztest"), Void, (StructPtr{ComplexPair{Int}},), &ComplexPair(122,3))\r\nccall((:cgptest,"ztest"), Void, (StructPtr{ComplexPair{Float64}},), &ComplexPair(2.,3))\r\n\r\nccall((:cgtest,"ztest"), Void, (Struct{ComplexPair{Float64}},), ComplexPair(2.,3))\r\nccall((:ctest,"ztest"), Void, (Struct{ComplexPair{Int}},), ComplexPair(2,3))\r\n\r\nccall((:sptest,"ztest"), Void, (Struct{ASCIIString},), "asdf")\r\n```\r\n\r\ncompile the following library with `gcc ztest.c -shared -o ztest.so -g -Wall` or `gcc ztest.c -shared -o ztest.dylib -g -Wall` depending on your platform:\r\n```c\r\n#include <stdio.h>\r\n#include <complex.h>\r\n#include <stdint.h>\r\n#include <inttypes.h>\r\ntypedef struct {\r\n    long real;\r\n    long imag;\r\n} complex_t;\r\nvoid ctest(complex_t a) {\r\n    //Unpack a ComplexPair{Int} struct\r\n    printf("%ld + %ld i\\n", a.real, a.imag);\r\n    return;\r\n}\r\nvoid cgtest(complex double a) {\r\n    //Unpack a ComplexPair{Float64} struct\r\n    printf("%g + %g i\\n", creal(a), cimag(a));\r\n    return;\r\n}\r\nvoid cgptest(complex double *a) {\r\n    //Unpack a ComplexPair{Float64} struct\r\n    printf("%g + %g i\\n", creal(*a), cimag(*a));\r\n    return;\r\n}\r\nvoid cptest(complex_t *a) {\r\n    //Unpack a ComplexPair{Int} struct pointer\r\n    printf("%ld + %ld i\\n", a->real, a->imag);\r\n    return;\r\n}\r\nvoid stest(char *x) {\r\n    //Print an Array\r\n    printf("%s\\n", x);\r\n}\r\nvoid sptest(struct { struct { void* t; char* x } *x } x ) {\r\n    //Unpack an ASCIIString\r\n    printf("%s\\n", x.x->x);\r\n}\r\n```'
1822,'vtjnash','ensure 16-byte alignment of arrays on 32-bit x86 architectures\nAs discussed in issue #1806, the intention in Julia is that arrays be allocated with 16-byte alignment, in order to enable SSE/SSE2/AVX optimizations for the DSFMT and FFTW libraries.  Arrays are currently allocated with `malloc`, which is guaranteed to be 16-byte aligned on most 64-bit systems (MacOS X, Windows, GNU libc, Solaris...).  `malloc` is also 16-byte aligned in 32-bit MacOS X.\r\n\r\nUnfortunately, `malloc` is only guaranteed to be 8-byte aligned on 32-bit x86 Windows (and even then only for allocating at least 8 bytes: http://msdn.microsoft.com/en-us/library/83ythb65.aspx) or glibc (http://www.gnu.org/software/libc/manual/html_node/Aligned-Memory-Blocks.html#Aligned-Memory-Blocks).  This is not sufficient for SSE/SSE2/AVX.\r\n\r\nOn Unices, the portable way to ensure 16-byte alignment nowadays is to use `posix_memalign`, which produces pointers that can be deallocated normally with `free`.  (Years ago, this was not available on BSDs, but that seems to have been fixed.)  On 32-bit Windows, there is a function called `_aligned_malloc` (http://msdn.microsoft.com/en-us/library/8z34s9c6.aspx) and a corressponding `_aligned_free`.  (Years ago, `_aligned_malloc` was not widely available, but this seems to have been mostly fixed. At the time, in FFTW we had to implement our own version; this is also pretty easy to do if need be, see `kernel/kalloc.c` in the FFTW sources.)'
1817,'JeffBezanson','support C++ style default arguments?\nIt might be nice to support the C++ default-argument idiom.  i.e. defining\r\n\r\n    f(x, y = 3, z = 0) = .....\r\n\r\nwould be equivalent to defining\r\n\r\n    f(x,y,z) = ....\r\n    f(x,y) = f(x,y,0)\r\n    f(x) = f(x,3,0)\r\n\r\nas I find myself doing the latter a lot.'
1815,'JeffBezanson',"efficient interface for accessing an external c variable's value\nproposed api (new built-in):\r\n`cvalue( (:sym, :lib), Type ) :: Type`\r\n\r\nfunctionally equivalent to \r\n`unsafe_ref( convert( Ptr{T}, dlsym( :sym, dlopen(:lib) ) ) )`\r\nbut with only the unsafe_ref call occurring at runtime, the rest being converted into a llvm global at compile time (similar to the first argument to ccall)\r\n\r\nadditionally, another valuable function would be\r\n`cexists( (:sym, :lib) ) :: Bool`\r\n\r\nthen I think dlsym/dlopen can be removed from the language?"
1812,'staticfloat',"Autodetect 32/64-bit mismatch in OpenBLAS\nI think we could dodge a few errors by checking the result of [openblas_get_config()](https://github.com/xianyi/OpenBLAS/commit/bdf8d9411e2e3698c7462a46e813c148c0e8aa98) to see if it's been compiled 64-bit or 32-bit, as these errors are a little mysterious sometimes.  This is just on the TODO list until OpenBLAS 0.2.6 comes out."
1798,'JeffBezanson','"too many parameters for type alias" on the first call, no problem on the second same call\nHi,\r\n\r\nI am getting "too many parameters for type alias" the first I call a constructor, but it is working when called a second time.\r\nThe example is unfortunately not as short as I wish it could be, and it is using the bridge to R and developing ( https://github.com/lgautier/Rif.jl ).\r\nI am giving a transcript of a full session (the the problem is reproducible) for comments and pointers.\r\n\r\nNear the end, the line\r\n```\r\nv_r = Rif.RArray{Int32,1}(v)\r\n```\r\nresults in an error the first time, but is working the second time.\r\n\r\n```\r\n$julia-release-readline                _\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+105028350.rc78b\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit c78b184005 (2012-12-20 19:11:36)\r\n|__/                   |\r\n\r\njulia> load("Rif")\r\n\r\njulia> \r\n\r\njulia> # set starting parameters for the embedded R\r\n\r\njulia> argv = ["Julia-R", "--slave"]# "--quiet"]\r\n2-element ASCIIString Array:\r\n "Julia-R"\r\n "--slave"\r\n\r\njulia> Rif.setinitargs(argv)\r\n\r\njulia> # initialize embedded R\r\n\r\njulia> Rif.initr()\r\nUsing R_HOME=/usr/local/packages/R/2.15/lib/R\r\n0\r\n\r\njulia> \r\n\r\njulia> # new anonymous R vector of integers\r\n\r\njulia> v = Int32[1,2,3]\r\n3-element Int32 Array:\r\n 1\r\n 2\r\n 3\r\n\r\njulia> v_r = Rif.RArray{Int32,1}(v)\r\ntoo many parameters for type alias\r\n in anonymous at no file\r\n in anonymous at no file\r\n\r\njulia> elt = v_r[1]\r\nv_r not defined\r\n\r\njulia> v_r = Rif.RArray{Int32,1}(v)\r\nRArray{Int32,1}(Ptr{Void} @0x0000000004277010)\r\n\r\njulia> elt = v_r[1]\r\n2\r\n```\r\n\r\nThanks,\r\n\r\n\r\nL.'
1789,'JeffBezanson',"julia -p 2 not working on OSX\nRunning commit 60b229b9bf on Mac OS X 10.8.2, trying to run the following reduction:\r\n```\r\nn = @parallel (+) for i=1:100\r\n                1        \r\n              end\r\n```\r\n\r\nIf I run with single processor, this terminates as expected with the answer 100. If I use julia -p 2, the computation never terminates, and the second process crashes at this stack crawl:\r\n```\r\nThread 0 Crashed:: Dispatch queue: com.apple.main-thread\r\n0   libsystem_kernel.dylib        \t0x00007fff8946e212 __pthread_kill + 10\r\n1   libsystem_c.dylib             \t0x00007fff87020b54 pthread_kill + 90\r\n2   libjulia-release.dylib        \t0x000000010082d37a SignalHandler(int) + 586\r\n3   libsystem_c.dylib             \t0x00007fff8700d94a _sigtramp + 26\r\n4   libsystem_kernel.dylib        \t0x00007fff8946e322 __select + 10\r\n5   libsystem_kernel.dylib        \t0x00007fff8946d20f select + 69\r\n6   ???                           \t0x0000000102612e0b 0 + 4334890507\r\n7   ???                           \t0x0000000102612806 0 + 4334888966\r\n8   ???                           \t0x0000000102612227 0 + 4334887463\r\n9   libjulia-release.dylib        \t0x000000010005afc1 jl_apply_generic + 337\r\n10  ???                           \t0x00000001026121d6 0 + 4334887382\r\n11  libjulia-release.dylib        \t0x00000001000971cf start_task + 223\r\n12  libjulia-release.dylib        \t0x00000001000964ba julia_trampoline + 90\r\n13  julia                         \t0x0000000100001d49 main + 89\r\n14  julia                         \t0x0000000100001344 start + 52\r\n```\r\n[pao: formatting; watch `@`-expressions in GitHub comments, they send emails to people if they're not backticked]"
1784,'JeffBezanson','Strange interaction between return and try/finally\nDiscovered through https://github.com/toivoh/Debug.jl/issues/30 :\r\nIt seems that `try/finally` doesn\'t like that you leave the try block using `return`.\r\nSometimes it gives a syntax error, as in\r\n\r\n    julia> let\r\n               try\r\n                   return 5\r\n               finally\r\n                   println("exiting")\r\n               end                   \r\n           end\r\n       \r\n    syntax error: misplaced return statement at line 3\r\n\r\nSometimes, it just bypasses the `finally` block, as in\r\n\r\n    julia> let\r\n               try\r\n                   return 5\r\n                   3\r\n               finally\r\n                   println("exiting")\r\n               end                   \r\n           end\r\n       \r\n    5\r\n\r\nTo my mind, both of these examples should print out `"exiting"`, and then return the value 5.\r\n\r\nThe reason that I bring this up is because [Debug.jl](https://github.com/toivoh/Debug.jl) wraps each scope block in a `try/finally` to make sure to capture when you leave a block, e.g. for step over/out. If the fix is nontrivial, is there some way to work around this issue in the meantime?\r\n\r\n'
1782,'StefanKarpinski',"file API cleanup\nImplement these decisions:\r\n\r\nhttps://docs.google.com/spreadsheet/ccc?key=0AonDF0GF0Z06dGZSZlRCVmZnWEd3amo5aGZfc2dsWGc#gid=0\r\n\r\nAlso possibly put file operations in their own module? Not sure about that, but it feels a bit funny to have names like `mv` and `cp` in Base. These things aren't something you need to do all the time, after all."
1754,'StefanKarpinski','Safeguards for developing within package repository?\nThe tail end of [this](http://git-scm.com/book/ch6-6.html#Cloning-a-Project-with-Submodules) documentation section describes a slightly scary scenario. Would such an error break the ability to do `Pkg.update()`?\r\n\r\nWhen people are developing from within `.julia`, it would be helpful to have a package manager command that:\r\n\r\n1. pushes any package commits to the public repository\r\n2. upon success of step 1, bumps the version and pushes/pullrequests the change\r\n\r\nOn pull requests for version bumps, would it be possible to automatically check whether the given commit is publicly-accessible?\r\n'
1753,'StefanKarpinski','Improve conversion of existing repository to a package\nConverting an existing repository into a package is not yet as simple as we\'d like. It seems reasonable to hope to be able to do this via two calls, something like:\r\n```\r\nPkg.add(url) # infers the package name from the URL\r\nPkg.register("Packagename", v"0.0.0")\r\n```\r\nThe first generates a "full" (with attached head) repository with read/write permission (assuming one has used the correct url). The latter should basically call `Pkg.version()` and then add the read-only variant of the url to `METADATA/Packagename`.'
1735,'JeffBezanson','Module private macros\nThe delete-unexported-macros optimization makes it impossible to have module-private macros. For example\r\n\r\n    module Spillguts\r\n    \r\n    export @interface_macro #, @implementation_macro\r\n    \r\n    macro interface_macro ()\r\n        :(@implementation_macro)\r\n    end\r\n    \r\n    macro implementation_macro ()\r\n        12\r\n    end\r\n    \r\n    end\r\n    \r\ngives the disappointing result \r\n    \r\n    julia> @Spillguts.interface_macro\r\n    @implementation_macro not defined\r\n'
1727,'JeffBezanson','Parametric functions taking varargs \nBasic setup:\r\n\r\n    abstract Component\r\n\r\n    type Transform <: Component\r\n      x\r\n      y\r\n      z\r\n\r\n      Transform() = new(0, 0, 0)\r\n    end\r\n    \r\n    type Body <: Component\r\n      vel\r\n      curr_force\r\n    \r\n      Body() = new(0, 0)\r\n    end\r\n\r\n    function NewEntity{ T<:Component }(components::Type{T}...)\r\n      # ...\r\n      map((c)->c(), components)\r\n    end\r\n\r\nNow, I would expect something like this to fail:\r\n\r\n    julia> NewEntity(Transform, Transform, Body, Body)\r\n    no method NewEntity(CompositeKind,CompositeKind,CompositeKind,CompositeKind)\r\n     in method_missing at base.jl:81\r\n\r\nBut what is happening here:\r\n\r\n    julia> NewEntity(Transform, Transform)\r\n    (Transform(0,0,0),Transform(0,0,0))\r\n\r\n    julia> NewEntity(Transform, Transform, Body, Body)\r\n    (Transform(0,0,0),Transform(0,0,0),Body(0,0),Body(0,0))\r\n\r\nIt seems like, after the call with only Transform types, there is a\r\n\r\n    NewEntity{ T<:Component }(Transform, Transform, components::Type{T}...)\r\n\r\nin memory or something...'
1717,'JeffBezanson',"for loop surprises\nIn porting code from MATLAB, this one caught me by surprise. Would it be possible (worthwhile) to generate a warning if an inner anonymous function shadows a local array (variable)? The scope of the length(x) call also surprised me, although I can't think of an example where this would matter in real code.\n\nIn MATLAB:\n```matlab\nx = zeros(10,1)\nfor i = 1:length(x)\n    x(i) = 1;\nend\n```\n\nIn Julia:\n```julia\njulia> x=zeros(10,1)\n\njulia> for i = 1:length(x)\n                  x(i) = 1\n              end\nin anonymous: x not defined\n in anonymous at no file\n\njulia> for i = 1:10\n                  x(i) = 1\n              end\n\njulia> x==zeros(10,1)\ntrue\n\njulia> for i = 1:10\n                  x[i] = 1\n              end\n\njulia> x==ones(10,1)\ntrue\n```"
1713,'JeffBezanson',"RFC: prevent conflicts in library symbols\nThis patch obfuscates library symbols before using them in ccall to prevent naming conflicts.\n\nEssentially, I wrote this just to be usable as test code to use to see if a segfault occurs because of a symbol conflict or something else (hence I marked it as RFC since I don't care if it actually gets merged, but just to have available for now)"
1688,'JeffBezanson','macro hygiene problem with a[end]\n```julia\njulia> module Foo\n         export @bug\n         a = [1,2,3]\n         macro bug()\n           quote\n             a[end]\n           end\n         end\n       end\n\njulia> using Foo\n\njulia> @bug\nend not defined\n```'
1667,'StefanKarpinski',"protect pkg initialization from ctrl-c\nMany of issues I've seen mentioned on the julia mailing lists seem to stem from incomplete initialization of something, for one reason or another. I believe that git internally tries to prevent too much inconsistent state whenever possible (such as during checkout and pull). However, this does not seem to apply during init() or clone(). I propose that these two functions (and possibly others such as create and skeleton?) should stage their work in mktempdir() and finish with path_rename() to make them more atomic."
1665,'JeffBezanson','possibly macro hygiene bug for catch block arguments\nHere\'s the module:\n\n```julia\nmodule Test\nexport @test\n\nabstract Result\ntype Success <: Result\n    expr\nend\ntype Failure <: Result\n    expr\nend\ntype Error <: Result\n    expr\n    err\nend\n\ndefault_handler(r::Success) = nothing\ndefault_handler(r::Failure) = error("test failure: $(r.expr)")\ndefault_handler(r::Error)   = error("test error: $(r.expr)\\b$(r.err)")\n\nhandler = default_handler\n\nmacro test(ex)\n    qex = expr(:quote,ex)\n    quote\n        handler(try\n            $(esc(ex)) ? Success($qex) : Failure($qex)\n        catch err\n            Error($qex,err)\n        end)\n    end\nend\n\nend # module\n```\n\nHere\'s the problem:\n\n```julia\njulia> load("test")\n\njulia> using Test\n\njulia> @test true\n\njulia> @test false\ntest failure: false\n in default_handler at /Users/stefan/projects/julia/base/test.jl:17\n\njulia> @test 1\nerr not defined\n```'
1651,'JeffBezanson','make eval() module local\nIf I have a file named `test.jl` containing\n\n~~~julia\nmodule TestMod\n    using Base\n\n    load("strpack")\n\n    type(Point)\n        x::Int8\n        y::Int8\n    end\n\n    function test_unpack()\n        s = "\\x01\\x02"\n        unpack(s, Point)\n    end\nend\n~~~\n\nand then from the repl run\n\n~~~julia\nload("test")\nTestMod.test_unpack()\n~~~\n\nI get the following error:\n\n~~~\nin anonymous: DataAlign not defined\n in anonymous at no file\n in test at /home/bmattern/code/julia/test/test.jl:13\n~~~\n\nDoes strpack need to be modularized in order to be used from a module?'
1647,'JeffBezanson','type inference bug in converting to uncertain type\nExample code:\r\n\r\n```julia\r\nmodule Time\r\nexport TimeDelta\r\n\r\nimport Base.+, Base.-, Base.convert, Base.promote_rule\r\n\r\ntype TimeDelta{p}\r\n    v::Int64\r\nend\r\n\r\nconvert{p,q}(::Type{TimeDelta{p}}, x::TimeDelta{q}) =\r\n    TimeDelta{p}(p <= q ? x.v*10^(q-p) : div(x.v,10^(p-q)))\r\n\r\npromote_rule{p,q}(::Type{TimeDelta{p}}, ::Type{TimeDelta{q}}) = TimeDelta{min(p,q)}\r\n\r\n-{p}(x::TimeDelta{p}) = TimeDelta{p}(-x.v)\r\n+{p}(x::TimeDelta{p}, y::TimeDelta{p}) = TimeDelta{p}(x.v+y.v)\r\n-{p}(x::TimeDelta{p}, y::TimeDelta{p}) = TimeDelta{p}(x.v-y.v)\r\n\r\n+(x::TimeDelta, y::TimeDelta) = +(promote(x,y)...)\r\n-(x::TimeDelta, y::TimeDelta) = -(promote(x,y)...)\r\n\r\nend # module\r\n```\r\n\r\nResult:\r\n\r\n```julia\r\njulia> load("time")\r\n\r\njulia> using Time\r\n\r\njulia> x = TimeDelta{3}(123)\r\n123 kiloseconds\r\n\r\njulia> y = TimeDelta{0}(234)\r\n234 seconds\r\n\r\njulia> +(promote(x,y)...)\r\n123234 seconds\r\n\r\njulia> x + y\r\n^C^C <= infinite loop\r\n```'
1632,'JeffBezanson','Extraneous ambiguity warning: (R, S) vs (T, T)\nThe following code\n\n    f{R,S}(::R, ::S) = 1\n    f{T}(  ::T, ::T) = 2\n\nproduces the ambiguity warning\n\n    Warning: New definition f(T,T) is ambiguous with f(R,S).\n             Make sure f(T,T) is defined first.\n\nthough the second method clearly seems to be more specific.\nThe warning is not produced when the order of definition is reversed:\n\n    g{T}(  ::T, ::T) = 2\n    g{R,S}(::R, ::S) = 1\n'
1628,'JeffBezanson','Inconsistent enumerate behavior (order of evaluation?)\nShould this work consistently?\n\n```julia\n~:$ julia\n\njulia> abstract CXTypeKind\n\njulia> [(i,arg_t) for (i,arg_t) in enumerate( (CXTypeKind,Int32,Uint8) )]\nno method Enumerate((AbstractKind,BitsKind,BitsKind),)\n in method_missing at base.jl:80\n in anonymous at no file\n\njulia> en = enumerate( (CXTypeKind,Int32,Uint8) )\nEnumerate{(AbstractKind,BitsKind,BitsKind)}((CXTypeKind,Int32,Uint8))\n\njulia> [(i,arg_t) for (i,arg_t) in en]\n3-element (Any,Any) Array:\n (1,CXTypeKind)\n (2,Int32)     \n (3,Uint8)  \n```'
1627,'ViralBShah','Cholmod falls over when fed 64-bit ints\nThis is more of a reminder to me (or to Viral, if he gets there first).  Attempts to use anything in ```suitesparse.jl``` with a ```SparseMatrixCSC{Float64,Int64}``` type will fail.  The names of entry points in libcholmod, etc. must be changed from, e.g. ```:cholmod_amd``` to ```:cholmod_l_amd```.'
1611,'JeffBezanson','Curious error involving early return\nWithout 504866e02fb3307c3001b87580785fa87ab87216, the following test script fails:\n\n```julia\nload("profile.jl")\n\n@profile begin\nfunction f1(x::Int)\n  z = 0\n  for j = 1:x\n    z += j^2\n  end\n  return z\nend\nend #@profile\n```\n\nGit bisect blames 9a68a05fbb698d95f10b29170af4c207b13230c6.'
1587,'StefanKarpinski',"Use ILP in Pkg.resolve()\n@StefanKarpinski, this uses integer programming in both `resolve` linear programming steps, as per the commit message in c4d199d03b330885b6c195d3054df608cb6149ff.\n\nI tested it and it seems to work fine, but I'm doing a pull request in case you have more complex cases where you want to test it."
1573,'ViralBShah','sparse matrix eigs, svds fails\neigs and svds run into trouble computing too many eigenvalues/singular values\r\nnot sure if this is expected behavior\r\n\r\njulia> load("sparse.jl")\r\n\r\njulia> load("suitesparse.jl")\r\n\r\njulia> load("arpack.jl")\r\n\r\njulia> A=speye(4)\r\n4x4 sparse matrix with 4 nonzeros:\r\n        [1, 1]  =  1.0\r\n        [2, 2]  =  1.0\r\n        [3, 3]  =  1.0\r\n        [4, 4]  =  1.0\r\n\r\n\r\njulia> svds(A)\r\nerror code -3 from ARPACK saupd\r\n in svds at /home/jeffb/julia/extras/arpack.jl:230\r\n in svds at /home/jeffb/julia/extras/arpack.jl:259\r\n\r\njulia> eigs(A)\r\nCompute fewer eigenvalues using eigs(A, k)\r\n in eigs at /home/jeffb/julia/extras/arpack.jl:83\r\n in eigs at /home/jeffb/julia/extras/arpack.jl:187\r\n\r\njulia> eigs(A,2)\r\n([1.0, 1.0],\r\n4x2 Float64 Array:\r\n -0.0760132  -0.534781\r\n -0.521881    0.360963\r\n  0.539126    0.685331\r\n -0.656662    0.337693)\r\n'
1571,'JeffBezanson','each instance of a comprehension variable should be different\nCurrently we have this:\n\n```julia\njulia> map(f->f(), [ ()->i for i=1:10 ])\n10-element Int64 Array:\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n```\n\nI think this should definitely evaluate to `[1:10]`. I also think that\'s what for loops should do, but in the case of comprehensions, I think the case is much more powerful.\n\nI\'ve tagged this with "parallel" because comprehensions are a very natural place for implicit parallelism in the language, but that essentially would require the semantics I\'m proposing in order to work correctly. Note that I\'m talking about evaluating a normal comprehension using multiple threads, rather than producing a `DArray` distributed across multiple machines.'
1568,'JeffBezanson',"gc on exited task causes segfault\nThe garbage collector is unaware of task->done and/or task->stkbuf == NULL which can cause segfaults. I think all that needs to be changed is adding a code guard, but I wasn't quite sure where it was most appropriate.\n\ncode for record: https://gist.github.com/4109519\nload -> yieldto -> ctrl-c -> reload -> yieldto -> segfault in gc\n\ndebug log for record:\n```\nProcess 21945 stopped\n* thread #1: tid = 0x1f03, 0x000000010007e5d1 libjulia-debug.dylib`gc_mark_stack + 49 at gc.c:473, stop reason = EXC_BAD_ACCESS (code=1, address=0xfffffffffffffe5c)\n    frame #0: 0x000000010007e5d1 libjulia-debug.dylib`gc_mark_stack + 49 at gc.c:473\n   470 \t    while (s != NULL) {\n   471 \t        s = (jl_gcframe_t*)((char*)s + offset);\n   472 \t        size_t i;\n-> 473 \t        jl_value_t ***rts = (jl_value_t***)((char*)s->roots + offset);\n   474 \t        if (s->indirect) {\n   475 \t            size_t nr = s->nroots;\n   476 \t            for(i=0; i < nr; i++) {\n(lldb) bt\n* thread #1: tid = 0x1f03, 0x000000010007e5d1 libjulia-debug.dylib`gc_mark_stack + 49 at gc.c:473, stop reason = EXC_BAD_ACCESS (code=1, address=0xfffffffffffffe5c)\n    frame #0: 0x000000010007e5d1 libjulia-debug.dylib`gc_mark_stack + 49 at gc.c:473\n    frame #1: 0x000000010007e3b5 libjulia-debug.dylib`gc_mark_all + 1093 at gc.c:585\n    frame #2: 0x000000010007cc57 libjulia-debug.dylib`gc_mark + 391 at gc.c:651\n    frame #3: 0x000000010007c964 libjulia-debug.dylib`jl_gc_collect + 68 at gc.c:705\n    frame #4: 0x000000010007d3c5 libjulia-debug.dylib`pool_alloc + 37 at gc.c:342\n    frame #5: 0x000000010007d5ee libjulia-debug.dylib`allocobj + 78 at gc.c:767\n    frame #6: 0x0000000101c5bdec\n    frame #7: 0x0000000100012573 libjulia-debug.dylib`jl_apply + 51 at julia.h:908\n    frame #8: 0x0000000100013fdb libjulia-debug.dylib`jl_apply_generic + 539 at gf.c:1339\n    frame #9: 0x0000000101c5ce04\n    frame #10: 0x000000010001c293 libjulia-debug.dylib`jl_apply + 51 at julia.h:908\n    frame #11: 0x000000010001e1f6 libjulia-debug.dylib`jl_trampoline + 502 at builtins.c:703\n    frame #12: 0x0000000100072ea3 libjulia-debug.dylib`jl_apply + 51 at julia.h:908\n    frame #13: 0x0000000100072d2e libjulia-debug.dylib`start_task + 238 at task.c:377\n    frame #14: 0x0000000100071b45 libjulia-debug.dylib`switch_stack + 117 at task.c:188\n    frame #15: 0x0000000100071abd libjulia-debug.dylib`jl_switch_stack + 29 at task.c:198\n    frame #16: 0x0000000100071735 libjulia-debug.dylib`julia_trampoline + 101 at init.c:289\n    frame #17: 0x00000001000022cd julia-debug-basic`main + 157 at repl.c:294\n    frame #18: 0x0000000100001354 julia-debug-basic`start + 52\n(lldb) frame select 1\nframe #1: 0x000000010007e3b5 libjulia-debug.dylib`gc_mark_all + 1093 at gc.c:585\n   582 \t        }\n   583 \t        else {\n   584 \t            offset = ta->stkbuf - (ta->stackbase-ta->ssize);\n-> 585 \t            gc_mark_stack(ta->state.gcstack, offset);\n   586 \t        }\n   587 \t#else\n   588 \t        gc_mark_stack(ta->state.gcstack, 0);\n(lldb) print *ta\n(jl_task_t) $9 = {\n  (_jl_type_t *) type = 0x0000000101045681\n  (_jl_task_t *) on_exit = 0x0000000101071000\n  (_jl_task_t *) last = 0x000000010220eec0\n  (jl_value_t *) tls = 0x00000001010b4c00\n  (jl_value_t *) consumers = 0x00000001010b4c00\n  (int8_t) done = '\\x01'\n  (int8_t) runnable = '\\x01'\n  (jmp_buf) ctx = {\n    (int) [0] = 1606415696\n    (int) [1] = 32767\n    (int) [2] = 1606414368\n    (int) [3] = 32767\n    (int) [4] = 1606414336\n    (int) [5] = 32767\n    (int) [6] = 1\n    (int) [7] = 0\n    (int) [8] = 7\n    (int) [9] = 0\n    (int) [10] = 0\n    (int) [11] = 0\n    (int) [12] = 15257600\n    (int) [13] = 1\n    (int) [14] = 466995\n    (int) [15] = 1\n    (int) [16] = 0\n    (int) [17] = 0\n    (int) [18] = 8096\n    (int) [19] = 895\n    (int) [20] = 0\n    (int) [21] = 0\n    (int) [22] = 0\n    (int) [23] = 0\n    (int) [24] = 0\n    (int) [25] = 0\n    (int) [26] = 0\n    (int) [27] = 0\n    (int) [28] = 0\n    (int) [29] = 0\n    (int) [30] = 0\n    (int) [31] = 0\n    (int) [32] = 0\n    (int) [33] = 0\n    (int) [34] = 0\n    (int) [35] = 0\n    (int) [36] = 0\n  }\n  (_jl_task_t::<anonymous>)  = {\n    (void *) stackbase = 0x00007fff5fbffad0\n    (void *) stack = 0x00007fff5fbffad0\n  }\n  (jmp_buf) base_ctx = {\n    (int) [0] = 0\n    (int) [1] = 0\n    (int) [2] = 1606417008\n    (int) [3] = 32767\n    (int) [4] = 1606416912\n    (int) [5] = 32767\n    (int) [6] = 0\n    (int) [7] = 0\n    (int) [8] = 0\n    (int) [9] = 0\n    (int) [10] = 0\n    (int) [11] = 0\n    (int) [12] = 0\n    (int) [13] = 0\n    (int) [14] = 470240\n    (int) [15] = 1\n    (int) [16] = 0\n    (int) [17] = 0\n    (int) [18] = 8096\n    (int) [19] = 895\n    (int) [20] = 0\n    (int) [21] = 0\n    (int) [22] = 0\n    (int) [23] = 0\n    (int) [24] = 0\n    (int) [25] = 0\n    (int) [26] = 0\n    (int) [27] = 0\n    (int) [28] = 0\n    (int) [29] = 0\n    (int) [30] = 0\n    (int) [31] = 0\n    (int) [32] = 0\n    (int) [33] = 0\n    (int) [34] = 0\n    (int) [35] = 0\n    (int) [36] = 0\n  }\n  (size_t) bufsz = 652\n  (void *) stkbuf = 0x0000000000000000\n  (size_t) ssize = 652\n  (jl_function_t *) start = 0x0000000107ba6f40\n  (jl_value_t *) result = 0x00000001010b4c60\n  (jl_savestate_t) state = {\n    (_jl_task_t *) eh_task = 0x0000000101071000\n    (jmp_buf *) eh_ctx = 0x0000000000000000\n    (ptrint_t:1) err = 0\n    (ptrint_t:1) bt = 0\n    (jl_gcframe_t *) gcstack = 0x00007fff5fbff6a0\n    (_jl_savestate_t *) prev = 0x0000000000000000\n  }\n}\n(lldb) \n```"
1567,'JeffBezanson','regression in passing char** to ccall\n'
1564,'JeffBezanson','Operator overloading ease-of-use with modules\nOS: MacOS X (10.8.2)\nI was trying the example from the presentation on InfoQ and following is the execution output:\n\nJulia Version 0.0.0+89847179.re208.dirty\nCommit e20808de09 (2012-06-27 18:12:05)*\n\njulia> type ModInt{N} <: Integer\n       k::Int\n       ModInt(k) = new(k % N)\n       end\n\njulia> ModInt{11}(100)\nno promotion exists for ModInt{11} and Int64\nin promote_type at promotion.jl:14\nin abs at number.jl:26\nin show at show.jl:15\nin repl_show at client.jl:40\nin sprint at io.jl:101\nin sprint at io.jl:105\nin __eval_exprs at ../lib/julia/extras/julia_web_base.jl:206\nin include at boot.jl:197\nat ../lib/julia/extras/julia_web_base.jl:225\nin include at boot.jl:197\nsession expired\n\n-----\nI also tried it on the latest build (julia version 0.0.0+102130447.r2894) and got the following:\n\nScenario 1:\n\n               _\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.0.0+102130447.r2894\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 2894f5ea7a (2012-11-17 00:13:13)\n|__/                   |\n\njulia> type ModInt{N} <: Integer\n       k::Int\n       ModInt(k) = new(k % N)\n       end\n\njulia> ModInt{11}(100)\nModInt{11}(1)\n\njulia> +{N}(a::ModInt{N}, b::ModInt{N})=ModInt{N}(a.k+b.k)\n\njulia> x=ModInt{11}(100)\nModInt{11}(1)\n\njulia> x+x\nno method +(Int64,Int64)\n in method_missing at base.jl:74\n in + at none:1\n\njulia> \n\nScenario 2:\n\n               _\n   _       _ _(_)_     |  A fresh approach to technical computing\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.0.0+102130447.r2894\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 2894f5ea7a (2012-11-17 00:13:13)\n|__/                   |\n\njulia> type ModInt{N} <: Integer\n       k::Int\n       ModInt(k) = new(k % N)\n       end\n\njulia> ModInt{11}(100)\nModInt{11}(1)\n\njulia> # addition works\n\njulia> 2+4\n6\n\njulia> +{N}(a::ModInt{N}, b::ModInt{N})=ModInt{N}(a.k+b.k)\nerror compiling anonymous: error in method definition: function Base.+ must be explicitly imported to be extended\n\njulia> '
1562,'StefanKarpinski','TextWrap package installation doesn\'t complete successfully\nFrom no .julia directory at all, the following sequence causes the error:\n\n```require("Pkg")\nPkg.init()\nPkg.add("TextWrap")\n\ninstalling Options v0.0.0\nCloning into \'Options\'...\nremote: Counting objects: 10, done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 10 (delta 1), reused 6 (delta 0)\nReceiving objects: 100% (10/10), done.\nResolving deltas: 100% (1/1), done.\ninstalling TextWrap v0.0.0\nCloning into \'TextWrap\'...\nremote: Counting objects: 12, done.\nremote: Compressing objects: 100% (6/6), done.\nremote: Total 12 (delta 2), reused 12 (delta 2)\nReceiving objects: 100% (12/12), 3.73 KiB, done.\nResolving deltas: 100% (2/2), done.\nThere are both staged and unstaged changes to packages.\n in cd at file.jl:181\n in add at /Users/harlan/Documents/OpenSource/julia/base/pkg.jl:61\n in add at /Users/harlan/Documents/OpenSource/julia/base/pkg.jl:88\n```\n\nI can add Example, Distributions, and Options without a problem, but ArgParse depends on TextWrap, and so installing those causes this error. I can load TextWrap after this, but most other subsequent Pkg operation fails.\n\nThis is from an up-to-date origin/master on OS X 10.8.2, git version 1.7.9.6 (Apple Git-31.1).'
1557,'JeffBezanson','String interpolation unaware of macro-local variables\nThis simple macro\n\n    macro foo ()\n        quote\n            a = 1\n            println("a = ", a)\n            println("a = $a")\n        end\n    end\n\nwhen expanded\n    \n    println(macroexpand(:(@foo)))\n\ngives\n    \n    quote \t#  line 3:\n        #2 = 1\t#  line 4:\n        println("a = ", #2)\t#  line 5:\n        println($(Base).sprint($(print), "a = ", a))\n    end\n    \nConsequently\n    \n    @foo\n\ngives\n\n    a = 1\n    a not defined\n'
1555,'JeffBezanson',"'+', '==' conspire to misbehave\n    for (a,b) in ((2,3),)\n        @assert a+b == 5\n        @assert b+a == 5\n        @assert a+b == b+a\n    end\n\nThe last assertion fails.\n"
1540,'JeffBezanson','Allow adding methods via Foo.bar(x)\nIt may be a clearer convention in many cases to allow adding methods to external global functions by adding a module prefix like this:\r\n\r\n```julia\r\nusing Foo\r\nFoo.bar(x) = x+1\r\n```\r\n\r\nrather than having to do this:\r\n\r\n```julia\r\nusing Foo\r\nimport Foo.bar\r\nbar(x) = x+1\r\n```\r\n'
1536,'JeffBezanson','can\'t serialize inner generic functions\n(Apologies for the title...)  This is a contrived example, but is something that is often convenient to do in certain optimization problems:\r\n\r\n```\r\nfunction test()\r\n    data = Array(Array{Float64,1},10)\r\n    for i=1:10\r\n        data[i] = randn(5)\r\n    end\r\n\r\n    function eval(A)\r\n        function minieval(x)\r\n            x\'*A*x\r\n        end\r\n        pmap(minieval,data)\r\n    end\r\n\r\n    A = randn(5,5)\r\n    eval(A)\r\nend\r\n\r\ntest()\r\n```\r\n\r\nRunning this leads to no good:\r\n\r\n```\r\n$ ~/julia/julia -p 8\r\n               _\r\n   _       _ _(_)_     |\r\n  (_)     | (_) (_)    |\r\n   _ _   _| |_  __ _   |  A fresh approach to technical computing\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+97420535.r2eb7\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 2eb755c877 (2012-09-24 02:54:41)\r\n|__/                   |\r\n\r\njulia> load("test_serialization.jl")\r\nexception on 1: minieval is not serializable\r\nexception on 1: minieval is not serializable\r\nexception on 1: minieval is not serializable\r\nexception on 1: minieval is not serializable\r\nexception on 1: minieval is not serializable\r\nexception on 1: minieval is not serializable\r\nexception on 1: minieval is not serializable\r\n```'
1529,'StefanKarpinski',"Dicts with defaults, etc.\nThis one is straight from Ruby: dicts with default values, provides either by a value (immutable) or a default value generator function. The Ruby style is `(h,k)->...` so that you can choose to cache the default value or not.\n\nAn interesting idea is having type-specific defaults for typed Dicts. Another interesting idea comes from @avibryant's talk at Hacker School: dicts naturally become a monoid if their values form a monoid.\n\nAnother generalization of Dict behavior would come from using different hashing functions. Not sure that's really a great idea though."
1522,'JeffBezanson',"Consider implicit Base\nI believe we've briefly gone over this before, but since it's the Month of Chaos I'd like it to be made as an explicit decision.\r\n\r\nLots of Julia is implemented as pure Julia in the `Base` module. This means that lots of the useful bits of the language are only accessible in a module that has a `using Base` statement, such that nearly every module will end up needing a `using Base`.\r\n\r\nGiven:\r\n\r\n1. Julia will need to be usable by technical non-programmers,\r\n2. Much of what we would consider the core Julia language is in `Base`,\r\n3. The `Main` module already implicitly loads `Base`\r\n\r\nI would suggest that all modules should implicitly open with `using Base`, unless some escape mechanism (TBD, but cf. GHC's `NoImplicitPrelude`) is used to prevent that from occurring.\r\n\r\nIf nearly every module needs it anyways, it seems like the sort of thing that will just annoy the heck out of people for no good reason."
1518,'ViralBShah',"move sparse, glpk & linprog into base\nThe major blocker here is sparse because I don't want to screw up the (re)merge for all of @ViralBShah and @dmbates work on sparse matrices. These modules need to go into base and get loaded by default so that the Pkg module, which relies on them, can get loaded by default so that people can add and remove packages without having to do anything. Or maybe that's too much stuff to load by default?"
1517,'JeffBezanson',"Intrinsics module\nJulia's intrinsics are special and dangerous – most definitely not to be used unless you know what you're doing. We should put them into their own module that isn't used/imported unless explicitly asked for."
1516,'ViralBShah',"issym returns false on A.'*A for matrices when syrk is not used\nI tried to write som test code for linear algebra but it failed because of ```ishermitian``` and ```issymmetric```. For example\r\n\r\n```\r\njulia> for i = 1:20\r\n       mA=randn(5,5)\r\n       println(issym(mA'mA))\r\n       end\r\nfalse\r\ntrue\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\nfalse\r\ntrue\r\nfalse\r\nfalse\r\nfalse\r\n```\r\nI know that floating point representations are not exact, but I would expect ```==(Float,Float)``` to be aware of this. Right now, the solver ```\\(Matrix,VecOrMat)``` uses ```ishermitian```, but I guess that it almost never returns ```true```. Should the requirement be more like ```abs(Float-Float)<sqrt(eps())```?\r\n\r\nI then had a look at ```At_mul_B``` and was surprised by the the requirement of ```size(A,1)>500``` before calling ```syrk_wrapper``` when ```B=A```. Why is it so? The tests do not fail on matrices return from ```syrk``` so that would to some extend solve the first problem, but it should also be faster.\r\n\r\nFinally, is much gained from checking for symmetri/hermitianity before calling the solver in ```\\```? It looks like the test consumes the benefit from the more efficient solver."
1514,'StefanKarpinski',"readall and run hang when command doesn't exist\n```\r\njulia> readall(`foobar`)\r\n```\r\nand\r\n```\r\njulia> run(`foobar`)\r\n```\r\nhang when there is no ```foobar``` executable in the path. \r\n\r\nThis should give an error instead."
1510,'nolta','Add explicit Base. imports to extras/cairo.jl\nFix errors like the following when loading ```cairo.jl```:\r\n```\r\njulia> load("cairo.jl")\r\nerror in method definition: function Base.fill must be explicitly imported to be extended\r\n in load_now at util.jl:231\r\n in load_now at util.jl:245\r\n in require at util.jl:174\r\nat /home/lulu/dev/julia/extras/cairo.jl:200\r\n in load_now at util.jl:231\r\n in load_now at util.jl:245\r\n in require at util.jl:174\r\n in load_now at util.jl:256\r\n in require at util.jl:174\r\n```'
1494,'JeffBezanson',"operations on None[] type arrays\nNone[] type arrays behave exactly like Any[] type arrays, except that push() throws an error. This doesn't seem quite right:\r\n\r\n```julia\r\njulia> x=Array(None,2)\r\n2-element None Array:\r\n #undef\r\n #undef\r\n\r\njulia> grow(x,3)\r\n5-element None Array:\r\n #undef\r\n #undef\r\n #undef\r\n #undef\r\n #undef\r\n\r\njulia> x[1] = Nothing()\r\n\r\njulia> x[2] = Nothing\r\nNothing\r\n\r\njulia> x[3] = Type\r\nType{T<:Top}\r\n\r\njulia> x[4] = 1\r\n1\r\n\r\njulia> x[5] = *;\r\n\r\njulia> x\r\n5-element None Array:\r\n  nothing     \r\n  Nothing     \r\n  Type{T<:Top}\r\n 1            \r\n  * \r\n```"
1479,'JeffBezanson','set test cause internal compiler error on 32-bit systems\n2fee749729fcadeb8d7aff92c7c3bf1a3746a356 appears to cause the following failure on 32-bit systems:\r\n\r\n```\r\n$ make testall\r\n...\r\n     * file\r\nerror compiling append!: error compiling assign: error compiling copy_to: error compiling copy_to_unsafe: error compiling pointer: internal compiler error: invalid type id\r\n in cmd_gen at process.jl:720\r\n in file_create at file.jl:215\r\n in load_now at util.jl:231\r\n in require at util.jl:174\r\n in runtests at /usr/home/nolta/julia/test/runtests.jl:4\r\n in load_now at util.jl:231\r\n in require at util.jl:174\r\n in load_now at util.jl:231\r\n in require at util.jl:174\r\n in runtests at /usr/home/nolta/julia/test/runtests.jl:4\r\n in anonymous at no file:49\r\n in load_now at util.jl:231\r\n in load_now at util.jl:245\r\n in require at util.jl:174\r\n in process_options at client.jl:182\r\n in _start at client.jl:236\r\nat /usr/home/nolta/julia/test/file.jl:22\r\n...\r\n```'
1474,'JeffBezanson','method static parameter behavior\n```julia\r\njulia> type X{a,b} end\r\njulia> Y{A,B}(::Type{X{A,B}}) = 1\r\njulia> Y{A}(::Type{X{A}}) = 2\r\njulia> Y(::Type{X}) = 3\r\n\r\njulia> Y(X)\r\n3\r\n\r\njulia> Y(X{Int})\r\n2\r\n\r\njulia> Y(X{Int,String})\r\nno method Y(CompositeKind,)\r\n in method_missing at base.jl:70\r\n\r\njulia> Y(::CompositeKind) = 4\r\njulia> Y(X{Int,String})\r\n4\r\n```\r\n\r\nThat last one seems incorrect, and seems to result from 2 replacing 1 in the method lookup table, even though they do not apply to the same type.  I could switch the order of declaration of 1 and 2 and it would swap which method declaration was lost.'
1469,'Keno','treat SIGPIPE as normal termination by default?\nSee [this comment](https://groups.google.com/d/msg/julia-dev/OIPGKwM0DOU/oEk8VI1CuA4J) from John Cowan:\r\n\r\n>> In general, Julia\'s command execution is far more careful (aka finicky) when it comes to termination status of subprocesses than the shell or other programming languages.\r\n>\r\n> I very much agree that this is the Right Thing in general, but I also strongly believe that SIGPIPE should be treated as normal termination. Pipes are essentially a form of lazy data stream connecting two coroutines, in which the consumer resumes the producer when it needs more input.  If the consumer chooses not to read from the producer, this ought not to be treated as a fault in the producer, which is what any other sort of signal would mean.  The reason for SIGPIPE to happen at all is to prevent useless processes from hanging about with nowhere to send their output to.\r\n>\r\n> In particular, using ignorestatus on any occasion when the consumer *might* terminate spontaneously without reading all of its input ("sed q" is just one such case), which in principle can mean *any* process that writes to a pipe, will wind up masking actual errors (the best is the enemy of the good). It should be possible to determin that a SIGPIPE has occurred, of course, but it should not propagate an error into the controlling process.\r\n'
1459,'JeffBezanson',"RFC: Show symbols with a colon\nCurrently, symbols show without a colon:\r\n\r\n    julia> :x\r\n    x\r\n\r\nThis patch changes it to\r\n\r\n    julia> :x\r\n    :x\r\n\r\n`print` still produces the raw name when you need it, and thus `string` does as well.\r\n\r\nI think this change would improve clarity. I put an RFC in the title because I wasn't sure if there's a reason that this hasn't been implemented already. Thoughts?\r\n\r\nBtw, I built this patch on top of #1458, since I thought that one would be less controversial. If there's interest for a patch only changes `show` for symbols, I could fix that easily."
1458,'JeffBezanson',"Minor cosmetic improvements for showing of AST:s\nFixes:\r\n\r\n* Show wrongly interpolated AST:s such as `:(x=$[1])` differently from correct AST:s such as `:(x=[1])`, so you can see that they are fishy.\r\n* Get rid of some superfluous quoting in the fallback for exprs that we don't know how to show,\r\n    such as `expr(:foo, 1, :x)`.\r\n* (Added: ) Get rid of superfluous `@` when showing macro invocations. \r\n\r\nBefore:\r\n\r\n    julia> [:(x=$[1]), :(x=[1])]\r\n    2-element Expr Array:\r\n     :( x = [1] )\r\n     :( x = [1] )\r\n\r\n    julia> expr(:foo, 1, :x)\r\n    :( $(expr(:foo, :( 1 ), :x)) )\r\n\r\nAfter:\r\n\r\n    julia> [:(x=$[1]), :(x=[1])]\r\n    2-element Expr :Array:\r\n     :( x = $([1]) )\r\n     :( x = [1] )   \r\n\r\n    julia> expr(:foo, 1, :x)\r\n    :( $(expr(:foo, 1, :x)) )\r\n\r\n\r\nI would like to reduce quoting in the last example further to show it as `expr(:foo, 1, :x)` instead, but I haven't figured out a good way to do that yet. \r\n"
1448,'StefanKarpinski','RFC: Added named regular expressions.\nPCRE supports named regular expressions (ala perl/python/ruby), and they could already be used for back referencing.  This pull request adds a `get_name_table` method to `pcre.jl`, a `capture_dict` variable to `RegexMatch`es to allow access to the named captures, and minor related updates to `Regex`, `show`, etc.  It also adds a blurb in the manual.\r\n'
1444,'johnmyleswhite','Poisson variables from Distributions cause stack overflow\n    load("distributions.jl")\r\n\r\n    import Distributions.*\r\n\r\n    Poisson(19.0)\r\n\r\n    rand(Poisson(19.0))\r\n\r\nOn my machine, the code above consistently produces a stack overflow error. The only input parameter that does not seem to cause this error is `rand(Poisson(1.0))`.\r\n'
1442,'JeffBezanson',"Dispatch inconsistency and confusing ambiguity warning\nIn the code below, \r\n\r\n    type S{T}\r\n    end\r\n\r\n    f(::CompositeKind) = 1\r\n    f{T}(::Type{S{T}}) = 2\r\n\r\nthe second method definition produces the the confusing (and recursive!) ambiguity warning\r\n\r\n    Warning: New definition f(Type{S{T}},) is ambiguous with f(CompositeKind,).\r\n             Make sure f(Type{S{T}},) is defined first.\r\n\r\nEdit: \r\nIt appears there's more to this than just the ambiguity warning:\r\n\r\n    julia> Type{S{Int}} <: CompositeKind\r\n    true\r\n\r\n    julia> f(S{Int})\r\n    1\r\n\r\n    julia> methods(f)\r\n    Methods for generic function f\r\n    f(CompositeKind,) at none:1\r\n    f{T}(Type{S{T}},) at none:1\r\n\r\nSince `Type{S{Int}} <: CompositeKind` I would expect `f(S{Int}) == 2`.\r\nMore generally, I would expect the second method to be more specific than the first.\r\n"
1436,'JeffBezanson','[RFC] Added typed array comprehensions\nFor example:\r\n\r\n```\r\njulia> Integer[i^2 for i=1:3]\r\n3-element Integer Array:\r\n 1\r\n 4\r\n 9\r\n```\r\n\r\nThis was discussed in #947 and [this thread](https://groups.google.com/forum/#!msg/julia-dev/IJkh1sUXq1A/GaLLQgQxu6kJ) on the dev list (and maybe somewhere else).\r\n\r\nTo my mind, this is also the last obstacle in removing the curly notation for Arrays and using it for Dicts, since with this the notation `Any[...]` can be used everywhere in place of `{...}` (unless I forgot something).\r\n\r\nEverything seems in order and working to me, but I learned LISP along the way and it would surely be safer if someone (@JeffBezanson) had a good look.'
1431,'JeffBezanson','Minor bugfixes to #1424\nMake readall(s::IO) read Uint8 instead of Char.\r\nIOString truncate(), close() bugfix: ptr -> io.ptr'
1419,'JeffBezanson','function_loc gives wrong line\nIf a method is defined by a `function` statement, `function_loc` returns the subsequent line. For example:\r\n\r\n```julia\r\njulia> function_loc(function_loc)\r\n("/Users/simon/src/julia/base/util.jl",66)\r\n```\r\n\r\nwhen it actually starts on 65:\r\nhttps://github.com/JuliaLang/julia/blob/master/base/util.jl#L65'
1403,'StefanKarpinski','^ not defined for rationals\n'
1393,'StefanKarpinski','make it easy to disable "quiet" Make\nMotivated by discussion here:\r\n\r\nhttps://github.com/JuliaLang/julia/commit/c6089ee140e742e4a63c64c6067afe26703129cd#commitcomment-2002052\r\n'
1392,'JeffBezanson','Provide mechanism for turning off bounds checking\nBounds-checking can be a source of extra overhead, especially now that we can check each index. Having a mechanism to turn it off would be a nice performance optimization.\r\n\r\nPrevious discussions:\r\nissue #996\r\nhttps://groups.google.com/d/msg/julia-dev/Jz-0f_cLQ_4/XE9lclBz_okJ\r\n'
1389,'JeffBezanson','Redefinition of a constant should be an error, rather than a warning\n[Originally posted on -dev by Fermat 618: https://groups.google.com/d/topic/julia-dev/MOt74gNrc9E/discussion]\r\n\r\nWhen I assign a lambda to a function,\r\n\r\n```\r\njulia> f(x) = x + 2\r\n\r\njulia> f = (x) -> x + 20\r\nWarning: redefinition of constant f ignored.\r\n#<function>\r\n\r\njulia> f(3)\r\n5\r\n```\r\nI find  neither an Error is raised nor the assignment take effect.\r\n\r\nIt is very dangerous to ignore an error. A program that returns a wrong\r\nanswer is much more worse than a program that fails.\r\n\r\nWhen I write something, I expected it to take effect. If it do not, I\r\nexpect an error. A warning is reasonable when someone write\r\n\r\n```\r\n     if (a = b) { xxx; }\r\n```\r\nin C. Even though `if (a == b)` is likely what one want, one can still\r\nignore the warning when he/she is sure `if (a = b)` is wanted. But this\r\nis definitely not the case.\r\n\r\nIn my opinion, a well designed programming language should give as less\r\n[warnings] as possible. '
1384,'JeffBezanson',"`import A.*` vs `import A.something` behaves differently on defining `something`\n(on 184662749bae6f45569a5ffe5edae4a117a904b3)I found those two to be different; with the definition:\r\n\r\n    module Foo\r\n      a(x) = b(x)\r\n      export a,b                \r\n    end\r\n\r\n    import Foo.*\r\n    b(x) = 2\r\n    a(:something) #Fails; b earlier (apparently)didn't extend Foo.b, just Main.b\r\n\r\nVersus: Edit: you have to restart julia, and redefine the module above\r\n\r\n    import Foo.b, Foo.a #edit added Foo.a\r\n    b(x) = 2\r\n    a(:something) #Succeeds.\r\n\r\nI dont see this difference mentioned in the manual. I dont see why this doesn't create a problem with my overloads on the iterator stuff, though. (`start`, `next, done`..)\r\n\r\nWhat i also dont see in the documentation/other notes:\r\n\r\n* I was hoping `import SomeModule` might look up the relevant file(s) and load them. Currently i `load` the files with the modules in them, and then repeat myself saying what to import. Just specifying a file to load for each module would be nicer..\r\n\r\n* Relative to what directory are `include`/`load`s are, if you have a . It seems that if i `load` a file, it forgets `LOAD_PATH` or something. Maybe if they're being loaded as said in the previous point, it should be relative to the given path?\r\n\r\n* (edit)Camelcase convention on modules clashes with names of `type`s, and doesnt match how i name projects.. I think i'll go for `_`-ed names.."
1379,'JeffBezanson','should for create a new binding for each iteration?\n[post from Stefan regarding example below]\r\n\r\nThe key is that without a let the same i is captured by each closure, so the two closures actually do the same thing. With a let i, each iteration has a different i and the closures are thus different and each one when called will return the value of its own i, i.e. the corresponding iteration number. This is a very Lispy thing.\r\n\r\nI have previously thought that it might be good if each iteration of a for loop implicitly had its own i, but that might adversely affect performance. I suspect, however, it would be easier to reason about, would possibly allow us to eliminate the let keyword, and might be more friendly to implicit parallelism since it breaks the dependency between different iterations.\r\n\r\n[the example]\r\n\r\nDoes Julia intend that these two ways of assigning an anonymous function yield different results?\r\n\r\nM=Array(Any,2)\r\nfor i in 1:2\r\n   M[i] = () -> i\r\nend\r\n\r\n\r\nM[1](), M[2]()\r\n(2, 2)\r\n\r\nwhile\r\n\r\nN=Array(Any,2)\r\nN[1] = () -> 1\r\nN[2] = () -> 2\r\nN[1](), N[2]()\r\n(1,2)\r\n\r\n\r\n'
1351,'vtjnash','more complete version info\nAs @vtjnash suggests:\r\n\r\nSomething like ver(), that provides more complete information, would probably be nice to add. I currently can think of the following to include:\r\n* Base.libblas_name\r\n* Base.VERSION\r\n* `uname -mprsv`\r\n* uv_cpu()'
1349,'ViralBShah','Fix of return type from gels (least squares A\\B, when B is a vector).\n...ur as gesv!.'
1345,'JeffBezanson',"Supplying (x;y) as an argument is the same as supplying y\nI think I know what's going on here--`x` is evaluated for side-effects, its result discarded, then `y` returned. Unfortunately, `randi()` can take either a 2-tuple of integers or a single integer as first argument, and let's say I've been writing a lot of vector literals...\r\n\r\n```Julia\r\nrandi((-10, 10)) # correct\r\nrandi((-10; 10)) # will never return a negative number; equivalent to randi(10)\r\n```\r\n\r\n```\r\njulia> (x -> x[2])((1,2))\r\n2\r\n\r\njulia> (x -> x[2])((1;2))\r\nno method ref(Int64,Int64)\r\n in method_missing at base.jl:70\r\n in anonymous at no file\r\n```\r\n\r\nThis seems like a bit of a trap, given the visual similarity of `;` and `,`. The interaction with `randi()` is worse, since the output is random anyways, you might not notice."
1344,'ViralBShah',"rand(-1) throws MemoryError with no (useful) message\n```\r\njulia> rand(-1)\r\nMemoryError()\r\n in rand at rng.jl:148\r\n```\r\n\r\n1. I would have expected this to be a different type of error. Do we have a list of standard exceptions and what they mean?\r\n1. The error message tells me the name of the exception, and I do get a backtrace, but provides no indication as to what I did wrong. Note that `randi()` uses a first argument differently; while we're MATLAB compatible this is another one where MATLAB is kind of confusing.\r\n\r\nI'd look to see what MATLAB does here except I'm not at work. Preemptively assigning to @ViralBShah because he's been doing the RNG refactoring."
1342,'JeffBezanson','relative importing\nQuoting Stefan:\r\n\r\n```\r\n    module Foo\r\n      module Bar\r\n        export baz\r\n      end\r\n      import Foo.Bar.*\r\n    end\r\n```\r\n\r\nIf feels really weird to have to write `import Foo.Bar.*` inside of `Foo` to import from the inner module `Bar`. One thing I can think of is to look for imports relative to the current module first and then fall back to searching relative to `Main`. Another possibility would be to have a syntax for relative import, e.g. `import .Bar.*` or something like that.\r\n'
1340,'JeffBezanson','Malformed macro can hang Julia\n```julia\r\njulia> macro test()\r\n       {Int32}\r\n       end\r\n\r\njulia> @test\r\n```\r\n\r\nAnd off-screen `pkill julia`. Yes, macros can do stupid things, but should be probably be safer than `ccall`s. An earlier, non-reduced testcase just printed "malformed tree" everytime I pressed enter and also had to be pkilled; I think it\'s probably the same root cause.'
1317,'JeffBezanson','morebits from int.jl  is not available at startup\n'
1310,'JeffBezanson','Multiple import statements on one line fails\nThis fails:\n\n````\njulia> import RNG; import RNG.*\nsyntax error: invalid import statement\n````\n\nIt would be great if we could also do:\n`import RNG, RNG.*`'
1306,'vtjnash','Strange EOF behavior in REPL\nIf I start the REPL and enter the code below it works as one would expect the first time, breaking on ctrl-d, but the second time will return immediately.\n\n    while true\n        line = readline(stdin_stream)\n        if line == ""\n            break\n        end\n        print(line)\n    end'
1305,'JeffBezanson','Weird bug\nLike the descriptive title of this issue? I was quite taken with its clarity myself.\n\nGit bisect (my first time using it) blames 57ca955e23127e3f59be42dc1c4365c158cae22a\n\nHere\'s the test code:\n\n```Julia\n\nto_tuple(v::Vector) = ntuple(length(v), i->v[i])\n\nfunction test()\n    szt = to_tuple([5])\n    println(szt)\n    R = zeros(Float64, szt)\n#    R = zeros(Float64, (5,))\n    println(size(R))\n    sR = [strides(R)...]\n    skipR = sR[1]\n    indices = [1]\n    n = 5\n    startR = sum((indices-1).*sR)+1\n#    startR = 1\n    skipR = 1\n    println("startR = $startR, skipR = $skipR, typeof(startR) = ", typeof(startR))\n    rR = Range(startR, skipR, n-1)\n    println("$n $rR $skipR")\n    rR.start += skipR\n    println("$n $rR $skipR")\n    return first(rR)\nend\n\n@assert test() == 2\n\nexit()\n```\n\nOne of the funny things is that if you uncomment _either_ of those two lines, it works correctly, despite the suggestion from the println output that neither one should change anything.\n\nHere\'s the correct output:\n```\n(5,)\n(5,)\nstartR = 1, skipR = 1, typeof(startR) = Int64\n5 1:1:4 1\n5 2:1:5 1\n```\n\nHere\'s the incorrect output:\n```\n(5,)\n(5,)\nstartR = 1, skipR = 1, typeof(startR) = Int64\n5 1:1:4 1\n5 15786448:1:15786451 1\nassertion failed: :( (test()==2) )\n```\n'
1292,'JeffBezanson','++ doubleplusungood\n```\njulia> n = 1\n1\n\njulia> n++\n(type-error string.find string #<eof>)\nunexpected error: #0 (char-numeric? #<eof>)\n#1 (parse-unary/lambda/lambda/lambda\n #<eof>)\n#2 (parse-LtoR [#f #<io stream> #f #f] #fn("8000r1c0qe1|3141;" [#fn("9000r1e0|316@0e1c2c3|3231530]2c4|e5326=0c6qe7~3141;e8e9~31~42;" [closing-token?\n  error #fn(string) "unexpected " #fn(memq) unary-ops #fn("9000r1c0qe1i10a[3141;" [#fn("<000r1~c0<17702~c1<16O02e2|3117E02|c3=16<02e4i20a[316P0c5qe6e7i20a[|c3=~c0<33i203241;c8qe9i203141;" [-\n  + char-numeric? #\\. read-char #fn(";000r1c0e1i3031c2326i0|c3W6A0e4c5c6|y3231530]2e7i30e8i10|32322c9i10e:i3031L3;|;" [#fn(memq)\n  peek-token (^ .^) #int64(-9223372036854775808) error #fn(string)\n  "invalid numeric constant " ts:put-back! maybe-negate call parse-factor])\n  parse-juxtapose read-number #fn("8000r1e0|31660i10;|c1=6E0e2i30i10322e3i3041;c4qe5i303141;" [closing-token?\n  #\\{ ts:put-back! parse-factor #fn("9000r1|F16802|Mc0<6>0c1c2i20|N43;c2i20|L3;" [tuple\n  #fn(list*) call]) parse-unary]) peek-token]) peek-char]) take-token\n  parse-juxtapose parse-factor]) require-token] parse-unary)\n\t    (// .//))\n#3 (parse-term/lambda (* / ./ % & .* |\\\\| |.\\\\|))\n#4 (parse-LtoR [#f #<io stream> #f #f] #fn("7000r1c0qc141;" [#fn("8000r1c0q]31e1~31^42;" [#fn("6000r1c0qm02|;" [#fn("9000r2c0qe1i2031i20b2[42;" [#fn(";000r2c0|i2032740~;|\\x7f\\x82O0e1i30312i10c2~e3i3031L132\\x7f42;e1i30312e416R02}16L02c0|e53216@02e6i30a[31c7=@6=0e8i30|322~;i10c9|~e3i3031L4|c:<16402|42;" [#fn(memq)\n  take-token #fn(append) parse-rational space-sensitive unary-and-binary-ops\n  peek-char #\\space ts:put-back! call *]) peek-token])]) parse-rational])\n\t\t\t\t\t\t\t  (* / ./ % & .* |\\\\|\n\t\t\t\t\t\t\t     |.\\\\|)] parse-term)\n\t    (<< >> >>> .<< .>> &>> &<<))\n#5 (parse-expr/lambda/lambda/lambda/lambda/lambda\n #f)\n#6 (parse-range [#f #<io stream> #f #f])\n#7 (parse-comparison [#f #<io stream> #f #f]\n\t\t  (> < >= <= == === != .> .< .>= .<= .== .!= .= .! <: >: &> &<))\n#8 (parse-RtoL [#f #<io stream> #f #f] #fn("8000r1e0|c142;" [parse-comparison (>\n  < >= <= == === != .> .< .>= .<= .== .!= .= .! <: >: &> &<)] parse-ineq)\n\t    (<- -- -->))\n#9 (parse-LtoR [#f #<io stream> #f #f] #fn("9000r1e0|e1c243;" [parse-RtoL\n\t\t\t\t\t\t\t    parse-ineq (<- --\n  -->)] parse-arrow)\n\t    (&&))\n#10 (parse-LtoR [#f #<io stream> #f #f] #fn("9000r1e0|e1c243;" [parse-LtoR\n\t\t\t\t\t\t\t    parse-arrow (&&)] parse-and)\n\t    (|\\|\\||))\n#11 (parse-cond [#f #<io stream> #f #f])\n#12 (parse-Nary [#f #<io stream> #f #f] #fn("8000r1c0qe1|3141;" [#fn("8000r1e0~31c1<740|;e2~312c3qc4qe53141;" [peek-token\n  ? take-token #fn(":000r1e0i1031c1<790e2c341;c4~|e5i1031L4;" [take-token :\n\t\t\t\t\t\t\t       error "colon expected in ? expression"\n\t\t\t\t\t\t\t       if parse-cond])\n  #fn("7000r1^k02c1qc2q41;" [range-colon-enabled #fn("7000r1c0qc1qt|302;" [#fn("7000r0e0i3041;" [parse-eq*])\n  #fn("7000r1~302c0|41;" [#fn(raise)])]) #fn("6000r0~k0;" [range-colon-enabled])])\n  range-colon-enabled]) parse-or] parse-cond)\n\t    #\\, tuple (#\\)) #f)\n#13 (parse-RtoL [#f #<io stream> #f #f] #fn("<000r1e0|e1c2c3c4^46;" [parse-Nary\n\t\t\t\t\t\t\t\t parse-cond #\\,\n\t\t\t\t\t\t\t\t tuple (#\\))] parse-comma)\n\t    (= := += -= *= /= //= .//= .*= ./= |\\\\=| |.\\\\=| ^= .^= %= |\\|=| &=\n\t     $= => <<= >>= >>>= ~ .+= .-=))\n```'
1287,'JeffBezanson','return from try and catch blocks\nCurrently returning from a try/catch is a syntax error:\n\n```julia\njulia> function f()\n         try\n           return 1\n         end\n       end\nsyntax error: misplaced return statement at line 3\n\njulia> function g()\n         try\n           error("badness")\n         catch\n           return 1\n         end\n       end\nsyntax error: misplaced return statement at line 3\n```\n\nThose should both really be allowed and handled for you.'
1282,'timholy','don\'t use sizeof in blocked matmul code\nThis use of sizeof makes it nasty to make matmul work for new types:\n\nhttps://github.com/JuliaLang/julia/blob/master/base/linalg_dense.jl#L126\n\nFor an example see https://github.com/JuliaLang/julia/blob/master/examples/modint.jl for which matmul does not work:\n\n```julia\njulia> load("examples/modint.jl")\n\njulia> A = map(ModInt{11}, randi(1000, 10, 10))\n10x10 ModInt{11} Array:\n 8  7  2   7  6   5   7  4   9  4 \n 7  2  0   4  8   10  9  9   8  6 \n 2  4  9   1  10  9   7  9   8  0 \n 8  5  2   0  1   0   7  5   8  3 \n 8  2  9   8  8   4   8  3   8  1 \n 4  2  5   3  10  1   6  5   7  4 \n 1  6  10  6  1   4   3  3   3  5 \n 5  3  4   2  9   3   9  8   7  4 \n 2  1  0   1  0   0   4  0   8  5 \n 7  5  3   1  4   5   1  10  9  10\n\njulia> A^2\nsize of type ModInt{11} unknown\n in sizeof at operators.jl:125\n in _jl_generic_matmatmul at linalg_dense.jl:126\n in _jl_generic_matmatmul at linalg_dense.jl:109\n in power_by_squaring at intfuncs.jl:79\n in ^ at linalg_dense.jl:462\n```'
1278,'JeffBezanson','adding methods to imported functions should not be the default\nCurrently if a module imports `f` and then says `f(...) = ...` it adds a method. This is different from assignments; `f = ...` will always create a new binding. It could also lead to unexpected behavior since you might unintentionally add a method when you meant to have your own (possibly private!) function. The default should be changed.\n\nOne possibility is for the default behavior to be adding `f(x...) = Other.f(x...)`, so the new function falls back to the imported one.\n\nTo add a method to an imported function, you have to specify something like `extend f`.'
1274,'JeffBezanson',"import not at beginning of line doesn't work\n```julia\njulia> x=1; import Base\nunsupported or misplaced expression import\n```"
1273,'timholy','Bug in lapack Tridiagonal/ldlt\nOccasionally, the lapack test fails. I\'ve captured one instance where this happens:\n\n```Julia\ndl = [-0.654981, -0.93716 , -0.459534, -0.0961306]\nd = [1.03823, 1.00984, 1.30874 , 1.23003 , 1.98585]\nv = [0.878788, 0.550649, 1.32675, -0.0301826, -0.48512]\n\n# lines 174-178 of test/lapack.jl\nTs = Tridiagonal(dl,d,dl)\nFs = full(Ts)\ninvFsv = Fs\\v\nTldlt = ldlt(Ts)\nx = Tldlt\\v\n\nerr = norm(x - invFsv)\n\nprintln("err = ", err)\n```\n\nThis prints `err = 19.89758303433311` (while in most cases the value is of the order of 1e-16).\nI get the same result of 2 different machines, one using openblas and another using ATLAS+lapack compiled from source.'
1271,'StefanKarpinski','RFC: process redirections\nThis addresses #307 (and does a little more). There are 2 commits:\n\n1) in the first one, I added file redirections. This allows things as:\n\n```Julia\nrun(`ls` > "out.txt") # write to stdout\nrun(`ls` >> "out.txt") # append to stdout\nrun(`ls nonexistent.txt` .> "err.txt") # write to stderr\nrun(`ls nonexistent.txt` .>> "err.txt") # append to stderr\nrun("in.txt" > `grep xyz`) # read from stdin\n```\n\nNotice that I had to use `.>` for stderr, since `2>` is obviously unavailable. I also had to add `.>>` to the parser. This is as close I could get to the familiar shell syntax without introducing too many new operators, but if anyone comes up with a nicer alternative it would be great.\n\nAll forms have a mirror counterpart, e.g.\n\n```Julia\nrun(`grep xyz` < "in.txt")\n```\n\nand can be used together, since the result of `(>)(::Cmd,::String)` is a Cmd, although they require brackets:\n\n```Julia\nrun((`ls a b` > "out.txt") .> "err.txt")\n```\n\nwhich of course is a side-effect of using comparison operators and inheriting their precedence rules (one more reason to think of some alternative notation, if possible).\n\nEverything works the same when using IOStreams instead of Strings:\n\n```Julia\nopen("out.txt", "w") do f\n    run(`ls` > f)\nend\n```\n\nbut of course in that case there are no append operators, since the mode is inherited from the stream.\n\nApart from notation issues, I think the internals are sound, as I basically extended what\'s already done for pipes.\n\n2) The second commit introduces here-strings and 2-in-1 redirections:\n\n```Julia\nrun("one\\ntwo\\nthree" >>> `grep t`) # prints two and three\nrun(`ls a b` &> "both.txt") # redirects both stdout and stderr\nrun(`ls a b` &>> "both.txt") # same as above, append mode\n```\n\nThere are also the mirror versions `<<<`, `&<` and `&<<`\n\nSo, even more extra operators...'
1268,'JeffBezanson','module init functions\nIt is common for C libraries to require some init call on startup, like `Tk_Init`. It would be nice to know about modules that need to call such functions, and hook them into julia\'s `_init` in the future when julia code is used as a library.\n\nCurrently we have 2 overall phases: definition time (when a source file is loaded) and run time. We need to insert "startup time" in between. It takes place right after load time when you first load a file, and also at startup when "compiled" code is loaded.'
1252,'JeffBezanson','arrayref out-of-range error upon first function parsing\nThe version of [argparse.jl](https://github.com/carlobaldassi/julia/blob/argparse.opt.bug/extras/argparse.jl) in [this branch](https://github.com/carlobaldassi/julia/tree/argparse.opt.bug) displays a very weird bug: the mere existence of the function call on [line 1356](https://github.com/carlobaldassi/julia/blob/argparse.opt.bug/extras/argparse.jl#L1356) (marked by an "XXX") produces the following behaviour:\n\n```\njulia> require("argparse.jl")\n\njulia> import ArgParse.*\n\njulia> p = ArgumentParser();\n\njulia> parse_args(p, {"-h"})\nin ref: arrayref: index out of range\n in parse_args at /home/carlo/Programmi/julia/extras/argparse.jl:1023\n in parse_args at /home/carlo/Programmi/julia/extras/argparse.jl:1013\n```\n\nThe error is triggered when the function `_parse_short_opt` (which contains the line) is called ([line 1083](https://github.com/carlobaldassi/julia/blob/argparse.opt.bug/extras/argparse.jl#L1083)), but I verified that the function is never actually executed, and the offending line 1356 wouldn\'t be reached anyway (the `if` clause chooses the other branch). It seems that the error occurs at parsing time. In fact, calling it twice produces the correct result the second time:\n\n```\njulia> p = ArgumentParser();\n\njulia> parse_args(p, {"-h"})\nin ref: arrayref: index out of range\n in parse_args at /home/carlo/Programmi/julia/extras/argparse.jl:1023\n in parse_args at /home/carlo/Programmi/julia/extras/argparse.jl:1013\n\njulia> parse_args(p, {"-h"})\nusage: <command> [-h]\n\noptional arguments:\n  -h, --help  show this help message and exit\n```\n\nCommenting the function call at line 1356 removes the error.\nAlso, the error happens only when trying to return more than one value.'
1250,'StefanKarpinski','better element type of split result\nDiscussed [here](https://groups.google.com/d/topic/julia-dev/2Cj_tz66B0s/discussion). This requires exposure of the necessary type inference machinery.\n\ncc: @JeffBezanson, @johnmyleswhite'
1239,'Keno','julia-17f50ea4e0-WINNT-i686 jl_getc call\nHello,\n\nFound a small bug when trying the Julia<->Matlab connector in Windows.\n\nFile julia/base/io.jl lines 224-230, "jl_getc" should be "ios_getc"\n\nfunction read(s::IOStream, ::Type{Uint8})\n    b = ccall(:jl_getc, Int32, (Ptr{Void},), s.ios)\n    if b == -1\n        throw(EOFError())\n    end\n    uint8(b)\nend\n\n'
1220,'JeffBezanson','Segfault when creating array incorrectly inside function\nIf you mistakenly try to construct a vector using ``Vector`` rather than ``Array`` inside a function, a segfault results:\n\n```\njulia> function myfun(len::Int)\n         z = Vector(Int, len)\n       end\n\njulia> z = myfun(3)\nSegmentation fault (core dumped)\n```\n\nIf you try the same thing from the command line, it just gives an error.\n'
1212,'StefanKarpinski','readline with vi editing-mode\nEdits made using readline with vi key bindings (.inputrc contains "set editing-mode vi") appear to not update after a CR in the middle of a recalled command.  The edits do take however, if the cursor is positioned at the end of the line after making changes.\n\nExample:\njulia> 2+3\n5\n\n    ESC-k (recall previous line)\n     lr*<CR> (change the + to a * ) move cursor 1 position to the right (l), change \'+\' to \'*\' with "r*" then <CR>\njulia> 2*3\n5\n\n    ESC-k (recall previous line) and <CR>\njulia> 2*3\n5\n\n    ESC-k A<CR> (recall previous line, jump to end of line with \'A\' then <CR>\njulia> 2*3\n6'
1207,'Keno',"libuv git submodule pointing to non-existent tree?\nI am attempting to build Julia on Debian GNU/Linux 6.0.  I'd tell you what git version I'm on (updated master branch today), but git status is hanging.\n\nI re-ran make about 20 times because it kept exiting with uninformative errors, but then kept finding new targets to build.  Finally I got stuck on:\n\nfatal: reference is not a tree: a6d3d8f90f6177d782a5f6cc143e60216ccd3567\nUnable to checkout 'a6d3d8f90f6177d782a5f6cc143e60216ccd3567' in submodule path 'deps/libuv'\nmake[2]: *** [libuv/Makefile] Error 1\nmake[1]: *** [julia-release] Error 2\nmake: *** [release] Error 2\n\nCheers,\nAndrew"
1202,'JeffBezanson','incorrect method match\ncalling methods(::TypeConstructor) should throw a method_missing error, instead it seems to pretend that it is a CompositeKind\n\n```julia\njulia> methods(methods)\nMethods for generic function methods\nmethods(Union(CompositeKind,Function),Any) at inference.jl:31\nmethods(Union(CompositeKind,Function),Any,Any) at inference.jl:32\nmethods(Function,) at util.jl:156\nmethods(CompositeKind,) at util.jl:162\n\njulia> methods(Vector)\ntype TypeConstructor has no field env\n in methods at util.jl:162\n\njulia> isa(Vector,CompositeKind)\nfalse\n\njulia> TypeConstructor | super\nType{T<:Top}\n\njulia> TypeConstructor | super | super\nAny\n```\n\n```julia\nutil.jl:162 :: methods(t::CompositeKind) = t.env\n```'
1200,'JeffBezanson','module generation from macros\nThere are definitely situations where this would be desirable:\n\n```julia\njulia> macro mymodule(name)\n         quote\n           module ($name)\n           end\n         end\n       end\n\njulia> @mymodule Foo\nunsupported or misplaced expression module\n```\n\nFor example, see my enum commit 804f6830bf57a0197cb8589192813b4823c3feba, which would be nicer as a module.'
1199,'JeffBezanson',"problems generating bitstypes from macros\nSee 804f6830bf57a0197cb8589192813b4823c3feba for an example of the issue. It's not just that you can't generate a bitstype from a macro, however, since this simple case works fine:\n\n```julia\nulia> macro mybitstype(N,T)\n           quote\n               bitstype ($esc(N)) ($esc(T))\n           end\n       end\n\njulia> @mybitstype 64 Foo\n\njulia> Foo\nFoo\n\njulia> typeof(Foo)\nBitsKind\n\njulia> Foo.nbits\n64\n```\n"
1196,'JeffBezanson','Inner constructor of parametric type (bug with seg fault)\n(I tried to label this as bug, but can\'t figure out how...)\n\nI found the following when toying around with modular arithmetic.\nI get a segmentation fault with the following incorrect code. (I did realize after a while that the inner constructor is written without the type parameter.)\n\ntype Test{p} <: Number\n  value::Array{Int64,1}\n  Test{p}(x::Array) = new(mod(x,p))  \nend\n\njulia> load("test_inner.jl")\n\nWith a type parameter, I get an error message, ok\njulia> a=Test{Int}([5])\nno method Test(Array{Int64,1},)\n in method_missing at base.jl:70\n\nWith an integer parameter -> crash\njulia> a=Test{5}([5])\nSegmentation fault\n\n\nJulia version:\nVersion 0.0.0+93974770.rfeba\nCommit febaf62ed4 (2012-08-14 22:45:16)\n\nJuha'
1195,'JeffBezanson','be able to replace the top-level module\nThis would provide the equivalent of "clear all" in an acceptable way. Currently magic is required to create and "get inside" the Main module, so we need some kind of interface for this.'
1192,'ViralBShah',"randi(i) not specified for i <= 0\nhelp(randi) says:\n Generate a random integer from 1 to 'n' inclusive\n\nIn practice :\n - if n < 0, randi(n) seems to return the same as randi(-n)\n - randi(0) gives some big integers:\n  julia> [randi(0) for i in 1:10]\n  10-element Int64 Array:\n   4019814217571923104\n   4204180419773589875\n   2089920851382469948\n    126630259232964697\n   1517339501548144743\n   1958160476308144191\n   5662355465365495984\n   958273701257133022\n   3995175444360077141\n  184715128446828109\n\nMaybe these two cases should be specified in the docs, or throw errors instead? (I was bitten by the rand(0) case, where I was indexing an array with a random index, when the computation of n was off by one. I'd definitely favor throwing errors in both cases.)"
1191,'JeffBezanson',"document macro hygienification; expose it to the user\nThe transformation that quoted code generated by macros undergoes before being inserted into a local AST needs two things:\n\n1. documentation in [metaprogramming](http://docs.julialang.org/en/latest/manual/metaprogramming/)\n2. exposure to the user\n\nThese are related because documentation will be much easier and more effective if it can be demonstrated.\n\n**ORIGINAL ISSUE**\n\nOn e519c91d571a7caf9dc96e8ca355d6e5d958bf83, the following:\n\n    function value_one() #Of course it works\n       1\n    end\n    macro defv2 ()                      \n       :(function value_two()\n          2\n         end)\n    end\n    @defv2\n    value_two #Not defined!\n\nFound this out with the [get_c_fun](https://github.com/o-jasper/parse-c-header/blob/master/julia-src/get_c.j) macro.. I'd *much* prefer to keep using that."
1183,'JeffBezanson','Cannot vcat tuples of mixed UTF/ASCII strings\nWhile attempting to fix #946, I ran across a help entry for `glpk` (`glp_minisat1`) containing UTF8 strings, which julia didn\'t like mixed with ASCII strings.  A simple version is below\n\n```julia\njulia> vcat(("a","c"), ("é","b"))\nno method promote_type((CompositeKind,CompositeKind),(CompositeKind,CompositeKind))\n in method_missing at base.jl:70\n in cat at abstractarray.jl:567\n in vcat at abstractarray.jl:581\n```\n\nIt might be that the best solution is to change the representation of the help strings, but I thought I would start here.'
1181,'JeffBezanson','SubArray linear indexing\nSubArrays are very useful to avoid copies \nbut their linear indexing does not seem to work:\n\n> a=reshape(1:12,3,4)\n3x4 Int64 Array:\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n \n> b=sub(a,2:3,3:4)\n2x2 SubArray of 3x4 Int64 Array:\n 8  11\n 9  12\n\n> b[:,:]=99; a\n3x4 Int64 Array:\n 1  4   7  10\n 2  5  99  99\n 3  6  99  99\n\nThis works as expected.\n\n \n> b[:]=99; a\nBoundsError()\n\nThis fails, but would be very convenient.\nIs SubArray linear indexing a planned feature on any timescale?\n'
1180,'JeffBezanson',"quote doesn't handle omitted function arg names\nThis fails:\n\n```julia\njulia> ex = :(f(::Type{Foo}) = 1)\nError showing value of type Expr:\nin show: arrayref: index out of range\n\njulia> ex.args\n2-element Any Array:\n #undef\n   1   \n```\n\nThis works:\n\n```julia\njulia> ex = :(f(x::Type{Foo}) = 1)\nf(x::curly(Type,Foo)) = 1\n\njulia> ex.args\n2-element Any Array:\n  f(x::curly(Type,Foo))\n 1                     \n```"
1179,'JeffBezanson',"re-evaluating macro definitions doesn't replace them\nThis used to work, it no longer does, which is a massive pain for macro development. You have to keep restarting the repl."
1178,'JeffBezanson',"make $ interpolation in quote less greedy\nAll our other interpolations are ungreedy. This is the only one that's greedy and as a result, one ends up having to put parens around almost all interpolations. It's a massive annoyance. I propose that we make $ interpolation in quote minimal as well."
1177,'JeffBezanson','odd parsing of bitstype declarations in quote\n```julia\njulia> T = :Foo;\n\njulia> :(bitstype Int.nbits $T)\n$(*(bitstype(Int,.),nbits),T)\n\njulia> :(bitstype (Int.nbits) $T)\nbitstype(Int.:nbits,Foo)\n```\n'
1175,'ViralBShah','Migrate from fdlibm to openlibm\nOpenlibm offers some benefits over fdlibm:\n\n1. Forked from FreeBSD, and includes a number of fixes\n2. Includes assembly versions of various routines\n3. No need to mix routines from libm and fdlibm for performance as is done currently\n\nIt is already used in the Windows version, and can be made default for mac and linux.\n'
1173,'Keno',"Added support, bindings for readdir() using libuv.\nGet a list of entries in a directory.  \n\nWith the libuv interface, it's not currently possible to get any additional information (vs., with readdir() on unix, you can get read a dirent struct, which includes the file type).  So all additional information will have to come from stat().  But at least it should be portable.  (I am not set up on Windows.  Could someone please test there?)  \n\nComments/concerns/suggestions welcome.\n\nKevin"
1172,'JeffBezanson','volatile declaration needed on values used after a try/catch block\nVariables referenced after a try block need to be forceable sent to ram (somewhat similar to the volatile keyword in C) or values can be unexpectedly lost. (Imagine how bad this could fail if I was opening a file instead, and expecting to be able to reference it to close it in the catch block!). I\'m not quite sure how feasible this is to fix though.\n\n```julia\njulia> function test_volatile()\n\tNP = 0\n\ttry\n\t\twhile true\n\t\t\tNP += 1\n\t\tend\n\tcatch e\n\t\tprintln("Halted at NP=$NP")\n\t\tif !isa(e,InterruptException)\n\t\t\terror(e)\n\t\tend\n\tend\n\tprintln("NP is now $NP")\nend\n\njulia> test_volatile()\n^C\nHalted at NP=0\nNP is now 0\n\njulia>\n```'
1164,'JeffBezanson','[ x for x=x ]\nAdmittedly abusive naming, but this probably ought to work, no?\n\n```julia\njulia> x = [1,2,3];\n\njulia> [ x for x=x ]\nin anonymous: #1 not defined\n in anonymous at no file\n```\n\nEven if disallowed, this is certainly the wrong behavior.'
1159,'timholy','profiler does not work with string interpolation\n```\nrequire("profile.jl")\n\n@profile begin\nfunction test()\n    a = 7\n    println("$a > 5")\nend\nend\n```\n\nThis loads fine, but when you try to execute it as ``test()`` you get the error\n\n```\nin test: a not defined\n in test at no file:6\n```\n'
1155,'JeffBezanson','comprehension syntax quirk\nThis is a pretty fiddly edge case, but I just encountered this:\n\n```julia\njulia> w = [ contains(wanted,vers[i].package) ?\n               -i*length(vers)^2 : i\n             for i=1:length(vers) ]\nsyntax error: invalid comprehension syntax\n```\n\nPutting the `for` on the line above makes it work.'
1153,'JeffBezanson','negative integer type parameters\n```\njulia> type SI{m, s, kg}\n         value::Float\n       end\n\njulia> *{m1, m2, s1, s2, kg1, kg2}(x::SI{m1, s1, kg1}, y::SI{m2, s2, kg2}) = SI{m1 + m2, s1 + s2, kg1 + kg2}(x.value * y.value)\n\njulia> SI{0,0,1}(1.0) * SI{1,2,0}(2.0)\nSI(2.0)\n\njulia> SI{0,0,1}(1.0) * SI{1,-2,0}(2.0)\nno method *(SI{0,0,1},SI{1,-2,0})\n in method_missing at base.jl:70\n```\n'
1146,'StefanKarpinski',"fold memchr functionality into search; add upper bound argument\nI was a bit surprised to find out that contrary to the C version of the function the `i` in\n```\nmemchr(a::Array{Uint8,1}, b::Integer, i::Integer)\n```\n\nis an offset and not the number of Uint8's to search. \n\nMaybe a somewhat better design would be to have\n\n```\nmemchr(a::Array{Uint8,1}, b::Integer, r::Range1)\n```\n\nwhere `r` specifies what part of the Array to search."
1141,'JeffBezanson','task/inference bug\nI\'m afraid I haven\'t been able to boil this down to a better test case, but this fails:\n\n```julia\njulia> each_package() = @task begin\n           for line in each_line(`git ls-tree HEAD`)\n               m = match(r"^\\d{6} tree [0-9a-z]{40}\\t(\\S+)$", line)\n               if m != nothing\n                   produce(m.captures[1])\n               end\n           end\n       end\n\njulia> for pkg in each_package()\n         println(pkg)\n       end\nno method copy(Module,)\n in method_missing at base.jl:70\n in map at cell.jl:19\n in copy at expr.jl:32\n in map at cell.jl:19\n in copy at expr.jl:32\n in inlineable at inference.jl:1447\n in inlining_pass at inference.jl:1523\n in inlining_pass at inference.jl:1488\n in inlining_pass at inference.jl:1488\n in typeinf at inference.jl:1102\n in typeinf_ext at inference.jl:843\n```'
1134,'JeffBezanson',"typealias Maybe{T} Union(T,Nothing)\nCan this be made to work? Currently it's an error:\n\n```julia\njulia> typealias Maybe{T} Union(T,Nothing)\ntype error: typealias: expected Type{T<:Top}, got TypeVar\n in anonymous at no file\n```\n"
1133,'StefanKarpinski','"print_shortest not defined"\n```\njulia> csvwrite("test.txt", A)\nin dlmwrite: print_shortest not defined\n in open at io.jl:103\n in dlmwrite at datafmt.jl:184\n in csvwrite at datafmt.jl:190\n```\n\nI don\'t know what\'s causing this. Ran into other "not defined" errors earlier today because some names were not exported in `sysimg.jl`, but this one is already.\n\nTaught me not to upgrade Julia in the middle of a project. Came back from summer vacation and all the code I wrote in June is now broken :)'
1131,'JeffBezanson','weird method lookup case\n```\njulia> which(idump,dump,stdout_stream,StridedArray.body,5,"    ")\nidump(Function,IOStream,UnionKind,Int64,Any) at show.jl:283\n\njulia> dump(StridedArray)\nTypeConstructor \n  parameters: (TypeVar,TypeVar,TypeVar) (T,N,A<:Array{T,N})\n  body: TypeConstructor \n    parameters: type UnionKind has no field parameters\n in idump at show.jl:261\n in dump at show.jl:360\n in idump at show.jl:261\n in dump at show.jl:357\n in dump at show.jl:358\n\njulia> which(idump,dump,stdout_stream,StridedArray.body,5,"    ")\nidump(Function,IOStream,Any,Int64,Any) at show.jl:253\n```\n\nInitially the correct method is found by `which`. Then the call to `dump` fails in an unexpected way; the wrong `idump` method is called, and reported by future calls to `which`. This is especially strange because `which` only looks at the list of definitions, not the method cache, and the definitions shouldn\'t change here.'
1127,'JeffBezanson',"error out if an exported binding is never assigned\nAlthough we're generally pretty lax about making things throw errors, I think it would catch a fair number of problems and be quite reasonable if it was an error when an exported module binding isn't defined by the time the module gets closed. What happens now is just an undefined error when you try to look up the binding:\n\n```julia\njulia> module Foo\n         export bar\n       end\n\njulia> import Foo\n\njulia> Foo.bar\nbar not defined\n\njulia> import Foo.*\n\njulia> bar\nbar not defined\n```\n"
1125,'JeffBezanson','macro errors in repl should flush a newline first\nExample:\n\n```julia\njulia> @sprintf("$pi %d",1)@printf: first or second argument must be a format string\n\nsyntax error: error expanding macro printf\n```\n\nThis is pretty suboptimal for readability. A better output would be something along the lines of\n\n```julia\njulia> @sprintf("$pi %d",1)\nsyntax error: @printf: first or second argument must be a format string\n```\n'
1117,'JeffBezanson',"can't explicitly import operators\n```julia\njulia> module Bar\n         import Base.+\n       end\nsyntax error: invalid import statement\n```\n"
1114,'JeffBezanson','possible macro escaping bug\n```\n$ julia -e \'@sprintf("%d %f",pi,pi)\'\nsyntax error: local g1 conflicts with argument\n in process_options at client.jl:142\n in _start at client.jl:227\n```\n'
1108,'JeffBezanson','syntax bug: non-standard string field access\nWriting something like `S"foo".data` doesn\'t work:\n\n```julia\n\njulia> "foo".data\n3-element Uint8 Array:\n 0x66\n 0x6f\n 0x6f\n\njulia> S"foo".data\nin anonymous: wrong number of arguments\n\nsyntax error: error expanding macro S_str\n\njulia> (S"foo").data\n3-element Uint8 Array:\n 0x66\n 0x6f\n 0x6f\n```\n\nLooks like the `.data` may be getting interpreted as trailing modifier to the `S_str` macro?'
1107,'JeffBezanson','allow unimported macros to be called\nI.e. something like this:\n\n```julia\n@Mod.mac 1+2\n```\n'
1095,'JeffBezanson',"Dict with Tuple key or value type\nas mentioned in #671, Tuples aren't types. Below is at least a partial fix for dict.jl that would allow Associatives to contain Tuples.  However, now I'm tempted to define ```AllTypes = Union(Type, Tuple)``` to cover this in general, but that just seems even more odd. \n\n```diff\ndiff --git a/base/dict.jl b/base/dict.jl\nindex cf97d2e..caad129 100644\n--- a/base/dict.jl\n+++ b/base/dict.jl\n@@ -24,7 +24,7 @@ function show(io, t::Associative)\n     end\n end\n \n-function keys(T::Type, a::Associative)\n+function keys(T::Union(Type, Tuple), a::Associative)\n     i = 0\n     keyz = Array(T,length(a))\n     for (k,v) in a\n@@ -34,7 +34,7 @@ function keys(T::Type, a::Associative)\n end\n keys{K,V}(a::Associative{K,V}) = keys(K,a)\n \n-function values(T::Type, a::Associative)\n+function values(T::Union(Type, Tuple), a::Associative)\n     i = 0\n     vals = Array(T,length(a))\n     for (k,v) in a\n@@ -44,7 +44,7 @@ function values(T::Type, a::Associative)\n end\n values{K,V}(a::Associative{K,V}) = values(V,a)\n \n-function pairs(T::Union(Type,(Type,Type)), a::Associative)\n+function pairs(T::Union((Type, Tuple),((Type, Tuple),(Type, Tuple))), a::Associative)\n     i = 0\n     pairz = Array(T,length(a))\n     for (k,v) in a\n```\n\nIssue found by @mcstar."
1088,'JeffBezanson',"imported bindings should not be automatically exported\nImported module are automatically exported:\n\n```julia\njulia> module Foo end\n\njulia> module Bar\n         import Foo\n       end\n\njulia> Foo\nFoo not defined\n\njulia> import Bar.*\n\njulia> Foo\nModule(Foo)\n```\n\nAs a result, there's no way to privately import a module."
1087,'timholy','RFC: fixed options and turned into a module\n* the new macro namespace rules clobbered extras/options.jl -- I _think_ I fixed it\n* `load("test.jk"); tests("test/test_options.jl")` now works\n* needs review, especially from @timholy (Tim, the whole options-checking mechanism seems overly complex to me, so I\'m not totally sure it\'s working the way you expect...)'
1083,'JeffBezanson','API cleanup\nAs we can now clearly see on the list of exports, we have inter, intersect, intersection, intersection!, and!, and &. This is a little bit crazy and seems like it should be cleaned up. Browsing this list for similar bad smells is encouraged, as is removing identifiers whenever possible.'
1081,'StefanKarpinski','printf: "%.0f" formatting bug\nLooks like there may be a bug in printf regarding formatting of a Float64.  The following log shows Julia apparently omitting the last digit of a %.0f conversion.  Actually, the last digit is being rendered as a binary zero (NUL char), which doesn\'t display:\n\n```\nScript started on Tue Jul 24 11:52:00 2012\n1david@LC2430HD:~$ date\nTue Jul 24 11:52:02 CDT 2012\n1david@LC2430HD:~$ uname -a\nLinux LC2430HD 3.2.0-26-generic #41-Ubuntu SMP Thu Jun 14 17:49:24 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux\n1david@LC2430HD:~$ julia\n               _\n   _       _ _(_)_     |\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  A fresh approach to technical computing\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 0.0.0+91038668.recea\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit ecea06b17a (2012-07-11 15:10:14)\n|__/                   |\n\njulia> printf( "%.0f\\n", 1343145839.99999999)\n134314584\n\njulia> \n1david@LC2430HD:~$ exit\nexit\n\nScript done on Tue Jul 24 11:52:37 2012\n```\n[pao: formatting]'
1077,'StefanKarpinski','change map_to so the function is the first arg\nThis makes it play well with do-block syntax.'
1076,'StefanKarpinski','L"\\" doesn\'t work\nThis seems to make the parser think the string isn\'t finished; when you hit enter, it refuses to evaluate the expression, clearly expecting more input. If you keep hitting enter, you get this:\n\n```Julia\njulia> L"\\"\n       \n       \nsyntax error: incomplete: invalid string syntax\n```\n'
1075,'JeffBezanson',"allow multiple catch blocks\nOne ought to be able to write something like this:\n\n```julia\ntry f()\ncatch e::NoMethodError\n  # handle no method error\ncatch e::SomeOtherError\n  # handle some other error\ncatch e\n  # handle any thrown object\nend\n```\n\nAlthough it needn't actually be implemented by creating a generic function, this should probably emulate the behavior of dispatch, implying that clause order doesn't matter."
1071,'JeffBezanson','Allow symbols to be type parameters\nWhen creating an abstract syntax tree it would be handy to not have to create a new type for every operator.\n\nUsing pure type information for the operator, allows you to take the most advantage of the JIT compiling / caching powers of Julia.\n\nand being able to do this\n\n```julia\ntype DeBinop{OP,T1,T2} <: DeEle\n  op1::T1\n  op2::T2\nend\n\nfor op = (:+,:-,:.*,:./)\n  @eval ($op)(a::DeEle,b::Number) = DeBinOp{$op}(de_promote(a,b)...)\n  @eval ($op)(a::Number,b::DeEle) = DeBinOp{$op}(de_promote(a,b)...)\n  @eval ($op)(a::DeEle,b::DeEle) =  DeBinOp{$op}(de_promote(a,b)...)\nend\n```\n\ninstead of this \n\n```julia\ntype DeBinop{OP,T1,T2} <: DeEle\n  op1::T1\n  op2::T2\nend\n\ntype AddOp end\ntype MinusOp end\ntype DotMultOp end\ntype DotDivOp end\n\nconst SymbolToType = {:+ => AddOp, :- => MinusOp, :.* => DotMultOp, :./ => DotDivOp}\n\nfor op = (:+,:-,:.*,:./)\n  @eval ($op)(a::DeEle,b::Number) = DeBinOp{$SymbolToType[op]}(de_promote(a,b)...)\n  @eval ($op)(a::Number,b::DeEle) = DeBinOp{$SymbolToType[op]}(de_promote(a,b)...)\n  @eval ($op)(a::DeEle,b::DeEle) =  DeBinOp{$SymbolToType[op]}(de_promote(a,b)...)\nend\n```'
1047,'carlobaldassi',"cannot load libglpk dylib (name mangled)\nUpdating the Julia formula, I can get it all compiling just fine, but when I run the `glpk` test, I get the following error:\n    could not load module libglpk: dlopen(libglpkUH?PH?wH?=R?^, 1): image not found\n     in dlopen at base.jl:103\n     in load at util.jl:234\n     in require at util.jl:177\n     in anonymous at no file:2\n     in cd at file.jl:20\n     in load at util.jl:234\n     in runtests at runtests.jl:3\n     in load at util.jl:234\n     in load at util.jl:234\n     in load at util.jl:246\n     in runtests at runtests.jl:3\n     in include at boot.jl:197\n     in process_options at client.jl:172\n     in _start at client.jl:214\n\nThis looks to me like the libglpk image's name has been mangled somehow.  Where does this name get written into julia during compile-time so I can try and figure out why this is happening?\n\nUseful Info: OSX 10.7 on a Macbook pro, compiled through Homebrew, Revision 62afe7b592"
1038,'StefanKarpinski','String Array not displaying itself in this instance\nI don\'t know what causes this, here is an example:\n\njulia> a = readchomp(`zdump -v -c1990,1991 America/New_York`)\n"America/New_York  -9223372036854775808 = NULL\\nAmerica/New_York  -9223372036854689408 = NULL\\nAmerica/New_York  Sun Apr  1 06:59:59 1990 UTC = Sun Apr  1 01:59:59 1990 EST isdst=0 gmtoff=-18000\\nAmerica/New_York  Sun Apr  1 07:00:00 1990 UTC = Sun Apr  1 03:00:00 1990 EDT isdst=1 gmtoff=-14400\\nAmerica/New_York  Sun Oct 28 05:59:59 1990 UTC = Sun Oct 28 01:59:59 1990 EDT isdst=1 gmtoff=-14400\\nAmerica/New_York  Sun Oct 28 06:00:00 1990 UTC = Sun Oct 28 01:00:00 1990 EST isdst=0 gmtoff=-18000\\nAmerica/New_York  9223372036854689407 = NULL\\nAmerica/New_York  9223372036854775807 = NULL"\n\njulia> b=split(a,\'\\n\')\n8-element String Array:\n   :  \n      \n      \n      \n      \n   :  \n      \n      \n\njulia> show(b)\n["America/New_York  -9223372036854775808 = NULL"  ...  ]\njulia> print(b)\n["America/New_York  -9223372036854775808 = NULL"  ...  ]\njulia> b\n8-element String Array:\n   :  \n      \n      \n      \n      \n   :  \n      \n      \n\njulia> \n'
1023,'nolta',"broken/inconsistent anchors for HTML sections\nThe anchors/fragment identifiers for HTML sections in the RST documentation seems to be quite inconsistent and is often missing (or defaults to something like `id1`). What's going on here? Is there some way we can fix this and make the anchors consistent?"
1022,'nolta',"broken file links in RST documentation\nI'm not sure what happened in porting the docs from Markdown to RST, but all the file links seem to be broken."
1021,'nolta','next/prev links in manual\nWe used to have this on the GitHub-hosted version of the manual. Is there some way we can get that on the ReadTheDocs-hosted version?'
1009,'StefanKarpinski',"`cmd` quoting with a newline\nCommand interpolation is duplicating the previous token when it encounters a newline:\n\n```\njulia> good_cmd = `echo`\n`echo`\njulia> bad_cmd = `echo\n`\n`echo 'echo \n'`\njulia> bad_cmd2 = `echo a\n`\n`echo a 'a \n'`\n```"
1006,'pao','Extras/LRU CacheItem should somehow be covariant\nObviously this being in extras, is of lower priority, but for the record.  The stdlib Dict behaves correctly. \n\n```julia\njulia> abstract A\n\njulia> type B <: A\n          x::ASCIIString\n       end\n\njulia> b = B("test")\nB("test")\n\njulia> DCACHE = Dict{ASCIIString, A}()\nDict()\n\njulia> LCACHE = UnboundedLRU{ASCIIString, A}()\nUnboundedLRU()\n\njulia> DCACHE["test"] = b\nB("test")\n\njulia> LCACHE["test"] = b\nno method convert(Type{CacheItem{ASCIIString,A}},CacheItem{ASCIIString,B})\n in method_missing at base.jl:60\n in assign at dict.jl:265\n in assign at /Users/aviks/dev/julia/usr/bin/../lib/julia/extras/lru.jl:98\n\njulia> \n```'
996,'JeffBezanson','Checking sizes on array indices\nCurrently the following is allowed in Julia:\n\n    julia> A = reshape(1:15,3,5)\n    3x5 Int64 Array:\n     1  4  7  10  13\n     2  5  8  11  14\n     3  6  9  12  15\n    \n    julia> A[4,2]\n    7\n    \n    julia> X = zeros(1,12);\n    \n    julia> X[2,2] = 5\n    5\n    \n    julia> X\n    1x12 Float64 Array:\n     0.0  0.0  5.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\nThat\'s because checking is done to make sure that no invalid memory will be accessed, but the individual indices are not checked. This seems reasonable, but of course it\'s a little unexpected (esp. compared to Matlab) and could make it harder to notice bugs in algorithms.\n\nThe downside of more checking, of course, is that there is a performance hit.\n\nI see three options:\n1. Leave things as they are\n2. Introduce checking to all ref/assign functions for arrays\n3. Do both: make ref/assign check by default, but also create ref_unsafe and assign_unsafe variants that don\'t check. Also define a macro `@disable_arrayind_check` that one can use to wrap a function definition to get more performance out of well-tested code. That macro would "just" change all cases of ref/assign for arrays to their unsafe versions (not sure how easy this would be to write).\n\nObviously the third is the most ambitious. Given the new array ref/assign code that just got checked in, I\'m also going to be testing whether we can yank some of the specialized definitions (particularly abundant for assign). If so, that will make this issue easier to address.\n\nOr perhaps there are other ways?\n'
992,'carlobaldassi',"A[:] does not work\nTry this:\n\n    A = randn(3,5)\n    A[:]\n\nand you'll see it gives this error:\n\nin ref: arrayref: index out of range\n in ref at array.jl:196\n in _F_ at abstractarray.jl:217\n in gen_cartesian_map at abstractarray.jl:253\n in ref at array.jl:216\n\nBy putting in a println(I) in array.jl:189, you'll see that [:] is being converted to a long set of function arguments, so the function\n    ref(A,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)\nis being called."
991,'StefanKarpinski',"make_pipe: Too many open files\nRunning this code:\n\n    while true\n        s = readchomp(`cat file`)\n    end\n\nwhere 'file' is some existing, readable file, produces this error (after running for a few seconds):\n\n    make_pipe: Too many open files\n     in system_error at error.jl:16\n     in make_pipe at process.jl:80\n     in read_from at process.jl:304\n     in _readall at process.jl:481\n     in readchomp at io.jl:247\n     in anonymous at no file:2\n    \n    julia>"
988,'JeffBezanson','obtaining backtraces in exception handlers\nBefore raising an exception, we need to know if the handler wants a backtrace so we know whether to construct one before cutting to the handler (building a trace is very expensive). Currently this is done with the horrible hack of ccalling `jl_register_toplevel_eh`, which marks the handler as wanting a backtrace.\n\nSome better options are:\n\n- Cut to the handler first, and have it make a call to get a trace, supported by remembering what the stack top used to be. Of course this might clobber part of the stack, but it might be good enough to get useful traces.\n- Smalltalk approach suggested by avi bryant: make the catch block a closure, and invoke it in a new frame on top of the throwing frame. Then it can construct a backtrace with no clobbering. The stack is popped when the catch block exits. Only downside is closure allocation, plus possible impact on dataflow analysis, though maybe we can leave enough metadata that the compiler knows the closure is only used as an exception handler.\n- Some kind of syntax to indicate the handler wants a backtrace. For example, `backtrace()` could be a pseudofunction whose presence in the catch block triggers the behavior of `jl_register_toplevel_eh`.'
985,'StefanKarpinski',"make julia -p N use fork instead of exec\nThe tricky bit here is making sure each process knows that it isn't process 1."
984,'JeffBezanson','Confusing error reporting of invalid expressions\n    julia> iters = 0\n    0\n    julia> iters + = 1\n    syntax error: extra input after end of expression\n\nSo far so good. Making the typo on the command line, inside a for statement:\n\n    julia> for i=1:10\n           iters + = 1\n           end\n    \n           unsupported or misplaced expression continue\n    julia>\n\nI have to type "enter" three times to get out of readline. Now, trying to load a file with this typo:\n\n    julia> load("test.jl")\n    syntax error: incomplete: for at test.jl:1 requires end at test.jl:2\n    [...]\n    julia>\n\nThe first error report ("extra input...") is useful, the other two are very confusing.\n\nContents of test.jl:\n\n    for l = 0:1\n        iters + = 1\n    end'
983,'StefanKarpinski','clarify pass-by-reference in manual\nGiven the confusion that C++\'s reference "feature" [has caused](http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference), we need to clarify what pass-by-reference means in the manual with some examples. Perhaps we should consider using Python\'s term "pass-by-sharing" since the term pass-by-reference seems to be poisoned at this point.'
982,'ViralBShah','Argument types in deps/SuiteSparse_wrapper.c\nThe dimension arguments to the C functions `jl_cholmod_dense` and `jl_cholmod_sparse` are declared as `size_t` in `deps/SuiteSparse_wrapper.c` but are passed as `Int` in the Julia functions `_jl_cholmod_dense` and `_jl_cholmod_sparse` defined in `extras/linalg_suitesparse.jl`.  Should those arguments be passed as Uint instead?\n\nOn a related issue, the CHOLMOD and UMFPACK libraries of C functions use this funky templating mechanism where the types of the arguments are determined by the name of the C function.  So a function like `cholmod_factorize` declares the dimension arguments as `int` and `cholmod_l_factorize` declares them to be `SuiteSparse_long` which, I believe, is now (as of SuiteSparse 4.0.0) the native integer size.  I think therefore that the `_l_` versions should be used.  There is already a mechanism to determine whether the rowind and colptr arrays are Int64 or Int32 arrays and that is incorporated in the Julia functions that create the cholmod* objects.  However, the ability to use Int64 for the dimension arguments, especially nnz, is important in big data applications.'
978,'JeffBezanson','a test for when the clang compiler method signature mismatches with the julia ccall one\nThe clang / llvm-gcc compiler that ships with Apple does not cast 8 bit values to the appropriate size in function arguments. I worked around this bug in the fall to correct boxing of 8 bit values and get the code to compile, but I realized this could affect ccall also (if the target code was compiled with llvm-gcc / clang) so I started to put together this testsuite for ccall to demonstrate the error.\r\n'
972,'ViralBShah','definition of LIBS in Make.inc\nVery minor point, but I believe the `LIBS` defined in `Make.inc` is only used by `src/Makefile`, for building libjulia*.so. If so, it would be better to move it to that Makefile.'
956,'dmbates','Implemented multinomial and Dirichlet distributions.\nHere\'s an implementation of the multinomial and Dirichlet distributions. Below are some examples you can use to test these functions:\n\n\n    load("base/distributions.jl")\n\n    d = Multinomial(1, [0.5, 0.4, 0.1])\n    d = Multinomial(1, 3)\n    d = Multinomial(3)\n    d = Multinomial(1, [0.6; 0.4])\n    d = Multinomial(1, [0.6; 0.4]\')\n    mean(d)\n    var(d)\n    insupport(d, [1, 0])\n    insupport(d, [1, 1])\n    insupport(d, [0, 1])\n    pmf(d, [1, 0])\n    pmf(d, [1, 1])\n    pmf(d, [0, 1])\n    logpmf(d, [1, 0])\n    logpmf(d, [1, 1])\n    logpmf(d, [0, 1])\n    rand(d)\n    A = zeros(Int, 10, 2)\n    rand!(d, A)\n    A\n\n    d = Dirichlet([1.0, 2.0, 1.0])\n    d = Dirichlet(3)\n    d = Dirichlet([1.0; 2.0; 1.0])\n    d = Dirichlet([1.0; 2.0; 1.0]\')\n    mean(d)\n    var(d)\n    insupport(d, [0.1, 0.8, 0.1])\n    insupport(d, [0.1, 0.8, 0.2])\n    insupport(d, [0.1, 0.8])\n    pdf(d, [0.1, 0.8, 0.1])\n    rand(d)\n    A = zeros(Float64, 10, 3)\n    rand!(d, A)\n    A\n'
948,'ViralBShah',"Generic matrix-matrix and matrix-vector multiplication do not check dimensions\nIn linalg_dense.jl, the two functions `_jl_generic_matvecmul` and `_jl_generic_matmatmul` will happily operate on arguments of incompatible shapes. In some cases this results in an `arrayref: index out of bounds` error, but in others it silently produces incorrect results. For example:\n```\njulia> a = [1 2 3; 4 5 6];\n\njulia> b = [1 2; 3 4];\n\njulia> a * b\n2x2 Int64 Array:\n  7  10\n 19  28\n```\nIdeally, both functions would ensure compatibility of the arrays' dimensions and raise an informative error message when that is not the case (as in linalg_blas.jl)."
947,'JeffBezanson',"comprehension types failure above nesting depth 2\nIf I write a nested comprehension of depth 2, type inference works fine:\n\n```\njulia> a = [[randi(3) for k=1:3] for i=1:3, j=1:2]\n3x2 Array{Int64,1} Array:\n [2, 3, 2]  [1, 2, 3]\n [2, 1, 1]  [3, 2, 1]\n [2, 2, 1]  [3, 2, 1]\n```\n\nIf, on the other hand, I go to depth 3, the inferred type is `Any` rather then `Array{Array{Int64,1},1}`:\n\n```\njulia> a = [[[randi(3) for l=1:2] for k=1:2] for i=1:3, j=1:2]\n3x2 Any Array:\n [[2, 2], [2, 1]]  [[3, 3], [2, 3]]\n [[3, 3], [3, 1]]  [[1, 1], [3, 2]]\n [[3, 1], [1, 1]]  [[1, 1], [3, 1]]\n```\n\nI tried using type assertions: they pass, but the result is the same:\n\n```\njulia> a = [[[randi(3)::Int64 for l=1:2]::Vector{Int64} for k=1:2]::Vector{Vector{Int64}} for i=1:3, j=1:2]\n3x2 Any Array:\n [[3, 3], [3, 2]]  [[3, 2], [3, 2]]\n [[3, 2], [1, 2]]  [[3, 1], [1, 3]]\n [[3, 2], [2, 1]]  [[3, 1], [1, 3]]\n```\n\nBecause of this, going to depth 4 also fails the type assertion:\n\n```\njulia> a = [[[[randi(3)::Int64 for l=1:2]::Vector{Int64} for k=1:2]::Vector{Vector{Int64}} for j=1:2]::Vector{Vector{Vector{Int64}}} for i=1:2]\ntype error: anonymous: in typeassert, expected Array{Array{Array{Int64,1},1},1}, got Array{Any,1}\n in anonymous at no file\n```\n\nThis also happens if breaking up the nested structures in functions:\n\n```\njulia> n1() = [randi(3) for l=1:2]\n\njulia> n2() = [n1() for l=1:2]\n\njulia> n3() = [n2() for l=1:2]\n\njulia> n1()\n2-element Int64 Array:\n 1\n 2\n\njulia> n2()\n2-element Array{Int64,1} Array:\n [3, 3]\n [3, 2]\n\njulia> n3()\n2-element Any Array:\n [[3, 2], [2, 1]]\n [[2, 2], [2, 1]]\n```\n\nType assertions in the comprehensions don't help here either. What works above depth 2 (apart from allocating everything explicitly) is forcing the return type, as follows:\n\n```\njulia> function n3()\n    ret::Vector{Vector{Vector{Int64}}} = [n2() for l=1:2]\nend\n\njulia> n3()\n2-element Array{Array{Int64,1},1} Array:\n [[1, 2], [1, 1]]\n [[2, 3], [2, 1]]\n```\n\nPossibly, the same type enforcing behaviour should occur from type assertions within the comprehensions as well."
946,'nolta','extras do not get added to helpdb.jl\nI just added documentation for the profiler. I noticed that the things in "extras" make it into the latexpdf documentation, but they don\'t get incorporated into helpdb.jl. That\'s because the final step in making helpdb.jl is this:\n\n    mv $(BUILDDIR)/jlhelp/stdlib/base.jl helpdb.jl\n\nIn other words, only "base" gets in.\n\nMy first attempt at addressing this was to change this to\n\n    cat $(BUILDDIR)/jlhelp/stdlib/base.jl [other files] > helpdb.jl\n\nThis "almost" works. However, each file contains the lines\n\n    function _jl_help_db() return [\n    ...\n    ] end\n\nand as a consequence, only the last file in that list ends up being documented.\n\nI considered fixing this by stripping the offending lines out of each file (e.g., some combination of cat, head, and tail), and then cringed with the awareness that this must not be the right way. I would guess that the right way to fix it lies in sphinx/jlhelp.py, but not knowing Python myself, I am not the right person to fix this.\n'
942,'JeffBezanson','sparse multiplication is slow\nJulia:\n````\njulia> s = sparse(ones(1000,1000));\njulia> @time s*s\nelapsed time: 6.074394941329956 seconds\n````\n\nMatlab:\n````\n>> s = sparse(ones(1000,1000));\n>> tic; s*s; toc;\nElapsed time is 2.198466 seconds.\n````'
937,'JeffBezanson','problem with Dicts in list comprehensions\nHere\'s the offending code:\n\njulia> d = {"a"=>0}\n{"a"=>0}\n\njulia> [k for k in filter(x->length(x)==1, keys(d))]\nno method convert(Type{None},ASCIIString)\n in method_missing at base.jl:60\n in assign at array.jl:257\n in anonymous at no file\n\nwhile if I put the Dict in there explicitly it works fine:\njulia> [k for k in filter(x->length(x)==1, keys({"a"=>1}))]\n1-element Any Array:\n "a"\n'
935,'JeffBezanson',"Disassemble of LLVM code for a method\nThis is a slightly improved version of the LLVM disassemble code I wrote in a gist. I don't know if it should be merged as is, but decided to create a pull request to discuss it anyway. \n\nThe Julia front-end llvm_dump must be loaded from ldump.jl in extras. The builtin function llvm_dump_lambda returns a Julia string with the LLVM code, given the LambdaStaticData for the method (jl_lambda_info_t on the C side). It compiles (or recompiles) the method if the LLVM functionObject is NULL. I don't know if this has any impact on the whole of code generation. \n\nThe code is returned as a Julia string that can then be printed, written to a file, etc. It's still missing some checks (if the function is a builtin, for example, it won't have a LLVM function object), but I hope this is useful as a starting point. "
923,'carlobaldassi','Complete GLPK integration, document it, etc.\nHi @carlobaldassi \n\nIs the GLPK interface ready for usage? If so, can you document it in the manual? In glpk.jl, it suggests towards the end that there are many more functions to be added. We can enable the building of GLPK in the deps then as part of the default build.\n\nEventually, this is something that will live in its own package and have its own lifecycle, but until then, it would be nice to have for general usage.'
922,'JeffBezanson','incorrect line number reported for index out of range error\nIf you run:\n```\nfunction foo()\n\tx = ones(10)\n\tprint("first access\\n")\n\tx[1]\n\tprint("second access\\n")\n\tx[20]\nend\nfoo()\n```\nthe result is\n```\nfirst access\nsecond access\nin foo: arrayref: index out of range\n in foo at none:4\n```\nNote the line number is incorrect. As in #900, this isn\'t helpful when trying to debug :)'
920,'JeffBezanson','ccall on NULL function\nCurrently, if ccall gets a NULL function pointer, it kills julia. I propose turning this into a julia exception so it doesn\'t immediately kill the REPL:\n\nCurrent behavior:\n```julia\njulia> ccall(C_NULL, Void, ())\nLLVM ERROR: Program used external function \'ccall_545\' which could not be resolved!\n$\n```\n(I used C_NULL explicitly for simplicity, but in code, this will occur whenever a symbol lookup fails)\n\nProposed behavior:\n```julia\njulia> ccall(C_NULL, Void, ())\nin anonymous: ccall: null function pointer\n\njulia> \n```\n\nProposed fix:\n```diff\ndiff --git a/src/ccall.cpp b/src/ccall.cpp\nindex 1f166a7..bc85181 100644\n--- a/src/ccall.cpp\n+++ b/src/ccall.cpp\n@@ -204,6 +204,11 @@ static Value *emit_ccall(jl_value_t **args, size_t nargs, jl_codectx_t *ctx)\n         JL_TYPECHK(ccall, pointer, ptr);\n         fptr = *(void**)jl_bits_data(ptr);\n     }\n+    if (fptr == NULL) {\n+        std::string msg = "in " + ctx->funcName +\n+            ": ccall: null function pointer";\n+        jl_error(msg.c_str());\n+    }\n     JL_TYPECHK(ccall, type, rt);\n     JL_TYPECHK(ccall, tuple, at);\n     JL_TYPECHK(ccall, type, at);\n```\n'
918,'ViralBShah',"eigs won't compute 4 eigenvalues of a 4x4 matrix\nI get this:\n\n```\njulia> a=rand(4,4);\n\njulia> eigs(a,3)\nCompute fewer eigenvalues using eigs(A, k)\n in eigs at extras/arpack.jl:130\n in eigs at extras/arpack.jl:119\n\njulia> eigs(a,4)\nCompute fewer eigenvalues using eigs(A, k)\n in eigs at extras/arpack.jl:130\n in eigs at extras/arpack.jl:119\n```\n"
915,'Keno',"buildbot, or Continuous Integration\nI figured I'd start an issue on this rather than necro the [email thread](https://groups.google.com/forum/?fromgroups#!searchin/julia-dev/build$20bot/julia-dev/UfdH20ydsKU/NYbWMDD2cPQJ), but I'm interested in trying to setup a buildbot, primarily to get as close to immediate feedback on breaking changes as possible, with the secondary objective of turning those builds into binary releases eventually.\n\nI have little experience with anything outside of OSX and Linux, so I'm mostly looking to start discussion again and get the ball rolling.  Last I read, one of the choke points was finding an easy-to-use software package to actually manage this kind of task. Although a shell script running `git clone ... && make testall`, and sending the exit status to a webpage somewhere would work, are there killer features that kind of approach lacks? Is it overengineering to ask for more?  (Ideally we'd have something ridiculously awesome like speed.pypy.org, tracking not only build progress but performance benchmarks, etc....)"
892,'JeffBezanson',"foo, bar, baz = split(line,'\\0',3)...\nIt would be nice if you could write this:\n\n```julia\nfoo, bar, baz = split(line,'\\0',3)...\n```\n\nas a more pleasant and intuitive abbreviation for this:\n\n```julia\nfoo, bar, baz = tuple(split(line,'\\0',3)...)\n```"
872,'Keno',"Need to download lighttpd binary on Windows\nBuilding lighttpd properly on windows is next to impossible due to its dependency on Cygwin (AFAIK this will change in the next major release of lighttpd, but that could take a while). We somehow need to be able to download a binary build of Lighttpd and install it in the proper directories (available e.g. here: http://en.wlmp-project.net/downloads.php?cat=lighty). \n\nI'm opening this issue here as we are currently disabling the lighttpd build on windows (which was part of the changes merged from the libuv branch), so that we won't forget about it. This is also required to provide binaries on windows that include the web repl."
870,'Keno','Web repl freezes on many things\nJust cloned and compiled a brand new, clean julia installation and fired the web server. I can get to it by pressing the "Try Julia Now" button, but many commands I give end up not returning the "julia>" prompt to me. I can only get the prompt back by clicking "Julia Web Interface" and then "Try Julia Now" again.\n\nStuff that freezes it for me:\nx=[1:5]\nrandn(1) (even though it\'s an error (Why is it an error?))\nrandn(3)\n\nStuff that doesn\'t:\nx=1\nrandn()\n\nI could probably find many more.. // These things seem to work on julia.forio.com though.'
867,'StefanKarpinski','Julia should be value-preserving\nIn ISO C, integral type conversions are "value-preserving" rather than "unsigned-preserving", which was common in older C.  This means that when unsigned type A and signed type B meet over an arithmetic operator, the result is the smallest type that contains all the values of both A and B.  This provides the fewest number of surprises.\n\nJulia does not currently do this:\n\n\njulia> hasty = 10\n10\n\njulia> nasty = uint8(5)\n0x05\n\njulia> typeof(hasty)\nInt32\n\njulia> typeof(nasty)\nUint8\n\njulia> nasty-hasty\n0xfffffffb\n\njulia> typeof(nasty-hasty)\nUint32\n\nHere the surprising 0xfffffffb results because Uint8 and Int32 produce a Uint32, even though Int32 fully subsumes the values of Uint8, and Uint32 does not even subsume the values of Int32!  The result should be an Int32 instead, since that is the smallest type that preserves value.'
864,'nolta',"Tweak test line\nPer Nolta's comment, tweaks the `test` line in #862"
863,'ViralBShah','Minor fixes in lufact!\n@ViralBShah This fixes up my code from #860. \nS.colptr should be set to ones, not zeros, to be a valid "empty" sparse matrix. Also fix a misleading variable name.'
858,'StefanKarpinski','printf precision\nThis isn\'t really a bug since both outputs are correct, but this discrepancy is curious:\n\n```julia\njulia> _show(stdout_stream, 0.1, GRISU_PRECISION, 19)\n0.1000000000000000056\n\njulia> printf(f"%.19f",0.1)\n0.1000000000000000100\n```\n\nJeff noticed this. I\'m creating an issue so I remember to look into it.'
849,'StefanKarpinski','printf et al. discard backslashes\nI see the following on MacOS 10.6.8:\n\n                   _\n       _       _ _(_)_     |\n      (_)     | (_) (_)    |\n       _ _   _| |_  __ _   |  A fresh approach to technical computing\n      | | | | | | |/ _` |  |\n      | | |_| | | | (_| |  |  Version 0.0.0+86211913.r5da5\n     _/ |\\__\'_|_|_|\\__\'_|  |  Commit 5da5d40136 (2012-05-17 09:24:19)\n    |__/                   |\n    \n    julia> "\\\\hfil"\n    "\\\\hfil"\n    \n    julia> sprintf("\\\\hfil")\n    "hfil"\n   '
848,'JeffBezanson','allow _ in numbers\nSee discussion [here](https://groups.google.com/d/topic/julia-dev/bRPc_c0dFdQ/discussion). Slightly breaking since currently `123_456` would be interpreted as `123*_456`, where `_456` is a very oddly named variable. Although this is technically a breaking change, who the hell names variables things like `_456`?\n\n'
847,'StefanKarpinski','sprintf %s format prints to console instead of to string\n```\njulia> sprintf("%d%s%d", 1, "a", 2)\na"12"\n```'
843,'ViralBShah','fix LU & QR tests\nSee 0c0a489510e9dce51b258b1e44b49c3103119cd7. These norms are both around 2 on my machine.'
841,'StefanKarpinski','performance tips in "Getting Started"\nhttps://groups.google.com/d/topic/julia-dev/4y43h2DDYNI/discussion\n\nThis seems to trip newcomers up a lot so probably deserves to be mentioned much earlier than the very last chapter in the manual.'
838,'Keno','dlopen fails with segmentation fault\ni\'m using julia version 0.0.0+86002406.r738c Commit 738cda1a57 (2012-05-14 15:12:32).\n\ni tried to execute the line `libc = dlopen("libc")` from the julia manual inside the repl.\n\nthe result is a `Segmentation fault (core dumped)`'
833,'pao',"Build fails in fftw\nLooks like a missing link to our fdlibm library?\n\n```\nMaking install in tests\nmake[2]: Entering directory `/home/patrick/julia/deps/fftw-3.3.2-double/tests'\n/bin/bash ../libtool --tag=CC   --mode=link gcc -std=gnu99 -pthread -O3 -fomit-frame-pointer -mtune=native -malign-double -fstrict-aliasing -fno-schedule-insns -ffast-math   -o bench bench-bench.o bench-hook.o bench-fftw-bench.o ../threads/libfftw3_threads.la ../libfftw3.la ../libbench2/libbench2.a  -lpthread\nlibtool: link: gcc -std=gnu99 -pthread -O3 -fomit-frame-pointer -mtune=native -malign-double -fstrict-aliasing -fno-schedule-insns -ffast-math -o .libs/bench bench-bench.o bench-hook.o bench-fftw-bench.o  ../threads/.libs/libfftw3_threads.so ../.libs/libfftw3.so ../libbench2/libbench2.a -lpthread -pthread -Wl,-rpath -Wl,/home/patrick/julia/usr/lib\n../libbench2/libbench2.a(mflops.o): In function `mflops':\nmflops.c:(.text+0x86): undefined reference to `log'\nmflops.c:(.text+0xce): undefined reference to `log'\n../libbench2/libbench2.a(verify-lib.o): In function `aphase_shift':\nverify-lib.c:(.text+0x1798): undefined reference to `sincos'\n../libbench2/libbench2.a(verify-r2r.o): In function `sin00':\nverify-r2r.c:(.text+0x1082): undefined reference to `sin'\nverify-r2r.c:(.text+0x10aa): undefined reference to `cos'\n../libbench2/libbench2.a(verify-r2r.o): In function `cos01':\nverify-r2r.c:(.text+0x11b2): undefined reference to `cos'\nverify-r2r.c:(.text+0x11da): undefined reference to `sin'\n../libbench2/libbench2.a(verify-r2r.o): In function `cos00':\nverify-r2r.c:(.text+0x12e2): undefined reference to `cos'\nverify-r2r.c:(.text+0x130a): undefined reference to `sin'\n../libbench2/libbench2.a(verify-r2r.o): In function `sin11':\nverify-r2r.c:(.text+0x1412): undefined reference to `sin'\nverify-r2r.c:(.text+0x143a): undefined reference to `cos'\n../libbench2/libbench2.a(verify-r2r.o): In function `sin10':\nverify-r2r.c:(.text+0x1532): undefined reference to `sin'\nverify-r2r.c:(.text+0x155a): undefined reference to `cos'\n../libbench2/libbench2.a(verify-r2r.o): In function `sin01':\nverify-r2r.c:(.text+0x1652): undefined reference to `sin'\nverify-r2r.c:(.text+0x167a): undefined reference to `cos'\n../libbench2/libbench2.a(verify-r2r.o): In function `cos11':\nverify-r2r.c:(.text+0x1782): undefined reference to `cos'\nverify-r2r.c:(.text+0x17aa): undefined reference to `sin'\n../libbench2/libbench2.a(verify-r2r.o): In function `cos10':\nverify-r2r.c:(.text+0x18b2): undefined reference to `cos'\nverify-r2r.c:(.text+0x18da): undefined reference to `sin'\n../libbench2/libbench2.a(verify-r2r.o): In function `coshalf':\nverify-r2r.c:(.text+0x19ca): undefined reference to `cos'\nverify-r2r.c:(.text+0x1a1d): undefined reference to `sin'\ncollect2: ld returned 1 exit status\nmake[2]: *** [bench] Error 1\nmake[2]: Leaving directory `/home/patrick/julia/deps/fftw-3.3.2-double/tests'\nmake[1]: *** [install-recursive] Error 1\nmake[1]: Leaving directory `/home/patrick/julia/deps/fftw-3.3.2-double'\nmake: *** [/home/patrick/julia/usr/lib/libfftw3.3.so] Error 2\n```"
821,'JeffBezanson','`a / 2b` is parsed as `(a/2)b`\nThere seems to be a problem with numeric literal coefficients.\r\n```julia\r\njulia> a, b = 10, 2\r\n(10,2)\r\n\r\njulia> a / 2b\r\n10.0\r\n```\r\nShould be parsed as `a / (2b)`?\r\n'
815,'ViralBShah','Installation fails because usr/sbin/* is mentioned but not found.\n```\r\n`/nix/store/a9xjqfi966j9mx0z0bmjf44srbgxjahd-julia-git-20120501/lib/libsuitesparse_wrapper.so\' -> `/nix/store/a9xjqfi966j9mx0z0bmjf44srbgxjahd-julia-git-20120501/share/julia/usr/lib/libsuitesparse_wrapper.so\'\r\n`/nix/store/a9xjqfi966j9mx0z0bmjf44srbgxjahd-julia-git-20120501/lib/libumfpack.so\' -> `/nix/store/a9xjqfi966j9mx0z0bmjf44srbgxjahd-julia-git-20120501/share/julia/usr/lib/libumfpack.so\'\r\ninstall -v usr/sbin/* "/nix/store/a9xjqfi966j9mx0z0bmjf44srbgxjahd-julia-git-20120501"/share/julia/usr/sbin\r\ninstall: cannot stat `usr/sbin/*\': No such file or directory\r\nmake: *** [install] Error 1\r\n```\r\n\r\n'
814,'JeffBezanson','methods not found with some union signature types\nNot sure what\'s going on here, but I noticed that linprog.jl was not working any more because dispatch on Unions, or at least on some kind of Unions, is somehow broken.\r\n\r\nReference code is in https://gist.github.com/2630858.\r\n\r\nFirst example:\r\n\r\n```Julia\r\ntypealias MatOrNothing{T} Union(AbstractMatrix{T}, Vector{None}, Nothing)\r\n\r\nmy_func{T}(A::MatOrNothing{T}) = println("my_func ok")\r\n\r\nM = [1. 2. ; 3. 4.]\r\n\r\nmy_func(M) # works\r\nmy_func([]) # works\r\nmy_func(nothing) # fails\r\n```\r\n\r\nThe last call fails with a no-method error.\r\n\r\nIf I only allow `Matrix{T}` or `Nothing` in the union:\r\n\r\n```Julia\r\ntypealias MatOrNothing{T} Union(tMatrix{T}, Nothing)\r\n\r\nmy_func{T}(A::MatOrNothing{T}) = println("my_func ok")\r\n\r\nM = [1. 2. ; 3. 4.]\r\n\r\nmy_func(M) # works\r\nmy_func(nothing) # fails\r\n```\r\n\r\n it still fails at `Nothing`, as before.\r\n\r\nHowever, the problem doesn\'t seem to be `Nothing`, in the second example, the Union types only accept non-Nothing types:\r\n\r\n```Julia\r\ntypealias MatOrNothing{T} Union(AbstractMatrix{T}, Vector{None})\r\n\r\nmy_func{T<:Real}(A::MatOrNothing{T}, B::MatOrNothing{T},\r\n        C::MatOrNothing{T}) = println("my_func ok")\r\n\r\nM = [ 2. 1. ; 1. 1. ]\r\n\r\nmy_func(M, M, M)\r\n#my_func([], M, M) # fails\r\nmy_func(M, [], M)\r\nmy_func(M, M, [])\r\nmy_func(M, [], [])\r\n#my_func([], M, []) # fails\r\n#my_func([], [], M) # fails\r\nmy_func([], [], [])\r\n```\r\n\r\nthere are still seemingly random failures (marked by comments), still throwing no-method errors, depending on the combination of the parameters.\r\n\r\nMoreover, even more failures show up with this code:\r\n\r\n```Julia\r\ntypealias VecOrNothing{T} Union(AbstractVector{T}, Vector{None})\r\ntypealias MatOrNothing{T} Union(AbstractMatrix{T}, Vector{None})\r\n\r\n# like my_func but C is VecOrNothing : fails more often\r\nmy_func2{T<:Real}(A::MatOrNothing{T}, B::MatOrNothing{T},\r\n        C::VecOrNothing{T}) = println("my_func2 ok")\r\n\r\nM = [ 2. 1. ; 1. 1. ]\r\nV = [ 0.; 0.]\r\n\r\nmy_func2(M, M, V)\r\n#my_func2([], M, V) # fails\r\nmy_func2(M, [], V)\r\n#my_func2(M, M, []) # fails (worked in my_func)\r\n#my_func2(M, [], []) # fails (worked in my_func)\r\n#my_func2([], M, []) # fails\r\n#my_func2([], [], V) # fails\r\nmy_func2([], [], [])\r\n```\r\n'
810,'StefanKarpinski','Pretty printing of link commands during Make is broken\nNote that the LINK line during the build is eating up some slashes. Should be `LINK ui/julia-release-basic`.\r\n\r\n````\r\n$ make release\r\n    CC ui/repl.o\r\n    LINK uijulia-release-basic\r\n    LINK uijulia-release-readline\r\n    JULIA sys0.ji\r\n````'
804,'JeffBezanson',"dispatch ambiguity\nConsider this code:\r\n\r\n```Julia\r\ntype MyType{T}\r\n    x::T\r\nend\r\n\r\nmy_func{T}(P::MyType{T}, Q::MyType{T}) = 0\r\nmy_func{T}(x::T, P::MyType{T}) = 1\r\nmy_func{T}(P::MyType{T}, x::T) = 2\r\n```\r\n\r\nwhen loaded, it prints this ambiguity warning:\r\n\r\n```\r\nWarning: New definition my_func(MyType{T},T) is ambiguous with my_func(T,MyType{T}).\r\n         Make sure my_func(MyType{T},MyType{T}) is defined first.\r\n```\r\n\r\nIndeed, the method which is supposedly missing is defined:\r\n\r\n```\r\nMethods for generic function my_func\r\nmy_func{T}(MyType{T},MyType{T}) at tmp/ambiguity.jl:5\r\nmy_func{T}(T,MyType{T}) at tmp/ambiguity.jl:6\r\nmy_func{T}(MyType{T},T) at tmp/ambiguity.jl:7\r\n```\r\n\r\nbut it's only working as expected up to a point. Everything's fine here:\r\n\r\n```\r\njulia> a=MyType{Int}(3);\r\n\r\njulia> my_func(a,a)\r\n0\r\n\r\njulia> my_func(1,a)\r\n1\r\n\r\njulia> my_func(a,1)\r\n2\r\n\r\njulia> b=MyType{MyType{Int}}(a);\r\n\r\njulia> my_func(b, b)\r\n0\r\n\r\njulia> my_func(a, b)\r\n1\r\n\r\njulia> my_func(b, a)\r\n2\r\n```\r\n\r\nbut here's some trouble instead:\r\n\r\n```\r\njulia> c=MyType{MyType}(a); # do not specify {Int}\r\n\r\njulia> my_func(c,c)\r\n0\r\n\r\njulia> my_func(a,c) # should produce 1, because T=Int for a and T=MyType for c\r\n0\r\n\r\njulia> my_func(c,a)\r\n2\r\n```\r\n\r\nI haven't found any way to disambiguate this, apart from restricting `T` in some way which excludes `MyType` itself. About this last point, there are two questions I have:\r\n\r\n 1. Is is conceivable to have some syntax to exclude some types in parametric declarations? Something like `{T<!:MyType}`\r\n 2. Is there a way to restrict type and functions definitions to e.g. `BitsKind`? What I'd like to do is capture all of the types which have concrete bits implementations, like `Bool`, `Int64` etc., including user-defined types. I still haven't found any way to do this.\r\n\r\nIf the answer to those is non-trivial, I may add feature requests or open a discussion in the dev-list (particularly about the second one), since they don't really belong here."
803,'JeffBezanson','declaration placement corner cases\nIt seems that type declarations on variables can leak out from inner scopes to their containing scopes:\r\nEntering this at the julia prompt \r\n\r\n    let\r\n        x::Float\r\n        let\r\n            x::Int=1\r\n        end\r\n        x=3.5\r\n        println("x         = ", x)    \r\n        println("typeof(x) = ", typeof(x))    \r\n    end\r\n\r\nprints\r\n\r\n    x         = 4\r\n    typeof(x) = Int64\r\n\r\nI guess the inner `x::Int=1` should be taken as a type assertion, since `x` is bound already?\r\n'
799,'JeffBezanson','x::Int->x\nkills the repl.'
794,'ViralBShah',"Provide a more flexible way to find sys.ji, base and extras\nCurrently, the julia binaries are installed in $JULIAHOME. They should get installed in $JULIAHOME/usr/bin, with a symlink in $JULIAHOME. This is essential to get julia packaged for various unix-y platforms. I believe the following can be done:\r\n\r\n1. Put everything sys.ji, base, extras in executable_path/../share\r\n2. Allow a command line switch to specify a different location for these\r\n3. Libraries will be in executable_path/../lib\r\n4. I don't think location can be changed easily for external libs - this has has to be changed at compile time\r\n\r\nBasically, make all of this flexible enough so that package maintainers on different platforms can adopt whatever directory layout they want."
793,'StefanKarpinski','Removing current_output_stream broke dlmwrite\nPatch resolving issue 754 broke dlmwrite for float types (that use grisu.jl). C.f.:\r\n\r\n```julia\r\na = zeros(Float64, 2, 2)\r\ndlmwrite(stdout_stream, a)\r\n\r\nin f_jl_print_shortest: current_output_stream not defined\r\nin f_jl_print_shortest at grisu.jl:111\r\nin dlmwrite at datafmt.jl:159\r\nin dlmwrite at datafmt.jl:179\r\n```'
789,'pao',"RFC: Optionally set FZ/DAZ on SSE(2) processors\nA potentially serious performance bottleneck on Intel processors is getting stuck in microcode for handling subnormals, which can kill code such as IIR filters and feedback controllers. A quick source grep seems to indicate we're not doing this by default, which is good for absolute correctness, but we should have a way to set either the flush-to-zero or denormals-are-zero flags as appropriate for the x86 variant. The intrinsics are defined in `xmmintrin.h`.\r\n\r\nAny ideas on the Right Way to make this available?"
788,'StefanKarpinski','get rid of unnecessary unbox calls\nNow that unboxing happens automatically when calling intrinsics, we could get rid of a lot of unsightly and verbose unboxes.'
787,'nolta',"RFC: add rfft, rfftn functions\nAny objections to adding the following functions, which are basically just wrappers for fftw's r2c routines?\r\n\r\n```\r\nrfft(A [, dim=1])\r\n\r\n   One-dimensional FFT of real array A along dimension 'dim'. If A has size (..., n_dim, ...),\r\n   the result has size (..., ceil(n_dim/2), ...).\r\n\r\nrfftn(A)\r\n\r\n   N-d FFT of real array A. If A has size (n_1, ..., n_d), the result has size\r\n   (n_1, ..., ceil(n_d/2)).\r\n```"
786,'JeffBezanson','type instantiation bug\nIf I put the code below into a file and run it, it prints\r\n\r\n    node     = Node(SymbolEx(),[])\r\n    node.val = TupleEx\r\n    ...\r\n\r\nIf I change the signature of `rewrite` to `rewrite(node::ANY)` it works as intended, printing `node.val = SymbolEx`.\r\nRemoving the type specification on `args::Vector{Node}` also seems to make the problem go away.\r\nIt seems like the type of `node` in the inner invocation of `rewrite` is inferred to be `Node{TupleEx}`, though it is actually `Node{SymbolEx}`.\r\n\r\n    type Node{T}\r\n        val::T\r\n        args::Vector{Node}  # error goes away if ::Vector{Node} is left out\r\n\r\n        Node(val::T, args) = new(val, args)\r\n    end\r\n\r\n    type SymbolEx; end\r\n    type TupleEx; end\r\n\r\n    function rewrite(node)\r\n    #function rewrite(node::ANY)  # error goes away with this signature\r\n        args = Array(Node, length(node.args))\r\n        for k=1:length(node.args)\r\n            args[k] = rewrite(node.args[k])\r\n        end\r\n\r\n        println("node     = ", node)    \r\n        println("node.val = ", typeof(node.val))\r\n\r\n        Node{typeof(node.val)}(node.val, args)\r\n    end\r\n\r\n    x = Node{SymbolEx}(SymbolEx(), Node[])\r\n    bottom = Node{TupleEx}(TupleEx(), Node[x])\r\n\r\n    rewrite(bottom)\r\n'
783,'pao','part of fftw build runs on every make\nTyping `make` again after the build is done seems to rerun the fftw build every time.'
778,'pao','Changes in {extras,test}/Rmath.jl\nThis pull request was intended to be for changes in extras/Rmath.jl and test/Rmath.jl that I had discussed with Viral.  It also contains my commits to the file extras/glm.jl which I would have put in a separate branch, had I known how to do so.  The glm.jl file can be ignored for now.'
774,'StefanKarpinski',"handle Unicode uppercase/lowercase conversions correctly\nAs pointed out [here](http://www.utf8everywhere.org/), there are cases where a single Unicode character needs to be split into multiple characters when converted to uppercase: e.g. ß to SS and ﬄ to FFL (it's possible that similar cases exist for conversion from uppercase to lowercase as well). The interface of the `towupper` and `towlower` functions which we use for general Unicode case conversion can't handle such transformations since the signature is `Char` to `Char`. Despite this, we should handle these conversions correctly, although I'm not sure where to get code that does this."
772,'JeffBezanson',"Can't destructure tuples in comprehension\nI expected something similar to this to work by analogy with the for loop:\r\n\r\n```\r\njulia> [a | (a,) in enumerate(2:4)]\r\nsyntax error: invalid syntax in local declaration\r\n```\r\n\r\nIt doesn't. Note that the above is just a quick way to get an iterable of tuples, not the actual code where I encountered this. I'll index in the expression for now, but this should probably work."
766,'StefanKarpinski','rename HashTable to Dict\nDiscussed on the list:\r\n\r\nhttps://groups.google.com/d/msg/julia-dev/3mGsZXB5E4s/DCia6AVtxP0J'
764,'boyers','Web REPL crashes often - $HOME/.julia_history concurrency issue \nThe Julia Web REPL crashes under load at least in part due to the fact that there are concurrency issues around the $HOME/.julia_history file.  (line 78 - repl-readline.c)  \r\n\r\nWe find that the server crashes often (every few hours) because two sessions are trying to write to the same file at once.\r\n\r\nWe think this problem could be fixed by creating a per session $HOME/.julia_history file.\r\n\r\nYou would have to create a file per session, then clear the file per session removal, and pass a session identifier whenever writing to the file. '
761,'JeffBezanson','the creation of typealias make generic method not usable\nIn this case, the creation of the generic function g, work as expected\r\n```julia\r\njulia> type A{T}; a::T; end\r\n\r\njulia> g{T}(a::A{A{T}}) = a\r\n\r\njulia> a = A(A(1))\r\nA(A(1))\r\n\r\njulia> g(a)\r\nA(A(1))\r\n\r\njulia> typealias AoA{T} A{A{T}}\r\nA{A{T}}\r\n\r\njulia> g(a)\r\nA(A(1))\r\n```\r\n\r\nIn this case, the creation of the type alias AoA before the the generic function g, make\r\ng not usable\r\n\r\n```julia\r\njulia> type A{T}; a::T; end\r\n\r\njulia> typealias AoA{T} A{A{T}}\r\nA{A{T}}\r\n\r\njulia> g{T}(a::A{A{T}}) = a\r\n\r\njulia> a = A(A(1))\r\nA(A(1))\r\n\r\njulia> g(a)\r\nno method g(A{A{Int64}},)\r\n in method_missing at base.jl:60\r\n```'
759,'JeffBezanson','typealias and generic constructors\nI\'m trying to create a typealias for a particular parameterised type, and a subsequent constructor for the aliased type. However, the method definition fails with an error "not a generic function".\r\n```jlcon\r\njulia> type Foo{T<:Real}; a::T; end\r\n\r\njulia> typealias Bar Foo{Int}\r\nFoo{Int64}\r\n\r\njulia> function Bar(x::String); Bar(int(x)); end \r\nin method definition: not a generic function\r\n\r\njulia> function Bar(x::String); Foo{Int}(int(x)); end \r\nin method definition: not a generic function\r\n```\r\nStrangely, if I define a differently named function with the same arguments, the earlier definitions start working.  Therefore, this seems like a bug to me.  Continuing on the same session...\r\n\r\n```jlcon\r\njulia> function tee(x::String); Bar(int(x)); end\r\n\r\njulia> tee("1")\r\nFoo(1)\r\n\r\njulia> function Bar(x::String); Bar(int(x)); end \r\n\r\njulia> Bar("1")\r\nFoo(1)\r\n\r\njulia> \r\n```'
754,'StefanKarpinski',"get rid of current_output_stream\nThis may be a misfeature. We should pass an output stream around explicitly instead and have defaults that don't require it. Hopefully that's not too incredibly annoying and code bloating."
746,'JeffBezanson',"Inscrutable error message on ::Foo in REPL\nWhile `::Type{Integer}` appears to be a nonsensical expression entered standalone at the REPL, the error message isn't all that helpful:\r\n\r\n```\r\njulia> ::Type\r\n#58 not defined\r\n\r\njulia> ::Type{Integer}\r\n#59 not defined\r\n\r\njulia> ::Type()\r\n#60 not defined\r\n```\r\nThe message is the same even if the type is nonexistent:\r\n\r\n```\r\njulia> Something\r\nSomething not defined\r\n\r\njulia> ::Something\r\n#62 not defined\r\n```"
745,'StefanKarpinski','make x^y for integer x,y return a float?\nWe need to decide if `x^y` should return an int or a float when x and y are ints. Current behavior [may be problematic and/or surprising](https://groups.google.com/d/topic/julia-dev/tfg8NRmB5H8/discussion). Since there are very few integer values of `x` and `y` where `x^y` can be computed exactly with integers, maybe it should default to floating point. In which case we may want to introduce `ipow(x,y)` as a shorter name for `power_by_squaring`.'
744,'JeffBezanson','change comprehension indicator to `for`\nUsing the pipe character `|` for comprehensions has become annoying and confusing. Use `for` instead:\r\n\r\n```julia\r\n[ x^2 for x=1:10 ]\r\n```\r\n'
742,'StefanKarpinski','replace() error string replace\n```\r\njulia> replace("String", "tr", "-")\r\nno method split(ASCIIString,Regex,Bool,Int64)\r\n in method_missing at base.jl:60\r\n in replace at regex.jl:135\r\n```'
737,'JeffBezanson',"ICE at inference.jl:423\nSome code evaluated in julia-commit-203455c2d2ae2a321099e5fd84d34e4be55edbd1\r\n\r\n```\r\njulia> arrayfun(n) = if (n<=0); {{1}} ; else local res = {}; for x in arrayfun(n-1); push(res, vcat({1}, x)); end; res; end\r\n\r\njulia> arrayfun(1)\r\ntype error: Ranges: in T, expected Real, got Type{Any}\r\n in abstract_call_gf at inference.jl:423\r\n in abstract_call at inference.jl:502\r\n in abstract_eval_call at inference.jl:543\r\n in abstract_eval at inference.jl:583\r\n in _jl_abstract_interpret at inference.jl:702\r\n in typeinf at inference.jl:988\r\n in typeinf at inference.jl:839\r\n in abstract_call_gf at inference.jl:456\r\n in abstract_call at inference.jl:502\r\n in abstract_eval_call at inference.jl:543\r\n in abstract_eval at inference.jl:583\r\n in anonymous at no file\r\n in map at tuple.jl:30\r\n in abstract_eval_call at inference.jl:532\r\n in abstract_eval at inference.jl:583\r\n in _jl_abstract_interpret at inference.jl:710\r\n in typeinf at inference.jl:988\r\n in typeinf_ext at inference.jl:833\r\n\r\njulia> arrayfun(1)\r\n1-element Any Array:\r\n {1, 1}\r\n```\r\n\r\nWhy did it fail the first time and worked the second time? Could I please at least get a clue about what part of my code caused the failure (If I put this in a function, I don't get to see even what function failed, let alone which expression)"
733,'StefanKarpinski',"Error running julia on Lion\nGetting this when I run julia\r\n\r\n```\r\nerror during init:\r\nin make_stdout_stream: new not defined\r\n```\r\n\r\nHere's my GCC and gfortran, and then the output of my make.  I'm guessing it has to do with the missing ~/Developer/lib directory.  I'm using XCode 4.1 but am downloading 4.3 now to see if that fixes it.\r\n\r\n\r\n```\r\n[macbook@nate:build/julia (master)]$ gcc -v                                                        (12:20 AM 18-04-12)\r\nUsing built-in specs.\r\nTarget: i686-apple-darwin11\r\nConfigured with: /private/var/tmp/llvmgcc42/llvmgcc42-2335.15~25/src/configure --disable-checking --enable-werror --prefix=/Developer/usr/llvm-gcc-4.2 --mandir=/share/man --enable-languages=c,objc,c++,obj-c++ --program-prefix=llvm- --program-transform-name=/^[cg][^.-]*$/s/$/-4.2/ --with-slibdir=/usr/lib --build=i686-apple-darwin11 --enable-llvm=/private/var/tmp/llvmgcc42/llvmgcc42-2335.15~25/dst-llvmCore/Developer/usr/local --program-prefix=i686-apple-darwin11- --host=x86_64-apple-darwin11 --target=i686-apple-darwin11 --with-gxx-include-dir=/usr/include/c++/4.2.1\r\nThread model: posix\r\ngcc version 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)\r\n```\r\n\r\n```\r\n[macbook@nate:build/julia (master)]$ gfortran -v                                                   (12:22 AM 18-04-12)\r\nUsing built-in specs.\r\nTarget: i686-apple-darwin11\r\nConfigured with: /Volumes/Media/Builds/gcc-5666.3/build/obj/src/configure --disable-checking --prefix=/usr --mandir=/share/man --enable-languages=c,objc,c++,obj-c++,fortran --program-transform-name=/^[cg][^.-]*$/s/$/-4.2/ --with-slibdir=/usr/lib --build=i686-apple-darwin11 --program-prefix=i686-apple-darwin11- --host=x86_64-apple-darwin11 --target=i686-apple-darwin11 --with-gxx-include-dir=/include/c++/4.2.1\r\nThread model: posix\r\ngcc version 4.2.1 (Apple Inc. build 5666) (dot 3)\r\n```\r\n\r\n```\r\nllvm[3]: ***** Completed Release Build\r\nllvm[3]: Installing include files\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/ADT\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Analysis\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Assembly\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Bitcode\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/CodeGen\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/CodeGen/PBQP\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/CodeGen/PBQP/Heuristics\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Config\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/DebugInfo\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/ExecutionEngine\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/MC\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/MC/MCParser\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Object\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Support\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/TableGen\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Target\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Transforms\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Transforms/IPO\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm/Transforms/Utils\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm-c\r\nllvm[3]: Making install directory /Users/macbook/build/julia/external/root/include/./llvm-c/Transforms\r\nllvm[4]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMSupport.a\r\nllvm[4]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMTableGen.a\r\nllvm[5]: Install circumvented with NO_INSTALL\r\nllvm[5]: Install circumvented with NO_INSTALL\r\nllvm[5]: Install circumvented with NO_INSTALL\r\nllvm[5]: Install circumvented with NO_INSTALL\r\nllvm[5]: Install circumvented with NO_INSTALL\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-tblgen\r\nllvm[5]: Install circumvented with NO_INSTALL\r\nllvm[6]: Install circumvented with NO_INSTALL\r\nllvm[6]: Install circumvented with NO_INSTALL\r\nllvm[4]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMCore.a\r\nllvm[4]: Installing /Users/macbook/build/julia/external/root/include/llvm/Intrinsics.gen\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMAsmParser.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMArchive.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMBitReader.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMCore.a\r\nllvm[5]: Installing /Users/macbook/build/julia/external/root/include/llvm/Intrinsics.gen\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMBitWriter.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMInstrumentation.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMTransformUtils.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMAnalysis.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMipa.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMScalarOpts.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86CodeGen.a\r\nllvm[7]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86AsmPrinter.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMInterpreter.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMInstCombine.a\r\nllvm[7]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86AsmParser.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMJIT.a\r\nllvm[7]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86Disassembler.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMipo.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMMCJIT.a\r\nllvm[7]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86Info.a\r\nllvm[6]: Installing Release Shared Library /Users/macbook/build/julia/external/root/lib/LLVMHello.dylib\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMRuntimeDyld.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMExecutionEngine.a\r\nllvm[7]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86Desc.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMSelectionDAG.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMLinker.a\r\nllvm[7]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMX86Utils.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMTarget.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMObject.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMAsmPrinter.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMCodeGen.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMDebugInfo.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMMCDisassembler.a\r\nllvm[6]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMMCParser.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLLVMMC.a\r\nllvm[4]: Installing Release Shared Library /Users/macbook/build/julia/external/root/lib/libLLVM-3.0.dylib\r\nllvm[4]: Regenerating LibDeps.txt.tmp\r\nllvm[4]: Installing llvm-config\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-as\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-dis\r\nllvm[5]: Installing llvm-config\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/opt\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llc\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-ar\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-ranlib\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-nm\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-prof\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-link\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-ld\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/lli\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-extract\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-mc\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-bcanalyzer\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/bugpoint\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-stub\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-diff\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/macho-dump\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-objdump\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-rtdyld\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-dwarfdump\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-cov\r\nllvm[5]: Installing Release /Users/macbook/build/julia/external/root/bin/llvm-size\r\nllvm[5]: Installing Release Shared Library /Users/macbook/build/julia/external/root/lib/BugpointPasses.dylib\r\nllvm[5]: Installing Release Shared Library /Users/macbook/build/julia/external/root/lib/libLTO.dylib\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libLTO.a\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libEnhancedDisassembly.a\r\nllvm[5]: Installing Release Shared Library /Users/macbook/build/julia/external/root/lib/libprofile_rt.dylib\r\nllvm[5]: Installing Release Archive Library /Users/macbook/build/julia/external/root/lib/libprofile_rt.a\r\n    CC src/jltypes.o\r\n    CC src/gf.o\r\n    CC src/support/hashing.o\r\n    CC src/support/timefuncs.o\r\n    CC src/builtins.o\r\n    CC src/support/dblprint.o\r\n    CC src/support/ptrhash.o\r\n    CC src/support/operators.o\r\n    CC src/support/socket.o\r\n    CC src/support/utf8.o\r\n    CC src/module.o\r\n    CC src/codegen.o\r\n    CC src/support/ios.o\r\n    CC src/support/dirpath.o\r\n    CC src/support/htable.o\r\n    CC src/support/bitvector.o\r\n    CC src/support/int2str.o\r\n    CC src/interpreter.o\r\n    CC src/support/dump.o\r\n    CC src/alloc.o\r\n    CC src/support/libsupportinit.o\r\n    CC src/dlload.o\r\n    CC src/support/arraylist.o\r\n    CC src/sys.o\r\n    CC src/init.o\r\n    CC src/task.o\r\n    CC src/array.o\r\n    CC src/dump.o\r\n    CC src/gc.o\r\n    LINK src/support/libsupport.a\r\n    CC src/flisp/flisp.o\r\n    CC src/flisp/builtins.o\r\n    CC src/flisp/string.o\r\n    CC src/flisp/equalhash.o\r\n    CC src/flisp/table.o\r\n    CC src/flisp/iostream.o\r\n    CC src/flisp/julia_extensions.o\r\n    CC src/flisp/flmain.o\r\n    LINK src/flisp/libflisp.a\r\n    CC src/flisp/flisp\r\n    FLISP src/julia_flisp.boot\r\n    FLISP src/julia_flisp.boot.inc\r\n    CC src/ast.o\r\n    LINK src/libjulia-release.a\r\n    LINK libjulia-release.dylib\r\n    PERL base/pcre_h.jl\r\n    PERL base/errno_h.jl\r\n    CC ui/repl.o\r\n    CC ui/repl-basic.o\r\n    CC ui/repl-readline.o\r\n    LINK uijulia-release-basic\r\n    LINK uijulia-release-readline\r\nld: warning: directory not found for option '-L/Users/macbook/Developer/lib'\r\nld: warning: directory not found for option '-L/Users/macbook/Developer/lib'\r\n    LINK ui/webserverjulia-release-webserver\r\n    JULIA sys0.ji\r\n    JULIA sys.ji\r\n```"
727,'nolta','FFT slow compared to octave\n```\r\n               _\r\n   _       _ _(_)_     |\r\n  (_)     | (_) (_)    |\r\n   _ _   _| |_  __ _   |  A fresh approach to technical computing\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+1334567822.r4c78\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 4c782a79a3 (2012-04-16 05:17:02)\r\n|__/                   |\r\n\r\njulia> x=randn(120000,512);tic();y=fft(x);toc()\r\nelapsed time: 15.953217029571533 seconds\r\n15.953217029571533\r\n\r\njulia> x=randn(120000,512);tic();y=fft(x);toc()\r\nelapsed time: 45.36599397659302 seconds\r\n45.36599397659302\r\n```\r\n\r\n```\r\nGNU Octave, version 3.2.4\r\nCopyright (C) 2009 John W. Eaton and others.\r\nThis is free software; see the source code for copying conditions.\r\nThere is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\r\nFITNESS FOR A PARTICULAR PURPOSE.  For details, type `warranty\'.\r\n\r\nOctave was configured for "x86_64-redhat-linux-gnu".\r\n\r\nAdditional information about Octave is available at http://www.octave.org.\r\n\r\nPlease contribute if you find this software useful.\r\nFor more information, visit http://www.octave.org/help-wanted.html\r\n\r\nReport bugs to <bug@octave.org> (but first, please read\r\nhttp://www.octave.org/bugs.html to learn how to write a helpful report).\r\n\r\nFor information about changes from previous versions, type `news\'.\r\n\r\noctave:1> x=randn(120000,512);tic();y=fft(x);toc()\r\nElapsed time is 1.89153 seconds.\r\n```'
725,'StefanKarpinski','make convert(Integer, x::Float) an error for non-integer-valued x\nAs a corollary, we can reinstate automatic conversion of fields to constructors after this.'
707,'carlobaldassi','ambiguous methods for BitArray\nNot critical, but this is pretty annoying when I run tests:\r\n\r\n```\r\nWarning: New definition fill(BitArray{N},Any) is ambiguous with fill(Any,(Int64...,)).\r\n         Make sure fill(BitArray{N},(Int64...,)) is defined first.\r\nWarning: New definition *(BitArray{N},AbstractArray{T,N}) is ambiguous with *(AbstractArray{T,2},AbstractArray{S,1}).\r\n         Make sure *(BitArray{2},AbstractArray{S,1}) is defined first.\r\nWarning: New definition *(BitArray{N},AbstractArray{T,N}) is ambiguous with *(AbstractArray{S,1},AbstractArray{T,2}).\r\n         Make sure *(BitArray{1},AbstractArray{T,2}) is defined first.\r\nWarning: New definition *(BitArray{N},AbstractArray{T,N}) is ambiguous with *(AbstractArray{T,2},AbstractArray{S,2}).\r\n         Make sure *(BitArray{2},AbstractArray{S,2}) is defined first.\r\nWarning: New definition *(AbstractArray{T,N},BitArray{N}) is ambiguous with *(AbstractArray{T,2},AbstractArray{S,1}).\r\n         Make sure *(AbstractArray{T,2},BitArray{1}) is defined first.\r\nWarning: New definition *(AbstractArray{T,N},BitArray{N}) is ambiguous with *(AbstractArray{S,1},AbstractArray{T,2}).\r\n         Make sure *(AbstractArray{S,1},BitArray{2}) is defined first.\r\nWarning: New definition *(AbstractArray{T,N},BitArray{N}) is ambiguous with *(AbstractArray{T,2},AbstractArray{S,2}).\r\n         Make sure *(AbstractArray{T,2},BitArray{2}) is defined first.\r\n```\r\n'
704,'carlobaldassi',"falses(5) stopped working\nThis is due to a change in 8b188a9 that affected the type signature of `fill()`. I'm not sure whether all that's necessary is to add back the two removed lines, for the general case, or not. In any case, a regression-test should be added to `test/arrayops.jl` too. @carlobaldassi "
701,'JeffBezanson','comprehension segfaults when invoked on empty vararg\nthis code\r\n\r\n```Julia\r\nfunction buggy(X...)\r\n    [x | x = X]\r\nend\r\n```\r\n\r\nsegfaults when `X` is empty:\r\n\r\n```\r\njulia> buggy(2)\r\n1-element Int64 Array:\r\n 2\r\n\r\njulia> buggy()\r\nSegmentation fault\r\n```\r\n'
697,'StefanKarpinski','string to integer conversion with newline\nIn Julia passing a string that contains an integer and ends in a newline causes int() to error(). In other languages if the last character is a newline int() doesn\'t complain. Example:\r\n\r\n    julia> int("1\\n")\r\n    \'\\n\' is not a valid digit (in "1\\n")\r\n     in parse_int at string.jl:886\r\n     in int at string.jl:916\r\n\r\nI think that "1\\n" should be valid and "1\\n2" should be invalid. If there is a newline and it isn\'t the last character in the string, then the operation is ill defined. This is how Python\'s int works by the way.\r\n\r\nThe thinking for this behavior comes from the following use case:\r\n\r\n    n = int(readline(stream))\r\n\r\nIt is pretty common, at least for me, to write parsers for simple file formats where there is a single number per line. Currently you would need to call chomp() before int().'
696,'StefanKarpinski','Regex unicode support\nSuppose I want regex matching with unicode (utf-8 stored as UTF8String, of course)...\r\n\r\nWhat I would like:\r\n\r\njulia> println(match(r"^.$"x, "z"))\r\nRegexMatch("z")\r\n\r\nWhat happens:\r\n\r\njulia> println(match(r"^.$"x, "я"))\r\nnothing\r\n\r\nWhat PCRE recommends:\r\n\r\njulia> match(Regex("^.\\$", PCRE_UTF8), "я")\r\ninvalid regex option(s)\r\n in Regex at regex.jl:14\r\n in Regex at regex.jl:22\r\n\r\nFIX: if only Regex added PCRE_UTF8 to allowed flags. \r\n| PCRE_UTF8\r\naround pcre.jl : line 20-27\r\n\r\nWORKAROUND for now: \r\n\r\njulia> match(Regex("(*UTF8)^.\\$",), "я")\r\nRegexMatch("я")\r\n\r\njulia> match(r"(*UTF8)^.$", "я")\r\nRegexMatch("я")\r\n\r\nThanks to pcre library authors for supporting that..'
694,'pao','RFC: Binary strings/streams<->composite types (aka strpack.jl)\nBringing this here for some more thought/review. Arrays are kind of weak; I don\'t have a good idea how to support them from existing types. I hack my way around it in the generated struct types; do we need to introduce fixed-size arrays (#593)? Or is there another solution that isn\'t horrible?\r\n\r\nStrings are a very weak spot. Why is `read(in, Char)` different from `read(in, Char, 1)`?\r\n\r\n```Julia\r\njulia> tmp = memio(); write(tmp, "abcdefghijklmnopqrstuvwxyz")\r\njulia> seek(tmp, 0); read(tmp, Char)\r\n\'a\'\r\n\r\njulia> seek(tmp, 0); read(tmp, Char, 2)\r\n[\'\', \'\']\r\n```\r\n\r\nThe current struct string syntax:\r\n\r\n```\r\nstruct_string := endianness? element_specifier*\r\nendianness := "<" | ">" | "!" | "=" | "@"\r\nelement_specifier := name? size? type\r\nname := "[" identifier "]"\r\nsize := unsigned_integer | "(" unsigned_integer ("," unsigned_integer)* ")"\r\ntype := predefined_type | "{" identifier "}"\r\npredefined_type := "x" | "c" | "b" | "B" | "?" | "h" | "i" | "I" | "l" | "L" | "q" | "Q" | "f" | "d"\r\n```\r\nString examples: `s"3bxd"`, `s">[name]($rows, $cols){Complex128}"`\r\n\r\nUsage example:\r\nhttps://gist.github.com/2333148'
688,'JeffBezanson',"Allow different calling conventions for ccall\nThis was discussed on the mailing list, but I though I'd open an issue to keep track of it:\r\n\r\nFor windows we need to support different calling conventions and call site selection of such. This is very easy to do in LLVM (only one call to setCallingConv on the result of CreateCall. Stefan suggested to differentiate the different ccalls by creating new intrinsics like this:\r\n\r\n```julia\r\nccall(:test,Void,()) # __cdecl\r\nccall_stdcall(:test,Void,()) #__stdcall\r\nccall_fastcall(:test,Void,()) #__fastcall\r\n#etc\r\n```\r\nAll these can share the backend implementation and need only be differentiated in the call to [SetCallingConv](http://llvm.org/docs/doxygen/html/classllvm_1_1CallInst.html#acd74b2224788f8d010e47622bb3c2a04). Maybe it's possible to pass it as a flag to ccall and save the calling conv in the AST."
687,'nolta','Running winston on Mac OS X 10.7\nRather new to julia and found a few potential issues trying to get winston to work on OS X. Running ```load("plot.jl")``` yields\r\n\r\n```syntax error: ccall argument types must be a tuple; try (T,) at cairo.jl:97```\r\n\r\nChanging this line in cairo.jl and recompiling yields\r\n\r\n```dlopen(libcairo.bundle, 2): image not found```\r\n\r\nI believe this is due to OS X Lion throwing cairo in /usr/X11/*. This of course can be fixed by changing LD_LIBRARY_PATH (is there a cleaner fix here? maybe look here by default in julia?). \r\n\r\nThis leads to missing libpangocairo, which is fixed by installing pango (should this be a dependency downloaded during ```make``` on OS X?).\r\n\r\nI now can ```load("plot.jl")``` and then ```plot([1,2,3,4])```, which returns a FramedPlot but nothing is shown. Is there a next step here or is it supposed to output at this point and it isnt working yet?'
684,'JeffBezanson','typeof/symbol bug\nUsing Commit 03c57fcb15 (2012-04-08 17:59:11)\r\nLinux 32-bit\r\n\r\n    julia> typeof(:a)\r\n    Symbolaccess to undefined reference\r\n     in isgeneric at inference.jl:38\r\n     in repl_show at client.jl:34\r\n    \r\n    julia> a\r\n    a not defined\r\n'
682,'StefanKarpinski','There seems to be no UTF8-correct substring function\nIt is hard to see from both manual and code that there is one way to extract substring and it is related to chars(). Also, SubString and ref do not behave identically w.r.t. UTF-8, which is surprising. Maybe there should be a standard wrapper for unicode-aware substring operation? It could get a better implementation than what I use later...\r\n\r\njulia> "фыва"[1:2]\r\n"ф"\r\n\r\njulia> SubString("фыва",1,2)\r\n"ф"\r\n\r\njulia> join(chars("фыва")[1:2])\r\n"фы"\r\n\r\njulia> "фыва"[2:3]\r\n"ы"\r\n\r\njulia> SubString("фыва",2,3)\r\n"invalid UTF-8 character index\r\n in next at utf8.jl:35\r\n in next at string.jl:225\r\n in print_escaped at string.jl:422\r\n in print_quoted at string.jl:437\r\n in show at string.jl:27\r\n in repl_show at client.jl:32\r\n'
681,'ViralBShah',"sort segfaults\nAll commits from master applied to my fork (which doesn't touch sort.jl), `make clean`, `make test` passes, I get the following. Other arrays work; this one doesn't:\r\n\r\n    julia> zz =   [0.2,0.2,0.2,0.2,0.2,0.4,0.3,0.2,0.2,0.1,0.2,0.2,0.1,0.1,0.2,0.4,0.4,0.3,0.3,0.3,0.2,0.4,0.2,0.5,0.2,0.2,0.4,0.2,0.2,0.2,0.2,0.4,0.1,0.2,0.2,0.2,0.2,0.1,0.2,0.2,0.3,0.3,0.2,0.6,0.4,0.3,0.2,0.2,0.2,0.2,1.4,1.5,1.5,1.3,1.5,1.3,1.6,1.0,1.3,1.4,1.0,1.5,1.0,1.4,1.3,1.4,1.5,1.0,1.5,1.1,1.8,1.3,1.5,1.2,1.3,1.4,1.4,1.7,1.5,1.0,1.1,1.0,1.2,1.6,1.5,1.6,1.5,1.3,1.3,1.3,1.2,1.4,1.2,1.0,1.3,1.2,1.3,1.3,1.1,1.3,2.5,1.9,2.1,1.8,2.2,2.1,1.7,1.8,1.8,2.5,2.0,1.9,2.1,2.0,2.4,2.3,1.8,2.2,2.3,1.5,2.3,2.0,2.0,1.8,2.1,1.8,1.8,1.8,2.1,1.6,1.9,2.0,2.2,1.5,1.4,2.3,2.4,1.8,1.8,2.1,2.4,2.3,1.9,2.3,2.5,2.3,1.9,2.0,2.3,1.8]\r\n    [0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3  ...  2.3, 2.5, 2.3, 1.9, 2.0, 2.3, 1.8]\r\n    \r\n    julia> sort(zz)\r\n    Segmentation fault"
680,'JeffBezanson','gc stack overflow on deeply-nested structures\nJulia, 64-bit Linux, libc 2.13\n\n```julia\njulia> type trivial a end\njulia> x=0; for i = [1:1000000] x=trivial(x) end\n```\n\nIt leads to segmentation fault. Backtrace consists of many repetitions of\n[line number] 0x000000000045a0fc in gc_markval_.part.1 ()\n\n'
678,'ViralBShah','reshape on ranges produces unititialized arrays\nFrom the mailing list:\r\n\r\n```\r\njulia> reshape(1:9,3,5)\r\n3x5 Int32 Array:\r\n 1  4  7      5120  40530224\r\n 2  5  8  40915760      5136\r\n 3  6  9  40915728  40915776\r\n```\r\nThis should result in a mismatched dimension error. '
674,'JeffBezanson','Regression on 32-bit\nI get a strange crash on beowulf1. It would be good to do a bisect maybe.'
671,'JeffBezanson',"isa doesn't work for tuple types\n    julia> isa((Int64, Float64, Char), Type)\r\n    false\r\n    \r\n    julia> isa(Int64, Type)\r\n    true\r\n    \r\n    julia> isa((Int64, Float64, Char), Type{(Int64,Float64,Char)})\r\n    false\r\n    \r\n    julia> isa(Int64, Type{Int64})\r\n    true\r\n"
648,'JeffBezanson','ccall with extra args segfaults\n```\r\njulia> ccall(:getpid, Uint32, (), 1)\r\nzsh: segmentation fault  julia\r\n```\r\n'
642,'vtjnash',"PIC and arpack\nThe Makefile entry in external/ for arpack only has $(FFLAGS) in its build call.  Since FFLAGS is no longer defined in Make.inc this results in an PIC error on x86-64 machines unless FFLAGS is already defined and has a -fPIC flag.  Here is the git diff:\r\n\r\ndiff --git a/julia/.git/index b/julia-jdn/.git/index\r\nindex 6af42b5..d1bc124 100644\r\nBinary files a/julia/.git/index and b/julia-jdn/.git/index differ\r\ndiff --git a/julia/external/Makefile b/julia-jdn/external/Makefile\r\nindex f9f2694..ebd06ab 100644\r\n--- a/julia/external/Makefile\r\n+++ b/julia-jdn/external/Makefile\r\n@@ -355,7 +355,7 @@ $(ARPACK_OBJ_TARGET): arpack-ng-$(ARPACK_VER)/configure $(LAPACK_OBJ_TARGET) $(O\r\n \tmkdir -p $(EXTROOTLIB)\r\n \tcd arpack-ng-$(ARPACK_VER) && \\\r\n \trm -f UTIL/second_NONE.f && \\\r\n-\t$(FC) -shared $(FFLAGS) SRC/*.f UTIL/*.f $(LIBLAPACK) $(LIBBLAS) -o libarpack.$(SHLIB_EXT) && \\\r\n+\t$(FC) -shared $(JFFLAGS) SRC/*.f UTIL/*.f $(LIBLAPACK) $(LIBBLAS) -o libarpack.$(SHLIB_EXT) && \\\r\n \tcp libarpack.$(SHLIB_EXT) $(EXTROOTLIB)\r\n \ttouch $@\r\n\r\nThere doesn't seem to be a way to attach files to issues... apologies if I'm missing something.\r\n\r\nWith regards,\r\nJason\r\n"
632,'JeffBezanson',"Silly bug\nThis should be high on the list of the most bizarre bugs. I have written some code (you find it at the bottom of this post, while [at this link](https://gist.github.com/2159174) you also find an annotated version and a bug-free version) which, when put into a file and loaded (or typed in the REPL) produces this output:\r\n\r\n```\r\nno method ref(StateUpdate,Int64)\r\n in method_missing at base.jl:60\r\n in stupdate at inference.jl:786\r\n in typeinf at inference.jl:1071\r\n in typeinf at inference.jl:840\r\n in abstract_call_gf at inference.jl:455\r\n in abstract_call at inference.jl:501\r\n in abstract_eval_call at inference.jl:542\r\n in abstract_eval at inference.jl:582\r\n in typeinf at inference.jl:1030\r\n in typeinf_ext at inference.jl:834\r\n in include at src/boot.jl:192\r\nat silly_bug_minimal.jl:14\r\n in include at src/boot.jl:192\r\n```\r\n\r\nI trimmed down the code to the minimum required to expose the bug. There are several conditions to be met, all at the same time, some of which are just [silly](http://i.imgur.com/37SUf.jpg). Here is a description:\r\n\r\n * create a function main() [the name doesn't matter] which does the following:\r\n  * store a permutation inside a `Vector{Any}` (not a `Vector{Vector{Int64}}`, that works fine)\r\n  * apply that permutation to the rows (or the columns) of a matrix\r\n  * do an hcat (or a vcat) of the permuted matrix with any other matrix (possibly itself)\r\n  * pass the resulting matrix to another function calc [the name doesn't matter] whose argument list contains at least one argument named `N`. Yes the name of the argument matters. It doesn't matter if it is the matrix itself which is called N, or if there's a second (possibly unused) argument (of whatever type, even a vararg) called `N`, or if there are even more arguments. What matters is that:\r\n    * the matrix is used in an assignment somewhere within the function\r\n    * the function is parametric; or, it is non parametric but it is called once (no matter how) before being called as described above\r\n * now call main()\r\n\r\nAdditional notes:\r\n\r\n * The bug happens even if one uses `copy` to extract the permutation from the `Array{Any}` and to produce the concatenated matrix.\r\n\r\nThe minimal code:\r\n\r\n```\r\nfunction calc{T}(N::Matrix{T})\r\n   mN = N\r\n   return\r\nend\r\n\r\nfunction main()\r\n    X = rand(3, 2)\r\n    pl = cell(1)\r\n    pl[1] = randperm(3)\r\n    Xp = X[pl[1],:]\r\n    Y = [X Xp]\r\n    calc(Y)\r\nend\r\nmain()\r\n```"
628,'JeffBezanson','"type too large" error with large array literals\nWhile trying to check that I transcribed the coefficients in `ode45` correctly, I hit this:\r\n\r\n```\r\n              _\r\n   _       _ _(_)_     |\r\n  (_)     | (_) (_)    |\r\n   _ _   _| |_  __ _   |  A fresh approach to technical computing\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.0.0+1332376075.r8bd7\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 8bd708721b (2012-03-21 19:27:55)\r\n|__/                   |\r\n\r\njulia> a3 = [    0           0          0         0         0        0    0\r\n                     1/5         0          0         0         0        0    0\r\n                     3/40        9/40       0         0         0        0    0\r\n                    44/45      -56/15      32/9       0         0        0    0\r\n                 19372/6561 -25360/2187 64448/6561 -212/729     0        0    0\r\n                  9017/3168   -355/33   46732/5247   49/176 -5103/18656  0    0\r\n                    35/384       0        500/1113  125/192 -2187/6784  11/84 0] \r\ntype too large\r\n\r\njulia> a2 = [  0           0          0         0         0        0    0\r\n               1/5         0          0         0         0        0    0\r\n               3/40        9/40       0         0         0        0    0\r\n                                                                          \r\n           ]\r\n3x7 Float64 Array:\r\n 0.0    0.0    0.0  0.0  0.0  0.0  0.0                                           0.2    0.0    0.0  0.0  0.0  0.0  0.0\r\n 0.075  0.225  0.0  0.0  0.0  0.0  0.0\r\n\r\njulia> a3 = [    0           0          0         0         0        0    0\r\n                     1/5         0          0         0         0        0    0\r\n                     3/40        9/40       0         0         0        0    0\r\n                    44/45      -56/15      32/9       0         0        0    0\r\n                 19372/6561 -25360/2187 64448/6561 -212/729     0        0    0\r\n                  9017/3168   -355/33   46732/5247   49/176 -5103/18656  0    0\r\n                    35/384       0        500/1113  125/192 -2187/6784  11/84 0] \r\ntype too large\r\n\r\njulia> a2 = [  0           0          0         0         0        0    0\r\n               1/5         0          0         0         0        0    0\r\n               3/40        9/40       0         0         0        0    0\r\n               44/45      -56/15      32/9       0         0        0    0\r\n           ]\r\n4x7 Float64 Array:\r\n 0.0        0.0      0.0      0.0  0.0  0.0  0.0                                 0.2        0.0      0.0      0.0  0.0  0.0  0.0\r\n 0.075      0.225    0.0      0.0  0.0  0.0  0.0\r\n 0.977778  -3.73333  3.55556  0.0  0.0  0.0  0.0\r\n\r\njulia> a3 = [    0           0          0         0         0        0    0\r\n                     1/5         0          0         0         0        0    0\r\n                     3/40        9/40       0         0         0        0    0\r\n                    44/45      -56/15      32/9       0         0        0    0\r\n                 19372/6561 -25360/2187 64448/6561 -212/729     0        0    0\r\n                  9017/3168   -355/33   46732/5247   49/176 -5103/18656  0    0\r\n                    35/384       0        500/1113  125/192 -2187/6784  11/84 0] \r\n7x7 Float64 Array:\r\n 0.0          0.0      0.0        0.0        0.0       0.0       0.0\r\n 0.2          0.0      0.0        0.0        0.0       0.0       0.0\r\n 0.075        0.225    0.0        0.0        0.0       0.0       0.0\r\n 0.977778    -3.73333  3.55556    0.0        0.0       0.0       0.0\r\n 2.9526     -11.5958   9.82289   -0.290809   0.0       0.0       0.0\r\n 2.84628    -10.7576   8.90642    0.278409  -0.273531  0.0       0.0\r\n 0.0911458    0.0      0.449236   0.651042  -0.322376  0.130952  0.0\r\n```\r\nNote that the array I\'m using to break the largeness barrier is `a2`, and the one that gets the full 7x7 is `a3`, so whatever this is it appears to be per-session, not per-binding.'
618,'JeffBezanson','problematic conversion to Vector{Tuple} in constructor\nAfter commit 195236611781740154aa0bfabe897b6a3a05450c the code at the bottom ([also found here](https://gist.github.com/2142899)) doesn\'t work if the last line is uncommented.\r\n\r\nAs per the comments, it seems that a conversion isn\'t working, therefore failing to trigger the call to the innner constructor: as a result, the outer constructor is called recursively ad infinitum (until stack overflow).\r\n\r\nNote that if one substitutes `MyTuple` with `Int`, everything works fine.\r\nAlso note that the exact same conversion works just fine outside the outer constructor (and in the REPL): this is the simplest example I could come up with to expose the bug.\r\n\r\n```\r\ntypealias MyTuple (ASCIIString, BitsKind)\r\n\r\ntype MyType\r\n    some_field::Int\r\n    function MyType(vec::Vector{MyTuple})\r\n        println("INNER")\r\n        new(0)\r\n    end\r\nend\r\n\r\nfunction MyType(vec)\r\n    println("OUTER")\r\n    println(" eltype pre=$(eltype(vec))")\r\n    c_vec = convert(Vector{MyTuple}, vec) ## this conversion doesn\'t work!\r\n    println(" eltype post=$(eltype(c_vec))")\r\n    MyType(c_vec)\r\nend\r\n\r\nsome_data = [("a", Int32), ("b", Int32)]\r\nsome_c_data = convert(Vector{MyTuple}, some_data) ## conversion works here\r\n\r\nex_c_data = MyType(some_c_data) ## <- this works\r\n#ex_data = MyType(some_data) ## <- this keeps calling the\r\n                                ## outer constructor\r\n```\r\n\r\n'
617,'nolta','winston issues\nWinston looks very capable already, I am impressed.\r\n\r\n1. Will x11(p) be implemented before 1.0? It would be easy to underestimate it given the lack of screen output.\r\n\r\n2. The first example shows this\r\n           setattr(p, "xlabel", L"$\\Sigma x^2_i$")\r\nbut in my tests you want to leave out the $ symbols.\r\n\r\n3. Example 4 renders without tick marks\r\n\r\n4. Example 5 renders without tick labels\r\n'
616,'JeffBezanson','bug in comprehension eltype with load("file.jl")\nElement type inference in comprehensions acts differently when commands are typed in the REPL or loaded from a file.\r\nUsing a single command:\r\n\r\n```\r\nv = [ i::Int | i = 1 : 10 ]\r\n```\r\n\r\nWhen typed directly everything\'s ok:\r\n\r\n```\r\njulia> v = [ i::Int | i = 1 : 10 ]\r\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n```\r\n\r\nWhen put into a file and loaded:\r\n\r\n```\r\njulia> load("compr_tst.jl")\r\n\r\njulia> v\r\n{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\r\n\r\njulia> typeof(v)\r\nArray{Any,1}\r\n```\r\n\r\n(the same happens when calling `julia compr_tst.jl` at the command line).'
607,'StefanKarpinski',"finalize behavior of bool conversion\nhttp://docs.python.org/dev/library/stdtypes.html#truth\r\n\r\nThis is less important for us since nothing is automatically promoted in boolean context (`if`, `?:`), but we may as well emulate Python's established behavior for the `bool` function. Either that or we should just get rid of it. It's not entirely clear what purpose it serves. Usually testing a specific thing is more sensible."
606,'JeffBezanson','reproducible segfault with composite type\nI\'m running with a fresh "make" after updating to commit 8574723e2a6b9ce6f3620bad98abb9d1154af1b5.\r\n\r\nSnip out the code below and save it as a file. Load that file into a julia session.\r\n\r\nThis next line seems to run properly:\r\n\r\n```\r\nimg = MyType(imgdata,"drc",szv,[],ones(1,1),[],[],zeros(0),"");\r\n```\r\n\r\nBut then if you type "img" on the julia command line you get a segfault:\r\n\r\n```\r\nimg\r\n```\r\n\r\nHowever, the next version does not produce the segfault:\r\n\r\n```\r\nimg = MyType(imgdata,"drc",szv,[],ones(1,1),["mm"],[],zeros(0),"");\r\nimg\r\n```\r\n\r\nCode:\r\n\r\n```\r\ntype MyType{DataType<:Number}\r\n    data::Array{DataType}\r\n    arrayi_order::ASCIIString\r\n    data_size::Vector{Int}\r\n    arrayi_range::Vector\r\n    arrayi2physc::Matrix{Float64}\r\n    physc_unit::Vector\r\n    physc_name::Vector\r\n    arrayti2physt::Vector{Float64}\r\n    t_unit::String\r\nend\r\n\r\nimgdata = rand(256,512,3)\r\nsz = size(imgdata)\r\nszv = vcat(sz...)\r\n```\r\n'
602,'JeffBezanson','Building julia with clang: tests fail\nBuilding julia with clang segfaults when building sys0.ji. Using OS X 10.7.3, with the clang that ships with XCode 4.3.1 (Apple clang version 3.1 (tags/Apple/clang-318.0.54) (based on LLVM 3.1svn))\r\n\r\n````\r\n(gdb) set args -b stage0.jl\r\n(gdb) r\r\nStarting program: /Users/viral/julia/julia -b stage0.jl\r\nReading symbols for shared libraries ++++++................................................................................................ done\r\nReading symbols for shared libraries . done\r\n\r\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\r\nReason: KERN_INVALID_ADDRESS at address: 0x00000000000000a0\r\n0x000000010064c7f5 in fl_raise (e=4331668007) at flisp.c:175\r\n175\t    while (readstate != (fl_readstate_t*)fl_ctx->rdst) {\r\n(gdb) bt\r\n#0  0x000000010064c7f5 in fl_raise (e=4331668007) at flisp.c:175\r\n#1  0x000000010064cd6d in type_error (fname=0x10067d72e "apply", expected=0x1006ab117 "function", got=1) at flisp.c:217\r\n#2  0x0000000100654e3b in _applyn (n=0) at flisp.c:637\r\n#3  0x00000001006550c7 in fl_applyn (n=0, f=1) at flisp.c:674\r\n#4  0x000000010001423f in jl_init_frontend () at ast.c:95\r\n#5  0x0000000100060c6a in julia_init (imageFile=0x0) at init.c:112\r\n#6  0x0000000100002122 in main ()\r\nCurrent language:  auto; currently minimal\r\n(gdb) \r\n````'
591,'StefanKarpinski','rename jl/ to base/\n'
590,'JeffBezanson','make f(x, y=3) a syntax error\nThis reserves the syntax for keyword arguments in the future (#485).'
588,'JeffBezanson','2.5.*3\n```\r\njulia> 2.5.*3\r\nsyntax error: invalid numeric constant 2.5.\r\n```\r\n'
575,'JeffBezanson',"Segment fault in ccall when called from inside a function\nThe code in\r\n\r\n  https://gist.github.com/2028272\r\n\r\n(a subset of the HDF5 interface I am working on) crashes during the second ccall in the function size(). When I run the code of the function size() outside of the function, it works fine. Before the recent modifications to ccall(), the function version worked fine as well.\r\n\r\nI haven't been able to come up with a smaller code sample that illustrates this behavior, sorry.\r\n\r\nJudging from my quick analysis with GDB and from looking at the HDF5 source code, this looks like 0x0000000000000001 is passed as the second argument to H5Sget_simple_extent_dims.\r\n"
570,'StefanKarpinski','RopeString and ASCIIString hashes don\'t match\nI think since RopeString and ASCIIString `cmp` for the same underlying strings evaluate to true, their hashes should also be equal. If hashtable keys are created with ropestrings (due to, for example, string concatenation during their creation), they cannot be queried using normal strings. \r\n\r\n```\r\n\r\njulia> x=HashTable()\r\nHashTable()\r\n\r\njulia> y=RopeString("1","2")\r\n"12"\r\n\r\njulia> x[y]=true\r\ntrue\r\n\r\njulia> x\r\n{"12"=>true,}\r\n\r\njulia> x["12"]\r\nkey not found: 12\r\n in ref at /Users/aviks/dev/julia/jl/table.jl:19\r\n\r\njulia> y=="12"\r\ntrue\r\n\r\njulia> hash(y) == hash("12")\r\nfalse\r\n\r\n```'
565,'JeffBezanson',"Unary minus precedence?\nNot sure if this is intentional or not, but it caused me some confusion. If it's intentional, I'd be interested to hear the rationale.\r\n\r\nThe precedence of the unary minus seems to be over exponentiation such that `-(x-y)^2` equals `(-(x-y))^2`, so for example `-(1-3)^2 == 4`.  This differs from at least Python, where `-(x-y)**2` equals `-((x-y)**2)`. \r\n\r\nMight be a matter of taste (as Python is my major language), but for me this latter way is more intuitive, and makes for prettier expressions. I was writing something with a gaussian function `exp(-(x-a)^2)` and got quite unexpected numbers out at first. Had to write it `exp(-((x-a)^2))` which looks a bit cluttered.\r\n\r\nI think this should at least be mentioned in the manual somewhere (at least I couldn't find much about operator precedence)."
551,'ViralBShah','fftw fails to compile\nWhen compiling a recent Julia snapshot, I get this error:\r\n\r\nlibtool: link: gcc -shared  -Wl,--whole-archive kernel/.libs/libkernel.a dft/.libs/libdft.a dft/scalar/.libs/libdft_scalar.a dft/scalar/codelets/.libs/libdft_scalar_codelets.a rdft/.libs/librdft.a rdft/scalar/.libs/librdft_scalar.a rdft/scalar/r2cf/.libs/librdft_scalar_r2cf.a rdft/scalar/r2cb/.libs/librdft_scalar_r2cb.a rdft/scalar/r2r/.libs/librdft_scalar_r2r.a reodft/.libs/libreodft.a api/.libs/libapi.a simd-support/.libs/libsimd_support.a simd-support/.libs/libsimd_sse2_nonportable.a dft/simd/sse2/.libs/libdft_sse2_codelets.a rdft/simd/sse2/.libs/librdft_sse2_codelets.a -Wl,--no-whole-archive  -lm  -Wl,-rpath   -Wl,-soname -Wl,libfftw3f.so.3 -o .libs/libfftw3f.so.3.3.0\r\n/usr/bin/ld: cannot find libfftw3f.so.3: No such file or directory\r\ncollect2: ld returned 1 exit status\r\nmake[3]: *** [libfftw3f.la] Error 1\r\nmake[2]: *** [install-recursive] Error 1\r\nmake[1]: *** [/home/JuliaLang/src/julia-build/external/root/lib/libfftw3f.3.so] Error 2\r\nmake: *** [julia-release] Error 2\r\n\r\nWould it be possible to include a USE_SYSTEM_FFTW for distributions having this problem?\r\n\r\nPlease also see https://aur.archlinux.org/packages.php?ID=56877'
549,'JeffBezanson','error in tuple_elim_pass on code with type error\n@pao found this:\r\n\r\n```\r\njulia> function lctest()\r\n           x::String = "a"\r\n           y = [ sqrt(x) | x = 1:10 ]\r\n           x == 10\r\n       end\r\n\r\njulia> lctest()\r\nin ref: arrayref: index out of range\r\n in ref at /home/patrick/julia/jl/array.jl:165\r\n in tuple_elim_pass at /home/patrick/julia/jl/inference.jl:1521\r\n in typeinf at /home/patrick/julia/jl/inference.jl:1059\r\n in typeinf_ext at /home/patrick/julia/jl/inference.jl:805\r\n```\r\n'
547,'JeffBezanson','iteration variables should be local to comprehensions\n<pre>\r\nx="a"\r\ny=[ sqrt(x) | x = 1:10 ]\r\n</pre>\r\nx==10 is true\r\nI think that\'s strange. x should be a local variable in that loop. Also Haskell style comprehensions are cool. On the one hand like map:\r\n<pre>\r\nx=[1,2,3,4,510,1,2,3,1,9]\r\ny=[sqrt(a) | a ∈ x]\r\n</pre>\r\nOn the other hand more powerful:\r\n<pre>\r\nx=[1,2,3,4,510,1,2,3,1,9]\r\ny=[sqrt(a) | a ∈ x, x%2==0]\r\n</pre>\r\nI \'d love unicode keywords (as valid alternative form), but i guess nobody else does.'
544,'JeffBezanson',"array element assignment returns entire array\n```\r\njulia> v = [1]\r\n[1]\r\n\r\njulia> v[1] = 2\r\n[2]\r\n```\r\n\r\nThis regression has been around for a long time. Not even sure when it was introduced, but it's really annoying."
543,'JeffBezanson','Update ccall documentation\nUpdate ccall documentation to capture the new functionality in commit 2ba6116fc1fdd4616bbfad314f14f16dd087e328\r\n\r\n\r\n1. Conversions are inserted automatically, so you can simply pass "x,\r\ny, z" instead of the "int32(x), uint64(y), int32(z)" we had to use\r\neverywhere. Of course, this uses the convert() function. Arrays and\r\nbyte strings can be converted to pointers.\r\n\r\n2. A pointer to a scalar can be passed using the syntax "&x". This is\r\nespecially useful for calling fortran. This syntax is a pun and does\r\nnot do the same thing as C. In particular, while it is safe for called\r\nfunctions to write through this pointer, you will not be able to see\r\nits changes (the variable "x" will not change). Things like &0 and\r\n&f(x) also work, since this is not a real address-of operator.\r\nConversion also happens with &; passing &x as a Ptr{T} will first\r\nconvert x to type T.'
539,'nolta','bigint do not work\nhow to reproduce: \r\n\r\n$  git pull\r\n$  make clean;make  \r\n$  make test\r\n    JULIA test/default\r\n     * default\r\n     * core\r\n     * numbers\r\n     * strings\r\n     * corelib\r\n     * hashing\r\n     * arrayops\r\n     * sparse\r\n     * lapack\r\n     * fft\r\n     * arpack\r\n     * random\r\n     * amos\r\n     * functional\r\n     * bigint\r\n/home/user/julia/lib/libgmp_wrapper.so: undefined symbol: __gmpz_get_si\r\ncould not load module libgmp_wrapper\r\n in dlopen at /home/user/julia/jl/base.jl:97\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in load at /home/user/julia/jl/util.jl:186\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in process_options at /home/user/julia/jl/client.jl:167\r\n in _start at /home/user/julia/jl/client.jl:205\r\nat ../jl/bigint.jl:1\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in load at /home/user/julia/jl/util.jl:186\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in process_options at /home/user/julia/jl/client.jl:167\r\n in _start at /home/user/julia/jl/client.jl:205\r\nat bigint.jl:2\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in load at /home/user/julia/jl/util.jl:174\r\n in load at /home/user/julia/jl/util.jl:186\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in process_options at /home/user/julia/jl/client.jl:167\r\n in _start at /home/user/julia/jl/client.jl:205\r\nat default.jl:14\r\n in load at /home/user/julia/jl/util.jl:197\r\n in runtests at ./runtests.jl:3\r\n in include at src/boot.jl:192\r\n in process_options at /home/user/julia/jl/client.jl:167\r\n in _start at /home/user/julia/jl/client.jl:205\r\nat ./runtests.jl:48\r\n in include at src/boot.jl:192\r\n in process_options at /home/user/julia/jl/client.jl:167\r\n in _start at /home/user/julia/jl/client.jl:205\r\nmake[1]: *** [default] Error 1\r\nmake: *** [test] Error 2\r\n$  nm /home/user/julia/lib/libgmp_wrapper.so|grep gmpz\r\n                 U __gmpz_add\r\n                 U __gmpz_clear\r\n                 U __gmpz_cmp\r\n                 U __gmpz_fdiv_q\r\n                 U __gmpz_fdiv_r\r\n                 U __gmpz_get_si\r\n                 U __gmpz_init\r\n                 U __gmpz_mul\r\n                 U __gmpz_pow_ui\r\n                 U __gmpz_set\r\n                 U __gmpz_set_si\r\n                 U __gmpz_set_str\r\n                 U __gmpz_set_ui\r\n                 U __gmpz_sqrt\r\n                 U __gmpz_sub\r\n$  uname -a\r\nLinux tux 3.0.0-16-generic #28-Ubuntu SMP Fri Jan 27 17:44:39 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux\r\n'
536,'tanmaykm',"readdlm should be able to ignore header/comments\nFrom Patrick's youtube video - dlmread needs to be able to ignore headers/comments.\r\n"
535,'StefanKarpinski',"Describe ARGS in the documentation\nFrom Patrick's youtube video - describe ARGS in the documentation.\r\n"
521,'Keno','WIP: libuv rewrite and Windows port\nWARNING: Do not merge yet. I opened this pull request to have a central place for review/discussion.\r\n\r\nThe rewrite of Julia based on libuv (supporting Win,Linux and OS X) is getting more and more stable. I need to do some more testing, but now that all major features are implemented, I wanted to open up review/discussion. Fire away!'
520,'JeffBezanson','line numbers are off when looking up functions\n````\r\n\r\njulia> rref\r\nMethods for generic function rref\r\nrref(Array{T,2},) at /Users/viral/julia/jl/linalg.jl:404\r\n````\r\n\r\n`rref` is at line 427 and not line 404.'
515,'JeffBezanson','Crashing bug in jl_subtype_le\nI wrote a program for solving the eight queens problem (due to me being german and screwing up it uses dames instead of queens).\r\n\r\nhttps://gist.github.com/1973923\r\n\r\nAfter adding types to it, it crashes.\r\n\r\nWith my very basic abilitys of gdb I got this backtrace:\r\n\r\nhttps://gist.github.com/1973928\r\n\r\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\r\nReason: KERN_INVALID_ADDRESS at address: 0x0000000000000026\r\n0x0000000100003dc9 in jl_subtype_le ()\r\n\r\nI am sorry that I could not provide a smaller code to demonstrate that.\r\n\r\n\r\nSystem: mac os x 10.7.3\r\nGit checkout 827847dcb129a69e3c7650614f0bd90b22b34bf0'
514,'StefanKarpinski',"R version used for performance comparison too old\nThe performance comparison shown on http://julialang.org/ indicates that R version 2.9.0 was used.  This is a 3 year old (!) version of R.  The [current version is 2.14.2](https://stat.ethz.ch/pipermail/r-announce/2012/000550.html) which has a [byte compiler](http://blog.revolutionanalytics.com/2011/08/with-byte-compiler-r-214-will-be-even-faster.html) which speeds it up considerable.\r\n\r\nI believe that for a comparison to be useful at all, it should use recent releases of the systems it compares.  Of course a newer version of R most likely won't beat Julia either, but it seems kind of pointless to include R at all in the comparison if the version that is used is so terribly outdated, especially considering the recent performance improvements R has received."
506,'boyers',"Compilation error in network.cpp\nHi,\r\n\r\nCompilation error in ./ui/webserver/network.cpp :\r\n\r\nnetwork.cpp: In function ‘int network_wrappers::wrap_bind(int)’:\r\nnetwork.cpp:76:22: error: ‘close’ was not declared in this scope\r\nnetwork.cpp:85:22: error: ‘close’ was not declared in this scope\r\nnetwork.cpp: In function ‘void network_wrappers::wrap_close(int)’:\r\nnetwork.cpp:185:19: error: ‘close’ was not declared in this scope\r\n\r\nThis was on Debian x86_64, yesterday's commit 5bb077d3c40b493ccd5e183bac3b8ce69778db54.\r\n"
503,'JeffBezanson',"stack overflow is unreliable\nSimple example below shows a segmentation fault for a recursive function call. \r\n\r\nthanks, jim\r\n\r\n               _\r\n   _       _ _(_)_     |\r\n  (_)     | (_) (_)    |  A fresh approach to technical computing\r\n   _ _   _| |_  __ _   |\r\n  | | | | | | |/ _` |  |  Version 0.0.0-prerelease\r\n  | | |_| | | | (_| |  |  Commit c84deda291 (2012-02-28 19:39:42)\r\n _/ |\\__'_|_|_|\\__'_|  |\r\n|__/                   |\r\n\r\njulia> f(n) = if (n == 0) 0 else f(n-1) + n\r\n              end\r\n\r\njulia> f(10)\r\n55\r\n\r\njulia> f(10000000000)\r\nSegmentation fault: 11"
496,'boyers',"Web REPL crashes on exit()\nSteps to reproduce:\r\n\r\n1. Launch web REPL\r\n2. Type: exit()\r\n\r\nAfter a few seconds, crashes with:\r\n\r\n    2012-03-01 14:05:01: (network_writev.c.115) writev failed: Socket is not connected 5\r\n\r\nI suspect this is because the underlying julia instance is actually handling the exit() and quitting. If this is the case, exit() and other things which don't maybe make sense in the web REPL should maybe be trapped"
489,'StefanKarpinski',"in ref: arrayref: index out of range for [0.0]\nTyping [0.0] leads to\r\n`in ref: arrayref: index out of range`\r\nWorks for Ints and non-zero values. I'm using the last commit and I didn't experience this problem yesterday. "
486,'StefanKarpinski','remove git-free source install instructions\nThese are broken now. See #474.'
485,'JeffBezanson',"keyword arguments\nUnless I've missed this in the manual, Julia does not currently have named parameters. I have found this language feature to dramatically improve the readability, correctness, and maintainability of complex mathematical software.\r\n\r\nI would like the following features (mostly common to R, and hacked onto Matlab using their string-value pairing convention):\r\n\r\n* The ability, when defining a function, to specify mandatory and optional parameters.\r\n* The ability, when defining a function, to specify default values for optional parameters (including the ability to specify that a certain function be called to obtain the default value when the function is called).\r\n* The ability, when calling a function, to use either parameter names (verbose, but clear) or parameter position (terse, but unclear).\r\n* The ability, when calling a function, to place named parameters in any order.\r\n\r\nIf I had to call it, I'd say Objective-C's requirement that parameter names be used is better than also allowing parameter position, but I appreciate this looks weird to users of some languages (particularly Matlab) and is perhaps too verbose in many cases (and may discourage use of anonymous functions).\r\n\r\nI appreciate that Julia encourages defining multiple functions of the same name but of different types to solve the optional-parameters-with-default-values problem, but I suggest that providing syntactical sugar that allows a function to be defined in one place, with default values for parameters, but which is equivalent to defining multiple functions of different type, may be a good solution. Novice programmers may be confused by the ability to define multiple versions of the same function, and poor programmers are going to spread multiple definitions of a given function all over the place."
478,'JeffBezanson','Scalar exponentiation incorrect with negative Integer powers in a vector \n```\r\njulia> 10.^[0]\r\n[1.0]\r\n\r\njulia> 10.^-1\r\n0.1\r\n\r\njulia> 10.^[-1]\r\n[-1.71799e9]\r\n```'
466,'JeffBezanson',"dropped type tag\nConsider the example in https://gist.github.com/1916540, when I run it, I get the following output:\r\nReturning: 24.186773244895647\r\nGot: 4627501189117941816\r\n\r\nUncommenting line 31 (clusterError = clusterError) gives the following output:\r\nReturning: 24.186773244895647\r\nGot: 24.186773244895647\r\n\r\nIt seems that Julia somewhere loses track of the clusterError return value used in line 29.\r\n\r\nI've reduced the example in https://gist.github.com/1916540 as much as possible, so the code itself is awkward and not very useful, but captures the problem.\r\n\r\nI've tried the example on the provided Mac OS X build (Commit a9647abf93 (2012-02-20 12:10:02))"
463,'JeffBezanson','HashTables not being successfully fetch()\'d when run on other processors\nAttempted to write a parallel word-count program while playing with Julia\'s parallelism. See https://github.com/ajdecon/julia-wordcount.  To duplicate, run "julia -p 2 testrun.j" using the files in this repo.\r\n\r\nWhen I spawn the wordcount function (which returns a HashTable) to a second processor and then try to fetch() the result, I get a de-serialization error.\r\n\r\nMessage from @JeffBezanson suggests that the problem is the lack of custom serialize/deserialize methods for HashTables.\r\n\r\nSee this thread in the julia-dev list for more details: http://groups.google.com/group/julia-dev/browse_thread/thread/6aad0d71691e9d4c.'
462,'JeffBezanson','Odd error in slicedim\n```\r\njulia> slicedim(foo, 1, 1)\r\nin slicedim: S not defined\r\n in slicedim at /home/jeff/src/julia2/julia/j/array.j:759\r\n```\r\n\r\nUndoubtedly the optimizer doing something unspeakable.\r\n'
460,'StefanKarpinski','sort_by is broken\nThe mutating version`sort_by!` is fine.'
445,'JeffBezanson','stockcorr benchmark is slow\nJulia looks really interesting.  My impression was that it\'d be a great language to compare in the studies done here: http://www.walkingrandomly.com/?p=3604.\r\n\r\nThe idea is to generate about 500MB of synthetic time series data for financial applications.\r\n\r\nThe unoptimized Matlab code takes about 10 seconds on my machine.\r\n\r\nI expected Julia to do much better on that same unoptimized code, which heavily utilizes for loops.\r\n\r\nHowever, when I tried the following julia port:\r\n\r\n```\r\nfunction original_corr()\r\n#ORIGINAL_CORR - The original, unoptimised code that simulates two correlated assets\r\n\r\n## Correlated asset information\r\nCurrentPrice = [78. 102.];       #Initial Prices of the two stocks\r\nCorr = [1. 0.4; 0.4 1.];         #Correlation Matrix\r\nT = 500;                       #Number of days to simulate = 2years = 500days\r\nn = 100000;                    #Number of simulations\r\ndt = 1./250.;                    #Time step (1year = 250days)\r\nDiv=[0.01 0.01];               #Dividend\r\nVol=[0.2 0.3];                 #Volatility\r\n\r\n##Market Information\r\nr = 0.03;                      #Risk-free rate\r\n\r\n## Define storages\r\nSimulPriceA=zeros(T,n);    #Simulated Price of Asset A\r\nSimulPriceA[1,:]=CurrentPrice[1];\r\nSimulPriceB=zeros(T,n);    #Simulated Price of Asset B\r\nSimulPriceB[1,:]=CurrentPrice[2];\r\n\r\n## Generating the paths of stock prices by Geometric Brownian Motion\r\nUpperTriangle=chol(Corr);    #UpperTriangle Matrix by Cholesky decomposition\r\n\r\nfor i=1:n\r\n   Wiener=randn(T-1,2);\r\n   CorrWiener=Wiener*UpperTriangle;\r\n   for j=2:T\r\n      SimulPriceA[j,i]=SimulPriceA[j-1,i]*exp((r-Div[1]-Vol[1]^2/2)*dt+Vol[1]*sqrt(dt)*CorrWiener[j-1,1]);\r\n      SimulPriceB[j,i]=SimulPriceB[j-1,i]*exp((r-Div[2]-Vol[2]^2/2)*dt+Vol[2]*sqrt(dt)*CorrWiener[j-1,2]);\r\n   end\r\nend\r\n\r\nreturn (SimulPriceA, SimulPriceB)\r\n\r\nend\r\n```\r\n\r\nI was surprised to see that it took 60 seconds... 6 times longer than Matlab.  \r\n\r\nIf I take out the matrix multiplication:\r\n````\r\nWiener=randn(T-1,2);\r\n#CorrWiener=Wiener*UpperTriangle;\r\nCorrWiener=Wiener;\r\n````\r\n\r\nThen the function takes only 6 seconds instead, which is still a bit slower than I would have expected.  Vectorized Matlab code takes 3 seconds.\r\n\r\nIs there something else in that code that is "slow" in julia?\r\n\r\nAnd does the MKL in Matlab really make the 500x2 -times- 2x2 mat-mults that much faster?'
441,'JeffBezanson',"ruby-like blocks\nThis has come up a couple of times. I'd like to accumulate syntax suggestions here."
439,'JeffBezanson',"julia-syntax.scm error messages lack line numbers\n    $ julia -L hugefile.j \r\n    syntax error: invalid type signature\r\n     in include at src/boot.j:192\r\n     in process_options at /Users/nolta/julia/j/client.j:166\r\n     in _start at /Users/nolta/julia/j/client.j:201\r\n    at hugefile.j:0 \r\n\r\n    $ wc hugefile.j \r\n        3088   10733   82363 hugefile.j\r\n\r\nIt'd be great if this error message printed out the line number. I took a look at julia-syntax.scm, but it wasn't obvious to me how to add them."
432,'StefanKarpinski','package management system\nThis is probably v 2.0 or beyond, but a good system for contributing/installing/maintaining packages (or modules, libraries, whatever they are called in Julia), like that in R via CRAN, would allow developers to contribute to the project without having to touch the core repo. Making the package system frictionless goes a long way towards growing the community. (Compare R to Matlab in this regard, where the Mathworks has a vested interest in selling toolboxes, so community packages take a back seat.)'
428,'JeffBezanson','Reshape for ranges is missing\nThe manual gives examples of reshaping ranges (e.g. in the "Indexing" subsection of the "Arrays" section: http://julialang.org/manual/arrays/#Indexing), but `reshape` seems to be not (yet?) implemented for ranges:\r\n\r\n    julia> reshape(1:16, 4, 4)\r\n    no method similar(Range1{Int64},(Int64,Int64),(Int64,))\r\n    in method_missing, /opt/julia/j/base.j:58\r\n    in reshape, /opt/julia/j/abstractarray.j:59\r\n    in reshape, /opt/julia/j/abstractarray.j:65\r\n\r\n    julia>\r\n'
427,'JeffBezanson','`local x()` and `local ()` hangs the REPL\nWith Julia as of f002a965b4, a simple `local x()` (or even `local ()`) hangs the REPL (with 100% CPU usage):\r\n\r\n    $ ./julia -q\r\n    julia> local x()\r\n\r\nCtrl-C aborts and lets me re-edit the input.'
420,'JeffBezanson',"add the ability to abandon current input\nIf i start up the text repl, and enter:\r\n\r\n    julia> for (k,v) = EnvHash()\r\n           print k\r\n           end\r\n\r\nthen the session hangs, and i can't ctrl-C or ctrl-D out. I have to kill the session manually."
416,'boyers',"Web REPL frozen by single token expressions.\nOn OS X 10.6.8, 32-bi CPU.\r\n\r\nAfter launching `launch-server`, the web UI works fine and you get the `julia>` prompt. However, if you try to evaluate an expression, you don't get any answer. If you reload the page, or try to open another one, it takes ages to get past the `<initializing>` stage. You can still change the color theme.\r\n\r\nThe activity of julia-server shoots even higher than reportred in #300 (~ one full core).\r\n\r\nI get the following error at the console:\r\n\r\n`2012-02-20 15:37:20: (network_writev.c.115) writev failed: Socket is not connected 6`"
415,'StefanKarpinski',"RSS feed for the julia blog\nSomeone asked for an RSS feed for the julia blog. I don't think we expose one."
402,'StefanKarpinski',"map(Function, ASCIIString)\n```\r\ncipher(key, text) = map(c -> map(x -> x $ c, key), text)\r\n```\r\n\r\nShouldn't you be able to map a string as an array of chars? Let me know if this seems like something that fits within the design guidelines and I'd be happy to add it."
398,'StefanKarpinski','Use git submodules for dependencies where possible\nI think it might be a good idea to use git submodules to handle dependencies where possible. Not only would that avoid having to use wget/curl, but it would also enable working directly on the dependencies and pushing those changes upstream without much difficulty.'
393,'JeffBezanson','Unable to build on OSX\nHi there, greatly interested in Julia, but unable to compile on OSX 10.7.3. I managed to go past the issue with OpenBLAS, but I now have a problem at a further step :\r\n\r\n        CC src/jltypes.o\r\n        CC src/gf.o\r\n        CC src/support/hashing.o\r\n        CC src/support/timefuncs.o\r\n        CC src/support/dblprint.o\r\n        CC src/support/ptrhash.o\r\n        CC src/support/operators.o\r\n        CC src/support/socket.o\r\n        CC src/support/utf8.o\r\n        CC src/support/ios.o\r\n        CC src/support/dirpath.o\r\n        CC src/support/htable.o\r\n        CC src/support/bitvector.o\r\n        CC src/support/int2str.o\r\n        CC src/support/dump.o\r\n        CC src/support/libsupportinit.o\r\n        CC src/support/arraylist.o\r\n        LINK src/support/libsupport.a\r\n        CC src/flisp/flisp.o\r\n        CC src/flisp/builtins.o\r\n        CC src/flisp/string.o\r\n        CC src/flisp/equalhash.o\r\n        CC src/flisp/table.o\r\n        CC src/flisp/iostream.o\r\n        CC src/flisp/julia_extensions.o\r\n        LINK src/flisp/libflisp.a\r\n        CC src/flisp/flmain.o\r\n        CC src/flisp/flisp\r\n    eval: variable 2.0 has no value\r\n    in file unittest.lsp\r\n    #0 (lambda)\r\n    make[2]: *** [flisp] Error 1\r\n    make[1]: *** [flisp/libflisp.a] Error 2\r\n    make: *** [julia-release] Error 2'
391,'ViralBShah',"DESTDIR should not include /usr/ in it\nRelated to #6 (sorry for possibly beating this dead horse), but if you really want to use DESTDIR like Autotools' `--prefix`, you shouldn't have a `/usr/` after it. The default DESTDIR should *be* `/usr/`, which makes it easy to install to `/usr/local` (or wherever).\r\n\r\nSo, for example, the line:\r\n\r\n    install -d $(DESTDIR)/usr/share/julia/lib\r\n\r\nShould more properly be:\r\n\r\n    install -d $(DESTDIR)/share/julia/lib\r\n\r\nThis way, I can set DESTDIR to either `/usr/local` or `/usr` and it still works"
390,'ViralBShah','instructions for setting up local web-server\nThis has been requested and we should have it:\r\n\r\nhttp://julialang.org/blog/2012/02/why-we-created-julia/#comment-443074919\r\n'
389,'ViralBShah','Pre-built binary fails to run on OS X Lion\nInitial attempt to run after download and unpack:\r\n\r\n```\r\n$ cd ~/Downloads\r\n$ tar xf julia-c4865bd18d-Darwin-i386.tar \r\n$ cd julia\r\n$ ./julia\r\ndlopen(libarpack, 2): image not found\r\nerror during init:\r\ncould not load module libarpack\r\nin dlopen, /Users/viral/julia/j/base.j:99 sys.ji:17\r\n```\r\n\r\nAttempt to run it again, this time specifying DYLD_LIBRARY_PATH:\r\n\r\n```\r\n$ DYLD_LIBRARY_PATH=~/Downloads/julia/lib ./julia\r\ndyld: Library not loaded: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLAPACK.dylib\r\n  Referenced from: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/vecLib\r\n  Reason: Incompatible library version: vecLib requires version 1.0.0 or later, but libLAPACK.dylib provides version 0.0.0\r\nTrace/BPT trap: 5\r\n```'
384,'StefanKarpinski',"Failing to get OpenBLAS\nInstalling on Mac OS X 10.6.8.\r\n\r\nExecuted make per build instructions.\r\n\r\nMake output tail as follows:\r\n\r\n--15:16:54--  https://github.com/xianyi/OpenBLAS/tarball/v0.1alpha2.4\r\n           => `openblas-v0.1alpha2.4.tar.gz'\r\nResolving github.com... 207.97.227.239\r\nConnecting to github.com|207.97.227.239|:443... connected.\r\nERROR: Certificate verification error for github.com: unable to get local issuer certificate\r\nTo connect to github.com insecurely, use `--no-check-certificate'.\r\nUnable to establish SSL connection.\r\nmake[1]: *** [openblas-v0.1alpha2.4.tar.gz] Error 1\r\nmake: *** [julia-release] Error 2\r\n"
381,'ViralBShah','libamos error running ubuntu binaries\nI tried compiling it first but got some errors there.  Then I ran Ubuntu binaries and am getting a shared library error.\r\n\r\njulia$ cat /etc/lsb-release \r\nDISTRIB_ID=Ubuntu\r\nDISTRIB_RELEASE=11.04\r\nDISTRIB_CODENAME=natty\r\nDISTRIB_DESCRIPTION="Ubuntu 11.04"\r\n\r\njulia$ ./julia\r\nlibamos.so: cannot open shared object file: No such file or directory\r\nerror during init:\r\ncould not load module libamos\r\nin dlopen, /scratch/julia/julia/j/base.j:97\r\nat string:15\r\n\r\njulia$ find| grep amos\r\n\r\n-> Nothing called "amos" in the tarball\r\n\r\nDoesn\'t appear in my package repo:\r\n\r\njulia$ sudo apt-cache search amos\r\nlibhdate-dev - A library that help use hebrew dates (development files)\r\nlibhdate1 - A library that help use hebrew dates\r\npython-hdate - A library that help use hebrew dates (python bindings)\r\nkamoso - Tool to take pictures and videos from your webcam\r\nlibhdate-perl - A library that help use hebrew dates (perl bindings)\r\nlibhdate-php - A library that help use hebrew dates (php bindings)\r\nsdlbasic - BASIC interpreter for game development\r\nsdlbasic-dbg - BASIC interpreter for game development - debug symbols\r\nsdlbrt - BASIC interpreter for game development - runtime interpreter\r\nttf-gfs-theokritos - decorative Greek font\r\n\r\n'
378,'ViralBShah','SuiteSparse fails to compile on Mac OSX\nThe step to compile SuiteSparse fails on Mac OSX:\r\n\r\n    /usr/bin/ranlib: file: libspqr.a(spqr_parallel.o) has no symbols\r\n    /usr/bin/ranlib: file: libspqr.a(spqr_debug.o) has no symbols\r\n    ranlib: file: libspqr.a(spqr_parallel.o) has no symbols\r\n    ranlib: file: libspqr.a(spqr_debug.o) has no symbols\r\n    ld: library not found for -lgfortran\r\n    collect2: ld returned 1 exit status\r\n    make[4]: *** [qrdemo] Error 1\r\n    make[3]: *** [all] Error 2\r\n    ar: creating archive librbio.a\r\n    a - RBio.o\r\n\r\n    ===========================================================\r\n    title: [1U 8 STAGE COLUMN SECTION, ALL SECTIONS RIGOROUS ( CHEM. ENG. )]\r\n    status 0\r\n    key [WEST0479] nrow 479 ncol 479\r\n    mkind 0 skind 0 asize 3820 znz 22\r\n    mtype from file:               [RUA]\r\n    (A) RBok status 0 0 0\r\n    (Z) RBok status 0 0 0\r\n    mtype from examining matrix:   [rua]\r\n    mtype after reading from file: [rua]\r\n    raw nrow 479 ncol 479 nnz 1910 nelnz 0 xsize 1910\r\n    mtype from raw read from file: [rua]\r\n    (P) RBok status 0 0 0\r\n    mtype of pattern:              [pua]\r\n    mtype of tril(A):              [rua]\r\n    (L) RBok status 0 0 22\r\n    RBdemo OK\r\n    Undefined symbols:\r\n      "___gxx_personality_v0", referenced from:\r\n          long SuiteSparseQR<std::complex<double> >(int, double, long, int, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_sparse_struct**, cholmod_dense_struct**, cholmod_sparse_struct**, long**, cholmod_sparse_struct**, long**, cholmod_dense_struct**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<std::complex<double> >(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct**, long**, cholmod_sparse_struct**, long**, cholmod_dense_struct**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<std::complex<double> >(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_sparse_struct**, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<std::complex<double> >(int, double, long, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_dense_struct**, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<std::complex<double> >(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<std::complex<double> >(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct**, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          cholmod_sparse_struct* SuiteSparseQR<std::complex<double> >(int, double, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR.o\r\n          cholmod_dense_struct* SuiteSparseQR<std::complex<double> >(cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR.o\r\n          cholmod_dense_struct* SuiteSparseQR<std::complex<double> >(int, double, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<double>(int, double, long, int, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_sparse_struct**, cholmod_dense_struct**, cholmod_sparse_struct**, long**, cholmod_sparse_struct**, long**, cholmod_dense_struct**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<double>(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct**, long**, cholmod_sparse_struct**, long**, cholmod_dense_struct**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<double>(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_sparse_struct**, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<double>(int, double, long, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_dense_struct**, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<double>(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          long SuiteSparseQR<double>(int, double, long, cholmod_sparse_struct*, cholmod_sparse_struct**, cholmod_sparse_struct**, long**, cholmod_common_struct*)in SuiteSparseQR.o\r\n          cholmod_sparse_struct* SuiteSparseQR<double>(int, double, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR.o\r\n          cholmod_dense_struct* SuiteSparseQR<double>(cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR.o\r\n          cholmod_dense_struct* SuiteSparseQR<double>(int, double, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR.o\r\n          CIE in SuiteSparseQR.o\r\n          _SuiteSparseQR_C_qmult in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_solve in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_free in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_numeric in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_backslash_sparse in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_backslash in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_backslash_default in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_QR in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_factorize in SuiteSparseQR_C.o\r\n          _SuiteSparseQR_C_symbolic in SuiteSparseQR_C.o\r\n          CIE in SuiteSparseQR_C.o\r\n          int SuiteSparseQR_free<std::complex<double> >(SuiteSparseQR_factorization<std::complex<double> >**, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          int SuiteSparseQR_free<double>(SuiteSparseQR_factorization<double>**, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_dense_struct* SuiteSparseQR_solve<double>(int, SuiteSparseQR_factorization<double>*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_solve<double>(int, SuiteSparseQR_factorization<double>*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          SuiteSparseQR_factorization<std::complex<double> >* SuiteSparseQR_factorize<std::complex<double> >(int, double, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          SuiteSparseQR_factorization<double>* SuiteSparseQR_factorize<double>(int, double, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          int SuiteSparseQR_numeric<std::complex<double> >(double, cholmod_sparse_struct*, SuiteSparseQR_factorization<std::complex<double> >*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          int SuiteSparseQR_numeric<double>(double, cholmod_sparse_struct*, SuiteSparseQR_factorization<double>*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          SuiteSparseQR_factorization<std::complex<double> >* SuiteSparseQR_symbolic<std::complex<double> >(int, int, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          SuiteSparseQR_factorization<double>* SuiteSparseQR_symbolic<double>(int, int, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_dense_struct* SuiteSparseQR_solve<std::complex<double> >(int, SuiteSparseQR_factorization<std::complex<double> >*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_solve<std::complex<double> >(int, SuiteSparseQR_factorization<std::complex<double> >*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_dense_struct* SuiteSparseQR_qmult<double>(int, SuiteSparseQR_factorization<double>*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_dense_struct* SuiteSparseQR_min2norm<double>(int, double, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_min2norm<double>(int, double, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_qmult<double>(int, SuiteSparseQR_factorization<double>*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_dense_struct* SuiteSparseQR_qmult<std::complex<double> >(int, SuiteSparseQR_factorization<std::complex<double> >*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_dense_struct* SuiteSparseQR_min2norm<std::complex<double> >(int, double, cholmod_sparse_struct*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_min2norm<std::complex<double> >(int, double, cholmod_sparse_struct*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_qmult<std::complex<double> >(int, SuiteSparseQR_factorization<std::complex<double> >*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          void spqr_private_rtsolve<double>(SuiteSparseQR_factorization<double>*, int, long, long, double*, double*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          void spqr_private_rtsolve<std::complex<double> >(SuiteSparseQR_factorization<std::complex<double> >*, int, long, long, std::complex<double>*, std::complex<double>*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          void spqr_private_Happly<double>(int, SuiteSparseQR_factorization<double>*, long, long, long, double*, double*, long*, long*, double*, double*, double*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          void spqr_private_Happly<std::complex<double> >(int, SuiteSparseQR_factorization<std::complex<double> >*, long, long, long, std::complex<double>*, std::complex<double>*, long*, long*, std::complex<double>*, std::complex<double>*, std::complex<double>*, cholmod_common_struct*)in SuiteSparseQR_expert.o\r\n          CIE in SuiteSparseQR_expert.o\r\n          cholmod_sparse_struct* SuiteSparseQR_qmult<std::complex<double> >(int, cholmod_sparse_struct*, cholmod_dense_struct*, long*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_qmult.o\r\n          cholmod_sparse_struct* SuiteSparseQR_qmult<double>(int, cholmod_sparse_struct*, cholmod_dense_struct*, long*, cholmod_sparse_struct*, cholmod_common_struct*)in SuiteSparseQR_qmult.o\r\n          cholmod_dense_struct* SuiteSparseQR_qmult<double>(int, cholmod_sparse_struct*, cholmod_dense_struct*, long*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_qmult.o\r\n          cholmod_dense_struct* SuiteSparseQR_qmult<std::complex<double> >(int, cholmod_sparse_struct*, cholmod_dense_struct*, long*, cholmod_dense_struct*, cholmod_common_struct*)in SuiteSparseQR_qmult.o\r\n          CIE in SuiteSparseQR_qmult.o\r\n          int spqr_1colamd<double>(int, double, long, cholmod_sparse_struct*, long**, long**, long**, cholmod_sparse_struct**, long*, long*, cholmod_common_struct*)in spqr_1colamd.o\r\n          int spqr_1colamd<std::complex<double> >(int, double, long, cholmod_sparse_struct*, long**, long**, long**, cholmod_sparse_struct**, long*, long*, cholmod_common_struct*)in spqr_1colamd.o\r\n          CIE in spqr_1colamd.o\r\n          SuiteSparseQR_factorization<double>* spqr_1factor<double>(int, double, long, int, cholmod_sparse_struct*, long, long*, long*, double*, cholmod_common_struct*)in spqr_1factor.o\r\n          SuiteSparseQR_factorization<std::complex<double> >* spqr_1factor<std::complex<double> >(int, double, long, int, cholmod_sparse_struct*, long, long*, long*, std::complex<double>*, cholmod_common_struct*)in spqr_1factor.o\r\n          CIE in spqr_1factor.o\r\n          int spqr_1fixed<std::complex<double> >(double, long, cholmod_sparse_struct*, long**, long**, cholmod_sparse_struct**, long*, long*, cholmod_common_struct*)in spqr_1fixed.o\r\n          int spqr_1fixed<double>(double, long, cholmod_sparse_struct*, long**, long**, cholmod_sparse_struct**, long*, long*, cholmod_common_struct*)in spqr_1fixed.o\r\n          CIE in spqr_1fixed.o\r\n          spqr_analyze(cholmod_sparse_struct*, int, long*, int, int, cholmod_common_struct*)in spqr_analyze.o\r\n          CIE in spqr_analyze.o\r\n          int spqr_append<double>(double*, long*, cholmod_sparse_struct*, long*, cholmod_common_struct*)in spqr_append.o\r\n          int spqr_append<std::complex<double> >(std::complex<double>*, long*, cholmod_sparse_struct*, long*, cholmod_common_struct*)in spqr_append.o\r\n          CIE in spqr_append.o\r\n          void spqr_assemble<double>(long, long, int, long*, long*, long*, long*, long*, long*, long*, long*, double*, long*, long*, double**, long*, long*, long*, long*, double*, long*)in spqr_assemble.o\r\n          void spqr_assemble<std::complex<double> >(long, long, int, long*, long*, long*, long*, long*, long*, long*, long*, std::complex<double>*, long*, long*, std::complex<double>**, long*, long*, long*, long*, std::complex<double>*, long*)in spqr_assemble.o\r\n          CIE in spqr_assemble.o\r\n          long spqr_cpack<double>(long, long, long, long, double*, double*)in spqr_cpack.o\r\n          long spqr_cpack<std::complex<double> >(long, long, long, long, std::complex<double>*, std::complex<double>*)in spqr_cpack.o\r\n          CIE in spqr_cpack.o\r\n          spqr_csize(long, long*, long*, long*)in spqr_csize.o\r\n          CIE in spqr_csize.o\r\n          spqr_cumsum(long, long*)in spqr_cumsum.o\r\n          CIE in spqr_cumsum.o\r\n          spqr_numeric<std::complex<double> >* spqr_factorize<std::complex<double> >(cholmod_sparse_struct**, long, double, long, spqr_symbolic*, cholmod_common_struct*)in spqr_factorize.o\r\n          spqr_numeric<double>* spqr_factorize<double>(cholmod_sparse_struct**, long, double, long, spqr_symbolic*, cholmod_common_struct*)in spqr_factorize.o\r\n          void free_Work<std::complex<double> >(spqr_work<std::complex<double> >*, long, long, long, long, cholmod_common_struct*)in spqr_factorize.o\r\n          void free_Work<double>(spqr_work<double>*, long, long, long, long, cholmod_common_struct*)in spqr_factorize.o\r\n          spqr_work<std::complex<double> >* get_Work<std::complex<double> >(long, long, long, long, long, long*, cholmod_common_struct*)in spqr_factorize.o\r\n          spqr_work<double>* get_Work<double>(long, long, long, long, long, long*, cholmod_common_struct*)in spqr_factorize.o\r\n          CIE in spqr_factorize.o\r\n          spqr_fcsize(long, long, long, long)in spqr_fcsize.o\r\n          CIE in spqr_fcsize.o\r\n          void spqr_freefac<std::complex<double> >(SuiteSparseQR_factorization<std::complex<double> >**, cholmod_common_struct*)in spqr_freefac.o\r\n          void spqr_freefac<double>(SuiteSparseQR_factorization<double>**, cholmod_common_struct*)in spqr_freefac.o\r\n          CIE in spqr_freefac.o\r\n          void spqr_freenum<std::complex<double> >(spqr_numeric<std::complex<double> >**, cholmod_common_struct*)in spqr_freenum.o\r\n          void spqr_freenum<double>(spqr_numeric<double>**, cholmod_common_struct*)in spqr_freenum.o\r\n          CIE in spqr_freenum.o\r\n          spqr_freesym(spqr_symbolic**, cholmod_common_struct*)      in spqr_freesym.o\r\n          CIE in spqr_freesym.o\r\n          long spqr_front<double>(long, long, long, double, long, long, double*, long*, char*, double*, double*, double*, double*, cholmod_common_struct*)in spqr_front.o\r\n          long spqr_front<std::complex<double> >(long, long, long, double, long, long, std::complex<double>*, long*, char*, std::complex<double>*, std::complex<double>*, double*, double*, cholmod_common_struct*)in spqr_front.o\r\n          CIE in spqr_front.o\r\n          spqr_fsize(long, long*, long*, long*, long*, long*, long*, long*, long*, long*)in spqr_fsize.o\r\n          CIE in spqr_fsize.o\r\n          void spqr_happly<double>(int, long, long, long, long*, long*, double*, double*, double*, long, long, long*, long*, double*, double*, cholmod_common_struct*)in spqr_happly.o\r\n          void spqr_happly<std::complex<double> >(int, long, long, long, long*, long*, std::complex<double>*, std::complex<double>*, std::complex<double>*, long, long, long*, long*, std::complex<double>*, std::complex<double>*, cholmod_common_struct*)in spqr_happly.o\r\n          CIE in spqr_happly.o\r\n          spqr_happly_work(int, long, long, long, long*, long, long*, long*, long*)in spqr_happly_work.o\r\n          CIE in spqr_happly_work.o\r\n          void spqr_hpinv<double>(spqr_symbolic*, spqr_numeric<double>*, long*)in spqr_hpinv.o\r\n          void spqr_hpinv<std::complex<double> >(spqr_symbolic*, spqr_numeric<std::complex<double> >*, long*)in spqr_hpinv.o\r\n          CIE in spqr_hpinv.o\r\n          void spqr_kernel<std::complex<double> >(long, spqr_blob<std::complex<double> >*)in spqr_kernel.o\r\n          void spqr_kernel<double>(long, spqr_blob<double>*)in spqr_kernel.o\r\n          CIE in spqr_kernel.o\r\n          void spqr_larftb<double>(int, long, long, long, long, long, double*, double*, double*, double*, cholmod_common_struct*)in spqr_larftb.o\r\n          void spqr_larftb<std::complex<double> >(int, long, long, long, long, long, std::complex<double>*, std::complex<double>*, std::complex<double>*, std::complex<double>*, cholmod_common_struct*)in spqr_larftb.o\r\n          CIE in spqr_larftb.o\r\n          double spqr_maxcolnorm<std::complex<double> >(cholmod_sparse_struct*, cholmod_common_struct*)in spqr_maxcolnorm.o\r\n          double spqr_maxcolnorm<double>(cholmod_sparse_struct*, cholmod_common_struct*)in spqr_maxcolnorm.o\r\n          CIE in spqr_maxcolnorm.o\r\n          void spqr_panel<std::complex<double> >(int, long, long, long, long, long*, std::complex<double>*, std::complex<double>*, long, std::complex<double>*, std::complex<double>*, std::complex<double>*, cholmod_common_struct*)in spqr_panel.o\r\n          void spqr_panel<double>(int, long, long, long, long, long*, double*, double*, long, double*, double*, double*, cholmod_common_struct*)in spqr_panel.o\r\n          CIE in spqr_panel.o\r\n          void spqr_rconvert<double>(spqr_symbolic*, spqr_numeric<double>*, long, long, long, int, long*, long*, double*, long*, long*, double*, long*, long*, double*, double*)in spqr_rconvert.o\r\n          void spqr_rconvert<std::complex<double> >(spqr_symbolic*, spqr_numeric<std::complex<double> >*, long, long, long, int, long*, long*, std::complex<double>*, long*, long*, std::complex<double>*, long*, long*, std::complex<double>*, std::complex<double>*)in spqr_rconvert.o\r\n          CIE in spqr_rconvert.o\r\n          void spqr_rcount<double>(spqr_symbolic*, spqr_numeric<double>*, long, long, long, int, long*, long*, long*, long*)in spqr_rcount.o\r\n          void spqr_rcount<std::complex<double> >(spqr_symbolic*, spqr_numeric<std::complex<double> >*, long, long, long, int, long*, long*, long*, long*)in spqr_rcount.o\r\n          CIE in spqr_rcount.o\r\n          long spqr_rhpack<double>(int, long, long, long, long*, double*, double*, long*)in spqr_rhpack.o\r\n          long spqr_rhpack<std::complex<double> >(int, long, long, long, long*, std::complex<double>*, std::complex<double>*, long*)in spqr_rhpack.o\r\n          CIE in spqr_rhpack.o\r\n          int spqr_rmap<std::complex<double> >(SuiteSparseQR_factorization<std::complex<double> >*, cholmod_common_struct*)in spqr_rmap.o\r\n          int spqr_rmap<double>(SuiteSparseQR_factorization<double>*, cholmod_common_struct*)in spqr_rmap.o\r\n          CIE in spqr_rmap.o\r\n          void spqr_rsolve<double>(SuiteSparseQR_factorization<double>*, int, long, long, double*, double*, double**, long*, double*, cholmod_common_struct*)in spqr_rsolve.o\r\n          void spqr_rsolve<std::complex<double> >(SuiteSparseQR_factorization<std::complex<double> >*, int, long, long, std::complex<double>*, std::complex<double>*, std::complex<double>**, long*, std::complex<double>*, cholmod_common_struct*)in spqr_rsolve.o\r\n          CIE in spqr_rsolve.o\r\n          spqr_shift(long, long*)in spqr_shift.o\r\n          CIE in spqr_shift.o\r\n          spqr_stranspose1(cholmod_sparse_struct*, long*, long*, long*, long*, long*, long*)in spqr_stranspose1.o\r\n          CIE in spqr_stranspose1.o\r\n          void spqr_stranspose2<double>(cholmod_sparse_struct*, long*, long*, long*, double*, long*)in spqr_stranspose2.o\r\n          void spqr_stranspose2<std::complex<double> >(cholmod_sparse_struct*, long*, long*, long*, std::complex<double>*, long*)in spqr_stranspose2.o\r\n          CIE in spqr_stranspose2.o\r\n          double spqr_tol<double>(cholmod_sparse_struct*, cholmod_common_struct*)in spqr_tol.o\r\n          double spqr_tol<std::complex<double> >(cholmod_sparse_struct*, cholmod_common_struct*)in spqr_tol.o\r\n          CIE in spqr_tol.o\r\n          long spqr_trapezoidal<std::complex<double> >(long, long*, long*, std::complex<double>*, long, long*, int, long**, long**, std::complex<double>**, long**, cholmod_common_struct*)in spqr_trapezoidal.o\r\n          long spqr_trapezoidal<double>(long, long*, long*, double*, long, long*, int, long**, long**, double**, long**, cholmod_common_struct*)in spqr_trapezoidal.o\r\n          CIE in spqr_trapezoidal.o\r\n          int spqr_type<double>()in spqr_type.o\r\n          int spqr_type<std::complex<double> >()in spqr_type.o\r\n          CIE in spqr_type.o\r\n    ld: symbol(s) not found\r\n    collect2: ld returned 1 exit status\r\n    make[1]: *** [SuiteSparse-3.7.0/lib/libsuitesparse.dylib] Error 1\r\n    make: *** [julia-release] Error 2\r\n\r\nThe output from `uname -a` is:\r\n\r\n    Darwin bulbasaur.local 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:32:41 PDT 2011; root:xnu-1504.15.3~1/RELEASE_X86_64 x86_64'
370,'ViralBShah',"OpenBLAS not compiling\nI constantly get the error while trying to build julia\r\n\r\nMakefile:121: *** OpenBLAS: Detecting CPU failed. Please set TARGET explicitly, e.g. make TARGET=your_cpu_target. Please read README for the detail..  Stop.\r\nmake[1]: *** [openblas-v0.1alpha2.4/libopenblas.a] Error 2\r\nmake: *** [julia-release] Error 2\r\n\r\neven though I specified it in the Make.inc, supplied it via make TARGET= and tried to write it directly to the openblas make.inc. \r\nI'm on Arch Linux 3.2.2 x86_64 on a Core i5-2500.\r\n\r\nI also suspect that make clean does not really revert the build state. I'm now trying with a fresh clone from git and specifying TARGET before calling make. But even if that works, this should be mentioned in the documentation or solved in a way that avoids the need to recompile for example llvm again.\r\n"
369,'ViralBShah',"LLVM install sometimes redundant\nI already have LLVM installed. I'd rather not download, configure, compile, and install a duplicate LLVM, wasting several hours. I realize that it's an incredible help to do this automatically for Julia users, but for those that already have LLVM version Whatever, could the Makefiles be modified to only install LLVM if it's not already on the system? E.g. `which llvm-gcc`."
368,'ViralBShah',"hex not displaying as decimal as in manual\nI just read about Julia this morning, so I had to give it a try. It installed just fine, so I started following along in the manual. When I got to\r\n\r\n    julia> 0xff\r\n    255\r\n\r\n    julia> 0xffffffff\r\n    4294967295\r\n\r\nI had different results\r\n\r\n    julia> 0xff\r\n    0xff\r\n\r\n    julia> 0xffffffff\r\n    0xffffffff\r\n\r\nThey appear to be integers\r\n\r\n    julia> typeof(ans)\r\n    Uint32\r\n\r\nrather than strings or something, so I figured it was just that  the documentation was out of date. I thought I could make a pull request on [the wiki](https://github.com/oylenshpeegul/julia/wiki/Integers-and-Floating-Point-Numbers#wiki-Integers) the same as with code, but apparently it doesn't  work that way.\r\n\r\n"
367,'StefanKarpinski',"isequal is not transitive\nWe have\r\n\r\n```\r\njulia> isequal(0,0.0)\r\ntrue\r\n\r\njulia> isequal(0,-0.0)\r\ntrue\r\n\r\njulia> isequal(0.0,-0.0)\r\nfalse\r\n```\r\n\r\nIn the int,float case it's using `==`. Maybe a correct definition is:\r\n\r\n```\r\nisequal(a::Integer, b::Float) = (a==b) & isequal(float(a),b)\r\n```\r\n\r\n?\r\n\r\nI know Stefan will enjoy this issue :)\r\n"
364,'JeffBezanson','try-finally\nWould be useful to have.'
358,'JeffBezanson',"printing doesn't flush in non-repl mode\nAfter repl rejiggering, this no longer produces any output:\r\n\r\n```\r\njulia -e 'print(VERSION_COMMIT[1:8])'\r\n```\r\n"
356,'StefanKarpinski','add regex tests in test/strings.j\n'
355,'JeffBezanson',"div(typemin(Int64),-1)\n```\r\njulia> div(typemin(Int64),-1)\r\nerror: integer divide by zero\r\n```\r\n\r\nHmm. This should probably be `typemin(Int64)` since that's what `-typemin(64)` equals."
352,'StefanKarpinski','array printing only shows the first few columns now\nEarlier, array printing used to show the first few and the last few columns. Now, it only shows the first few. However, in the case of rows, it still shows the first and last few rows. It would be nice to have the original behavior of showing the first and last few columns.\r\n\r\n`julia> rand(100,100)\r\n100x100 Float64 Array:\r\n 0.9855081647166546   0.7290594996053321   0.4520218071241384   :  \r\n 0.9459221906691384   0.6523605246578399   0.0390424896981334      \r\n 0.9082303261548277   0.14640353894875724  0.978974074453369       \r\n 0.9831170811607819   0.5633738106088249   0.39999133833394396     \r\n 0.49178750990051645  0.8261447620770301   0.1373687161141457      \r\n 0.19815512698323468  0.07321565789387718  0.6713381196638348   :  \r\n 0.7485089268850265   0.3110337389266493   0.8127260070007878      \r\n 0.09225990672270057  0.5164689845360908   0.41622752801604057     \r\n 0.6463331342211742   0.631728035674942    0.8432739116222261      \r\n 0.9589961098014961   0.759966809218134    0.8773805898884042      \r\n :                                                                 \r\n 0.44189054473853373  0.7582624831117313   0.27365008249454736     \r\n 0.3789754476891729   0.7282745467614227   0.26109809717894983     \r\n 0.5755478924574304   0.744431037975464    0.8280690881815014      \r\n 0.31616385733163543  0.49213861339515086  0.5900419739032776      \r\n 0.16919930051323973  0.6495643537948732   0.07744277889228335  :  \r\n 0.4150890974477517   0.17595839381354095  0.01932111769978051     \r\n 0.45815810997355433  0.4925601322132367   0.2417257132734527      \r\n 0.43765247512322825  0.9175191887051555   0.11772815227330469     \r\n 0.27087472081338726  0.6977960270235686   0.5431813055965915      \r\n`'
350,'JeffBezanson','Building sys0.ji hangs on 32-bit linux\nThe build process hangs when building sys0.ji on 32-bit linux. I am on Ubuntu 11.10.\r\n'
347,'StefanKarpinski','fprintf\nNow that we have fprintf, it may be possible to get fprintf as well.\r\n'
346,'StefanKarpinski','printf and complex numbers\nHow do we handle complex numbers in printf? It would be nice to handle them. Does C99 say anything on the topic?\r\n\r\n```\r\njulia> printf("%8.2f\\n", randn()+im*randn())\r\ntype error: typeassert: expected Real, got Complex128\r\nin anonymous, no file\r\nin printf, /Users/viral/julia/j/printf.j:315\r\nin run_repl, /Users/viral/julia/j/client.j:22\r\nin _start, /Users/viral/julia/j/client.j:130\r\n```'
344,'JeffBezanson',"these signatures are not matched correctly\nStefan found this a while ago. These two signatures:\r\n\r\n```\r\nassign{K,V}(h::HashTable{K,V}, v::V, key::K)\r\nassign{K,V}(h::HashTable{K,V}, v, k) = assign(h, convert(V,v), convert(K,k))\r\n```\r\n\r\nare not dispatched correctly. I believe the second one called itself.\r\n\r\nThe root of the problem is that `jl_type_match` doesn't handle invariant vs. covariant contexts correctly, unlike type intersection.\r\n"
343,'JeffBezanson',"examine method sort order for *\nCurrently `*(Any,Any,Any)` is sorted before `*(String...,)`. I thought I had updated the algorithm to prioritize argument type over argument count, so I need to look in to why this happens. Fortunately this hasn't broken anything so far."
342,'StefanKarpinski','printf("%f", 1e308)\nDies. The problem is that we overrun the grisu _digits buffer. Too tired to fix it now.'
341,'JeffBezanson','print_to_string bug\n```\r\njulia> uints = [1,10,12,100,123,1000,1234,100000,123456]\r\n[1, 10, 12, 100, 123, 1000, 1234, 100000, 123456]\r\n\r\njulia> ints = [-reverse(uints),0,uints]\r\n[-123456, -100000, -1234, -1000, -123, -100, -12, -10, -1, 0, 1, 10, 12, 100, 123  ...  ]\r\n\r\njulia> join(ints,\',\')\r\n"-123456,-100000,-1234,-1000,-123,-100,-12,-10,-1,0,1,4538416056,12,100,123,1000,1234,100000,123456"\r\n\r\njulia> print_joined(ints,\',\')\r\n-123456,-100000,-1234,-1000,-123,-100,-12,-10,-1,0,1,10,12,100,123,1000,1234,100000,123456\r\n\r\njulia> print_to_string(print_joined, ints, \',\')\r\n"-123456,-100000,-1234,-1000,-123,-100,-12,-10,-1,0,1,4538416056,12,100,123,1000,1234,100000,123456"\r\n```\r\n\r\nSince `print_joined` does the right thing, the culprit here seems like it has to be `print_to_string`. I seen sporadic cases of this recently, but hadn\'t been able to isolate a reproducible example before.'
340,'JeffBezanson','simple way to cut down the number of r*_str macros\nThere are an absurd number of `r*_str` macros for creating regex objects at compile time via non-standard string literals. These exist to support some of the options one can apply to a regex when creating it. However, it\'s really annoying and silly to create a macros for each possible combination of regex flags. Many valid but less common regex flags are omitted because of the combinatorial explosion that would ensue if they were included.\r\n\r\nI propose that instead, non-standard string literals have an optional suffix as well, which, if present, is passed to the macro as a second string argument. Then we could have this definition for regex literals:\r\n\r\n```\r\nconst REGEX_FLAGS = {\r\n    \'i\' => PCRE_CASELESS,\r\n    \'m\' => PCRE_MULTILINE,\r\n    \'s\' => PCRE_DOTALL,\r\n    \'x\' => PCRE_EXTENDED,\r\n}\r\n\r\nmacro r_str(pattern, flags)\r\n  options = int32(0)\r\n  for x in flags\r\n    options |= PCRE_OPTIONS[x]\r\n  end\r\n  Regex(pattern, options)\r\nend\r\n```\r\n\r\nThis single definition would make the following regex literals with flags work:\r\n\r\n```\r\nr"^[a-z]+$"i   # => case insensitive\r\nr"/\\*.*?\\*/"sm # => multiline & dotall\r\nr"  ^          # start\r\n   ([a-z]+)    # protocol\r\n   ://         # colon-double-slash\r\n   ([a-z\\.]+)  # domain\r\n   ...         # etc.\r\n   $           # end\r\n"xi            # => case insensitive and extended syntax\r\n```\r\n'
339,'JeffBezanson','macros should be scoped like functions\n```\r\njulia> let x = 1\r\n         macro foo(v)\r\n           :($v+1)\r\n         end\r\n         @foo x\r\n       end\r\nsyntax error: macro foo not defined\r\nin run_repl, /Users/stefan/projects/julia/j/client.j:22\r\nin _start, /Users/stefan/projects/julia/j/client.j:134\r\n```\r\n Ideally, the macro `@foo` would exist only within the scope of the `let` block.'
337,'JeffBezanson','0-padding in bin,oct,dec,hex fails on negative arguments\n```\r\njulia> bin(-13,8)\r\n"000-1101"\r\n```\r\n'
336,'ViralBShah',"can't infer type of hcat(matrix,vector)\nFor example `[rand(2,2) rand(2)]`.\r\n\r\nThis uses the fallback definition of `cat(dim, x...)`, which handles scalars and everything else. We may need to both work on the function and make some type inference improvements.\r\n\r\nWe also might want to add some more specializations to `cat` to handle common cases like this.\r\n"
333,'JeffBezanson','speye(-1)\nThis causes a segfault.'
332,'JeffBezanson',"tricky method ordering case\n`next(r::Ranges, i::Integer)` gets sorted as more specific than `next{T<:Integer}(r::Ranges{T}, i::T)`, and it shouldn't be --- the second argument is the same, but the first argument of the second one is more restricted."
331,'JeffBezanson','incorrect iround, ifloor, iceil behavior near 2^53\n```\r\njulia> load("j/printf.j")\r\n\r\njulia> begin                       \r\n         p"%3s %3s %3s %3s %3s %3s %3s %3s %3s\\n"(\r\n           "x", "itf", "it", "irf", "ir", "iff", "if", "icf", "ic"\r\n         )                                          \r\n         for x = 2^53-10:2^53+10                    \r\n           y = float(x)                             \r\n           p"%3d %3d %3d %3d %3d %3d %3d %3d %3d\\n"(\r\n             x-2^53,                            \r\n             int(trunc(y))-2^53, itrunc(y)-2^53,\r\n             int(round(y))-2^53, iround(y)-2^53,\r\n             int(floor(y))-2^53, ifloor(y)-2^53,\r\n             int(ceil(y))-2^53,  iceil(y)-2^53\r\n           )\r\n         end\r\n       end\r\n  x itf  it irf  ir iff  if icf  ic\r\n-10 -10 -10 -10 -10 -10 -10 -10 -10\r\n -9  -8  -9  -8  -8  -8  -8  -8  -8\r\n -8  -8  -8  -8  -8  -8  -8  -8  -8\r\n -7  -6  -7  -6  -6  -6  -6  -6  -6\r\n -6  -6  -6  -6  -6  -6  -6  -6  -6\r\n -5  -4  -5  -4  -4  -4  -4  -4  -4\r\n -4  -4  -4  -4  -4  -4  -4  -4  -4\r\n -3  -2  -3  -2  -2  -2  -2  -2  -2\r\n -2  -2  -2  -2  -2  -2  -2  -2  -2\r\n -1   0  -1   0   0   0   0   0   0\r\n  0   0   0   0   0   0   0   0   0\r\n  1   0   0   0   0   0   0   0   0\r\n  2   2   2   2   2   2   2   2   2\r\n  3   4   4   4   4   4   4   4   4\r\n  4   4   4   4   4   4   4   4   4\r\n  5   4   4   4   4   4   4   4   4\r\n  6   6   6   6   6   6   6   6   6\r\n  7   8   8   8   8   8   8   8   8\r\n  8   8   8   8   8   8   8   8   8\r\n  9   8   8   8   8   8   8   8   8\r\n 10  10  10  10  10  10  10  10  10\r\n```\r\n\r\nThey\'re all fine above 2^53, but below 2^53, things are kind of screwed up, except for `itrunc` which uses the LLVM float-to-int primitive directly.'
330,'JeffBezanson','potentially confusing behavior in cartesian loops\nNot sure if this is a bug, but it did surprise me:\r\n\r\n```\r\njulia> for x = int64(2)^53-2:int64(2)^53+5, y=1:2\r\n         println(x)\r\n         x = uint64(x)\r\n       end\r\n9007199254740990\r\n0x001ffffffffffffe\r\n9007199254740991\r\n0x001fffffffffffff\r\n9007199254740992\r\n0x0020000000000000\r\n9007199254740993\r\n0x0020000000000001\r\n9007199254740994\r\n0x0020000000000002\r\n9007199254740995\r\n0x0020000000000003\r\n9007199254740996\r\n0x0020000000000004\r\n9007199254740997\r\n0x0020000000000005\r\n```\r\n'
329,'StefanKarpinski','float ranges: mismatch between length and bounds error\n```\r\njulia> r = 2.0^53-2:2.0^53+3\r\n9.00719925474099000e+15:9.00719925474099600e+15\r\n\r\njulia> r[1]\r\n9.00719925474099000e+15\r\n\r\njulia> r[2]\r\n9.00719925474099100e+15\r\n\r\njulia> r[3]\r\n9.00719925474099200e+15\r\n\r\njulia> r[4]\r\n9.00719925474099200e+15\r\n\r\njulia> r[5]\r\n9.00719925474099400e+15\r\n\r\njulia> r[6]\r\n9.00719925474099600e+15\r\n\r\njulia> r[7]\r\n9.00719925474099600e+15\r\n\r\njulia> r[8]\r\n9.00719925474099600e+15\r\n\r\njulia> r[9]\r\nBoundsError()\r\nin ref, /Users/stefan/projects/julia/j/range.j:76\r\nin run_repl, /Users/stefan/projects/julia/j/client.j:22\r\nin _start, /Users/stefan/projects/julia/j/client.j:134\r\n\r\njulia> length(r)\r\n7\r\n```\r\n'
328,'StefanKarpinski','writing to processes\n```\r\ncmd=`cat`\r\ns=fdio(write_to(cmd).fd,true)\r\nspawn(cmd)\r\nwrite(s,"a\\n")\r\nclose(s)\r\nwait(cmd)\r\n```\r\n\r\nThe `wait` here hangs.\r\n\r\nAlso, the following does not seem to work, but I\'m not sure it\'s supposed to be fully supported yet:\r\n\r\n```\r\njulia> run(Cmd(()->println("foo\\nbar")) | `sort`)\r\nfoo\r\nbar\r\n```\r\n'
325,'JeffBezanson','Error if function definition is split across multiple lines\nfunction foo{T<:Int64}\r\n   (x{T})\r\n\r\n   return x\r\n\r\nend\r\n\r\nsyntax error: misplaced return statement t.j:0\r\nin load, boot.j:266\r\nin run_repl, /Users/viral/julia/j/client.j:22\r\nin _start, /Users/viral/julia/j/client.j:134\r\n\r\n'
324,'StefanKarpinski','Use jit in pcre\nI expect julia regex stuff will get speedups due to the new jit in PCRE.'
322,'JeffBezanson','Error in parse_dec in quick.j\nI see the following on 32-bit (beowulf1):\r\n\r\n../julia quick.j\r\nassertion failed: parse_dec("3830974272")==0xe4580740 quick.j:122\r\nin load, boot.j:266\r\n'
314,'boyers',"plotting from the terminal\nWhat's the best approach to this? I was thinking that maybe we could allow connecting to localhost and seeing plots in a browser window while interacting with the repl in the terminal? Or maybe it's better to just get the web repl working locally more easily so that one can just start a local process and start repling on the local machine? That way local graphics and remote graphics would work the exact same way."
313,'JeffBezanson',"parse A'*B, A*B', and A'*B' specially\nIt's a nasty hack, but we're not going to implement a better solution soon, so lets just make these their own operators. Jeff, can you do this without too much difficulty? I'm not sure how to generalize this to chains of matrix multiplications, however, which is problematic..."
307,'StefanKarpinski','more process features\nThings that are needed:\r\n\r\n- writing to file handles: ``run(`echo Hello` | fh)``\r\n- reading from file handles: ``run(fh | `sort -nr`)``\r\n- writing to files by name: ``run(`echo Hello` > "hello.txt")``\r\n- append to files by name: ``run(`echo world` >> "hello.txt")``\r\n- reading from files by name: ``run("/usr/share/dict/words"  > `tr A-Z a-z`)``\r\n- programmatically writing to a pipeline\r\n- better name than `spawn` for starting a process without blocking\r\n- make `run(cmd)` throw an error on failure\r\n- use `success(cmd)` to just test for success or failure\r\n'
298,'boyers','add brief help instructions to UI\nThe web ui should have a line somewhere telling people how to get help:\r\n\r\n    For help, try help() or help(function), or apropos("string") to search help text.\r\n'
295,'JeffBezanson','want histograms\nI\'d like a hist function\r\n\r\nMost languages, in addition to COUNT,   give an option to have answers so that the area of the "bars"\r\nequals 1.  \r\n\r\nReally I think COUNT and PDF=Normalized  are the only two choices needed most, but some langauges\r\nhave other choices.\r\n\r\nHere\'s a basic histc I once wrote in matlab notation:\r\nI thought it was kind of clever but viral pointed out complexity not\r\nbeing optimal:\r\n\r\n function binsizes = myhistc(data, edges);\r\n ne = length(edges); nd = length(data);\r\n [ignore, p] = sort( [ edges data ] );\r\n f = find(p <= ne); f = f(:)\';\r\n binsizes = diff([ f double(1 + nd + ne)]) - 1;\r\n\r\nalso i prefer line plots to bar plots especially for a pdf plot\r\n'
292,'JeffBezanson','array iterator generating bad code\n```\r\njulia> function a()\r\n       x=[1,2,3]\r\n       function b()\r\n         for i=x\r\n           print(i)\r\n         end\r\n       end\r\n       b()\r\n       end\r\n\r\njulia> a()\r\nin b: #1237 not defined\r\nin b, prompt:4\r\nin a, prompt:8\r\nin run_repl, /Users/jameson/Desktop/18.337/julia/j/client.j:22\r\nin _start, /Users/jameson/Desktop/18.337/julia/j/client.j:128\r\n\r\njulia> function a()\r\n       x=[1,2,3]\r\n       function b()\r\n         for i=1:length(x)\r\n           print(x[i])\r\n         end\r\n       end\r\n       b()\r\n       end\r\n\r\njulia> a()\r\n123\r\n\r\njulia> function a()\r\n       x=[1,2,3]\r\n       function b()\r\n         for i=1:length(x)\r\n           print(x[i])\r\n         end\r\n       end\r\n       for i=x\r\n         print(x)\r\n       end\r\n       println()\r\n       b()\r\n       end\r\n\r\njulia> a()\r\n[1, 2, 3][1, 2, 3][1, 2, 3]\r\n123\r\njulia> for i = [1,2,3]\r\n       print(i)\r\n       end\r\n123\r\njulia> x=[1,2,3]\r\n[1, 2, 3]\r\n\r\njulia> for i = x      \r\n       print(i)\r\n       end\r\n123\r\njulia> \r\n```'
291,'JeffBezanson','Add documentation on how to get performance\nWe should document a few important and/or surprising features of our performance model. For example, that declaring specific types for struct fields is extremely helpful but other type declarations are generally unnecessary.\r\n'
290,'JeffBezanson','allow starting in parallel with a hostfile\nUseful on clusters.\r\n'
287,'JeffBezanson',"Associative Array Comprehension\nSomething like Python's http://www.python.org/dev/peps/pep-0274/"
277,'JeffBezanson','pmap example broken\njulia> M = {rand(800,800), rand(600,600), rand(800,800), rand(600,600)}\r\n{  ...  }\r\n\r\njulia> N = pmap(svd, M)\r\n       \r\naccess to undefined reference\r\nin ref, /Users/jameson/Desktop/18.337/julia/j/array.j:125\r\nin ref, /Users/jameson/Desktop/18.337/julia/j/abstractarray.j:416\r\nin alignment, /Users/jameson/Desktop/18.337/julia/j/show.j:266\r\nin print_matrix, /Users/jameson/Desktop/18.337/julia/j/show.j:323\r\nin show, /Users/jameson/Desktop/18.337/julia/j/show.j:457\r\nin run_repl, /Users/jameson/Desktop/18.337/julia/j/client.j:22\r\nin _start, /Users/jameson/Desktop/18.337/julia/j/client.j:128\r\n\r\njulia> '
274,'boyers',"plot doesn't handle NaN well\nExample:\r\n\r\n```\r\nplot(x->sin(x^2)/x, 0, 4pi())\r\n```\r\n\r\nSpeaking of which, this would be sooo much nicer if `pi` were just a `Float64` constant."
271,'JeffBezanson',"in some cases we could get more from type declarations\nCurrently type declarations are implemented with `convert`. The problem is, in a case like this\r\n\r\n    x = convert(Array{Float64,2}, ????)\r\n\r\nthere are so many matching convert methods that we can't infer the result type. We could either cheat and assume convert always returns something of the right type or, probably better, add a layer of `typeassert` to make sure convert returns the right thing in this case.\r\n"
268,'ViralBShah',"sparse() is really slow\nOn the most simple case, julia sparse() is 20 times slower than matlab. I think the code can be written in a better way for sure, but I'm not sure if it will give us 20x improvement. This does not even include the cases where the inputs have to be sorted.\r\n\r\nMatlab:\r\n\r\n>> a = 1:100000;\r\n>> tic; s = sparse(a,a,a); toc\r\nElapsed time is 0.010585 seconds.\r\n\r\nJulia:\r\n\r\njulia> x = 1:100000;\r\njulia> tic(); sparse(x,x,x); toc();\r\nelapsed time: 0.19214701652526855 seconds\r\n"
264,'StefanKarpinski','do type conversion before equality checking for typed hashes\n```\r\njulia> h = HashTable{Int64}()\r\nHashTable()\r\n\r\njulia> h[1.5] = "1.5"\r\n{2=>"1.5",}\r\n\r\njulia> h[2] = "2"\r\n{2=>"2",2=>"1.5",}\r\n```\r\n\r\nOops.'
263,'JeffBezanson',">>= etc.\nCurrently `>>=`, `<<=` and `>>>=` parse as operators but aren't defined. However, think that like `+=` and its ilk, we need these built into the parser, no?"
262,'JeffBezanson',"performance of keyword arguments\nJeff expressed some concern about performance impacts of keyword arguments since they are inputs to a chunk of code but because they don't get dispatched on, we may not always know much about their type. However, I pointed out that we could to internal dispatch, choosing between different versions specialized on the type of a keyword argument, but not allow external dispatch —\xa0i.e. which method is called is not determined by the type of a keyword argument."
260,'JeffBezanson','suggestions for faster startup\nIdeas for faster startup:\r\n\r\n- cache LLVM bitcode\r\n- cache native code generated by LLVM\r\n- mmap the heap data structures on startup\r\n\r\nWith all of these we may be able to get instantaneous startup.'
258,'JeffBezanson',"behavior of attempting to redefine constants\nOften a source file might define some constants, and you want to reload it to change some function definitions, but the constants don't change. Maybe instead of an error, we should print a warning that the redefinitions were ignored. Same goes for type declarations.\r\n\r\nAnother way to approach this is to change loading behavior so that every expression in a file is evaluated even if some cause errors. Instead of stopping we show the exception and move on.\r\n"
257,'StefanKarpinski','fix comparisons between Float64 and Int64\nWe currently promote to Float64, which gives the wrong answer in cases like these:\r\n\r\n```\r\njulia> float64(2^60) == (2^60+1)\r\ntrue\r\n\r\njulia> float64(2^60) < (2^60+1)\r\nfalse\r\n```\r\n'
255,'JeffBezanson','badness when VARIABLES is made global const\n```\r\njulia> VARIABLES\r\n[]\r\n\r\njulia> x = 1\r\n1\r\n\r\njulia> VARIABLES\r\n[]\r\n\r\njulia> push(VARIABLES, :foo)\r\n[foo]\r\n\r\njulia> VARIABLES\r\n[foo]\r\n\r\njulia> push(VARIABLES, 1)\r\nno method convert(Type{Symbol},Int64)\r\n\r\njulia> VARIABLES\r\naccess to undefined reference\r\n\r\njulia> length(VARIABLES)\r\n2\r\n```\r\n\r\nI made `VARIABLES` global and constant in a39ba7b8f3605b19d320d8095c884b6af959c091.'
253,'StefanKarpinski','incorrect matrix printing: [ [i,j] | i=1:100, j=1:100 ]\nThe output is all wonky.'
252,'JeffBezanson','syntax bug for "v[:end]"\n```\r\njulia> v[:10]\r\n10\r\n\r\njulia> v[:end]\r\nno method ref(Array{Int64,1},Symbol)\r\n\r\njulia> v[:length(v)]\r\ntype error: apply: expected Function, got Symbol\r\n```\r\n\r\nAdmittedly, I usually write the 1 at the front of the range, but this should probably work.'
251,'JeffBezanson','macros don\'t like "!"-suffixed method names\nI have this patch:\r\n\r\n```diff\r\ndiff --git a/j/combinatorics.j b/j/combinatorics.j\r\nindex ce4c4bb..9a57567 100644\r\n--- a/j/combinatorics.j\r\n+++ b/j/combinatorics.j\r\n@@ -56,7 +56,7 @@ function binomial{T<:Int}(n::T, k::T)\r\n     return sgn*convert(T,x)\r\n end\r\n \r\n-## in-place sorting methods ##\r\n+## sorting ##\r\n \r\n function issorted(v::AbstractVector)\r\n     for i=1:(length(v)-1)\r\n@@ -222,37 +222,38 @@ function _jl_mergesort(a::AbstractVector, lo::Int, hi::Int, b::AbstractVector)\r\n end\r\n \r\n sort!{T <: Real}(a::AbstractVector{T}) = _jl_quicksort(a, 1, length(a))\r\n-\r\n-sort!{T}(a::AbstractVector{T}) =\r\n-    _jl_mergesort(a, 1, length(a), Array(T, length(a)))\r\n+sort!{T}(a::AbstractVector{T}) = _jl_mergesort(a, 1, length(a), Array(T, length(a)))\r\n \r\n sortperm{T}(a::AbstractVector{T}) =\r\n     _jl_mergesort(copy(a), linspace(1,length(a)), 1, length(a),\r\n-              Array(T, length(a)), Array(Size, length(a)))\r\n-\r\n-function sort!(a::AbstractMatrix, dim::Index)\r\n-    m, n = size(a)\r\n-    if dim == 1\r\n-        for i=1:m:numel(a)\r\n-            sort!(sub(a, i:(i+m-1)))\r\n-        end\r\n-    elseif dim == 2\r\n-        for i=1:m\r\n-            sort!(sub(a, i:m:numel(a)))\r\n+                  Array(T, length(a)), Array(Size, length(a)))\r\n+\r\n+macro in_place_matrix_op(in_place, out_of_place)\r\n+    quote\r\n+        function ($in_place)(a::AbstractMatrix, dim::Index)\r\n+            m = size(a,1)\r\n+            if dim == 1\r\n+                for i=1:m:numel(a)\r\n+                    ($in_place)(sub(a, i:(i+m-1)))\r\n+                end\r\n+            elseif dim == 2\r\n+                for i=1:m\r\n+                    ($in_place)(sub(a, i:m:numel(a)))\r\n+                end\r\n+            end\r\n+            return a\r\n         end\r\n+        # TODO: in-place generalized AbstractArray implementation\r\n+        ($in_place)(a::AbstractMatrix) = ($in_place)(a,1)\r\n+\r\n+        ($out_of_place)(a::AbstractVector) = ($in_place)(copy(a))\r\n+        ($out_of_place)(a::AbstractArray, dim::Index) = ($in_place)(copy(a), dim)\r\n     end\r\n-    return a\r\n end\r\n \r\n-sort!(a::AbstractArray) = sort!(a, 1)\r\n-\r\n-## non-in-place sort methods ##\r\n-\r\n-sort(a::AbstractVector) = sort!(copy(a))\r\n-sort(a::AbstractArray, dim::Index) = sort!(copy(a), dim)\r\n-sort(a::AbstractArray) = sort(a, 1)\r\n+@in_place_matrix_op :(sort!) :sort\r\n \r\n-# TODO: make this in-place, then call in-place version on a copy\r\n+# TODO: implement generalized in-place, ditch this\r\n function sort(a::AbstractArray, dim::Index)\r\n     X = similar(a)\r\n     n = size(a,dim)\r\n@@ -271,7 +272,8 @@ function sort(a::AbstractArray, dim::Index)\r\n     return X\r\n end\r\n \r\n-# Knuth shuffle\r\n+## other ordering related functions ##\r\n+\r\n function shuffle!(a::AbstractVector)\r\n     for i = length(a):-1:2\r\n         j = randi(i)\r\n@@ -279,7 +281,8 @@ function shuffle!(a::AbstractVector)\r\n     end\r\n     return a\r\n end\r\n-shuffle(a::AbstractVector) = shuffle!(copy(a))\r\n+\r\n+@in_place_matrix_op :(shuffle!) :shuffle\r\n \r\n function randperm(n::Int)\r\n     a = Array(typeof(n), n)\r\n```\r\n\r\nwhich results in the following error when trying to make:\r\n\r\n```\r\nsyntax error: invalid method name \'sort! /Users/stefan/projects/julia/j/combinatorics.j:254 /Users/stefan/projects/julia/j/sysimg.j:87\r\n```\r\n'
250,'JeffBezanson','should default constructors use field types as their argument types?\nCurrently the default constructor for:\r\n\r\n```\r\ntype Foo\r\n  x::A\r\n  y::B\r\nend\r\n```\r\n\r\nwill have the signature `Foo(Any,Any)`, and whatever you pass will be converted (as with any field assignment). Maybe we should change this to `Foo(A,B)` to make it harder to make unintended objects.\r\n'
248,'JeffBezanson','make "global const" work\nTried this:\r\n\r\n```diff\r\ndiff --git a/j/client.j b/j/client.j\r\nindex 1e0d5f9..0776a85 100644\r\n--- a/j/client.j\r\n+++ b/j/client.j\r\n@@ -93,21 +93,21 @@ function _start()\r\n     try\r\n         ccall(:jl_register_toplevel_eh, Void, ())\r\n         ccall(:jl_start_io_thread, Void, ())\r\n-        global Workqueue = {}\r\n-        global Waiting = HashTable(64)\r\n+        global const Workqueue = empty(WorkItem)\r\n+        global const Waiting = HashTable(64)\r\n \r\n         if !anyp(a->(a=="--worker"), ARGS)\r\n             # start in "head node" mode\r\n-            global Scheduler = Task(()->event_loop(true), 1024*1024)\r\n-            global PGRP = ProcessGroup(1, {LocalProcess()}, {Location("",0)})\r\n+            global const Scheduler = Task(()->event_loop(true), 1024*1024)\r\n+            global const PGRP = ProcessGroup(1, {LocalProcess()}, {Location("",0)})\r\n             # make scheduler aware of current (root) task\r\n             enq_work(roottask_wi)\r\n             yield()\r\n         else\r\n-            global PGRP = ProcessGroup(0, {}, {})\r\n+            global const PGRP = ProcessGroup(0, {}, {})\r\n         end\r\n \r\n-        global VARIABLES = {}\r\n+        global const VARIABLES = empty(Symbol)\r\n \r\n         # Load customized startup\r\n         try\r\ndiff --git a/j/multi.j b/j/multi.j\r\nindex a093941..f36e7e1 100644\r\n--- a/j/multi.j\r\n+++ b/j/multi.j\r\n@@ -991,7 +991,7 @@ function start_worker(wrfd)\r\n     # close stdin; workers will not use it\r\n     ccall(dlsym(libc, :close), Int32, (Int32,), int32(0))\r\n \r\n-    global Scheduler = current_task()\r\n+    global const Scheduler = current_task()\r\n \r\n     worker_sockets = HashTable()\r\n     add_fd_handler(sockfd, fd->accept_handler(fd, worker_sockets))\r\ndiff --git a/j/process.j b/j/process.j\r\nindex 33ea6b4..db5a0fe 100644\r\n--- a/j/process.j\r\n+++ b/j/process.j\r\n@@ -29,9 +29,9 @@ process_success(s::ProcessExited) = (s.status == 0)\r\n \r\n type FileDes; fd::Int32; end\r\n \r\n-global STDIN  = FileDes(ccall(:jl_stdin,  Int32, ()))\r\n-global STDOUT = FileDes(ccall(:jl_stdout, Int32, ()))\r\n-global STDERR = FileDes(ccall(:jl_stderr, Int32, ()))\r\n+global const STDIN = FileDes(ccall(:jl_stdin,  Int32, ()))\r\n+global const STDOUT = FileDes(ccall(:jl_stdout, Int32, ()))\r\n+global const STDERR = FileDes(ccall(:jl_stderr, Int32, ()))\r\n \r\n isequal(fd1::FileDes, fd2::FileDes) = (fd1.fd == fd2.fd)\r\n ```\r\n\r\nDoesn\'t work since `global` and `const` don\'t appear to play nicely together. Not sure all of this diff is correct, but the construct makes sense, at least —\xa0it should allow an inner scope to declare a global constant. The opposite order `const global` should probably also work (or be illegal).'
247,'JeffBezanson','allow "!" at the end of an identifier name\nThis will allow us to have in-place array operations with suggestive names: `sort!`, etc.'
243,'JeffBezanson','im*Matrix is much slower than real scalar*Matrix\nMultiplying a matrix with im is 10x slower than multiplying it by a real number.\r\n\r\njulia> @time im*ones(2000,2000);\r\nelapsed time: 1.40052605 seconds\r\n\r\njulia> @time 2*ones(2000,2000);\r\nelapsed time: 0.13868904 seconds\r\n'
242,'ViralBShah','eigs fails on small matrices\n\r\njulia> eigs(randn(5,5))\r\n-3:error in ARPACK aupd\r\n'
240,'JeffBezanson','hitting control-C during input causes bad things to happen\n'
237,'JeffBezanson',"allow passing negative integers to bin, hex, oct\nNow that we do the decoding in Julia, there's no excuse not to handle negative numbers and floats, etc."
236,'ViralBShah',"binary installers\nTo release and expect more than a handful of hardcore users to try Julia, we need easy binary installers. Viral said he's done this on OS X before. Not sure what we can do on Linux — RPMs? Debian packages?"
235,'JeffBezanson',"short form functions inside blocks don't get a source location\nIn this code:\r\n\r\n```\r\nbegin\r\n    function foo()\r\n        1+1\r\n    end\r\n\r\n    bar() = 1\r\nend\r\n\r\nbaz() = 2\r\n```\r\n\r\nwe get source locations for `foo` and `baz` but not `bar`."
234,'StefanKarpinski','define ifloor and iceil library functions\nAll the conversion to integer functions should have i-prefixed versions that yield integer-typed answers.'
233,'JeffBezanson','flipud segfault for large array of strings\n```\r\njulia> Y = [ strcat(char(i),char(j)) | i=1:100, j=1:100 ]\r\n100x100 String Array\r\n"\\x01\\x01" "\\x01\\x02" "\\x01\\x03" : "\\x01b" "\\x01c" "\\x01d" \r\n"\\x02\\x01" "\\x02\\x02" "\\x02\\x03"   "\\x02b" "\\x02c" "\\x02d" \r\n"\\x03\\x01" "\\x03\\x02" "\\x03\\x03"   "\\x03b" "\\x03c" "\\x03d" \r\n:\r\n"b\\x01" "b\\x02" "b\\x03"   "bb" "bc" "bd" \r\n"c\\x01" "c\\x02" "c\\x03"   "cb" "cc" "cd" \r\n"d\\x01" "d\\x02" "d\\x03" : "db" "dc" "dd" \r\n\r\njulia> flipud(Y)\r\nzsh: segmentation fault  julia\r\n```\r\n'
232,'StefanKarpinski','implement reinterpret using jl_reshape_array\nThis should as a side-effect allow the result array to share memory with the argument array.'
231,'ViralBShah','slices of matrices should be vectors\n```\r\njulia> X = [ i^2 - j | i=1:10, j=1:10 ];\r\n\r\njulia> typeof(X)\r\nArray{Int64,2}\r\n\r\njulia> X[:,1]\r\n10x1 Int64 Array\r\n0 \r\n3 \r\n8 \r\n15 \r\n24 \r\n35 \r\n48 \r\n63 \r\n80 \r\n99 \r\n```\r\n'
230,'JeffBezanson',"consider adding TupleType\n```\r\njulia> empty((Int,Int))\r\nno method empty((AbstractKind,AbstractKind),)\r\n\r\njulia> empty\r\nMethods for generic function empty\r\nempty(AbstractArray{T,N},) at abstractarray.j:46\r\nempty(Type{T<:Top},) at array.j:63\r\n```\r\n\r\nShouldn't the above call work?"
227,'JeffBezanson','general expression l-values should fail gracefully\n```\r\njulia> -NaN = 1\r\n\r\njulia> -1 = 1\r\n(unbound-error lst)\r\nunexpected error: #0 (arg-type 1)\r\n#1 (llist-types (1))\r\n#2 (generic-function-def-expr/lambda\r\n (1))\r\n#3 (apply-patterns (#fn(":000r1e0c1|c2c344;" [plambda-expansion (function (call\r\n  name . argl)\r\n  body) #fn(":000r4e0}_g2g344;" [generic-function-def-expr])\r\n\t\t\t\t\t   (__ name argl body)])\r\n\t\t #fn(":000r1e0c1|c2c344;" [plambda-expansion (function (tuple . args)\r\n  body) #fn("9000r3c0c1c2}31Kg2L3;" [-> tuple #fn(copy-list)])\r\n\t\t\t\t\t   (__ args body)]))\r\n\t\t(function (call - 1) 1))\r\n#4 (apply-patterns/lambda\r\n (#fn(":000r1e0c1|c2c344;" [plambda-expansion (function (call (curly name . sparams) . argl)\r\n\t\t\t\t\t\t\tbody)\r\n\t\t\t    #fn(":000r5e0}g2g3g444;" [generic-function-def-expr])\r\n\t\t\t    (__ name sparams argl body)])\r\n  #fn(":000r1e0c1|c2c344;" [plambda-expansion (function (call name . argl) body)\r\n\t\t\t    #fn(":000r4e0}_g2g344;" [generic-function-def-expr])\r\n\t\t\t    (__ name argl body)])\r\n  #fn(":000r1e0c1|c2c344;" [plambda-expansion (function (tuple . args) body)\r\n\t\t\t    #fn("9000r3c0c1c2}31Kg2L3;" [-> tuple #fn(copy-list)])\r\n\t\t\t    (__ args body)])))\r\n\r\n\r\njulia> 1 + 2 = 3\r\n(unbound-error lst)\r\nunexpected error: #0 (arg-type 1)\r\n#1 (llist-types (1 2))\r\n#2 (generic-function-def-expr/lambda\r\n (1 2))\r\n#3 (apply-patterns (#fn(":000r1e0c1|c2c344;" [plambda-expansion (function (call\r\n  name . argl)\r\n  body) #fn(":000r4e0}_g2g344;" [generic-function-def-expr])\r\n\t\t\t\t\t   (__ name argl body)])\r\n\t\t #fn(":000r1e0c1|c2c344;" [plambda-expansion (function (tuple . args)\r\n  body) #fn("9000r3c0c1c2}31Kg2L3;" [-> tuple #fn(copy-list)])\r\n\t\t\t\t\t   (__ args body)]))\r\n\t\t(function (call + 1 2) 3))\r\n#4 (apply-patterns/lambda\r\n (#fn(":000r1e0c1|c2c344;" [plambda-expansion (function (call (curly name . sparams) . argl)\r\n\t\t\t\t\t\t\tbody)\r\n\t\t\t    #fn(":000r5e0}g2g3g444;" [generic-function-def-expr])\r\n\t\t\t    (__ name sparams argl body)])\r\n  #fn(":000r1e0c1|c2c344;" [plambda-expansion (function (call name . argl) body)\r\n\t\t\t    #fn(":000r4e0}_g2g344;" [generic-function-def-expr])\r\n\t\t\t    (__ name argl body)])\r\n  #fn(":000r1e0c1|c2c344;" [plambda-expansion (function (tuple . args) body)\r\n\t\t\t    #fn("9000r3c0c1c2}31Kg2L3;" [-> tuple #fn(copy-list)])\r\n\t\t\t    (__ args body)])))\r\n```\r\n'
226,'JeffBezanson','assignment to true and false should throw const error\n```\r\njulia> true = 12\r\ntrue\r\n\r\njulia> false = "hello"\r\nfalse\r\n```\r\n'
223,'JeffBezanson',"finish implementing ios_{seek,seek_end,skip}\nThese have big TODOs in the middle of them and don't actually do anything at the moment (at least `ios_seek_end` doesn't). Implementing these will make `a` and `a+` modes in `io.j` work correctly. I would try these, but it's hard to grok everything that's going on in `ios.c` and be sure I'm doing it right."
222,'JeffBezanson','assignment to a function-bound var should replace it or fail\n```\r\njulia> f() = 1\r\n\r\njulia> f = 2\r\nMethods for generic function f\r\nf()\r\n\r\njulia> f()\r\n1\r\n```\r\n\r\nEither the `f = 2` should blow away the function object bound to `f` or it should throw an error.'
221,'JeffBezanson','use julia-mode in emacs when calling edit()\nuse julia-mode in emacs when calling edit()'
219,'ViralBShah','Way to return only singular values from SVD\nAlan needs SVD where it only returns the singular values, without wasting resources computing U and V. Need to call the correct routine from LAPACK.\r\n\r\nThis is another of those multiple output things, where matlab does things based on nargout. \r\n\r\nHow do we do it?'
218,'StefanKarpinski','disassemble()\nWould be nice to have a disassemble() routine, and document in the manual the functions that show the AST, the inference results, and generated LLVM code.\r\n'
216,'boyers','Web REPL plus EC2\nWe need the web REPL version plus integration for EC2 to work for simple parallel problems. It seems like we have almost been there for a while, but just not fully there.\r\n'
215,'JeffBezanson',"hash literal syntax: {:a=>1, :b=>2}\nThis is pretty standard in the scripting languages. It's kind of ghetto not to have it."
213,'StefanKarpinski',"fix the external/Makefile target for libunwind\nThis one doesn't work like all the other ones."
208,'boyers','Julia graphics API\n'
207,'boyers','Get web repl working again\n'
206,'StefanKarpinski','replace repl with "interactive session" in manual\nThe term "repl" is not very intuitive and only widely known in Lisp circles.'
204,'StefanKarpinski','split: generalize to chars, strings, char sets, string sets, regexes\nFirst of all, the delimiter should come first like it does in other languages. Next, these should all work:\r\n\r\n```\r\nsplit(\',\', str)\r\nsplit(",", str)\r\nsplit([\',\',\';\'], str)\r\nsplit([",",";"], str)\r\nsplit(/[,;]/, str)\r\n```'
203,'JeffBezanson','single-value tuple destructuring syntax?\nThis works:\r\n\r\n```\r\njulia> (x,) = m.captures\r\n("capture",)\r\n```\r\n\r\nbut this doesn\'t:\r\n\r\n```\r\njulia> x, = m.captures\r\nsyntax error: extra input after end of expression\r\n```\r\n\r\nWould it make sense to allow this slightly odd syntax for destructuring a single value from a tuple?'
202,'JeffBezanson','sort on non-cell arrays fails\n```\r\njulia> sort(["Arabic", "Chinese", "Hebrew", "Hindi", "Japanese", "Korean"])\r\ntype error: copy_to: in conversion to native type, expected BitsKind, got CompositeKind\r\n```\r\n'
200,'StefanKarpinski',"make != and > and >= fallbacks work for all types\nThis seems simple, but there's some complication that made the obvious change fail."
198,'JeffBezanson','parsing bug: 1//-2\n```\r\njulia> 1//-2\r\nno method //(Int64,Function)\r\n```\r\n\r\nThis works:\r\n\r\n```\r\njulia> 1//(-2)\r\n-1//2\r\n```\r\n'
197,'JeffBezanson','hex literals for unsigned ints, sized by digits\nUsually when you use hex notation for numbers, you are trying to create an unsigned value with a particular bit pattern. To facilitate that, it has been proposed that `0x` hex integer literals represent unsigned integers of size determined by the number of digits:\r\n\r\n- hex literals with 1-2 digits create `Uint8` values\r\n- hex literals with 3-4 digits create `Uint16` values\r\n- hex literals with 5-8 digits create `Uint32` values\r\n- hex literals with 9-16 digits create `Uint64` values\r\n\r\nThis proposal would make leading zeros meaningful for hex literals, but only in that they affect the storage size of the resulting value, never its numeric value, which seems acceptable and intuitive.'
196,'JeffBezanson',"make 'let' faster\nYou know what to do."
195,'JeffBezanson',"surprising behavior of nested begin/local usage\n```\r\njulia> begin\r\n         local x = 1\r\n         begin\r\n           local x = 2\r\n         end\r\n         x\r\n       end\r\n2\r\n```\r\nReading through Variables and Scoping, I think this is actually what we say should happen because `begin` blocks *don't* introduce new scope blocks, but I still found it surprising. Maybe `begin` and `(;)` constructs *should* introduce new scope blocks?\r\n\r\nBtw, sorry about all the annoying parser bugs —\xa0it arises from working on the manual and trying out a lot of examples."
194,'JeffBezanson','zero argument macro parse bug\n```\r\njulia> macro todo()\r\n         :(error("TODO: unimplemented code called"))\r\n       end\r\n\r\njulia> @todo\r\nTODO: unimplemented code called\r\n\r\njulia> e = try     \r\n         @todo\r\n       catch e\r\nsyntax error: unexpected catch\r\n```\r\n\r\nNot sure of the general utility of zero-argument macros, but it seems like this ought to work.'
192,'StefanKarpinski','cmd parsing bug\n```\r\njulia> `echo "foo \\$ bar"`\r\nbar not defined\r\n\r\njulia> `echo "foo $ bar"`\r\nbar not defined\r\n```'
191,'JeffBezanson','treat newline as space in argument lists\nThis version doesn\'t parse:\r\n\r\n```\r\nrun(`perl -le \'$|=1; for(0..9){ print; sleep 1 }\'`\r\n    | prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3)\r\n    | prefixer("A",2) & prefixer("B",2))\r\n```\r\n\r\neven though this one does:\r\n\r\n\r\n```\r\nrun(`perl -le \'$|=1; for(0..9){ print; sleep 1 }\'` |\r\n    prefixer("X",3) & prefixer("Y",3) & prefixer("Z",3) |\r\n    prefixer("A",2) & prefixer("B",2))\r\n```\r\n'
189,'GeorgeXing','Implement quickselect\nQuickselect can quickly give us select(k) and median. This is quick and easy to implement, and  for most cases, this is good enough.\r\n\r\nhttp://en.wikipedia.org/wiki/Selection_algorithm#Partition-based_general_selection_algorithm\r\n'
188,'JeffBezanson',"subsection on let blocks\nWe don't explain `let` blocks since they're not control structures, per se. However, they're mentioned as introducing new variable scope blocks in [[Variables and Scoping]]. We need to explain them somewhere. @JeffBezanson, can you explain this, optimally with a few example to distinguish from other variables binding constructs —\xa0such as plain old assignment? I.e. what's the difference between these three blocks:\r\n\r\n```\r\nlet x = 1\r\n  # do something\r\nend\r\n\r\nbegin\r\n  local x = 1\r\n  # do something\r\nend\r\n\r\nfor x = [1]\r\n  # do something\r\nend\r\n```\r\n"
187,'JeffBezanson',"opaque pointers can't be serialized for system image creation\nSee the commit message for 82bdebe55c689efb839a20be04183b8ab0cb83f7. In short the issue is that if a system image needs to include an object that points to memory that's not visible from julia, then there's no way it can properly save and restore that unknown memory. This affects only `version.j` so far and is certainly something we can just work around, but maybe an error should be thrown at system image creation time since we know any pointers will be invalid upon image restoration."
185,'StefanKarpinski','Implement version() and banner()\nWe should have a version() that can programmatically query the version of julia, in a way that allows doing arithmetic on version numbers.\r\n\r\nWe should also have a banner(), which can recreate the banner printed on startup.'
184,'JeffBezanson','Bug in linspace(n,-1,1)\njulia> x = linspace(10,-1,1)\r\n[-9223372036854775808]\r\n\r\n'
183,'GeorgeXing','hcat/vcat need to check the input for errors\nOutput is incorrect size, with extra elements.\r\n\r\njulia> [[1 2; 3 4] [5 6]]\r\n2x4 Int64 Array\r\n1 2 5 0 \r\n3 4 6 0 \r\n\r\nThis should be an error, but gives a bizarre result.\r\n\r\njulia> [[1 2; 3 4] [5 6 7]]\r\n2x5 Int64 Array\r\n1 2 5 7 0 \r\n3 4 6 0 0 \r\n\r\nAnother example:\r\n\r\njulia> [[1, 2, 3] 4]\r\n3x2 Int64 Array\r\n1 4 \r\n2 4 \r\n3 4 \r\n'
182,'JeffBezanson','Print location of method definition when listing all methods\nIn this case, it would be nice if a location, such as floatfuncs.j:82, could be printed for every definition. \r\n\r\njulia> float64\r\nMethods for generic function float64\r\nfloat64(Array{T,n},)\r\nfloat64(String,)\r\nfloat64(Any,)\r\n'
181,'ViralBShah','special-case linear algebra operations for small matrices\nWe now know inline code is faster than BLAS for 2x2 at least.\r\nProbably also helps for matrix*vector and backslash.\r\n'
177,'ViralBShah','return eigenvalues and singular values as vectors\nnot diagonal matrices\r\n'
176,'JeffBezanson','hex(0xffffffffffff)\n```\r\njulia> hex(0xffffffffffff)\r\n"\\0ffffffffffff"\r\n```\r\n'
175,'JeffBezanson','parallel for has a large 1p slowdown\n...due to missing type inference on closures.\r\n'
173,'zingales','addssh_proc(ip,ssh_key) function\nNot only do i think this should be a feature in general. It would help me a out a tremendous amount setting up the EC2 cloud, which should be done in a week or two at the most.'
172,'ViralBShah','N-d support for vectorized functions\nThe vectorized versions of math library functions currently only work on 1- and 2-d arrays:\r\n\r\n```\r\njulia> sin(rand(2,2,2))\r\nno method sin(Array{Float64,3})\r\n```\r\n'
170,'StefanKarpinski',"make conversion to integers round\nThis is easy, per se, but making sure everything that depends on the behavior of conversion to integers doesn't break is harder."
169,'StefanKarpinski','return types of x^y\nAs per [this discussion](http://groups.google.com/group/julia-math/browse_thread/thread/883880718ad4fe99), implement these return types for x^y:\r\n\r\n```\r\nInt.^Int :: Union(Int,Float)\r\nArray{Int}.^Int :: Union(Array{Int},Array{Float})\r\nArray{Int}.^Array{Int} :: Array{Float}\r\nInt.^Array{Int} :: Array{Float}\r\n```\r\n'
168,'JeffBezanson','type intersection does not match NTuple correctly\n```\r\njulia> tintersect( (NTuple{N,Int},NTuple{N,Int}), ((Int,Int), (Int...)) )\r\n((Int,Int),(Int...,))\r\n```\r\n\r\nshould give `((Int,Int),(Int,Int))`.\r\n'
167,'ViralBShah','arpack wrappers should use Int32 for boolean\nThe native code expects bools to be 32 bits wide, and it writes to these arrays, so we are getting buffer overruns. Prevents tests from completing, unless you are "lucky".\r\n'
165,'JeffBezanson','const-ness of function bindings is not enforced consistently\nin the repl if you try to instantiate a variable that is a function name, no error is thrown. however, the variable is not instantiated.\r\n\r\nhowever, if you create a function and do the same thing, in a function declaration, the variable is instantiated.   I feel that these two methods should have the same result, since one should be able to run through a function line by line in the repl. \r\n'
164,'JeffBezanson','Highlight $var in emacs julia-mode\nIt would be nice if `$var` can also be highlighted in julia-mode in emacs. '
163,'JeffBezanson','Use of end in indexing messes up emacs julia-mode\nWhen emacs encounters the use of `end` in indexing, the julia-mode formatting gets messed up. Is this possible to fix?'
161,'JeffBezanson','segfault in complex copy\nI get this segfault on both mac and linux:\r\n\r\njulia> A = rand(4,4)+im*rand(4,4)\r\n0.17584250149951708 + 0.6877470544767339im 0.88135612335715074 + 0.173745331891624im 0.62363835972801351 + 0.02248435353017464im 0.44157952007352708 + 0.87347003136362589im \r\n0.4719037566556048 + 0.96752248726679224im 0.81421101192722722 + 0.04531975639747921im 0.69193175151875486 + 0.56105188807170214im 0.97064152823832361 + 0.07082139358179451im \r\n0.92940422889796293 + 0.26704916541357693im 0.31181040954517081 + 0.91672322585516786im 0.77870577184140521 + 0.88608334387021492im 0.8386925895590871 + 0.38267280920514213im \r\n0.89023876614904984 + 0.39396178263892545im 0.92978669620847909 + 0.84606749473374232im 0.91621144604940885 + 0.68185286607326945im 0.57967078512571946 + 0.29382021829615756im \r\n\r\njulia> copy(A)\r\nSegmentation fault\r\n\r\njulia> copy\r\nMethods for generic function copy\r\ncopy((Any...,),)\r\ncopy(Expr,)\r\ncopy(SubArray{T,N,A<:AbstractArray{T,N},I<:(Union(Int,AbstractArray{T<:Int,1})...,)},)\r\ncopy(DArray{T,N,distdim},)\r\ncopy(AbstractArray{T,N},)\r\ncopy(ANY,)\r\n\r\nWhat is the last method for type ANY? Is this by design, or is it a bug?\r\n'
160,'ViralBShah','Implement eig/eigs for nonsymmetric cases\nCurrently, only symmetric cases of eig/eigs are implemented. Need to complete all the cases.\r\n'
159,'JeffBezanson','odd type inference on this recursive function\n```\r\nfunction g(x,p::Int)\r\n       if p<0\r\n           return inv(g(x,-p))\r\n       end\r\n       return x\r\nend\r\n```\r\n\r\nThis gets the type `Union(Complex128,Int64)` for arguments `(Int64,Int64)`. The root cause is this case:\r\n\r\n```\r\nfoo(x)=inv(error("?"))\r\n```\r\n\r\nwhich gets the type `Complex128`. In this case that\'s fine since it doesn\'t return at all, but it\'s not right in the recursive case.\r\n'
158,'JeffBezanson','weird dispatch/inference/arithmetic bug\n```\r\njulia> f(x::Number, y::Number) = x^2 - 2y + 1\r\n\r\njulia> f(2, 3.0)\r\n-4611686018427387903\r\n```\r\n'
157,'JeffBezanson','absent method ambiguity warning\n```\r\njulia> f(x,y) = x + y\r\n\r\njulia> f(x::Float64, y) = 2x + y\r\n\r\njulia> f(x, y::Float64) = x + 2y\r\n\r\n```\r\n\r\nThe above should generate a warning about the method ambiguity but no longer does. In fact, this is the example ambiguous case in the manual.'
155,'JeffBezanson','load not displaying errors for missing "end"\nis it possible to make load functions display error if there are not the correct amount of ends?\r\n\r\nbecause what happens if there is not the correct amount of ends weird stuff happens, that a lot of times looks like load function is not loading your new methods. \r\n\r\n```\r\n##example function\r\nfunction gen_cartesian_map(cache, genbodies, ranges, exargnames, exargs...)\r\n    N = length(ranges)\r\n    if !has(cache,N)\r\n        dimargnames = { gensym() | i=1:N }\r\n        ivars = { gensym() | i=1:N }\r\n        bodies = genbodies(ivars)\r\n\r\n        ## creating a 2d array, to pass as bodies\r\n        if isa(bodies,Array)\r\n            if (length(size(bodies))==2)\r\n                println("2d array noticed")\r\n\t            body = bodies[1]\r\n\t            bodies = bodies[2:end,:]\r\n            elseif (length(size(bodies))==1)\r\n                println("1d array noticed")\r\n                body = bodies[1]\r\n                bodies_tmp = cell(N,2)\r\n                for i = 1:N\r\n                    bodies_tmp[i] = bodies[i]\r\n                    bodies_tmp[i+N] = nothing\r\n                end\r\n                bodies = bodies_tmp\r\n            ##THERE SHOULD BE AN END HERE\r\n        else\r\n            println("no array noticed")\r\n\t        body = bodies\r\n            bodies = cell(N,2)\r\n            { bodies[i] = nothing | i = 1:N}\r\n        end\r\n        fexpr =\r\n        quote\r\n            let _dummy_=nothing\r\n                local _F_\r\n                function _F_($(dimargnames...), $(exargnames...))\r\n                    $make_loop_nest(ivars, dimargnames, body, bodies)\r\n                end\r\n                _F_\r\n            end\r\n        end\r\n        f = eval(fexpr)\r\n        cache[N] = f\r\n    else\r\n        f = cache[N]\r\n    end\r\n    return f(ranges..., exargs...)\r\nend\r\n```\r\nexmaple behavior\r\n\r\n\r\n\r\n\r\n```\r\njulia> load("tensor.j")\r\n\r\njulia> find(y)\r\n     no method size(Expr,)\r\n     in method_missing, boot.j:274\r\n     in gen_cartesian_map, /home/g3/julia/j/tensor.j:321\r\n     in find, /home/g3/julia/j/tensor.j:922\r\n     in run_repl, /home/g3/julia/j/client.j:21\r\n     in _start, /home/g3/julia/j/client.j:157\r\n\r\n##after this line of code i fix the error that find is running into but do not fix the missing end##\r\njulia> load("tensor.j")\r\n\r\njulia> find(y)\r\n     no method size(Expr,)\r\n     in method_missing, boot.j:274\r\n     in gen_cartesian_map, /home/g3/julia/j/tensor.j:321\r\n     in find, /home/g3/julia/j/tensor.j:922\r\n     in run_repl, /home/g3/julia/j/client.j:21 \r\n     in _start, /home/g3/julia/j/client.j:157\r\n```\r\nHowever, only  i try to make again do i get\r\n\r\n\r\n```\r\nBackTrace(LoadError(ASCIIString(Array()),30,LoadError(ASCIIString(Array()),7,ErrorException(ASCIIString(Array())))),Array())\r\n\r\n```\r\nand i think thats only because tensor.j is loaded into the sysimg\r\n'
154,'JeffBezanson','a[end] should use linear index\nCurrently `end` always has the value `size(a,n)` where n is the position of `end` in the list of indexes. In matlab `a(end)` does `a(numel(a))`, so `end` is different if there is only one index.\r\n\r\nDo we want to do this? I assume we do.\r\n'
153,'JeffBezanson','improve syntax of unquote ($)\ncurrently the "unquote" is $. \r\n\r\nHowever, this conflicts with the $ operator, so the answer to \r\n\r\n```\r\nfor i = 1:10\r\n    quote\r\n        $(array[i])[\r\n    end\r\nend\r\n```\r\n\r\nis unsure. \r\n\r\nalso operations like \r\n\r\n```\r\nfor\r\n   quote \r\n        count$i = name$i (or)\r\n       $(count[i])[2]\r\n\r\n   end\r\nend\r\n```\r\n\r\nwill not do what you want/think it will do '
152,'ViralBShah','Can compare objects of unequal sizes with ==\nrand(2,2)==ones(3,2)\r\nfalse false\r\nfalse false\r\n'
149,'JeffBezanson',"constrained tuple type checking bug\n```\r\njulia> typealias Pair{T} (T,T)\r\nTypeConstructor((T,),(T,T))\r\n\r\njulia> isa((1,2),Pair)\r\ntrue\r\n\r\njulia> isa((1,2.5),Pair)\r\ntrue\r\n```\r\n\r\nThe first `isa` expression should be true, but the second one shouldn't."
148,'JeffBezanson','subtypes of restricted parametric types are unrestricted\nI can see that it would be annoying to enforce this, but it seems bad:\r\n\r\n```\r\njulia> abstract Pointy{T<:Real}\r\n\r\njulia> type Point{T} <: Pointy{T}\r\n         x::T\r\n         y::T\r\n       end\r\n\r\njulia> Pointy{String}\r\ntype error: Pointy: in T, expected Real, got AbstractKind\r\n\r\njulia> Point{String}\r\nPoint{String}\r\n```\r\n\r\nCan subtypes inherit restrictions on their type parameters from their supertype?'
140,'StefanKarpinski','finalize printf format calling syntax\nSee https://github.com/JuliaLang/julia/issues/29#issuecomment-1617061:\r\n\r\n> We should write a wrapper for printf that looks at the format string to check/convert arguments, then calls printf on each format specifier individually.'
136,'JeffBezanson','Matrix constructors should be able to take floating point value for size\nThis should work:\r\n\r\n\r\njulia> a = rand(1e6)\r\nno method rand(Float64,)\r\nin method_missing, boot.j:250\r\nin run_repl, /home/stephan/julia/j/client.j:23\r\nin _start, /home/stephan/julia/j/client.j:153\r\n\r\n'
135,'StefanKarpinski',"output of eig() is formatted in a non-obvious way\n@HomerReid wrote:\r\n\r\n> output of eig() is formatted in a non-obvious way\r\n>\r\n>```\r\n>  julia> eig([1.0 2.0; 2.0 1.0])\r\n>  (-1.0 0.0 \r\n>  0.0 3.0 ,-0.70710678118654746 0.70710678118654746 \r\n>  0.70710678118654746 0.70710678118654746 )\r\n>```\r\n\r\nThis is related to #25 and #29, but should be put down specifically because it's something people are likely to notice fast."
134,'ViralBShah','promote integer types for LAPACK routines\n@HomerReid wrote:\r\n\r\n> eig() fails for integer matrices:\r\n> \r\n>```\r\n>  julia> eig([1 2; 2 1])\r\n>  no method eig(Array{Int32,2},)\r\n>  in method_missing, boot.j:250\r\n>  in run_repl, /home/homer/hacking/julia/j/client.j:23\r\n>  in _start, /home/homer/hacking/julia/j/client.j:153\r\n>```\r\n\r\nThe solution is to add promotions for Real types in the lapack macros.'
133,'JeffBezanson',"add friendly error message for multiple return syntax\n```\r\n  julia> [V, D] = eig([1.0 2.0; 2.0 1.0]) \r\n  syntax error: invalid assignment lvalue (call (top vcat) V D)\r\n  in run_repl, /home/homer/hacking/julia/j/client.j:23\r\n  in _start, /home/homer/hacking/julia/j/client.j:153\r\n```\r\n\r\nInstead, detect what they're trying to do and show a nice friendly message."
132,'JeffBezanson',"ccall should automatically convert integers\nThis can be done for arguments whose types can be inferred. It will make things more convenient in general, but the cost is that it won't be easy to predict when an explicit conversion needs to be written. At the very least it will improve the situation with literals, so you don't need to write `int32(0)`.\r\n"
131,'JeffBezanson','very slow unsigned int for loop iteration\n```\r\njulia> @time for i=uint32(1):uint32(1e7); end;\r\nelapsed time: 3.38669109344482422 sec\r\n```'
129,'JeffBezanson','Implement dlmread / csvread\nImplementing dlmread/csvread will immediately improve the usability of julia, as it will allow people to start reading data from files. Saving to a csv file is also useful similarly.\r\n\r\nHopefully, we can write a csvread that is not restricted only to reading numbers. On many platforms, this is really slow, but hopefully, julia will have a really fast implementation.\r\n\r\nAs an added bonus, it will be useful to be able to read and write file.csv.gz or file.csv.zip.\r\n'
127,'JeffBezanson','64-bit array sizes\nCurrent plan:\r\n\r\n* Use `Size` for all array dims and numel(Array). `Size` will be Int64 on 64-bit platforms and Int32 on 32-bit.\r\n* Use platform word size integer for integer literals\r\n* Generally use `Int` instead of `Index` and allow any integer type.\r\n'
126,'JeffBezanson','the signature {T}(V::(Union(T,Array{T,1}))...) should give an error\nThis should give a union-too-complex error.'
125,'JeffBezanson','clearer error message for using non-booleans in boolean context\n```\r\njulia> (Int32 :: Type{Int32}) && (Type{Int32} <: typeof(Int32))\r\ntype error: lambda: in if, expected Bool, got BitsKind\r\n```'
123,'JeffBezanson','type intersection failure on types with similar supertypes\nThis is wrong:\r\n\r\n```\r\njulia> tintersect( (Array{Float64,2},Range1{Int32}), (Tensor{T},Tensor{S}))\r\nNone\r\n```\r\n'
121,'ViralBShah','Speeding up copy()\nCreate a deep_copy() so that it can be explicitly used where necessary.\r\n\r\nAlso, copy() and copy_to() need to be optimized to use the fastest implementations.  Here are some tests (Mac, Intel Core 2 Duo) that suggest:\r\n\r\n1. memcpy for large copy and copy_to\r\n2. Native julia for small copy\r\n3. BLAS for small copy_to\r\n\r\nCase 2 may be omitted since it is close enough to case 3 to keep things simple. Also, these tests need to be carried out on different architectures too.\r\n\r\n```\r\n!##### Test 1 #######\r\n\r\njulia> a = ones(100)\r\n[1.0,1.0,1.0,1.0,1.0,...,1.0,1.0,1.0,1.0,1.0]\r\n\r\n!## Julia implementation (FASTEST)\r\njulia> @time for i=1:1e5; jcopy(a); end;\r\nelapsed time: 0.38377809524536133 sec\r\n\r\n!## This is DCOPY from BLAS. It is an assembly language implementation in openblas\r\njulia> @time for i=1:1e5; bcopy(a); end;\r\nelapsed time: 0.41508984565734863 sec\r\n\r\n!## This one dispatches to memcpy\r\njulia> @time for i=1:1e5; copy(a); end;\r\nelapsed time: 0.61258411407470703 sec\r\n\r\n!##### Test 2 #######\r\n\r\nI now implemented copy_to() for all cases to remove allocation/GC costs:\r\n\r\njulia> a = ones(100)\r\n[1.0,1.0,1.0,1.0,1.0,...,1.0,1.0,1.0,1.0,1.0]\r\n\r\njulia> b = ones(100)\r\n[1.0,1.0,1.0,1.0,1.0,...,1.0,1.0,1.0,1.0,1.0]\r\n\r\n!## Julia implementation\r\njulia> @time for i=1:1e5; jcopy_to(b,a); end;\r\nelapsed time: 0.04522800445556641 sec\r\n\r\n!## BLAS (FASTEST)\r\njulia> @time for i=1:1e5; bcopy_to(b,a); end;\r\nelapsed time: 0.01788496971130371 sec\r\n\r\n!## memcpy\r\njulia> @time for i=1:1e5; copy_to(b,a); end;\r\nelapsed time: 0.27470088005065918 sec\r\n\r\n!##### Test 3 #######\r\n\r\nAnd now, a larger size:\r\n\r\njulia> a = ones(1000000)\r\n[1.0,1.0,1.0,1.0,1.0,...,1.0,1.0,1.0,1.0,1.0]\r\n\r\njulia> b = ones(1000000)\r\n[1.0,1.0,1.0,1.0,1.0,...,1.0,1.0,1.0,1.0,1.0]\r\n\r\n!## Julia implementation\r\njulia> @time for i=1:100; jcopy_to(b,a); end;\r\nelapsed time: 0.5620429515838623 sec\r\n\r\n!## BLAS\r\njulia> @time for i=1:100; bcopy_to(b,a); end;\r\nelapsed time: 0.5299229621887207 sec\r\n\r\n!## memcpy (FASTEST)\r\njulia> @time for i=1:100; copy_to(b,a); end;\r\nelapsed time: 0.35404396057128906 sec\r\n```'
117,'ViralBShah','find should return linear indices\nFind works differently than in MATLAB, because if you fi\x0cnd on a matrix, you get a bunch of index-pairs. But this is kind of annoying when you\'re dealing with nx1 or 1xn matrices, then you\'re often throwing in fi\x0cnd(v)[1] and \x0cfind(v)[2] to get things to work. To understand, type a = [1,0,1]; and then find\x0cnd(a), \x0cfindnd(a\'), find\x0cnd(a").\r\n\r\nFurthermore, in MATLAB you\'re often doing A1(logical(A2)) or vec1(logical(vec2)), there should be canonical ways of doing these things in Julia.\r\n\r\nThese things should be considered along with whatever Julia\'s solution is to ind2sub and sub2ind (from MATLAB). If A is a matrix of 1\'s and 0\'s, [x,y] = ind2sub(size(A),find(A)) does in MATLAB what find currently does in Julia.'
116,'ViralBShah',"Vector-scalar concatenation doesn't work\nYou can't concatenate a vector with a scalar: [[1,2,3],4] is wrong, [[1,2,3],[4]] is right."
114,'ViralBShah','diagm should support more argument types\n1-column matrices need to be made into vectors to call diagm on them.'
112,'JeffBezanson','reshape should not create a new copy\nreshape() creates a new copy of its input. Is it possible to reshape in-place, by just changing the dimensions. \r\n\r\nAt the very least, this could be done for the following:\r\n\r\na = reshape (a, shape)\r\n'
110,'JeffBezanson','occasional "deserialization error: key not found"\nThis bug shows up sometimes when doing parallel stuff. George and I have both seen it a couple times. It looks like some kind of data corruption, basically sending the wrong bits (those pesky ones and zeros all look alike...).\r\n\r\nA possible clue is that commit 0f686e107b30e769265f857c27e286b5a908333a seemed to make the problem happen much more often. There I tried writing to sockets from both threads.\r\n'
109,'JeffBezanson','promotion bug\n```\r\ntype Foo <: ComplexNum; end\r\nimag(::Foo) = 0\r\nreal(::Foo) = 0\r\n\r\njulia> promote(2,Foo())\r\n(true,false)\r\n```\r\n'
107,'StefanKarpinski','make S"..." and "..." throw errors identically\nWe\'re close to this, but the error messaging of these two forms is still quite different —\xa0the cases in which errors occur is (nearly) the same, but the way errors are shown is quite different. For maximum seamlessness between the two forms, all errors should appear the same.'
105,'JeffBezanson','isassigned predicates\nWe need some way to detect whether object array locations and struct fields are assigned. It would be nice to include local variables as well, plus extensibility for hash tables etc. We might want syntax for this, plus syntax for "assign if not already assigned".'
103,'StefanKarpinski','release process for 1.0 \nDo we fork off the codebase for 1.0? We may want to get rid of a number of things from that branch, as it is prepared for release. This issue can also track all the things that are removed and stay only on the development branch.'
102,'StefanKarpinski','copy byte arrays upon string construction\nStrings are immutable by interface even though manipulation of their underlying data is not prevented. This violates that abstraction:\r\n\r\n```\r\njulia> bytes = linspace(uint8(\'A\'),uint8(\'F\'))\r\n[65,66,67,68,69,70]\r\n\r\njulia> str = ASCIIString(bytes)\r\n"ABCDEF"\r\n\r\njulia> bytes[1] += 32\r\n[97,66,67,68,69,70]\r\n\r\njulia> str\r\n"aBCDEF"\r\n```\r\n\r\nHere, changing a mutable object affects the state of a string object whose interface is immutable.'
101,'JeffBezanson',"local goto\nBasically a `jmp` instruction within a function, much like C's local goto. Requires two pieces of syntax:\r\n\r\n1. labels\r\n2. `goto` statements\r\n\r\nOne issue to keep in mind is that `goto` might get used anywhere `return` does, including this:\r\n\r\n    x = a < b ? -1 :\r\n        a > b ? +1 : goto equal\r\n\r\nAlso: is there any way we can hack this in with minimal changes using the existing macro syntax?"
100,'StefanKarpinski','string interpolation and escaping bug\n```\r\njulia> println("\\\\ $(\'x\')")\r\n x\r\n\r\njulia> println("\\\\ x")\r\n\\ x\r\n```\r\n'
99,'StefanKarpinski','implement uc and lc in C for UTF-8 strings\nA single function may be able to do this depending on the details of UTF-8 encoding.'
96,'ViralBShah','randn performance - implement Ziggurat algorithm\nThis is the julia implementation of randn, which is exactly the same as the C version. It runs about 6 times slower than the C version - even if I remove all the global variable stuff altogether.\r\n\r\n```\r\njl_randn_next = -42.0\r\nfunction randn()\r\n    global jl_randn_next\r\n\r\n    if (jl_randn_next != -42.0)\r\n        s = jl_randn_next\r\n        jl_randn_next = -42.0\r\n        return s\r\n    end\r\n\r\n    s = 1.0\r\n    vre = 0.0\r\n    vim = 0.0\r\n    while (s >= 1.0)\r\n        ure = rand()\r\n        uim = rand()\r\n        vre = 2.0*ure - 1.0\r\n        vim = 2.0*uim - 1.0\r\n        s = vre*vre + vim*vim\r\n    end\r\n\r\n    s = sqrt(-2.0*log(s)/s)\r\n    jl_randn_next = s * vre\r\n    return s * vim\r\nend\r\n```\r\n\r\nHere is the performance analysis for a million calls. I even tried using the libm log, but only sqrt made a difference. I think Jeff has to tell us whats going on. I thought we were not that much slower than C.\r\n\r\nrandn (fully in C): .06 sec\r\nrandn (fuly in Julia, with libm sqrt): 0.38 sec - 6x slower\r\nrandn (fuly in Julia, with libfdm sqrt): 0.59 sec - 10x slower\r\n\r\n'
95,'JeffBezanson',"2d array indexing is very slow\n2d array indexing is significantly slower than matlab for us.\r\n\r\n*** MATLAB ***\r\n\r\nfunction t = mytranspose(x)\r\n    [m, n] = size(x);\r\n    t = zeros(n, m);\r\n    for i=1:n\r\n      for j=1:m\r\n        t(i,j) = x(j,i);\r\n      end\r\n    end\r\nend\r\n\r\n\r\n>> a = ones(2000,2000);\r\n>> tic; mytranspose(a); toc\r\nElapsed time is 0.132217 seconds.\r\n\r\n*** Julia ***\r\n\r\nfunction transpose(a::Matrix)\r\n    m,n = size(a)\r\n    b = similar(a, n, m)\r\n    for i=1:m, j=1:n\r\n        b[j,i] = a[i,j]\r\n    end\r\n    return b\r\nend\r\n\r\n\r\njulia> x = ones(2000,2000);\r\n\r\njulia> tic(); y = x'; toc();\r\nelapsed time: 2.17426395416259766 sec\r\n"
93,'GeorgeXing','subarray for implementing various operations on slices of arrays\nDiscussion on subarrays here:\r\n\r\nhttp://groups.google.com/group/julia-math/browse_thread/thread/f07b1f6047d98a8c/\r\n\r\nAlso, some in:\r\n\r\nhttp://groups.google.com/group/julia-math/browse_thread/thread/911c762b49ddb08/'
91,'JeffBezanson','spawn should capture global variables\n`@spawn` expressions correctly capture local variables the way closures always do, but this does not work for global variables defined at the prompt:\r\n\r\n    julia> d=drandn(4,4)\r\n    DArray((4,4),RemoteRef(1,1,2),[1,2],[1,3,5],2,1,GlobalObject())\r\n    \r\n    julia> @spawn d[1]+1\r\n    RemoteRef(2,1,4)\r\n    \r\n    julia> exception on 2: in anonymous: d not defined\r\n\r\nThis should be made to work somehow. Basically we need to surround the spawn with `let d=d ...` for each global it references.'
90,'JeffBezanson',"make isequal compare identity by default\nSee this discussion:\r\n\r\nhttp://groups.google.com/group/julia-math/browse_thread/thread/d9b27f68ffe6e85a/bdf8c3662affd183\r\n\r\nWe want hash tables to hash by object identity by default. In general, these definitions don't seem quite right:\r\n\r\n    isequal{T}(x::T, y::T) = (x==y)\r\n    isequal(x, y) = isequal(promote(x,y)...)\r\n"
88,'StefanKarpinski','(re)design regex API\nThe current approach of returning a RegexMatch object that sort of pretends to be a String is a bit fishy. We probably need to spend a good bit more time figuring out how to make application of regexes nicely usable.'
87,'boyers','Julia graphics\nWe need to get basic graphics functionality quickly. \r\n'
86,'JeffBezanson','[1,1]]]] should be rejected by the parser\nAll of these should be parse errors:\r\n\r\njulia> [1,1]]]]\r\n[1,1]\r\n\r\njulia> {1,1}}}}\r\n{1,1}\r\n\r\njulia> (1,1))))\r\n(1,1)\r\n'
85,'JeffBezanson',"ccall does not support C99 complex numbers\nI fixed complex dot(), but it still does not work correctly. I can't figure out what might be wrong. The only thing I can think of is that the C interface probably does not know how to return complex numbers.\r\n"
84,'StefanKarpinski','add section on constructors\nBased on [my explanation](http://groups.google.com/group/julia-math/browse_thread/thread/38166018a7c2caff) from the mailing list.'
83,'JeffBezanson',"macro arguments of type :foo :bar are parsed as ranges\nMacros that have multiple arguments of the following kind get parsed as ranges. It seems that putting brackets around `:foo` and `:bar` doesn't help either.\r\n\r\n    @foobar :foo :bar"
82,'JeffBezanson','a pair of new constructor bugs\n```\r\njulia> Set{Int32}()\r\nno method HashTable(BitsKind,BitsKind)\r\n\r\njulia> set()\r\nin set: T not defined\r\n```'
79,'ViralBShah','complete implementation of eigs and svds\nWe probably need to complete the eigs and svds implementation for 1.0, or at least decide what all we are going to provide for 1.0.\r\n\r\n'
74,'ViralBShah','Implement basic sparse matrix support\nWe have some preliminary work in sparse.j, but a long way to go. I feel that the right approach is to do all basic operations in Julia, so that we can have sparse arrays with all types.\r\n\r\nThen, plug in most of SuiteSparse for sparse linear algebra.\r\n\r\nhttp://www.cise.ufl.edu/research/sparse/SuiteSparse/\r\n'
73,'JeffBezanson','implement tab completion for global functions and vars\nreadline has an API for this.'
72,'JeffBezanson','don\'t treat #! args as options\nConsider the following script:\r\n\r\n```\r\n#!/usr/bin/env julia\r\nprintln(ARGS)\r\n```\r\n\r\nThis currently behaves like this:\r\n\r\n```\r\n$ ./printargs.j -x\r\njulia: invalid option -- x\r\n```\r\n\r\nwhereas, it should emulate perl and ruby, and behave like this:\r\n\r\n\r\n```\r\n$ ./printargs.j -x\r\n{"-x"}\r\n```\r\n'
68,'StefanKarpinski',"ARGS constant doesn't get set correctly anymore\n```\r\n$ julia -e 'println(ARGS)'\r\nArray(Any,(0,))\r\n$ julia -e 'println(ARGS)' foo bar\r\nArray(Any,(0,))\r\n```"
67,'ViralBShah',"improve RNG\nWe already use mersenne twister, but SFMT/dSFMT is supposed to be faster:\r\n\r\nhttp://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/index.html\r\n\r\nWe also need better seeding.\r\n\r\nThe work items are\r\n\r\n* Switch to SFMT\r\n* Move RNG library to external/, so everything under src/ is our own code.\r\n* Be able to seed from /dev/urandom\r\n* Save the seed somewhere (wherever it came from) so any run can be reproduced even if you didn't seed manually\r\n"
66,'StefanKarpinski','doc pages need links\nboth forwards and backwards to the next/previous sections'
65,'JeffBezanson','Start julia in parallel using a command line option\nWe need an easy way to start julia in parallel through a command line option. The default method can be addprocs_local. Something like the following will be great.\r\n\r\njulia -p 4\r\n\r\nor \r\n\r\njulia -n 4'
64,'StefanKarpinski','pcre_h.j introduces dependency on perl\nI feel that we should just check in pcre_h.j. It introduces an unnecessary dependency on perl.\r\n\r\nAlso, it seems to be odd to have this in the top-level Makefile. Perhaps this should be in j/Makefile.\r\n'
63,'ViralBShah','(2x3)\\(2x2) crashes inside LAPACK\nLooks like something is causing dgels to write outside an array:\r\n\r\n    julia> A=rand(2,3);b=rand(2,2)\r\n    0.15240817408192342 0.68197511458982851 \r\n    0.28618656967918277 0.85123727301755281 \r\n    \r\n    julia> A\\b\r\n    ==31381== Invalid write of size 8\r\n    ==31381==    at 0x12114FF0: dgels_ (in /home/jeff/src/julia-master/julia/external/root/lib/libLAPACK.so)\r\n    ==31381==    by 0x76F10C3: ???\r\n'
62,'GeorgeXing',"Backslash operator on bad inputs causes segfaults\nUsing the \\ operator on matrices with unequal numbers of rows causes segfaults to appear (not always in the same place). An example transcript:\r\n\r\n    julia> A = rand(2,3); b = rand(1,4)\r\n    0.91206938232058632 0.54042487514107229 0.06639860694511301 0.45407035177558663 \r\n    \r\n    julia> A \\ b\r\n    2.12491438834975988 0.29000399043165048 -0.44064826960265002 1.10118494911718057 \r\n    \r\n    julia> A\r\n    0.41408160823125217 0.12696871086821648 0.0105299806962571 \r\n    0.34489290137506634 0.80644665662943371 0.96747404070762699 \r\n    \r\n    julia> A[:,:]\r\n    0.41408160823125217 0.12696871086821648 0.0105299806962571 \r\n    0.34489290137506634 0.80644665662943371 0.96747404070762699 \r\n    \r\n    julia> b\r\n    0.91206938232058632 0.54042487514107229 0.06639860694511301 0.45407035177558663 \r\n    \r\n    julia> b[:,:]Segmentation fault\r\n\r\n(Often, this will segfault on the A[:,:] call, and it sometimes doesn't segfault at all.) I suspect that this is simply a result of the code for the \\ operator not checking that the inputs have the same number of rows."
60,'ViralBShah','implement fft and related functions\nWe need fft before launch. I assume FFTW is the only realistic library we can use. If it is too much of a pain to integrate until our full C FFI is ready,  we can go with FFTPACK.\r\n'
59,'GeorgeXing','Add complex versions of BLAS and LAPACK functions\nNow that we seem to have the capability, we need to implement the complex BLAS/LAPACK functions. The macros should be able to handle it largely, but some code changes will be required so that the right constructors are used etc. Currently, math_linalg.j was designed to target only the real functions.\r\n'
57,'JeffBezanson',"namespaces / modules\nWe're still unclear on how they would work, but we probably will want to have modules or namespaces at some point."
54,'JeffBezanson','divide by zero exception is not reliable\nIn LLVM semantics dividing by zero gives undefined behavior. Basically, in any case where it is able to evaluate the division at compile time you get a strange number answer instead of an exception:\r\n\r\n    julia> g()=begin\r\n           local b=0\r\n           div(1,b)\r\n           end\r\n    Methods for generic function g\r\n    g()\r\n    \r\n    julia> g()\r\n    -1081290856\r\n'
52,'StefanKarpinski','run doc example code as a test suite\nThe examples in the wiki should all be exactly what the interpreter actually produces. We should automate comparing the output of the interpreter with what is in the wiki, thereby ensuring accuracy of all the examples and serving as an additional set of integration tests. One issue is when to clear variables and state. An obvious choice is to retain state within sections (or subsections, or whatever).'
51,'StefanKarpinski','consistent design of streams, strings and their interfaces\nThis overlaps somewhat with issue #50 in that streams and strings can be viewed as collections that contain characters. However, it seems worth making a separate issue. We currently also make no distinction between streams of characters and strings, but there is a major difference: a stream can only be iterated forwards, while a string provides random access. Many of our string operations could actually be stream operations, thereby allowing much more efficient usage in cases where the data is being read incrementally.'
50,'StefanKarpinski',"consistent design of collections and their interfaces\nThe current interface to things like hashes and sets is pretty thrown together and dodgy. For example, you can't put a set into a set at the moment because `add(s::Set, s2::Set)` adds the contents of the second set to the first, rather than adding the second set to the first as an item."
48,'StefanKarpinski',"complete documentation for 1.0 release\n[edit: see Stefan's list below for bulleted list]\r\n\r\nThis includes:\r\n\r\n- JuliaLang.org [website](http://julialang.org)\r\n- up-to-date [README on GitHub](https://github.com/JuliaLang/julia#readme)\r\n- complete [wiki documentation](https://github.com/JuliaLang/julia/wiki) of all v1.0 language features\r\n\r\nThese are all necessary for the v1.0 release."
47,'JeffBezanson','Building sys.ji takes very long\nIt would be great if all the individual .j files are compiled separately, and then somehow combined into sys.ji. Even a one line modification triggers sys.ji to be built from scratch. Would be nice if it was faster.'
44,'JeffBezanson','implement floating point parsing; float32, float64, float\nSee [this](http://groups.google.com/group/julia-math/browse_thread/thread/e59e72b2a62fca88) email discussion.'
43,'JeffBezanson','try; catch; end\nMaybe should have made this one issue with #42:\r\n\r\n    julia> try; catch; end\r\n    syntax error: expected variable in catch\r\n'
42,'JeffBezanson','try catch end\n    julia> try\r\n           catch\r\n           end\r\n    in lambda: g4 not defined\r\n'
40,'ViralBShah','ARPACK compiles every time you run make\nLike it says, every time I run make in external/ it causes ARPACK to get recompiled.'
39,'JeffBezanson','missing fdlibm functions\nfdlibm seems to be missing a few functions here and there. fdlibmf has log2f, but fdlibm does not have log2:\r\n\r\n    julia> log2(2.)\r\n    dlsym: /home/jeff/src/julia2/julia/lib/libfdm.so: undefined symbol: log2\r\n\r\nOn the other hand, fdlibm has lgamma_r but fdlibmf does not.\r\nI found implementations of these from BSD sources by searching for e_log2.c and e_lgammaf_r.c.\r\n\r\n* We should check in fdlibm like we do for fdlibmf, and add the missing files\r\n* We only use platform libm for 5 functions, so we might as well stop linking against it and use fdlibm for everything\r\n'
38,'zingales','evaluate and improve array primitives\nI suspect many of our critical array functions like ref, assign, cat, and transpose are highly suboptimal in many cases. For example ref/assign should be able to use memcpy (or equivalent) for the inner loop even for N-d.\r\nWe should time each of these functions in various cases and deal with any problems.\r\n'
37,'JeffBezanson','whos command\nWe need a whos command, which shows all global variables.\r\n'
36,'JeffBezanson','input "a." causes internal error in parser\njulia> a.\r\n(type-error string.find string #<eof>)\r\nunexpected error: #0 (char-numeric? #<eof>)\r\n#1 (next-token/lambda/lambda\r\n #\\. #<eof>)\r\n#2 (next-token/lambda #\\.)\r\n#3 (peek-token [#f #<io stream> #f #f])\r\n#4 (parse-call/lambda/lambda/lambda\r\n a)\r\n'
35,'JeffBezanson','make return with no value return Nothing\nDepends on issue #28.'
30,'JeffBezanson',"redesign constructors to allow uninitialized fields\nCurrently we need to do ugly things to make circular references:\n\n    type MyType\n      self::Union((),MyType)\n      function MyType()\n        v = new(())\n        v.self = v\n      end\n    end\n\nThat is really bad, both ugly and compiler-unfriendly. With the change, we'd have\n\n    type MyType\n      self::MyType\n      MyType() = (this.self = this)\n    end\n\nFor constructors inside the type block, `this` is supplied, and the type's static parameters will be visible as well. `this` will also be returned automatically, and using `return` in a constructor will be an error.\nHere's what `Rational` would look like:\n\n     type Rational{T<:Int} <: Real\n         num::T\n         den::T\n     \n         function Rational(n::Int, d::Int)\n             # can use T here\n             g = gcd(n,d)\n             this.num = div(n,g)\n             this.den = div(d,g)\n             # this is returned implicitly\n         end\n     end\n     \n     Rational{T}(n::T, d::T) = Rational{T}(n,d)\n     Rational(n::Int, d::Int) = Rational(promote(n,d)...)\n     Rational(n::Int) = Rational(n,1)\n\nNotice the constructor inside the type block is only usable given an instantiated version of the type, `Rational{T}`. An outside generic function `Rational()` is defined to do this for you. If there are no user-defined constructors, we can still provide the same default constructors we have now.\n\nOne downside to this is that we'll have to check each field access for uninitialized references, as we currently do for elements of pointer arrays.\n"
28,'StefanKarpinski',"make for, while, etc. return Nothing instead of ()\nWe discussed this once a long time ago and decided that it would be nice to have a `Nothing` object that prints as nothing. Then when entering code into the repl, one doesn't have to worry about putting an unseemly `;` at the end of a for loop to suppress the annoying `()`. Also it would make some potential errors more sensible: if you try to do anything with the `Nothing` value it can throw a fairly specific error, whereas `()` is a perfectly legitimate value for many expressions to produce."
27,'JeffBezanson','strange behavior of SIGFPE and SIGSEGV handlers \nIn some builds, the SEGV handler does not work until SIGFPE has been raised. We used to address this with the infamous "awful_sigfpe_hack", then at some later point testing showed it was no longer necessary. However, for me the problem is back:\r\n\r\njulia> f(x)=f(x)\r\nMethods for generic function f\r\nf(Any,)\r\n\r\njulia> f(2)\r\nSegmentation fault (core dumped)\r\n\r\n\r\nVS.\r\n\r\n\r\njulia> div(1,0)\r\nerror: integer divide by zero\r\n\r\njulia> f(x)=f(x)\r\nMethods for generic function f\r\nf(Any,)\r\n\r\njulia> f(2)\r\nerror: stack overflow\r\n\r\nBy frobbing it a bit I found that setting up the signal handlers after loading the system image (in init.c) "fixes" the problem again. I don\'t understand this at all. It might have made sense that something was different after entering a signal handler (e.g. the signal mask, but I tried frobbing that too), but I don\'t know what is different this time. This is a mystery.\r\n'
26,'JeffBezanson','trap ctrl-C in the repl\nCtrl-C currently kills the repl, which is very annoying. It should abort the current computation as quickly as possible.'
24,'ViralBShah','use faster BLAS by default\nSimple linear algebra is likely to be one of the first things people try, and it needs to perform reasonably.\r\nWe could use ATLAS, or gotoblas:\r\nhttp://www.tacc.utexas.edu/tacc-projects/gotoblas2/downloads/\r\ngotoblas is not maintained, but it is already very fast, BSD licensed, and runs everywhere julia runs.\r\n'
22,'JeffBezanson','Change specificity rules for methods involving union types\nMethod signatures should look into Union types to find a more specific match.\n\nThe recent checkins in sparse.j result in a less specific version being called:\n\nWarning: new definition +(SparseArray2d{T},Union(Array{T,N},Number)) is ambiguous with +(Tensor{S,N},Tensor{T,N}). Make sure +(SparseArray2d{S},Array{T,N}) is also defined.\nWarning: new definition +(SparseArray2d{T},Union(Array{T,N},Number)) is ambiguous with +(Tensor{T,N},Number). Make sure +(SparseArray2d{T},Number) is also defined.'
21,'JeffBezanson',"Simplify concatenation syntax by disallowing use of , and ; simultaneously\nWhy don't we disallow combining comma and semicolon, and comma and space? In other words, the only allowed syntaxes are\r\n\r\n[1,2,3,4]  # 1d array\r\n[1 2;\r\n 3 4]  # matrix\r\n\r\nUse the first one when you are thinking of arrays or lists, and the second one when you are thinking of matrices."
18,'JeffBezanson','2.*3 parses as (2.)*(3) instead of (2).*(3)\nEnough said.'
17,'JeffBezanson','read(io, Type, n) beyond end of file hangs\nExample:\r\n\r\n    julia> read(open("/dev/null"), Uint8, 1)\r\n    ^C\r\n\r\nWorse still, it busy-waits. This bug kicks in when `make test-utf8` is run without run `make` in the `test/unicode` directory first.'
15,'StefanKarpinski','Doc and wiki reorg\nDoc stuff should perhaps move to the wiki, wherever it makes sense. Some of the stuff is notes, and then there is the manual as well.\r\n'
13,'JeffBezanson','implement immutable types\nThe conclusion of our [last discussion](http://groups.google.com/group/julia-math/browse_thread/thread/7aab753b3a979b0b/305572a47351411e) on immutability versus mutability was that it is largely a psychological distinction:\n\n* when an object is identified by its value, then it should be immutable: integers, floats, complexes, strings;\n* when an object is a container, whose identity can remain the same while its contents change, then it should be mutable: arrays, linked list nodes, tree nodes.\n\nTo declare that a new concrete type is immutable, prefix its declaration with immutable:\n\n    immutable type Complex{T<:Real} <: Number\n      re::T\n      im::T\n    end\n\nAlternately, only the immutable keyword could be used:\n\n    immutable Complex{T<:Real} <: Number\n      re::T\n      im::T\n    end\n'
12,'StefanKarpinski','remove unicode/; make test_utf8.j generate data on the fly\nNow that we have sufficient external process functionality, this should be easy.'
11,'StefanKarpinski','implement b"..." byte array literals\nGenerate literal byte arrays wherein `\\x` and `\\u` are just shorthand for sequences of bytes.'
10,'StefanKarpinski','throw error if a bare string literal is invalid UTF-8\nSee [this thread](http://groups.google.com/group/julia-math/browse_thread/thread/31942b387ea416c3). This changes the behavior for bare string literals previously described in #4 to be the following:\n\n* all bytes < 0x80: `ASCIIString`\n* has bytes ≥ 0x80 and is valid UTF-8: `UTF8String`\n* invalid UTF-8: throws an error\n\nThe `b"..."` string form (see #11) will let you use string syntax with `\\x` and `\\u` to make byte arrays. If you want to make a UTF-8 string that contains invalid UTF-8, you can do something this:\n\n    UTF8String(b"\\xff\\xff")\n'
9,'StefanKarpinski','fix test_utf8.j\nThis non-default test has been failing for quite some time, I think.'
7,'StefanKarpinski','load path\nCurrently we have a half-baked, implicit load path for `.j` files loaded via the builtin `load()` function. It should be possible to add a list of directories to look in for `.j` files. The rule should probably be that names without `/` in them are looked up via the load path, while names beginning with `/` are considered to be absolute and names with `/` anywhere else are relative to the current directory.'
6,'StefanKarpinski','install make target\nYou should be able to do `make install` and have a compiled copy of all of julia installed on a system. The default location should be under `/usr/local` but should be configurable. It would be nice even for us developers to have both an installed (unbroken) copy of julia and have the development copy still live in the repo directory. That way when the development version is broken, you can still use julia for other stuff.'
4,'StefanKarpinski','string literals: ASCIIString, UTF8String\nSee the [discussion here](http://groups.google.com/group/julia-math/browse_thread/thread/e353c4ef35ba05b3). The salient conclusion is this:\n\nEscapes continue to work the way they do now: `\\x` always inserts a single byte and `\\u` always inserts a sequence of bytes encoding a unicode character. Literals are turned into String objects according to the following simple check:\n\n   - `ASCIIString` if all bytes are < 0x80; \n   - `UTF8String` if any bytes are ≥ 0x80. \n\nIf you want to use `\\x` escapes with values at or above 0x80 to generate invalid UTF-8, that\'s your business. We can also introduce an `Latin1"..."` form that uses the Latin-1 encoding to store code points up to U+FF in an efficient character-per-byte form. Finally, the `b"..."` macro-defined string form can let you use characters and escapes (both `\\x` and `\\u`) to generate byte arrays.\n\nWe can safely and quickly concatenate `ASCIIString`s with each other, with `UTF8String`s, or with `Latin1String`s. Mixing `UTF8String`s and `Latin1String`s, however, requires transcoding the `Latin1String`s to UTF-8. This, however, will not occur with string literals since they will always be `ASCIIString`s or `UTF8String`s.'
3,'StefanKarpinski','systematic, efficient approach to string construction\nThe current approach uses polymorphism to make RopeString objects. This is pretty inefficient for the typical small string use-case. To efficiently construct a C-style string in the current framework, one makes the current output stream a memio object and then prints to it. The general pattern I\'ve used is to write a `print_whatever` function and then wrap it in a `whatever` function that returns a string using `print_to_string`. Should we stick with this pattern? It has the advantage of allowing the printing version to be very efficient, but it\'s kind of awkward to write. Should we figure out a different pattern? Something like C#\'s `StringBuilder` pattern?\r\n\r\nPerhaps it suffices to make `strcat` check the size and encodings of its arguments and use `print_to_string` approach to concatenate them into a copied string where appropriate —\xa0namely when the arguments are of compatible encodings (e.g. any mixture of `ASCIIString` and `UTF8String`), and if concatenated they would be below some size threshold. For larger strings, we should continue to use the `RopeString` approach. Also, string slices should copy their contents as well unless the resulting string is above the "large string" threshold, in which case, they can continue to use the current `SubString` with the known issue that this pins the superstring in memory.'
2,'StefanKarpinski','reimplement Set efficiently using hash tables\nThe current implementation is frankly embarrassing.'
1,'StefanKarpinski','efficient sets using hash tables\nThe current implementation was never meant to be more than a very temporary stop-gap and is frankly embarrassing.'
9116,'andreasnoack','Eliminate copies when returning from LAPACK wrappers\nSome of the wrapped LAPACK subroutines for eigenproblems support calculation of a subset of the spectrum and return an intereger of the number of eigenvalues calculated. Right now, the wrappers use this integer to return part of the array used by LAPACK. This creates a copy and we might want to avoid that in the LAPACK wrapper and wait until it is strictly necessary, e.g. in exported methods.'
9084,'andreasnoack','Segfault in svd\nIn release-0.3 I get a segfault in openblas when running svd\r\n\r\n    using TestImages, ImageView    \r\n    img = testimage("cameraman")\r\n    pixels = convert(Array{Float32}, img.data)\r\n    svd(pixels)\r\n\r\nyields\r\n\r\n    signal (11): Segmentation fault: 11\r\n    .L1_39 at /Users/syt/julia/usr/lib/libopenblas.dylib (unknown line)\r\n    signal (10): Bus error: 10\r\n    .L1_39 at /Users/syt/julia/usr/lib/libopenblas.dylib (unknown line)\r\n    signal (11): Segmentation fault: 11\r\n    .L1_39 at /Users/syt/julia/usr/lib/libopenblas.dylib (unknown line)\r\n    Bus error: 10\r\n\r\nThis runs fine when I exclude ImageView'
8839,'JeffBezanson','Jeff Bezanson PhD\nOne of the core Julia authors, @JeffBezanson, has become a problematic developer.   He needs to graduate from MIT, ideally by January 2015.   Dependencies:\r\n\r\n- [x] Thesis proposal.\r\n- [x] Thesis outline.\r\n- [x] Meeting with thesis committee.\r\n- [ ] Rough draft sent to advisor(s).\r\n- [ ] Schedule defense.\r\n- [ ] Final draft sent to committee.\r\n- [ ] Defense.\r\n- [ ] Alcohol.\r\n\r\nThis is a priority issue, to ensure that arms are not broken and to guarantee long-term viability of the Julia project.\r\n\r\ncc: @alanedelman, @jiahao, @StefanKarpinski, @ViralBShah, @samanamarasinghe, @gjs'
8728,'StefanKarpinski',"merging itrunc into trunc, etc.\n@simonbyrne [observed](https://github.com/JuliaLang/julia/issues/8646#issuecomment-58746586) that we could replace `itrunc(x)` with `trunc(Integer, x)` and similarly for `iround`, `iceil` and `ifloor`, making for a four-function reduction to the list of exports from Base. So far so good, but this brings up the issue of what these function generically mean, which is why I'm filing this issue for discussion."
8319,'timholy','var and std do not work for Any[]\nAll other statistic functions in Base work work for `Any` arrays of numeric values.\r\n\r\n```julia\r\njulia> test = Any[1,2,3]\r\n3-element Array{Any,1}:\r\n 1\r\n 2\r\n 3\r\n\r\njulia> std(test)\r\nERROR: `zero` has no method matching zero(::Type{Any})\r\n in var at statistics.jl:162\r\n\r\njulia> var(test)\r\nERROR: `zero` has no method matching zero(::Type{Any})\r\n in var at statistics.jl:162\r\n```'
8048,'StefanKarpinski','Better handling of error when remote repository is not available\nGithub isn\'t serving `Glob.jl` right now.  When trying to install, it would be nice if the error were better handled.\r\n\r\n```julia\r\njulia> Pkg.add("Glob")\r\nINFO: Cloning cache of Glob from git://github.com/vtjnash/Glob.jl.git\r\nfatal: remote error: \r\n  Storage server temporarily offline. See http://status.github.com for GitHub system status.\r\nERROR: unlink: no such file or directory (ENOENT)\r\n in wait at ./task.jl:284\r\n in wait at ./task.jl:194\r\n in wait at task.jl:48\r\n in sync_end at ./task.jl:311\r\n in add at pkg/entry.jl:319\r\n in add at pkg/entry.jl:71\r\n in anonymous at pkg/dir.jl:28\r\n in cd at ./file.jl:20\r\n in __cd#231__ at ./pkg/dir.jl:28\r\n in add at pkg.jl:20\r\n```'
8045,'JeffBezanson',"Incorrect ambiguity warning\nPerhaps I'm being blind, but I can't see any way in which these two methods are ambiguous:\r\n```\r\njulia> using FixedPointNumbers\r\n\r\njulia> scaleinfo{T}(::Type{T}, img::AbstractArray{T}) = 1\r\nscaleinfo (generic function with 1 method)\r\n\r\njulia> scaleinfo{To<:Ufixed,From<:FloatingPoint}(::Type{To}, img::AbstractArray{From}) = 2\r\nWarning: New definition \r\n    scaleinfo(Type{To<:Ufixed},AbstractArray{From<:FloatingPoint,N}) at none:1\r\nis ambiguous with: \r\n    scaleinfo(Type{T},AbstractArray{T,N}) at none:1.\r\nTo fix, define \r\n    scaleinfo(Type{_<:Ufixed},AbstractArray{_<:FloatingPoint,N})\r\nbefore the new definition.\r\nscaleinfo (generic function with 2 methods)\r\n\r\njulia> isa(Ufixed8, FloatingPoint)\r\nfalse\r\n```\r\nThis is on 0.3-rc4. I wonder if it's related in any way to #6383.\r\n"
7838,'vtjnash','Fix struct reference in docs\nAs noted [here](https://groups.google.com/d/msg/julia-users/0Xpq7YueyiU/JVvJiobQUmUJ), the docs still incorrectly state that \r\n\r\n> Currently, it is not possible to pass structs and other non-primitive types from Julia to C libraries.\r\n\r\nat the end of the first section [here](http://julia.readthedocs.org/en/latest/manual/calling-c-and-fortran-code/#calling-c-and-fortran-code).'
7706,'dcjones','Document goto in manual\n`@goto` and `@label` are mentioned in NEWS, but conspicuously absent in the Control Flow section of the manual.'
7534,'JeffBezanson','Possible dispatch error leading to Julia freezing\nI\'ve come across what seems to me to be a bug in Julia, related to dispatch, I guess. I\'ve reduce the problem to a couple of simple examples; one is given below, and another (with more undefined variables etc. that go undetected) can be found in the [discussion at Julia-Users](https://groups.google.com/forum/#!topic/julia-users/KyFti7C_5vE). In my original code, the problem is that the dispatch seems to go to the wrong function, creating infinite mutual recursion. In the simplified code below, I\'ve removed the alternative function (and other scaffolding code), so the expected behavior would be a method error, I guess?\r\n\r\n```julia\r\ntype B\r\nend\r\n\r\ntype X{T}\r\n    baz::Vector{T}\r\nend\r\n\r\nfunction foo(a, c)\r\n    bar(b, c)\r\nend\r\n\r\nfunction bar{T}(d::(X{T}, Int), val::T)\r\n    foo("err", d[1].baz)\r\nend\r\n\r\nb = B()\r\n\r\nfunction test()\r\n    bar(b, "wat")\r\nend\r\n\r\ntest()\r\n```\r\n\r\nWhen I run this, I would have expected:\r\n```\r\nERROR: no method bar(B, ASCIIString)\r\n```\r\nInstead, the code just hangs. I\'m not sure if it\'s really looping between `foo` and `bar`—I haven\'t been able to produce any evidence of that, really. Printing (with flushing) doesn\'t work, and undefined variables are ignored (c.f., the longer example on [Julia-Users](https://groups.google.com/forum/#!topic/julia-users/KyFti7C_5vE)). Could it be some loop/mutual recursion going on in Julia itself (in the inference/dispatch)?\r\n\r\nHere\'s my `versioninfo()`:\r\n\r\n```\r\nJulia Version 0.3.0-prerelease+3884\r\nCommit 3e6a6c7* (2014-06-25 10:41 UTC)\r\nPlatform Info:\r\n  System: Darwin (x86_64-apple-darwin12.5.0)\r\n  CPU: Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz\r\n  WORD_SIZE: 64\r\n  BLAS: libgfortblas\r\n  LAPACK: liblapack\r\n  LIBM: libopenlibm\r\n```'
7496,'vtjnash',"make win-extras its own makefile rule\nFrom @vtjnash comment in #6516. \r\n\r\n> the win-extras target is less elegant and usable than it probably should be: it doesn't \r\n> really need to be a separate manual step. i think it would be preferable to make this into a \r\n> more carefully written makefile rule (instead of the shell script hack that it is now)"
7386,'ihnorton','WIP: Chocolatey package for windows\nThis is a first cut at support for a [chocolatey](http://chocolatey.org/) package for julia. Not ready to be merged, there are still some open questions.\r\n\r\n# Background\r\n\r\n[Chocolatey](http://chocolatey.org/) is a package manager for Windows that seems to be the most popular one right now. Currently one downloads the client software from their site and then can use the command line to easily install and update software from the chocolatey gallery (i.e. ``cinst julia`` once this PR is done). Microsoft recently released a [preview of Powershell 5](http://blogs.technet.com/b/windowsserver/archive/2014/04/03/windows-management-framework-v5-preview.aspx) that includes client bits for chocolatey. They are on the record that this will be part of the next Windows release, so at that point one should be able to just open a command prompt on Windows and install something like julia with one command (``Install-Package julia``).\r\n\r\n# Use\r\n\r\n## To build a chocolatey package\r\n\r\n- Go to contrib/windows/chocolatey\r\n- call ``make``\r\n\r\nYou have a package, that is pretty much all. You can create packages for older commits/versions by passing in make variables.\r\n\r\n## To install chocolatey package\r\n\r\nAssuming chocoatey is installed:\r\n\r\n- Go to the directory with the nupkg file\r\n- Call ``cinst julia -source <currentDir>``. To install a prerelease version add ``-pre``\r\n- To update the installed julia version do ``cup julia``, again use ``-pre`` to also use prerelease versions\r\n\r\n# Open questions\r\n\r\n- If the julia devs like this, it should really become part of the regular build process and nightly prerelease versions should each have a package like this, they should be auto-uploaded to chocolatey.org etc. I think especially for people on nightly builds this could be handy, ``cup julia -pre`` should for example be enough to update to the latest nightly build with this.\r\n- This PR essentially works as follows: the chocolatey package has an install script, that script downloads the binary installer and then calls it in silent mode. An alternative would be that this install script downloads the binaries packaged as a zip file and unpacks them to a location, and then does anything else required as well. I would prefer the later (i.e. not to call the installer, but have everything in the chocolatey install script), but it would require that the julia nightly build creates zip files of the binaries in addition to the installer exe and uploades them to amazon etc. If the core devs like this whole approach, we might want to change over.\r\n- I think currently if one updates the chocolatey package with ``cup julia`` it does NOT first uninstall the previous version and then install the new one. I\'m not really happy with that, but if we would opt for the option to use packaged zip files instead of the installer exe, I know how to make updates "clean"\r\n- the nuspec file has some fields that need text/names, I was not sure what to use, would be great if the core devs could provide that\r\n- The package needs a link to the julia license. I link to github right now, but it would be nice to have a more permanent link (that could just redirect) like http://julialang.org/license\r\n- chocolatey needs a build #. I create one now by using the seconds since 1970, which kind of works, but it would probably be better to actually assign proper build # in some nightly script, keep track of them etc The build number needs to be present as the fourth part of the version.\r\n- The script is hard-coded to 0.3 releases. Things would be easier if the URL for binaries had less parts that need to be adjusted with version number info, or if I would know how to do even basic string manipulation within a makefile...\r\n\r\nThere are probably other things, but for now it would be good to get some feedback.'
7299,'timholy','On-demand loading of support for file formats?\n@mbauman had an interesting idea he proposed in https://github.com/timholy/HDF5.jl/pull/101 that may be worth discussing. He pointed out that there are conflicts for functions named `save` and `load`. He suggested that one way to solve this is based on file extension, e.g., `save("mydata.jld", ...)` would invoke the HDF5/JLD code, whereas `save("mydata.df", ...)` might invoke DataFrames routines, etc. (I don\'t know whether there\'s a standard extension for DataFrames, I just made that up.) This is especially important when the same datatype could be stored using two different on-disk formats.\r\n\r\nImages already has something that\'s a little bit like this, a framework for registering support for file formats based on extension and/or magic bytes, https://github.com/timholy/Images.jl/blob/master/doc/extendingIO.md#contributing-a-file-format-to-images. Should this registration framework be generalized and added to Julia proper? The idea is that all the support code would still live in packages, but that those packages would be loaded automatically depending on extension and/or magic bytes.\r\n'
7221,'JeffBezanson','Incorrect method order\nIn my ongoing, intermittent quest to understand Julia\'s precise definition of "most specific method", I found this anomaly in Julia 0.3 installed May 17:\r\n\r\n    ba = trues(3)\r\n    @which ba / ba\r\n    /(A::Union(AbstractArray{T,2},AbstractArray{T,1}),\r\n      B::Union(AbstractArray{T,2},AbstractArray{T,1})) at linalg/generic.jl:225\r\n\r\nIt should be the method `/(A::BitArray{N},B::BitArray{N})` at bitarray.jl:885, which is more specific according to jl_args_morespecific().\r\n\r\nI don\'t know my way around the internals of Julia real well, but I think jl_method_list_insert() is putting the generic.jl:225 method at the wrong place because it is thought to be more specific than the method `/{T<:Number}(x::T<:Number,y::T<:Number)` at promotion.jl:191.  But, obviously, those two methods have disjoint signatures.  Julia\'s method dispatch mechanism fundamentally depends on the more specific relation being transitive, but it\'s only transitive if it\'s always false for disjoint signatures, I think.\r\n\r\nHere\'s a simple test case which does not even depend on the loop at the end of jl_method_list_insert():\r\n\r\n    f{T<:Number}(::T) = 1\r\n    f(::BitArray) = 2\r\n    f(::AbstractVecOrMat) = 3\r\n    f(ba)  # returns 3, should be 2\r\n\r\nBut if I define the methods in a different order:\r\n\r\n    g(::BitArray) = 2\r\n    g(::AbstractVecOrMat) = 3\r\n    g{T<:Number}(::T) = 1\r\n    g(ba)  # returns 2 as expected\r\n\r\nBut surely in the absence of ambiguity warnings the result of method dispatch should not depend on the order of definition of methods.  So there must be a bug somewhere.'
6910,'JeffBezanson','RFC: Improvement to hygienic macros\nMake macro hygiene easier to use and less error-prone by eliminating the `esc` function and making hygiene automatic instead.  Details are in the commit log.  Comes from a discussion on julia-users.\r\n\r\nRisk: this broke the `@printf` macro because of its complex implementation.  It was easy to fix, but I do not know if there are other macros that will break that are in packages not tested by `make testall`.\r\n\r\nPossible future work: `eval` does not respect hygiene so only non-hygienic quotes must be used; this does not require any changes to existing code.  It would be nice to fix that but it would be a lot of work.'
6721,'JeffBezanson',"typealias bug ? \nSince this did not get answered on the user forum, I expect nobody knows and this is a potential bug.\r\nStarting with the following definitions\r\n```julia\r\nabstract Vartype\r\ntype VT1<:Vartype\r\nend\r\n\r\nabstract Graph{T<:Vartype}\r\nabstract Subgraph{T<:Vartype} <: Graph{T}\r\ntype Vertex{T<:Vartype} <: Subgraph{T}\r\nend\r\ntype Block{T<:Vartype,N} <: Subgraph{T}\r\nend\r\n\r\nabstract GraphObject{T<:Vartype}\r\ntype SubgraphObject{T<:Vartype,S<:Subgraph{T}} <: GraphObject{T}\r\nend\r\n\r\ntypealias VertexObject{T<:Vartype} SubgraphObject{T,Vertex{T}}\r\ntypealias BlockObject{T<:Vartype,N} SubgraphObject{T,Block{T,N}}\r\ntypealias VertexBlockObject{T<:Vartype} Union(VertexObject{T},BlockObject{T})\r\n\r\nO1=SubgraphObject{VT1,Vertex{VT1}}()\r\nO2=SubgraphObject{VT1,Block{VT1,3}}()\r\n```\r\nI did expect all of the following to be true, but nevertheless got the results in the comment\r\n```julia\r\nisa(O1,VertexObject) # false\r\nisa(O1,VertexObject{VT1}) # true\r\nisa(O1,VertexBlockObject) # false\r\nisa(O1,VertexBlockObject{VT1}) # true\r\n\r\nisa(O2,BlockObject) # false\r\nisa(O2,BlockObject{VT1}) # false\r\nisa(O2,BlockObject{VT1,3}) # true\r\nisa(O2,VertexBlockObject) # false\r\nisa(O2,VertexBlockObject{VT1}) # false\r\n```\r\n\r\nI don't see how this is different to `isa(randn(3,3),StridedMatOrVec)`, which returns `true` with or without full specification of the argument.\r\n\r\nIs this a bug or expected behaviour?"
6661,'vtjnash','introduce va_list\nproposal: introduce `va_list` type for `ccall` / `cfunction`\r\n\r\nusage:\r\n```julia\r\nccall(:abc, Int, (A, B, va_list{(C,D,E)}), a,b,c,d,e)\r\n# int abc(A, B, ...) {}\r\n# {\r\n# abc(a,b,c,d,e);\r\n# }\r\n\r\nva = va_list(c,d,e)\r\nccall(:abc, Int, (A, B, va_list), a, b, va)\r\nccall(:abc, Int, (A, B, va_list{()}), a, b, va)\r\n# int abc(A, B, va_list) {}\r\n# {\r\n# va_list ap;\r\n# va_start(ap, X);\r\n# abc(A,B, ap);\r\n# }\r\n```\r\n\r\ndefinitions:\r\n```julia\r\nimmutable va_list{T<:Tuple}\r\n  # opaque\r\n  va_list(args...) = (T == () ? new(magic...) : error("cannot construct a typed va_list"))\r\nend\r\nva_list(values...) = va_list{()}(values...)\r\n```\r\n\r\nthoughts? improvements? should I make a pull request?'
6610,'ViralBShah','Feature request: sparse truncated SVD\nThere is a request for the rank-truncated singular value decomposition of large sparse matrices returning k largest singular values and the corresponding singular vectors.'
6555,'StefanKarpinski','Pkg.publish(): protection against non-pushed commits?\nI had the impression that `publish` guarded against registering sha1s that had not been pushed, but I just got this:\r\n\r\n```\r\njulia> Pkg.publish()\r\nINFO: Validating METADATA\r\nINFO: Pushing Grid permanent tags: v0.3.0\r\nINFO: Submitting METADATA changes\r\nINFO: Forking JuliaLang/METADATA.jl to timholy\r\nINFO: Pushing changes as branch pull-request/e2af1570\r\nINFO: To create a pull-request open:\r\n\r\n  https://github.com/timholy/METADATA.jl/compare/pull-request/e2af1570\r\n```\r\n\r\nwith this repository state:\r\n```\r\ntim@diva:~/.julia/v0.3/Grid$ git log --graph --abbrev-commit --pretty=oneline --decorate\r\n* cd4c99d (HEAD, tag: v0.3.0, master) Fixes for elimination of solve! (fix #13)\r\n* 061dc31 (origin/master, origin/HEAD) restrict/prolong: fix type declaration for non-BLAS types\r\n* eb09710 (tag: v0.2.12) Allow `range` to work on older Julias\r\n```\r\n'
6383,'JeffBezanson','Spurious ambiguity warning (type parameter constraint not taken into account by dispatch)\nSee a85476b2c29d9af8fab7f0a6a04809daa442a7d4 and 005197af45e28904a8cb2a346918e56ead1bc95c and comments therein.\r\n\r\nIn summary, dispatch on a parametric type whose type is restricted in the declaration (`type A{T<:Integer}` etc.) make a difference between `A`, `A{T}` and `A{T<:Integer}`. In one case, `A{T}` seems to be taken as more general than `A`; in another case, `A` seems to be taken as more general than `A{T<:Integer}` - see examples below.\r\n\r\nExample: this shows the ambiguity\r\n\r\n```\r\njulia> type A{T<:Integer} <: Real\r\n           a::T\r\n       end\r\n\r\njulia> type B <: FloatingPoint\r\n       end\r\n\r\njulia> tst{T<:FloatingPoint,S}(::Type{T}, x::A{S}) = println(1)\r\ntst (generic function with 1 method)\r\n\r\njulia> tst(::Type{B}, x::A) = println(2) # this should disambiguate between the one above and the one below\r\ntst (generic function with 2 methods)\r\n\r\njulia> tst(::Type{B}, x::Real) = println(2)\r\nWarning: New definition \r\n    tst(Type{B},Real) at none:1\r\nis ambiguous with: \r\n    tst(Type{T<:FloatingPoint},A{S}) at none:1.\r\nTo fix, define \r\n    tst(Type{B},A{S})\r\nbefore the new definition.\r\ntst (generic function with 3 methods)\r\n\r\njulia> tst(B, A(1)) # works\r\n2\r\n```\r\n\r\nCurrently, the workarounds for the example above are: defining the disambiguation method with an otherwise useless parameter\r\n\r\n```\r\njulia> type A{T<:Integer} <: Real\r\n           a::T\r\n       end\r\n\r\n\r\njulia> type B <: FloatingPoint\r\n       end\r\n\r\njulia> tst{T<:FloatingPoint,S}(::Type{T}, x::A{S}) = println(1)\r\ntst (generic function with 1 method)\r\n\r\njulia> tst{S}(::Type{B}, x::A{S}) = println(2) # useless parameter S\r\ntst (generic function with 2 methods)\r\n\r\njulia> tst(::Type{B}, x::Real) = println(2) # no warning though\r\ntst (generic function with 3 methods)\r\n\r\njulia> tst(B, A(1))\r\n2\r\n```\r\n\r\nOr restricting the first method to `S<:Integer`:\r\n\r\n```\r\njulia> type A{T<:Integer} <: Real\r\n           a::T\r\n       end\r\n\r\njulia> type B <: FloatingPoint\r\n       end\r\n\r\njulia> tst{T<:FloatingPoint,S<:Integer}(::Type{T}, x::A{S}) = println(1) # the <:Integer part should be implicit\r\ntst (generic function with 1 method)\r\n\r\njulia> tst(::Type{B}, x::A) = println(2)\r\ntst (generic function with 2 methods)\r\n\r\njulia> tst(::Type{B}, x::Real) = println(2)\r\ntst (generic function with 3 methods)\r\n\r\njulia> tst(B, A(1))\r\n2\r\n```\r\n\r\n\r\nOne more problem: from the last example, continue like this:\r\n\r\n```\r\njulia> tst(::Type{FloatingPoint}, x::A) = println(3) # this should be more specific then the one which prints 1\r\ntst (generic function with 4 methods)\r\n\r\njulia> tst(FloatingPoint, A(1)) # calls the wrong version\r\n1\r\n```\r\n\r\nAgain, to fix it restrict the type parameter in the above definition:\r\n\r\n```\r\njulia> tst{S<:Integer}(::Type{FloatingPoint}, x::A{S}) = println(3)\r\ntst (generic function with 4 methods)\r\n\r\njulia> tst(FloatingPoint, A(1))\r\n3\r\n```'
6277,'amitmurthy','Issue https://github.com/JuliaLang/julia/issues/6264 related fixes\nI have implemented feature request of https://github.com/JuliaLang/julia/issues/6264\r\n\r\nNow we are able to create heterogeneous clusters where some nodes might not be visible to each other and one should initiate an SSH tunnel between them.\r\n\r\nOne additional bud is fixed which is related to https://github.com/JuliaLang/julia/issues/6256:\r\n1. Execution of ```addporcs(n)``` fails when some nodes where already added via SSH tunnel.'
6264,'amitmurthy','Remove direct visibility constraints for nodes in a cluster\nFor a heterogeneous clusters where nodes are visible to each other only via the ssh tunnelling it would be nice to have a workaround for making ```addprocs``` routine working in this case.\r\n\r\nPlease consider another issue https://github.com/JuliaLang/julia/issues/6256 which explained the problem and resulted in the necessity of a feature request. '
6241,'Keno',"libopenlibm.a Makefile rule is missing\n\r\n```\r\nMakefile:78: recipe for target '/c/programs/julia64/usr/lib/julia/sys0.o' failed\r\nmake[1]: *** [/c/programs/julia64/usr/lib/julia/sys0.o] Error 1\r\nMakefile:32: recipe for target 'release' failed\r\nmake: *** [release] Error 2\r\n```\r\n\r\nI also tried after make cleanall, where I had to manually fix this one\r\n\r\n```\r\ng++.exe: error: C:/programs/julia64/usr/lib/libopenlibm.a: No such file or directory\r\n*** Please ensure that the ncurses-devel package is installed on your OS, and try again. ***\r\nMakefile:60: recipe for target '/c/programs/julia64/usr/bin/julia-readline.exe' failed\r\nmake[2]: *** [/c/programs/julia64/usr/bin/julia-readline.exe] Error 1\r\nMakefile:43: recipe for target 'julia-release' failed\r\nmake[1]: *** [julia-release] Error 2\r\n```"
6195,'vtjnash',"julep: conditional modules\ncurrently, some modules (incorrectly and unfortunately) use `Pkg.installed` to decide whether it should include some additional functionality. I would like to propose the following extension to module initialization that could help simplify this situation of optional dependencies:\r\n\r\n---\r\n\r\n### Rules:\r\n\r\n1. During module parse time, a module can declare a dependency on another module, given by name\r\n\r\n2. Following the closing of a module (without error), and after all `__init__` functions have run, any modules that declared `module B require Main.C` will be (re-)loaded.\r\n\r\n### Example:\r\n\r\n```julia\r\nmodule A\r\n  module B requires Main.C\r\n    # code in here is part of A iff Main.C is defined as a module\r\n    # it's execution time is defined as after the call to A.__init__ and C.__init__\r\n    using Main.C\r\n    import ..A.something\r\n    something(::C.CType) = 2\r\n  end\r\n  # code in here is always part of A\r\n  something(::Any) = 1\r\nend\r\n# Accessing A.B here would throw an UndefRef-like error, with a message that B requires C\r\nmodule C\r\n  type CType end\r\nend\r\n# Now A.B exists, and A.something() has extra functionality\r\n```"
6187,'JeffBezanson',"Hit-and-miss method ambiguity warnings?\nIn Images, check out commit ddb4259fb2ac39464ed451c5f627d2cd729090ad (I'm about to fix a bunch of ambiguity warnings, but this is a commit that still has them). The list of ambiguity warnings starts with\r\n```\r\nWarning: New definition \r\n    -(AbstractImageDirect{T,N},AbstractArray{T,N}) at /home/tim/.julia/v0.3/Images/src/algorithms.jl:17\r\nis ambiguous with: \r\n    -(AbstractArray{TA,2},UniformScaling{TJ<:Number}) at linalg/uniformscaling.jl:35.\r\nTo fix, define \r\n    -(AbstractImageDirect{TA,2},UniformScaling{TJ<:Number})\r\nbefore the new definition.\r\n```\r\nWhy is `-` judged as ambiguous, when the corresponding `+` (which is also defined in `linalg/uniformscaling`) is not even mentioned?\r\n"
6168,'amitmurthy',"Making AWS cloud nicely usable for parallelism\nAfter asking @jiahao if I could just grab 1000 processors on AWS and run\r\na monte carlo experiment easily, I was told no not yet.  I've got the processors,\r\nwould be great if the setup was just\r\n\r\naddprocs(1000) after some initial script\r\n\r\n"
6122,'JeffBezanson','add default keyword constructor for immutables\nImplements #5333.'
6048,'JeffBezanson','Method ambiguity detection: false positive?\n```Julia\r\nfoo (b::Bar...) = 1\r\n# foo (generic function with 1 methods)\r\n\r\nfoo(a::Any, b::Bar) = 2\r\n# foo (generic function with 2 methods)\r\n\r\nfoo(b::Bar, a::Any) = 3\r\n# Warning: New definition\r\n#     foo(Bar,Any)\r\n# is ambiguous with:\r\n#     foo(Any,Bar)\r\n# To fix, define\r\n#     foo(Bar,Bar)\r\n# before the new definition.\r\n# foo (generic function with 3 methods)\r\n```\r\n\r\nSemantically, foo(Bar,Bar)` is covered by the first definition, and the above example behaves as expected.\r\n\r\nIs the warning really warranted?'
5183,'timholy','Profile.print(format=:flat) –\xa0sort in descending order of samples.\n@timholy,\xa0what do you think about this?'
5125,'JeffBezanson','optimize jl_binding_t in sysimg\nmaking `jl_binding_t` a statically allocated variable should be nice for performance.'
5090,'JeffBezanson','type inference of && and || chains\nAlthough I fixed https://github.com/JuliaLang/julia/issues/5084 by using a trinary operator (which is better style anyway, imo), type inference on the short-circuit `&&` and `||` operators could be tighter:\r\n\r\n```julia\r\njulia> f(b::Bool) = b && error("nope") || 1\r\nf (generic function with 1 method)\r\n\r\njulia> code_typed(f,(Bool,))\r\n1-element Array{Any,1}:\r\n :($(Expr(:lambda, {:b}, {{:#s2},{{:b,Bool,0},{:#s2,Bool,2}},{}}, quote  # none, line 1:\r\n        unless b::Bool goto 0\r\n        #s2 = throw($(Expr(:new, :(top(getfield)($(Base),:ErrorException)::Type{ErrorException}), "nope"))::ErrorException)::None\r\n        goto 1\r\n        0:\r\n        #s2 = false\r\n        1:\r\n        unless #s2::Bool goto 2\r\n        return #s2::Bool\r\n        2:\r\n        return 1\r\n    end)))\r\n\r\njulia> f(true)\r\nERROR: nope\r\n in f at none:1\r\n\r\njulia> f(false)\r\n1\r\n```\r\n\r\nThis can only ever return an `Int` and we could definitely infer that.'
5011,'JeffBezanson','Slowdown in Julia 0.2\nOn Julia 0.2 release I got significant slowdown in my old test script comparing with Julia 0.2-prerelease-d6f7c7c. Run time increased from 5s to 40s.\r\n```julia\r\nimport Base.div\r\n\r\nconst width = 640\r\nconst height = 480\r\nconst iters = 260\r\n\r\nimmutable Pixel\r\n  r::Uint8\r\n  g::Uint8\r\n  b::Uint8\r\nend\r\n\r\n+(p1::Pixel, p2::Pixel) = Pixel(uint8(p1.r+p2.r),uint8(p1.g+p2.g),uint8(p1.b+p2.b))\r\ndiv(p::Pixel, n::Int) = Pixel(uint8(div(p.r,n)),uint8(div(p.g,n)),uint8(div(p.b,n)))\r\n\r\nfunction avg!(a::Array{Pixel,2}, b::Array{Pixel,2})\r\n  for j = 2:height-1, i = 2:width-1\r\n    b[i,j] = div(a[i-1,j] + a[i+1,j] + a[i,j-1] + a[i,j+1], 4)\r\n  end\r\nend\r\n\r\nfunction test()\r\n  in = Array(Pixel,width,height)\r\n  out = Array(Pixel,width,height)\r\n  tic()\r\n  for i = 1:iters\r\n    avg!(in,out)\r\n    avg!(out,in)\r\n  end\r\n  toc()\r\nend\r\n\r\ntest()\r\n```'
4935,'JeffBezanson',"abstract types with fields\nThis would look something like\r\n\r\n```\r\nabstract Foo with\r\n    x::Int\r\n    y::String\r\nend\r\n````\r\n\r\nwhich will cause every subtype of `Foo` to begin with those fields.\r\n\r\nSome parts of the language internals already anticipate this; it's a matter of hooking up the syntax and filling in a few missing pieces."
4916,'JeffBezanson',"variable numbers of keyword arguments as dict\n```julia\r\nfoo(; args...)\r\n```\r\nInside of a function with this signature, `args` will be an array of tuples containing symbols and values. Cool, but the array will be unordered, so I pretty much have to loop over it trying to match symbols.\r\n\r\nI think it would be really cool if `args` came in as a dictionary. I'm guessing there would be some overhead involved in that, and that's perhaps why it has not been done. But I wonder if the overhead involved in looping over symbols and doing a bunch of string comparisons (I think that's what's happening, could be wrong) might even outweigh the dict creation.\r\n\r\nI didn't see an issue, but has this been considered?"
4914,'JeffBezanson','reusing function names as local variables is inconsistent\nWhy does the first definition succeed, but the second one fail? Does this somehow fall out of definition of functional recursion?\r\n\r\n```julia\r\njulia> a(a) = a\r\n\r\njulia> a(1)\r\n1\r\n\r\njulia> b(x) = (b=x; b)\r\na (generic function with 1 method)\r\n\r\njulia> b(1)\r\nERROR: invalid redefinition of constant b\r\n in b at none:1\r\n```'
4905,'Keno','LLVM checked arithmetic for 128-bit ints is broken\nThis is largely an upstream bug tracking issue.'
4873,'JeffBezanson','macro documentation and implementation mismatch\nFrom the docs (Manual/Metaprogramming):\r\n\r\n```\r\nmacro time(ex)\r\n  quote\r\n    local t0 = time()\r\n    local val = $ex\r\n    local t1 = time()\r\n    println("elapsed time: ", t1-t0, " seconds")\r\n    val\r\n  end\r\nend\r\n```\r\n> Julia’s macro expander solves these problems in the following way. [...] Local variables are then renamed to be unique (using the gensym function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro’s locals will not conflict with any user variables, and time and println will refer to the standard library definitions.\r\n\r\nYet if you put the above code verbatim into a script and tack this to the end:\r\n\r\n```\r\nprintln("I\'m println in the macro definition environment and I\'m all right.")\r\n \r\nfunction g()  \r\n    println("That same println still works. Functions\' hygiene is impeccable!")\r\nend\r\n\r\nfunction f()\r\n    println = "I\'m println the user variable! Thou shalt not conflict with me!"\r\n    g()\r\n    @time sleep(1)\r\nend\r\n \r\nf()  \r\n```\r\n\r\nYou get the output:\r\n```\r\nI\'m println in the macro definition environment and I\'m all right.\r\nThat same println still works. Functions\' hygiene is impeccable!\r\nERROR: type: f: in apply, expected Function, got ASCIIString\r\n```\r\nThat println sure doesn\'t refer to the standard library one like the docs say. Comparing the result to g(), one can clearly see macros\' lack of hygiene compared to functions. If the macro is defined in a different module, then it works because println is expanded to TheOtherModule.println. This could be fixed by expanding it to TheCurrentModule.println when it\'s not from a different module, so that in any case the globals lookups are always done from *some* module\'s globals.\r\n\r\nAnother one: the definition of assert in error.jl is different than claimed in the docs. One might say in the docs that this is a simplified version of the one in error.jl. More importantly, the use of $ex instead of $(esc(ex)) would be better fixed or remarked upon ("this is subtly broken as we see in the next section" or something) lest someone imitate it because the official docs say that this is good enough for the standard library! The unescaped assert from the docs is not that hard to break:\r\n```\r\nx = 1\r\n@assert (x -> x)(x) == 1\r\n```\r\nresults in:\r\n```\r\nERROR: x#12 not defined\r\n```'
4869,'JeffBezanson',"splatting in tuple construction\nI was surprised to discover that this doesn't work:\r\n```\r\n(3,4,(5,6)...)\r\n```\r\nI was expecting `(3,4,5,6)`, but got `type: apply_type: in Vararg, expected Type{T<:Top}, got (Int64,Int64)`\r\n\r\nEven more surprising, \r\n```\r\n(3,4,()...)\r\n```\r\nworks, but outputs `(3,4,()...)` instead of `(3,4)`, with `(3,4,()...)[3]` being a somewhat mysterious `()...` object of type `DataType`.\r\n\r\nI understand that some special magic has to occur here in order to be able to define tuple types like `(Int, Bool, Float64...)`, but the behavior above seems odd."
4793,'StefanKarpinski','Pkg rollback to v0.0.0- fails\n```\r\nINFO: Rolling back HTTPClient from v0.0.0 to v0.0.0-\r\nErrorException("could not open file METADATA/HTTPClient/versions/0.0.0-/sha1")\r\nINFO: Rolling back Gadfly from v0.1.24 to v0.1.23\r\nINFO: Rolling back AWS from v0.0.0 to v0.0.0-\r\nErrorException("could not open file METADATA/AWS/versions/0.0.0-/sha1")\r\n```\r\nThe real problem was somewhere else, but in rolling back it seems to want to read the SHA1 of version `0.0.0-` which obviously doesn\'t exist.'
4784,'JeffBezanson','performance of creating an array from a range\nI have tested the following three variations of array creation statement:\r\n\r\n```julia\r\nfunction func1(a, b, inc, iter)\r\n    tic()\r\n    for i=1:iter\r\n        A = [a:inc:b]\r\n    end\r\n    toc()\r\nend\r\n\r\nfunction func2(a, b, inc, iter)\r\n    A = Array(Float64, length(a:inc:b))\r\n    tic()\r\n    for i=1:iter\r\n        A = [a:inc:b]\r\n    end\r\n    toc()\r\nend\r\n\r\nfunction func3(a, b, inc, iter)\r\n    A = Array(Float64, length(a:inc:b))\r\n    tic()\r\n    for i=1:iter\r\n        A[:] = a:inc:b\r\n    end\r\n    toc()\r\nend\r\n```\r\nand their execution times with a=0, b=10000, inc=0.1, iter=1000\r\n\r\nfunc1: 0.67 seconds\r\nfunc2: 0.69 seconds\r\nfunc3: 0.34 seconds\r\n\r\nEquivalent python/numpy function\r\n\r\n```python\r\ndef func(a, b, inc, iter):\r\n    t0 = time()\r\n    for i in range(1000):\r\n        A = np.arange(a, b, inc)\r\n    print(time()-t0, " seconds elapsed")\r\n```\r\n\r\ntakes about 0.1 seconds and equivalent matlab function\r\n\r\n```matlab\r\nfunction func(a, b, inc, iter)\r\n    tic()\r\n    for i=1:iter\r\n        A = [a:inc:b];\r\n    end\r\n    toc()\r\n```\r\ntakes about 0.1 seconds.\r\n\r\n[jiahao - edit for formatting. Please use triple backquotes for posting code, otherwise it\'s unreadable.\r\n\r\nalso x-ref [julia-users](https://groups.google.com/forum/#!topic/julia-users/KDQPmiSLga8)]'
4600,'JeffBezanson',"relative using/import should search current directory\nWhen I do\r\n\r\n```julia\r\n# Main.jl\r\nmodule Main\r\n  using .Foo\r\nend\r\n```\r\n\r\nand there's a file called `Foo.jl` in the same directory as `Main.jl` it should be loaded. I suspect that relative `using` should also *not* look in the global require places –\xa0i.e. `Pkg.dir()` and then `LOAD_PATH`. The same applies to `import`."
4467,'JeffBezanson','performance of cat of scalars\nThe performance of\r\n```\r\nar = [a, b, c, d, e]\r\n```\r\nis much worse than the performance of\r\n```\r\nar = Array(Float64, 5)\r\nar[1]=a\r\nar[2]=b\r\nar[3]=c\r\nar[4]=d\r\nar[5]=e\r\n```\r\nwhere a-e are Float64\'s because the former syntax uses the cat operation (for a good reason, as explained by @JeffBezanson - a-e could be many things including arrays etc., which makes the "bracket" syntax require an extremely dynamic operation (i.e., cat) in the general case).\r\n\r\nThis is a request to analyze constructs in the "bracket" notation (i.e., the first example above) and optimize the creation of the array in cases where the types of the elements can be determined statically.  For example, translate the first block of code to the second internally, or do something more optimal.\r\n\r\n(Changing the [ ] code to manually declare and assign arrays as above in our code increases speed by about 25% currently.  However, the syntax is undesirable in our context from a readability standpoint.)\r\n'
4445,'JeffBezanson','let users control how DArray data should be distributed by the `distribute` function \nCurrently the `distribute` functions does not give users control of how the data in the array should be distributed across workers. It is not possible, for example, to specify whether rows or columns should be distributed across workers. This type of functionality is available in several DArray related function (e.g. `dzeroes`, `drand`), and it would be nice to have it also for `distribute`. See https://groups.google.com/forum/?fromgroups=#!topic/julia-users/7rnOZlKTidY for further reference.'
4428,'JeffBezanson',"Performance of nested functions\nI've found that nested functions usage cause significant performance degrade. In the following sample script I got increasing run time from 0.4s to 2.6s on my machine.\r\n\r\n```julia\r\ng(n) = 1.0/n\r\n\r\nfunction f(n)\r\n  sum = 0.0\r\n  g1(n) = 1.0/n\r\n  for i = 1:n\r\n    sum += g(i) # change to g1 to use nested function\r\n  end\r\n  sum\r\nend\r\n\r\ntic()\r\nprintln(f(10_000_000))\r\ntoc()\r\n```"
4418,'Keno','Support AVX2 and BMI2 instructions\nReminder  to revert the [temporary fix](https://github.com/JuliaLang/julia/commit/d5dc2262564beeea6d0269904c3e6aee3a7d8a58) for #4362.\r\n\r\nRelated LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=17422\r\n\r\nThis would likely be subsumed by [switching to MCJIT](https://github.com/JuliaLang/julia/issues/3922).\r\n\r\nSee also a [similar bug](http://llvm.org/bugs/show_bug.cgi?id=13349) in AVX support, resolved by backporting some functionality from MCJIT.\r\n\r\n'
4345,'JeffBezanson',"using/importall: clashing names should be dropped\nI think this is the only safe behavior:\xa0if you do `using Foo` and `using Bar` and both export a `frizz` function, then neither should show up – otherwise you're depending on some arbitrary ordering of `using` statements. This also means that a new export can only cause programs to break in the obvious manner of a name that used to be accessible becoming inaccessible, rather than the meaning of a function changing. Having neither export show up also follows the dynamic language tradition of not causing any problems as long as you don't use the problematic thing –\xa0so name clashes only affect you if you actually need to use the name that clashes."
4286,'jiahao','Warnings when working with singular matrices\nConsider the following example taken from http://www.walkingrandomly.com/?p=5092:\r\n\r\n\tA = [1 2 3;\r\n\t     4 5 6;\r\n\t     7 8 9];\r\n\r\n\tb = [15, 15, 15]\r\n\r\n\tx = A \\ b\r\n\r\nOn my OS X build of master, this produces the solution: \r\n\r\n\t3-element Array{Float64,1}:\r\n\t -39.0\r\n\t  63.0\r\n\t -24.0\r\n\r\nwhich is valid, but could potentially have been quite inaccurate. As the linked blog post notes, Matlab offers a warning in this case that the condition number of `A` is very high and that the result may be inaccurate.\r\n\r\nJulia should probably also raise warnings when solve operations are likely to produce inaccurate solutions.'
3688,'jiahao','implement Tridiagonal, Bidiagonal, and Triangular eigensolvers\nCurrently, `eig` and similar throw `no method eigfact` when applied to these types of matrices.  We should be able to provide efficient LAPACK-based solvers for these types.\r\n\r\nFor `Tridiagonal`, we can exploit the fact that it is already in Hessenberg form to call `xHSEQR` directly.\r\n\r\nIn the case of `Bidiagonal` matrices, the eigenvalues can be read off the diagonal with no computation, and eigenvectors can be obtained in O(m^2) time (one linear-time solve per eigenvector).\r\n\r\nSimilarly, any `Triangular` matrix is already in Schur form (or its transpose), allowing us to read off the eigenvalues from the diagonal and to compute the eigenvectors by calling `xTREVC`.\r\n\r\n- Bidiagonal\r\n - [x] eig\r\n - [x] eigvals\r\n - [x] eigvecs\r\n- Tridiagonal\r\n - [ ] eig\r\n - [ ] eigvals\r\n - [ ] eigvecs\r\n- Triangular\r\n - [x] eig\r\n - [x] eigvals\r\n - [x] eigvecs\r\n'
3596,'Keno','Int128 bit shift issue\nFrom #3447 \r\n```julia\r\nint128(1)<<0\r\n```\r\nis broken. \r\n\r\nCorresponding LLVM IR:\r\n```llvm\r\ndefine i128 @julia_foo2599(i32) {\r\ntop:\r\n  %1 = shl i32 %0, 4\r\n  %2 = zext i32 %1 to i128\r\n  %3 = shl i128 1, %2\r\n  %4 = icmp ugt i32 %1, 127\r\n  %5 = select i1 %4, i128 0, i128 %3\r\n  ret i128 %5\r\n}\r\ndefine i32 @main() {\r\ntop:\r\n  %0 = call i128 @julia_foo2599(i32 0)\r\n  %1 = lshr i128 %0, 64\r\n  %2 = trunc i128 %1 to i32\r\n  ret i32 %2\r\n}\r\n```\r\nLLVM bug no: http://llvm.org/bugs/show_bug.cgi?id=16439'
3466,'Keno',"RFC: Make struct passing work properly\nThis is a WIP on the long standing issue of passing Julia structs to C. I have implemented the x86_64 ABI and am working on the others. This is passing the tests included in Jameson's original pull request, though as the ABI is rather complicated, I would appreciate more tests to include."
3440,'JeffBezanson',"compiler optimization tracker\nThis is an umbrella issue for compiler and other low-level optimizations. I'm including ones that are already done, to make it more interesting.\r\n\r\ncompiler:\r\n- [x] static method lookup\r\n- [x] basic inlining\r\n- [ ] more general inlining (#3030)\r\n- [x] null check elimination\r\n- [x] function type check elimination\r\n- [ ] method lookup hoisting (#3426)\r\n- [ ] function-valued argument inlining (#3426)\r\n- [x] variable type specialization\r\n- [x] varargs allocation elision\r\n- [x] lambda lifting\r\n- [x] native calling convention\r\n- [x] hoist n-d array metadata loads\r\n- [ ] hoist 1-d array metadata loads\r\n- [ ] hoist access to fields in immutable values\r\n- [x] skip gc frame when possible\r\n- [x] avoid re-boxing non-assigned variables\r\n- [x] unboxed struct layout\r\n- [x] apply tuple lowering: `apply(f, t::(T,S)) => f(t[1],t[2])`\r\n- [x] apply tuple elision: `apply(f, (x,y)) => f(x,y)`\r\n- [x] temporary tuple elision\r\n- [x] create and return tuples as structs (#1976, #2496)\r\n- [ ] early freeing by dataflow analysis (#261)\r\n- [x] don't pass or store 0-field structs\r\n- [ ] rerun type inference after inlining in some cases\r\n- [ ] handle more constant conditions in inference\r\n- [x] remove excess temp vars\r\n- [ ] pool environments of inner functions\r\n- [x] inline builtins\r\n- [x] better inlining of apply()\r\n- [ ] inline invoke()\r\n- [ ] inline isdefined()\r\n- [x] constant-fold type applications\r\n- [ ] direct call methods specialized for non-leaf types\r\n- [ ] closure environment specialization\r\n- [ ] static keyword argument sorting\r\n- [x] compute first field of a new object before allocating, to avoid the unnecessary NULL store to the first slot\r\n- [x] identify types (especially immutable) that are always fully initialized, to avoid undefined checks on their fields (#8827)\r\n- [x] skip gc root for variables with stable values (e.g. vars that only alias arguments)\r\n- [x] avoid redundant loads of single-assigned variables from gc frame\r\n- [ ] possibly hoist boxing out of tight loops (might interfere with gc though?)\r\n- [ ] faster possibly-undefined variables (#6914)\r\n\r\nRTS:\r\n- [x] compress ASTs\r\n- [x] method hash tables\r\n- [ ] more efficient method and cache representation\r\n- [ ] gc: 1-bit refcount (#261)\r\n- [ ] flatten arrays of tuples\r\n- [x] use realloc in growing arrays (complicated by alignment constraints)\r\n- [x] avoid extra buffer copy in uv_write\r\n- [x] allow scheduler to be a function call, avoiding double task switch to get to next task\r\n- [ ] avoid some stack copies in Task; e.g. for tasks that never yield\r\n\r\nlarger projects:\r\n- [ ] bounds check elimination\r\n- [x] cache generated code (#260)\r\n- [ ] function types (#210)\r\n- [ ] henchmen unrolling\r\n- [ ] better type info for tasks/produce/consume\r\n- [ ] SIMD support (#2299)\r\n\r\nperformance-related features:\r\n- [x] inbounds macro (#3268, #1392)\r\n- [ ] bounds check intrinsic\r\n- [ ] sizeof intrinsic\r\n- [x] expose llvm `select` (inlined, eager-evaluated conditional function)\r\n- [ ] inline declaration (#1106)\r\n- [ ] pure function declaration (#414)\r\n- [ ] improve behavior of globals (#964)\r\n- [ ] better support for in-place ops (#3424, #249, #1115)\r\n"
3255,'pao','Provide + document public API to jl_zero_subnormals\nProbably also will rename this per #3105. Would really like this to be able to be a scoped thing, too--you may want to enable it just for a critical set of calculations.'
3167,'JeffBezanson','strange array element assignment error\nIt\'s possible that this is not repeatable, but on my machine with Julia Version 0.2.0-1644.rb3c30f37, Commit b3c30 f373b 2013-05-21 05:03:45, there is the following issue.  I believe the function foo below should behave like "convert(Array{typeof(x[1]), 1}, x)" (for some inputs x at least).  However, the code:\r\n\r\n```\r\nfunction foo(x)\r\n    ret=Array(typeof(x[1]), length(x))\r\n    for j = 1:length(x)\r\n        ret[j] = x[j]  \r\n    end\r\n    return ret\r\nend\r\n\r\nx = Array(Union(Dict{Int64,String},Array{Int64,3},Number,String,Nothing), 3)\r\nx[1] = 1.0\r\nx[2] = 2.0\r\nx[3] = 3.0\r\n\r\nfoo(x)\r\n```\r\ngives non-deterministic, incorrect results like\r\n```\r\n3-element Float64 Array:\r\n7.38985e-317\r\n3.20647e-316\r\n3.28281e-316\r\n```\r\nsometimes and also the error\r\n```\r\nERROR: no method convert(Type{Array{Int64,3}},Float64)\r\n in convert at base.jl:9\r\n in foo at none:4\r\n```\r\ncorresponding to the line \r\n\r\n    ret[j] = x[j]\r\n\r\nThe foo code seems to work fine in a global context and convert(Array{typeof(x[1]), 1}, x) seems to work fine.'
3025,'JeffBezanson',"ambiguity warning missing?\n```julia\r\njulia> function z(a::(Integer,Integer)...)\r\n       println(4)\r\n       end\r\n# methods for generic function z\r\nz(a::(Integer,Integer)...) at none:2\r\n\r\njulia> function z{T}(a::(T,T)...)\r\n       println(5)\r\n       end\r\n# methods for generic function z\r\nz(a::(Integer,Integer)...) at none:2\r\nz{T}(a::(T,T)...) at none:2\r\n\r\njulia> z((1,2),(3,int32(3))) #good\r\n4\r\n\r\njulia> z((1,2),(3,3)) #oops, expecting 5\r\n4\r\n\r\njulia> function z{T<:Integer}(a::(T,T)...)\r\n       println(6)\r\n       end\r\n\r\njulia> z((1,2),(3,4)) # ok, that's better but why?\r\n6\r\n```"
3022,'stevengj',"FFTW interface should allow passing output array\nIn my testing of the FFTW routines I found that I could get a factor of two improvement in rfft performance if I passed in the output array. This is especially so when doing large strided transforms as it removes the need for a large memory allocation in each call. I modified the plan_rfft routine and got a factor of two speed up on 8192x200 size real arrays where we are transforming on the first dimension. I didn't do other tests, but I guess other routines get similar improvement.\r\n\r\nIt would be very nice to have this feature, as FFT heavy code usually has predefined input/output arrays.\r\n\r\n```julia\r\nfunction plan_rfft(X::StridedArray{$Tr}, region,\r\n                          flags::Unsigned, tlim::Real)\r\n            d1 = region[1]\r\n            osize = [size(X)...]\r\n            osize[d1] = osize[d1]>>1 + 1\r\n            Y = Array($Tc, osize...)\r\n            p = Plan(X, Y, region, flags, tlim)\r\n            return (Z::StridedArray{$Tr}, W::StridedArray{$Tc}) -> begin\r\n                assert_applicable(p, Z)\r\n                #W = Array($Tc, osize...)\r\n                execute(p.plan, Z, W)\r\n                return W\r\n            end\r\n        end\r\n```\r\n"
2960,'vtjnash',"overflow in Rational arithmetic\nRational - Int comparisons are susceptible to overflow:\r\n\r\n```\r\njulia> 3//2 > typemax(Int)\r\ntrue\r\n```\r\n\r\nThis is due to multiplying the integer argument by the rational's denominator.\r\n\r\nOther operations that use `*` this way are similarly afflicted:\r\n\r\n```\r\njulia> r = (typemax(Int)-1)//typemax(Int)\r\n9223372036854775806//9223372036854775807\r\n\r\njulia> div(r,2)\r\n-4611686018427387903\r\n```\r\n"
2818,'vtjnash','WIP: types as C-structs\nThis is a first pass at giving pointers to julia types easy compatibility with C. This is done by "hiding" the type and GC information before the data, and shifting all references in the julia source by 1 to match. What this would mean for the user is that\r\n\r\n```julia\r\ntype A\r\n  a::Int\r\nend\r\ntype B\r\n  a::A\r\nend\r\n```\r\ncan be passed to a C function expecting:\r\n```c\r\ntypedef struct _A {\r\n  int a;\r\n} A;\r\ntypedef struct _B {\r\n  *A a;\r\n} B;\r\n```\r\nIf the user is receiving data from C (e.g. anything not created by Julia\'s GC), then they must instead declare it as `Ptr{A}` and access with unsafe_ref (I\'m wondering if it might be more appropriate to introduce another type for this purpose, but thats a separate issue I\'ll go into later).\r\n\r\nIf @JeffBezanson approves of this, I\'ll go back through and clean this up some to make it ready to merge. TODO items include:\r\n - [ ] remove some casts that are now no-ops\r\n - [ ] figure out what emit_arraysize is doing (and replace with offsetof for better maintainability)\r\n - [ ] finish fixing OVERLAP_TUPLE_LEN\r\n - [ ] stop over-allocating types by sizeof(void*) bytes in alloc_big, and check if there\'s double counting anywhere else (or conversely, fully move it to alloc_big)\r\n - [ ] document how to use & how to avoid getting burned'
2773,'JeffBezanson','Keyword arguments for anonymous functions\n#485 implemented keyword arguments for named functions. However, I would expect that\r\n\r\n```julia\r\n(a; b="c") -> a \r\n```\r\n\r\nwould create an anonymous function that takes a keyword argument `b` with a default value `"c"`. Instead, I currently get\r\n\r\n```\r\nERROR: syntax: malformed function arguments (block a (= b #<julia_value>))\r\n```'
2758,'JeffBezanson',"Show keyword arguments in list of methods\nCurrently the keyword arguments are completely ignored, and it's hard to see if a method has them or not.\r\n```julia\r\njulia> test(;y = 12) = y\r\n# methods for generic function test\r\ntest()\r\n\r\njulia> test\r\n# methods for generic function test\r\ntest()\r\n\r\njulia> test(y = 2)\r\n2\r\n```"
2669,'JeffBezanson','assigning variables inside spawn\n```\r\njulia> x = 10\r\n10\r\n\r\njulia> @spawn 1+$x\r\nRemoteRef(1,1,1)\r\n\r\njulia> exception on 1: ERROR: error compiling anonymous: syntax: prefix $ in non-quoted expression\r\n```\r\n\r\nI think I understand why this is tricky given the compile-time evaluation of the macro, but this would be really useful if it worked correctly. It seems to have already led to some confusion: https://groups.google.com/forum/#!searchin/julia-users/@everywhere/julia-users/KDnwAqD0urI/yVfBa3YYxdUJ'
2626,'JeffBezanson','a, b... = [1,2,3]\nThis would be a very nice syntax for taking head and rest. Likewise `a..., b = [1,2,3]` might be good for slurping the initial elements into `a` and the tail element into `b`.'
2586,'JeffBezanson','eval\'d expressions inside begin..end should be top-level when possible\nLooks like a bug in ``eval``:\r\n\r\n```\r\n   _       _ _(_)_     |  A fresh approach to technical computing\r\n  (_)     | (_) (_)    |  Documentation: http://docs.julialang.org\r\n   _ _   _| |_  __ _   |  Type "help()" to list help topics\r\n  | | | | | | |/ _` |  |\r\n  | | |_| | | | (_| |  |  Version 0.2.0-514.r3d43\r\n _/ |\\__\'_|_|_|\\__\'_|  |  Commit 3d43df9032 2013-03-16 06:59:07\r\n|__/                   |\r\n\r\njulia> @eval begin\r\n           type T \r\n               x \r\n           end\r\n           T(sum([1,2]))\r\n       end\r\nT(3)\r\n\r\njulia> @eval begin\r\n           type T2 \r\n               x \r\n           end\r\n           s = 0\r\n           for i in [1,2]\r\n               s += i\r\n           end\r\n           T2(s)\r\n       end\r\nERROR: error compiling anonymous: unsupported or misplaced expression composite_type in function anonymous\r\n```\r\n\r\n'
2554,'Keno',"ccall should allow the same type signatures as cfunction\nCommit d42bb6dc16ff1468cd006904704999650113f1cd updated `cfunction` to allow more type signatures, such as `Function`, which is great for callback routines in which the C caller passes through some arguments as `void*` through to the callback.  However, the same arguments must currently be passed as `Any` to `ccall`, which is a bit counter-intuitive.\r\n\r\nIt would be nice if `ccall` and `cfunction` accepted and treated argument types in the same way.\r\n\r\nFor example, consider the following method to pass a re-entrant callback routine to the GNU libc `qsort_r` function.  (Warning: don't try this with MacOS or BSD, where `qsort_r` has a different argument order in its callback.)\r\n\r\n````\r\nfunction qsort_r_callback{T}(a::Ptr{T},\tb::Ptr{T}, f::Function)\r\n    int32(f(unsafe_ref(a), unsafe_ref(b)) ?\r\n          -1 : unsafe_ref(a) == unsafe_ref(b) ? 0 : +1)\r\nend\r\n\r\nfunction qsort_r{T}(A::Vector{T}, f::Function)\r\n    ccall(:qsort_r, Void, (Ptr{T}, Uint, Uint, Ptr{Void}, Any),\r\n          A, length(A),\tsizeof(T),\r\n          cfunction(qsort_r_callback, Cint, (Ptr{T}, Ptr{T}, Function)),\r\n          f)\r\n    A\r\nend\r\n````\r\n\r\nThis works great, even for anonymous functions, e.g. `qsort_r([17,2,7,3,-1,14], (a,b) -> a < b)`.   However, if you change the `Any` argument of `ccall` to the sensible-seeming `Function` type, it segfaults."
2552,'JeffBezanson','typealias bug?\n```julia\r\njulia> typealias SelfDict{T} Dict{T,T}\r\nDict{T,T}\r\n\r\njulia> isself(d::Dict) = false\r\n# methods for generic function isself\r\nisself(d::Dict{K,V}) at none:1\r\n\r\njulia> isself(d::SelfDict) = true\r\n# methods for generic function isself\r\nisself(d::Dict{T,T}) at none:1\r\n\r\njulia> isself([1=>2])\r\ntrue\r\n\r\njulia> isself([1=>"foo"])\r\ntrue\r\n```'
2492,'StefanKarpinski','Provide a way to update METADATA without upgrading packages\nThere are two different things that `Pkg.update()` does right now - it updates the metadata, and the packages, both. Typically, package managers use `update` for metadata, and `upgrade` for packages.\r\n\r\nIt is useful to differentiate between these two operations. There are often times when I just want the latest metadata, so that I can pull some new packages. However, I am not interested in upgrading my existing packages (unless the new package has dependencies that upgrade existing packages).\r\n\r\nThis would be a major API change, and perhaps we can let `update` do what it currently does, and have a different function for just updating the metadata. However, the terminology would then be inconsistent with most other package managers.'
2430,'vtjnash','JULIA_ENV\ninstead of allowing `using` to take arguments, I thought it might make sense to provide a global dictionary `CONFIG` of type `Dict{String, Any}`, roughly equivalent to `ENV` that could take arbitrary configuration parameters.\r\ne.g.\r\n```julia\r\nCONFIG["PyCall/Python"] = "/usr/bin/python2"\r\nCONFIG["gfx/backend"] = "gtk" # shared graphics property using pseudo-group "gfx"\r\nCONFIG["Winston/backend"] = "tk" # graphics override for Winston\r\nCONFIG["answer_color"] = "green" # a configuration property currently in ENV["JULIA_ANSWER_COLOR"]\r\nCONFIG["OUTPUT_STREAM"] = PipeBuffer() # properties don\'t need to be strings\r\n```\r\n(note the convention that items in base will be only names, whereas Modules should prefix their variables with their uppercase module name, or a meaningful lowercase string if it is a shared option)\r\n\r\nand then we can also allow a callback notification function to be registered which can do additional work and/or disallow changes:\r\n```julia\r\nCONFIG_cb["OUTPUT_STREAM"] = function(new_val, old_val)\r\n    if isa(new_val, IO)\r\n        OUTPUT_STREAM = new_val\r\n        true\r\n    else\r\n        false\r\n    end\r\nend\r\n```\r\n\r\nedit: replaced `JULIA_ENV` variable with `CONFIG`'
2299,'Keno','SIMD types\nI have been floating the idea to expose and use SIMD instructions in a generic way. @JeffBezanson has suggested that this is quite feasible. @StefanKarpinski suggested VecInt and VecFloat bits types in this thread:\r\n\r\nhttps://groups.google.com/forum/?fromgroups=#!topic/julia-dev/h8EGtQvdq9U\r\n\r\nTo refine this further, it may be that we need VecInt32, VecInt64, VecFloat32, and VecFloat64 bits types. Arrays of these Vec types could correspond to simply reinterpreting arrays of the Int32, Int64, Float32, Float64. \r\n\r\nWe already do 16-byte alignment for memory allocation, although we may need 32-byte alignment for AVX instructions. This could be wasteful for small arrays, but there could be real performance gains for 2x2 and 3x3 matrix operations. As suggested in the thread above by @StefanKarpinski, we may need to do operations on the non-aligned portions in the head and tail separately.\r\n\r\nOnce we have this, we would probably want to implement all the vectorized base library operations using SIMD, which will give a nice performance boost until we have some kind of threading or fork/shmem based parallelism for Array objects.\r\n\r\nThen there are also operations such as trigonometric and various math library functions, which are unlikely to be as accurate as openlibm, but a whole lot faster. Perhaps these should not be used by default, but available as vecsin etc.'
2177,'Keno','ccall does not support complex return on 32 bit machines\nThe Travis build is segfaulting now because of this (but returns green anyway).\r\n\r\n64 bit OS X:\r\n```julia\r\njulia> erf(complex(1.0))\r\n0.8427007929497148 + 0.0im\r\n```\r\n32 bit Ubuntu:\r\n```julia\r\njulia> erf(complex(1.0))\r\nSegmentation fault (core dumped)\r\n```\r\ncc: @vtjnash '
1974,'JeffBezanson','allow overloading of a.b field access syntax\nBrought up here: https://github.com/JuliaLang/julia/issues/1263.'
1933,'vtjnash','combine various incantations of Async Runners\n@JeffBezanson this was an issue you had created. do you want to comment on a better API?'
1925,'Keno',"start_reading\nstart_reading / stop_reading are needed on stdin_stream to share it with other processes. when should this be called? how automatic can it be? I suspect it's only needed with respect to spawning, in which case the default state could be start_reading and when spawning call stop_reading on the stream passed for stdin. currently the situation is a bit haphazard."
1864,'JeffBezanson',"anonymous function calls have a huge overhead\nA surprising factor of 100 slowdown in this simple example:\r\n\r\n    julia> A = rand(100000);\r\n    \r\n    julia> foo(X) = for i = 1:numel(X); X[i] *= 2; end\r\n    \r\n    julia> bar(s) = X -> for i = 1:numel(X); X[i] *= s; end\r\n    \r\n    julia> @time foo(A)\r\n    elapsed time: 0.008594989776611328 seconds\r\n    \r\n    julia> @time foo(A)\r\n    elapsed time: 0.0002551078796386719 seconds\r\n    \r\n    julia> baz = bar(2)\r\n    #<function>\r\n    \r\n    julia> @time baz(A)\r\n    elapsed time: 0.048172950744628906 seconds\r\n    \r\n    julia> @time baz(A)\r\n    elapsed time: 0.0285341739654541 seconds\r\n\r\nI'm guessing there is some lack of JIT-ing going on?  This affects #1856."
1631,'JeffBezanson','Extraneous ambiguity warning: (MyType{T},T) vs (T,MyType{T})\nThe code\n\n    abstract MyType{T}\n\n    f{T}(::MyType{T}, ::T) = 1\n    f{S}(::S, ::MyType{S}) = 2\n\nproduces the ambiguity warning\n\n    Warning: New definition f(S,MyType{S}) is ambiguous with f(MyType{T},T).\n             Make sure f(MyType{T},MyType{S}) is defined first.\n\nThis seems like \n`S` has been instantiated to `MyType{T}` in the intersection, and\n`T` has been instantiated to `MyType{S}`.\nBut that would mean that `T == MyType{MyType{T}}`. No type could fulfill this, right?\n(8 out of the 19 ambiguity warnings [here](https://github.com/HarlanH/DataFrames.jl/issues/77) seem to be of this kind.)\n\nThe similar case\n\n    g{T}(::MyType{T}, ::T) = 1\n    g{S}(::S,         ::S) = 2\n\ndoes not produce an ambiguity warning, though it would have been ambiguous if there were a type `T` such that `T == MyType{T}`.'
1470,'JeffBezanson','int, Int, and box\nI.e. write `Int(1.5)` instead of `int(1.5)`. See this thread for discussion:\r\n\r\nhttps://groups.google.com/d/topic/julia-dev/gy1HlWWcxBA/discussion'
1334,'JeffBezanson',"Unusual backtrace line numbers with macros\nI've noticed that Julia's backtrace line numbers don't alway make sense.  For instance, in the following short program (named `lapack_perf.jl`) and ignoring the actual errors in the code:\r\n\r\n```\r\nreps  = 10\r\nn     = 100\r\nsrand(1234321)\r\na     = rand(n,n)\r\napd   = a'*a\r\n\r\nfunction test_chold{T<:Number}(apd::Matrix{T})\r\n    times = zeros(10)\r\n    cholds = T[]\r\n    times = [@elapsed push(cholds, chold(apd)) for k = reps]\r\n    \r\n    # return so it doesn't get optimized away\r\n    cholds\r\nend\r\n\r\n\r\nprint( test_chold(apd) )\r\n```\r\n\r\nI get the following backtrace:\r\n```\r\n$ julia lapack_perf.jl \r\nno method convert(Type{Float64},CholeskyDense{Float64})\r\n in method_missing at base.jl:70\r\n in push at array.jl:708\r\n in test_chold at /Users/sabae/Desktop/lapack_perf.jl:49\r\n in load_now at util.jl:231\r\n in load_now at util.jl:245\r\n in require at util.jl:174\r\n in process_options at client.jl:178\r\n in _start at client.jl:232\r\nat /Users/sabae/Desktop/lapack_perf.jl:17\r\n in load_now at util.jl:231\r\n in load_now at util.jl:245\r\n in require at util.jl:174\r\n in process_options at client.jl:178\r\n in _start at client.jl:232\r\n in load_now at util.jl:256\r\n in require at util.jl:174\r\n in process_options at client.jl:178\r\n in _start at client.jl:232\r\n```\r\n\r\nThis all looks fine and good until we see the `in test_chold at /Users/sabae/Desktop/lapack_perf.jl:49` line; Clearly this file doesn't have a line 49.\r\n\r\nEDIT: This is due to macros, as @dmbates states.  Is there a better way to effect line-printing with macros (which are very helpful and therefore likely to be used extensively)?"
1315,'Keno','Splicing in arguments into a ccall\nConceptually related to #1313.\n\nIf I try defining a function this way:\n\n```julia\n@eval begin\n    function mylseek(args...)\n        cpos = ccall(:lseek, FileOffset, (Int32, FileOffset, Int32), args...)\n    end\nend\n```\n\nthen I get:\n```\njulia> s = open("h5test.c")\nIOStream(<file h5test.c>)\n\njulia> mylseek(fd(s), 5, 0)\nerror compiling mylseek: ccall: wrong number of arguments to C function\n```\n\nOne workaround is the following:\n```julia\nccallargs = Any[:(:lseek), FileOffset, expr(:tuple, Any[Int32, FileOffset, Int32]), :(args[1]), :(args[2]), :(args[3])]\nex = expr(:ccall, ccallargs)\n@eval begin\n    function mylseek(args...)\n        $ex\n    end\nend\n\njulia> mylseek(fd(s), 11, 0)\n11\n```\n\nPerhaps there is a less-awkward syntax? If not, should we add a ``ccallexpr`` function to the library that would build those expressions?\n'
1289,'JeffBezanson','for-else and while-else\nAllow and else clause on for and while loops that executes if the loop never executes.'
1255,'JeffBezanson','module and import aliasing\nFor the module system, we can import and use a module with dot notation:\n\n```julia\nimport ArgParse\n... \n    ArgParse.add_argument(p, "--opt1") \n...\n```\n\nThis can be useful to prevent namespace pollution.  Because of the verbosity of module names, however, it would be nice to have module aliases:\n\n```julia\nimport ArgParse as ap \n... \n    ap.add_argument(p, "--opt1") \n...\n```\n'
1189,'JeffBezanson','debug metadata for inlined functions\nIt seems that julia error tracebacks sometimes leave out some lines, including the one with the actual error.\nWhen I load the following code from a script,\n\n    module M\n    function f()\n        x        # line 3: error occurs here\n    end\n    function g()\n        f()      # line 6\n    end\n    g()          # line 8\n    end\n\nit produces the output\n\n    in g: x not defined\n     in load at util.jl:230\n     in load at util.jl:242\n    at /work/toivo/code/juliastuff/code/errorline.jl:8\n     in load at util.jl:253\n\nNote that both line 3, where the error occurs, and line 6, which calls it, are missing from the traceback.\n'
1096,'JeffBezanson','julia functions as C callbacks\n--- update ---\r\nthe original issue is pretty much covered by cfunction. the remaining issues are:\r\n- [ ] support closures\r\n- [ ] adding conversion wrapper in case of inexact matches\r\n\r\n---- original text ---\r\nTo enable certain function calls to C code, it would be helpful to have a function callback API in Julia (this is partly inspired by the libuv interface, which ended up handling most of these issues by creating a tight coupling between julila function and types and libuv callbacks and types)\r\n\r\nThe two issues that I currently see would need to be handled are:\r\n1) Since pointers are leaving control of Julia, the garbage collector needs to know not to clean-up anything that may be used in the future (and notified when it can)\r\n2) Since C doesn\'t natively have type information, it requires some sort of reverse ccall interface\r\n\r\nTo handle 1, I think it may be safest to create a garbage collector allocation pool. Objects can be pushed to and popped from it from within Julia (using ref counting?). Then possibly add a default behavior that parameters to a ccall containing a Callback object are automatically saved until all callbacks are manually deleted. (since additional and previous calls to C functions may also hold onto object pointers, it may be useful to have this as a separately available function)\r\n\r\nTo handle 2, it will be necessary to indicate type information to the ccall. One possibility is to make a type that contains the information ```type Callback{ params <: Tuple } end ``` and is passed to the ccall in the third argument tuple. A generic function name would then be passed in the parameters list. A second possibility is to make Callback a simple type that contains all of that information ```type Callback; params <: Tuple; f :: Function; end```. A third (similar) possibility is to do the exact function lookup in Julia and require something like the value returned by getmethods and printed by whicht. In any case, I envision that ccall would JIT an intermediary function that converts from raw bits types to Julia types. This prompts the last possibility (and possibly my favorite) of having make_callback return a raw pointer to a newly JIT\'d  intermediary C function:\r\n\r\n```\r\ncallback_fcn = make_callback(fcn::Function, arg_types::Tuple)\r\narg2 = "test"\r\ncpreserve(arg2); cpreserve(fcn) # if args are not automatically preserved\r\nccall(:cfcn, Void, (Ptr, String), callback_fcn, arg2)\r\n...\r\ncrelease(arg2) # if args are not automatically preserved\r\ncrelease(fcn) # if args are automatically preserved, arg2 won\'t be freed till after this point\r\n```\r\n\r\nA final question is whether pointer_to_array is the best way to grab a c array? Or is there some way to indicate this in the argument type?\r\n\r\nThoughts and alternatives? Am I missing any challenging callback argument types?'
1090,'JeffBezanson','return type declarations\nProvide this convenient shorthand:\n\n```\nfunction foo(x)::T\n  ...\n  return z\nend\n```\n\nfor this:\n\n```\nfunction foo(x)\n  ret::T\n  ...\n  ret = z\n  return ret\nend\n```\n'
964,'JeffBezanson',"Type annotations in global scope\nIs it expected behaviour that I can't type annotate variable declarations in global scope? Example:\n```julia\njulia> foo::Float = 0.1\nfoo not defined\n\njulia> function bar()\n         foo::Float = 0.1\n       end\n\njulia> bar()\n0.1\n```"
939,'StefanKarpinski','sort/sortperm has poor performance\nsort/sortperm has poor performance compared to matlab.\r\n\r\n````\r\njulia> y = [1000000:-1:1];\r\n\r\njulia> @time sortperm(y);\r\nelapsed time: 0.0885950756072998 seconds\r\n````\r\n````\r\n>> tic; [ign, p] = sort(y); toc\r\nElapsed time is 0.030718 seconds.\r\n````\r\n\r\n[edit - updated the issue 1/25/2012 -- ViralBShah]\r\n'
685,'JeffBezanson','Improve macro-related error reporting\nMy personal favorite is "malformed tree," which provides no backtrace and no printout showing where or how the tree was malformed.\r\n\r\nRelated to #683, which can help error messages which occur when gensyms are unbound.\r\n\r\n@timholy, have you come across any others?'
524,'JeffBezanson',"treat globals as constant within top-level expressions when possible\n```\r\n   _       _ _(_)_     |\r\n  (_)     | (_) (_)    |  A fresh approach to technical computing\r\n   _ _   _| |_  __ _   |\r\n  | | | | | | |/ _` |  |  Version 0.0.0-prerelease\r\n  | | |_| | | | (_| |  |  Commit 335d1ef401 (2012-03-04 23:47:29)\r\n _/ |\\__'_|_|_|\\__'_|  |\r\n|__/                   |\r\n\r\njulia> x = 5\r\n5\r\n\r\njulia> typeof(x)\r\nInt64\r\n\r\njulia> typeof([i | i = 1:5])\r\nArray{Int64,1}\r\n```\r\nSo far, so good.\r\n\r\n```\r\njulia> typeof([i | i = 1:x])\r\nArray{Any,1}\r\n```\r\nWat.\r\n(with apologies to https://www.destroyallsoftware.com/talks/wat)"
505,'Keno',"debugger\nDebugging code is currently print() based. This isn't a particularly great solution.\r\n\r\nSpun this issue off of #502 so maybe we can put that one back on topic. (My fault for bringing it up)"
308,'JeffBezanson','data structures with cycles can\'t be serialized\nI have been trying to implement a simple parallel update scheme for doing local computations on a graph structure, and I encountered a problem; I\'m not sure if it is a "proper" bug or not. \r\n\r\nI have reduced everything to the bare minimum to reproduce the problem and I\'ve uploaded the relevant files in [this directory](https://github.com/carlobaldassi/julia/tree/simple_graph/simple_graph).\r\n\r\nBriefly, it goes like this: I define a simple graph structure, in which nodes contain vectors of reference to neighbouring edges, and edges contain references to the nodes they connect. Then, I define a local update function which works at the node level, using only information stored within the node itself and its neighbouring edges. Finally, I call this update function over all nodes. I wish to do this last step in parallel, so I use `@parallel for`.\r\n(All of this is defined in [simple_graph.j](https://github.com/carlobaldassi/julia/blob/simple_graph/simple_graph/simple_graph.j))\r\n\r\nTesting this on an almost-trivial graph (two nodes, one link, see [sg_test.j](https://github.com/carlobaldassi/julia/blob/simple_graph/simple_graph/sg_test.j)) everything works fine on a single processor, but when calling julia with more than one process I get a `stack overflow` error:\r\n\r\n    $julia -p 2 sg_test.j\r\n    error: stack overflow sg_test.j:10\r\n    in load, boot.j:265\r\n    in process_options, /home/carlo/Programmi/julia/j/client.j:88\r\n    in _start, /home/carlo/Programmi/julia/j/client.j:128\r\n\r\nI suspect the problem is an infinite recursion when julia is passing the data around (which BTW isn\'t necessary at all for this particular scheme, in fact: I could have memory shared between processes, with each working on a part of it). My suspect comes from the observation that I also get a `stack overflow` error when trying to print the structures without explicitly defining a show method for them.\r\n\r\nIs this a bug? Also, I (apparently) managed to solve the problem by using distributed arrays to store the objects (code is [here](https://github.com/carlobaldassi/julia/tree/simple_graph/dist_simple_graph)), but I was wondering if there is any other way to simply declare whole chunks of memory as shared between all processes, in an OpenMP kind of way, which in my case would be sufficient to achieve the task and would allow to use different structures than arrays. Also, `@parallel for` doesn\'t work in this context (it only updates the nodes owned by one of the processes), so I had to use `@sync` and `@spawnat`; if there was a way to share memory between processes this wouldn\'t be necessary (again, as when using `#pragma parallel for` with OpenMP).'
270,'JeffBezanson','make order irrelevant to ambiguous method warnings\nIt would be nice to be smarter about giving these warnings, so that if the needed method is defined, say, before the end of a file, no warning is printed.\r\n'
269,'JeffBezanson',"handle mutually-circular type declarations\nCurrently this doesn't work:\r\n\r\n```\r\ntype Foo\r\n    a::Bar\r\nend\r\n\r\ntype Bar\r\n    b::Foo\r\nend\r\n```\r\n\r\nA nice way to handle it is to automatically insert forward declarations for all types defined in a file after lowering. That way as long as the types are in the same file it will Just Work™.\r\n"
265,'JeffBezanson',"automatic recompilation of dependent functions\nif I define a function d2 before a function d1 which calls d2 then change d2, d1 uses the old definition for d2.\r\nI assume this is because it is all precompiled, but maybe there should be a note warning of this? Or would it be possible to replace the old definition with a longjmp to the new one?\r\n(Mostly important for the REPL, since I don't always do a full load)\r\n\r\n```julia\r\njulia> function d2()\r\n       a\r\n       end\r\n\r\njulia> function d()\r\n         d2()\r\n       end\r\n\r\njulia> d()\r\nin d: a not defined\r\n\r\njulia> function d2()\r\n       b=2\r\n       end\r\n\r\njulia> d()\r\nin d: a not defined\r\n\r\njulia> d2\r\nMethods for generic function d2\r\nd2() at prompt:2\r\n\r\njulia> function d()\r\n         d2()\r\n       end\r\n\r\njulia> d()\r\n2\r\n```"
261,'JeffBezanson','gc enhancements\nSome ideas for making GC faster/better:\r\n\r\n- Store cached type inference trees in a bytecode format instead of as a Julia objects on the heap.\r\n- Track escape bits (approximate ref counts) for objects, allowing immediate reclamation of unescaped objects.'
210,'JeffBezanson','function types\nThen just settle for map returning a type of the map function as the output array type.'
122,'JeffBezanson',"Framework for symbolic optimizations\nWe need a framework to express certain mathematical optimizations in julia itself. These may be expressed as rules that are run after types have been inferred. Examples are:\r\n\r\n1. `A' * B, A' \\ B`: Can be computed without computing the transpose by calling BLAS/LAPACK routines\r\n2. `A - B + C .* D`: Can be computed without temporaries\r\n3. `A[m:n, p:q] + B`: Avoid computing the ref. \r\n4. `A[m:n, p:q] * B`: Avoid computing the sref, and call DGEMM directly in cases where this is possible.\r\n5. `[ a b c; d f; e]`: Compute the entire concatenation in one shot.\r\n6. `A[p,q] = B[r,s]`: Temporary can be avoided by calling `assign(A, sub(B, r, s), p, q)`\r\n\r\nIn all cases, temporaries can be avoided. Either we can do it with optimizations, or have the parser such expressions down to the runtime. If a matching runtime implementation for such cases is not found, the existing base case should certainly be used.\r\n\r\n"
106,'StefanKarpinski',"use mmap to read files when possible\nIt occurs to me that we could potentially mmap files that are mmappable when reading them, potentially improving performance quite drastically. We'd have to test it out to make sure it didn't have major issues, but it could be a big win.\r\n\r\nOne really great example of where this could be an enormous performance improvement would be when using a regex to scan a file. The normal approach is to real in a chunk at a time and then scan that with the regex. However, that has issues if you can't be sure whether the regex has to match within the chunk. For example, when reading line-by-line, matching a regex that can only match within a line, this is fine —\xa0as long as the lines don't get prohibitively long. If the scan is through the entire file, e.g. in the case where the regex is being used to split the file into chunks for consumption, then this can get tricky. Using the mmap approach, you can just map the file and let the regex engine go to work —\xa0the kernel will handle getting the data when the regex engine is ready for it!\r\n\r\nIt would be nice to be able to apply the same trick to streamed data, which cannot be mmapped. However, I think a related trick might work: memory protect the page after the last bit of valid, read data from the file and trap accesses to that memory. Then if the regex engine (or whatever is doing the reading) reads past the valid buffer, you can go ahead and read more data on demand. This allows a very similar trick to be done even with streamed input."
89,'JeffBezanson','spawn should try not to spawn local indexing operations\nIn a statement like\r\n\r\n    @spawn f(A[I,J], B[I,K])\r\n\r\nif `A` is a local array the indexing should be done locally so only part of the array is sent elsewhere.\r\nA good approach might be to lower this as follows:\r\n\r\n    if isa(A, Array)\r\n        sub = A[I,J]\r\n        thk = ()->sub\r\n    else\r\n        thk = ()->A[I,J]\r\n    end\r\n    @spawn f(thk(), ...)\r\n'
29,'tanmaykm','Need better array printing - especially for complex arrays\nOur array printing is currently quite embarrassing. It needs to be fixed.'
25,'StefanKarpinski','better general object printing\nGoals:\n\n- printing circular structures\n- printing objects with type annotations\n- printing objects structurally instead of "pretty printing" them\n\nIt should probably be possible to switch between different printing modes in the repl. It\'s especially often quite handy to have type annotations in the repl.'
