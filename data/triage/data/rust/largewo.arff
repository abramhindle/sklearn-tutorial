@relation large.json
@attribute id integer
@attribute owner string
@attribute content string
@data
19226,'pcwalton','Moved block of code into a function\nThis is for the issue #19168 '
19152,'aturon','std: Align `raw` modules with unsafe conventions\nThis commit is an implementation of [RFC 240][rfc] when applied to the standard\r\nlibrary. It primarily deprecates the entirety of `string::raw`, `vec::raw`,\r\n`slice::raw`, and `str::raw` in favor of associated functions, methods, and\r\nother free functions. The detailed renaming is:\r\n\r\n* slice::raw::buf_as_slice => slice::from_raw_buf\r\n* slice::raw::mut_buf_as_slice => slice::from_raw_mut_buf\r\n* slice::shift_ptr => deprecated with no replacement\r\n* slice::pop_ptr => deprecated with no replacement\r\n* str::raw::from_utf8 => str::from_utf8_unchecked\r\n* str::raw::c_str_to_static_slice => str::from_c_str\r\n* str::raw::slice_bytes => deprecated for slice_unchecked (slight semantic diff)\r\n* str::raw::slice_unchecked => str.slice_unchecked\r\n* string::raw::from_parts => String::from_raw_parts\r\n* string::raw::from_buf_len => String::from_raw_buf_len\r\n* string::raw::from_buf => String::from_raw_buf\r\n* string::raw::from_utf8 => String::from_utf8_unchecked\r\n* vec::raw::from_buf => Vec::from_raw_buf\r\n\r\nAll previous functions exist in their `#[deprecated]` form, and the deprecation\r\nmessages indicate how to migrate to the newer variants.\r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0240-unsafe-api-location.md\r\n[breaking-change]\r\n\r\nCloses #17863'
19124,'alexcrichton','Remove struct_variants from tests\nRemoved usage of struct_variant feature from all tests.'
19122,'alexcrichton','removed usage of struct_variant feature as it is no longer gated\nThe struct_variant is not gated anymore. This commit just removes it and the resulting warnings when compiling rust. Now compiles with the snapshot from 11/18 (as opposed to PR #19014)'
19116,'aturon','Expose file descriptor\nFor FFI needs, as started by #15643, this allow `File`, `PipeStream` and `UnixStream` to export their internal file descriptor with the `AsFileDesc` trait provided by #18557.'
19089,'pcwalton','Infer argument types for unboxed closures by inspecting the expected type\nThis also lays the groundwork for a simple version of inference to decide on `FnOnce` vs `FnMut` etc.\r\n\r\nFixes #17907 \r\n\r\nr? @pcwalton '
19088,'huonw','Tracking issue for RFC 463 - tokenise idents immediately after a literal as part of the literal\nThis is backwards incompatible, but we do not want to block 1.0.'
19076,'pcwalton','librustrt: check for mips+linux config in stack_overflow\n'
19069,'jakub-',"Feature gate non-ascii lifetimes\nThe following compiles fine:\r\n\r\n```rust\r\n#![allow(dead_code)]\r\n\r\nstruct Foo<'π> {\r\n    x: &'π int\r\n}\r\n\r\nfn foo<'π>(_: &'π int) {}\r\n\r\nfn main() {}\r\n````\r\n\r\nThese should presumably be feature-gated like identifiers are."
19060,'aturon',"make Option::cloned generic over Deref, make cloned's tests actually run, add Cloned iterator adaptor\nEdit: whoops, didn't mean to hit post.\r\n\r\nAnyway, this is something I tried to do when I first implemented cloned, but couldn't figure out. Somewhere between then and the PR actually landing, we got Deref of references, so now this works! :tada: \r\n\r\nAlso turns out the test for the functionality was never marked as a #[test]. Oops!\r\n\r\nAlso added a Cloned iterator adaptor. If this isn't desirable, it can be taken out of the PR (seperate commits)."
19050,'aturon','More library DSTification\nr? @aturon \r\ncc #16918'
19049,'alexcrichton','Rolling up PRs in the queue\nr? @alexcrichton'
19042,'huonw','Make Utf16CodeUnits generic and give it a public constructor.\nThis allows encoding to UTF-16 something that is not in UTF-8, e.g. a `[char]` UTF-32 string.\r\n\r\nThis might help with servo/servo#4023'
19041,'aturon','DSTify `impl Clone for &T`\nCloses #19037 \r\ncc #16918\r\n\r\nr? @aturon '
19040,'aturon','std: Stabilize std::fmt\nThis commit applies the stabilization of std::fmt as outlined in [RFC 380][rfc].\r\nThere are a number of breaking changes as a part of this commit which will need\r\nto be handled to migrated old code:\r\n\r\n* A number of formatting traits have been removed: String, Bool, Char, Unsigned,\r\n  Signed, and Float. It is recommended to instead use Show wherever possible or\r\n  to use adaptor structs to implement other methods of formatting.\r\n\r\n* The format specifier for Boolean has changed from `t` to `b`.\r\n\r\n* The enum `FormatError` has been renamed to `Error` as well as becoming a unit\r\n  struct instead of an enum. The `WriteError` variant no longer exists.\r\n\r\n* The `format_args_method!` macro has been removed with no replacement. Alter\r\n  code to use the `format_args!` macro instead.\r\n\r\n* The public fields of a `Formatter` have become read-only with no replacement.\r\n  Use a new formatting string to alter the formatting flags in combination with\r\n  the `write!` macro. The fields can be accessed through accessor methods on the\r\n  `Formatter` structure.\r\n\r\nOther than these breaking changes, the contents of std::fmt should now also all\r\ncontain stability markers. Most of them are still #[unstable] or #[experimental]\r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0380-stabilize-std-fmt.md\r\n[breaking-change]\r\n\r\nCloses #18904'
19038,'huonw','Fix several typos in comments\nBaby steps here...\r\n\r\nFixed some comments in liblog, libregex, librustc, libstd.'
19016,'nikomatsakis','Remove duplicate code by using util::copy()\nThis code is identical to io::util::copy()'
19014,'nikomatsakis','removed struct_variant feature as it is not gated anymore\nThe struct_variant is not gated anymore. This commit just removes it and the resulting warnings when compiling rust.'
19012,'brson','Add a function to copy from a Reader to a Writer\nMove copying between streams from io::fs::copy() into a separate fn, adding a NoProgress check from read_at_least.\r\nInitially I wanted to add a write_from_reader() to Writer but it seemed to run afoul of object safety rules.'
19002,'brson','Move trans, back, driver, and back into a new crate, rustc_trans.\nMove trans, back, driver, and back into a new crate, rustc_trans (which probably needs a better name). This is not a principled split per se, though it does make some sense, as the things which have been moved all fall into "back end" territory. The primary motivation is reducing memory usage. Measurements with massif suggest that peak memory usage after this change is 1.5GB. In comparison, measurements on master show a range from 1.8 to 2.5 GB of usage.\r\n\r\nr? @brson \r\ncc @alexcrichton \r\ncc #18784 '
18999,'alexcrichton','libs: stabilize most numerics after RFC changes\nThis commit adds stability markers for the APIs that have recently been aligned with [numerics reform](https://github.com/rust-lang/rfcs/pull/369). For APIs that were changed as part of that reform, `#[unstable]` is used to reflect the recency, but the APIs will become `#[stable]` in a follow-up pass.\r\n\r\nIn addition, a few aspects of the APIs not explicitly covered by the RFC are marked here -- in particular, constants for floats.\r\n\r\nThis commit does not mark the `uint` or `int` modules as `#[stable]`, given the ongoing debate out the names and roles of these types.\r\n\r\nDue to some deprecation (see the RFC for details), this is a:\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton \r\ncc @bjz '
18994,'alexcrichton','Un-feature gate struct variants\nStruct variant field visibility is now inherited. Remove `pub` keywords\r\nfrom declarations.\r\n\r\nCloses #18641\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton '
18993,'pcwalton','Implement higher-ranked trait bounds.\nEnough said.\r\n\r\nFixes #18639.\r\n\r\nr? @pcwalton (or someone else?)\r\n\r\nThis is a [breaking-change]. In particular, several feature gates related to unboxed closures were consolidated into one (`overloaded_calls`, `unboxed_closure_sugar` => `unboxed_closures`). Otherwise, I think everything that worked before should still work. File a bug and cc @nikomatsakis if you find otherwise. :)'
18986,'jakub-','ICE: nested mods, improper namespace usage, match on struct named Buffer\nNot the best title, but I suppose it somehow summarizes the situation.\r\nThere\'s no ICE if I un-comment "use buffer" and prefix Buffer as the comment is suggesting. There\'s also no ICE if I rename Buffer into anything else. (fun!)\r\n```rust\r\nmod stuff {\r\n  pub struct Buffer {\r\n    pub x: int,\r\n  }\r\n}\r\n\r\nmod user {\r\n  use stuff;\r\n\r\n  fn make_buffer() -> stuff::Buffer {\r\n    stuff::Buffer{x: 0}\r\n  }\r\n\r\n  mod oops {\r\n    //use stuff;\r\n    fn test() {\r\n      match super::make_buffer() {\r\n        Buffer{x: 0} => panic!(),  // stuff::Buffer\r\n        _            => panic!(),\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nfn main() {\r\n}\r\n\r\n```\r\n> ERROR:rbml::::reader: failed to find block with tag 7\r\n> error: internal compiler error: unexpected panic\r\n> note: the compiler unexpectedly panicked. this is a bug.\r\n> note: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\r\n> note: run with `RUST_BACKTRACE=1` for a backtrace\r\n>\r\n> task \'rustc\' panicked at \'explicit panic\', /Users/rustbuild/src/rust-buildbot/slave/nightly-mac/build/src/librbml/lib.rs:247\r\n>\r\n> stack backtrace:\r\n>    1:        0x10e4cb01f - rt::backtrace::imp::write::h37f6e30fade15cb76mt\r\n>    2:        0x10e4ce1a7 - failure::on_fail::h4075de659ea4adb9VDt\r\n>    3:        0x10e750415 - unwind::begin_unwind_inner::h9e12d6856ac2af42j1c\r\n>    4:        0x10ca9052b - unwind::begin_unwind::h11182489159142915490\r\n>    5:        0x10ca8f5e3 - reader::get_doc::hc5118bbb2b31c59eaRa\r\n>    6:        0x10b3e0caf - middle::ty::lookup_item_type::h7caf3571e12f2099GPK\r\n>    7:        0x10b6157a7 - middle::typeck::check::_match::check_pat_struct::h530d0497877c87a3hpN\r\n>    8:        0x10b611f50 - middle::typeck::check::_match::check_pat::h711bfcd44ca5f0e512M\r\n>    9:        0x10b616adc - middle::typeck::check::_match::check_match::h47cf5b76682ede75dmN\r\n>   10:        0x10b6b71a7 - middle::typeck::check::check_expr_with_unifier::h5cc319219e4634c5KDZ\r\n>   11:        0x10b70c8c8 - middle::typeck::check::check_stmt::h009ea09e991284aaHK1\r\n>   12:        0x10b67c4df - middle::typeck::check::check_block_with_expected::h5b0b62d59a49dca7QO1\r\n>   13:        0x10b67974f - middle::typeck::check::check_fn::h34037919bf4d6fc6agW\r\n>   14:        0x10b678c7f - middle::typeck::check::check_bare_fn::h84006153c3903b4bp5V\r\n>   15:        0x10b674dfd - middle::typeck::check::check_item::hbe92f8f4fa881f38ypW\r\n>   16:        0x10b678652 - visit::walk_mod::h13658454776526124109\r\n>   17:        0x10b67865d - visit::walk_mod::h13658454776526124109\r\n>   18:        0x10b678adb - middle::typeck::check::check_item_types::h33c841ee77106c9fz4V\r\n>   19:        0x10b18a3e6 - util::common::time::h7952646948545449844\r\n>   20:        0x10b9837fe - middle::typeck::check_crate::h56303c294c543c95rrp\r\n>   21:        0x10b9ea561 - driver::driver::phase_3_run_analysis_passes::hd9e3e0ce5c907bdctaC\r\n>   22:        0x10b9e53b8 - driver::driver::compile_input::h73a7648d6863cf25eRB\r\n>   23:        0x10ba6289d - driver::run_compiler::ha880c9a92de1aa35vHF\r\n>   24:        0x10ba60dde - driver::run::closure.146204\r\n>   25:        0x10b1a269b - task::TaskBuilder<S>::try_future::closure.104764\r\n>   26:        0x10b1a2593 - task::TaskBuilder<S>::spawn_internal::closure.104735\r\n>   27:        0x10b1607bd - task::NativeSpawner.Spawner::spawn::closure.2551\r\n>   28:        0x10e7aea0c - rust_try_inner\r\n>   29:        0x10e7ae9f6 - rust_try\r\n>   30:        0x10e74dbe7 - unwind::try::h009a35089a5882701Pc\r\n>   31:        0x10e74da7c - task::Task::run::h4878cb7b665069bf61b\r\n>   32:        0x10b1605e3 - task::NativeSpawner.Spawner::spawn::closure.2475\r\n>   33:        0x10e74f2a7 - thread::thread_start::h8e83ad43ae75daab3mc\r\n>   34:     0x7fff8bef02fc - _pthread_body\r\n>   35:     0x7fff8bef0279 - _pthread_body\r\n\r\nrustc 0.13.0-nightly (e82f60eb4 2014-11-11 22:37:05 +0000)\r\nbinary: rustc\r\ncommit-hash: e82f60eb471c4ee092bd4867f6946d271a620e71\r\ncommit-date: 2014-11-11 22:37:05 +0000\r\nhost: x86_64-apple-darwin\r\nrelease: 0.13.0-nightly'
18984,'aturon','Fix for issue #17574\nFix #17574'
18968,'steveklabnik',"Guide: add a pointer to play.rust-lang.org\nAs-is, there's no indication that the code examples pop out into a window that runs on `play.rust-lang.org` until you mouse over them. I managed to get to section 4 of the guide before realizing you could do this since it didn't occur to me to mouse over the example text.\r\n\r\ncc @rose since we went through the tutorial together and I think it wasn't obvious to her either."
18967,'alexcrichton','Finish runtime removal\nThis PR completes the removal of the runtime system and green-threaded abstractions as part of implementing [RFC 230](https://github.com/rust-lang/rfcs/pull/230).\r\n\r\nSpecifically:\r\n\r\n* It removes the `Runtime` trait, welding the scheduling infrastructure directly to native threads.\r\n\r\n* It removes `libgreen` and `libnative` entirely.\r\n\r\n* It rewrites `sync::mutex` as a trivial layer on top of native mutexes. Eventually, the two modules will be merged.\r\n\r\n* It hides the vast majority of `std::rt`.\r\n\r\nThis completes the basic task of removing the runtime system (I/O and scheduling) and components that depend on it. \r\n\r\nAfter this lands, a follow-up PR will pull the `rustrt` crate back into `std`, turn `std::task` into `std::thread` (with API changes to go along with it), and completely cut out the remaining startup/teardown sequence. Other changes, including new [TLS](https://github.com/rust-lang/rfcs/pull/461) and synchronization are in the RFC or pre-RFC phase.\r\n\r\nCloses #17325\r\nCloses #18687\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton '
18948,'nikomatsakis','Improve examples for syntax::ext::deriving::encodable\nIn the documentation for `syntax::ext::deriving::encodable`,\r\n\r\n- `emit_field()` -> `emit_struct_field()`\r\n- `read_field()` -> `read_struct_field()`'
18940,'pcwalton',"Ensure that the type parameters passed to methods outlive the call expression\nEnsure that the type parameters passed to methods outlive the call expression.\r\n\r\nFixes #18899.\r\n\r\nThis is yet another case of forgotten to consistently enforce the constraints in every instance where they apply. Might be nice to try and refactor to make this whole thing more DRY, but for now here's a targeted fix.\r\n\r\nr? @pcwalton "
18934,'aturon','Add utility function that just calls Default::default.\n'
18933,'steveklabnik',"Don't use rust  keyword for fake code\nAs per IRC, fake rust is a bit too similar to real rust.\r\n\r\n```fn``` -> ```func``` for all code blocks marked notrust.\r\n\r\n/cc @steveklabnik \r\n"
18921,'aturon','libgraphviz: Id::new returns Result<Id, ()> instead of panicking on error\ncreating a new Id object requires the format to match a subset of `ID` format defined by the DOT language. When the format did not match, the function called assert. This was not mentioned in the docs or the spec. I made the failure explicit by returning an Result<Id, ()>.'
18914,'aturon','Add Cloned to Option, kill find_copy and get_copy in favour of explicit cloning\nPart of #18424. r? @aturon \r\n\r\n[breaking-change]'
18911,'pcwalton','change return type of slice_shift_char\n`slice_shift_char` splits a `str` into it\'s leading `char` and the remainder of the `str`. Currently, it returns a `(Option<char>, &str)` such that:\r\n\r\n    "bar".slice_shift_char() => (Some(\'b\'), "ar")\r\n    "ar".slice_shift_char()  => (Some(\'a\'), "r")\r\n    "r".slice_shift_char()   => (Some(\'r\'), "")\r\n    "".slice_shift_char()    => (None,      "")\r\n\r\nThis is a little odd. Either a `str` can be split into both a head and a tail or it cannot. So the return type should be `Option<(char, &str)>`. With the current behaviour, in the case of the empty string, the `str` returned is meaningless - it is always the empty string.\r\n\r\nThis PR changes `slice_shift_char` so that:\r\n\r\n    "bar".slice_shift_char() => Some((\'b\', "ar"))\r\n    "ar".slice_shift_char()  => Some((\'a\', "r"))\r\n    "r".slice_shift_char()   => Some((\'r\', ""))\r\n    "".slice_shift_char()    => None\r\n\r\n'
18899,'nikomatsakis',"Closures in methods can return pointers with short lifetimes\n```rust\r\nfn function<A, B>(f: |&A| -> B) {}\r\n\r\ntrait Foo<A> {\r\n    fn method<B>(&self, f: |&A| -> B);\r\n}\r\n\r\nstruct Bar<A>;\r\n\r\nimpl<A> Bar<A> {\r\n    fn inherent_method<B>(&self, f: |&A| -> B) {}\r\n}\r\n\r\nfn test<T: Foo<uint>>(x: T) {\r\n    function::<uint, &uint>(|a| a);\r\n    \r\n    Bar::<uint>.inherent_method::<&uint>(|a| a);\r\n    \r\n    x.method::<&uint>(|a| a)\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\n`function` and the two methods are basically identical, except only `function` correctly gets an error (there's no lifetime connection between the returned `B` and the reference passed to the closure so it should be illegal to return that reference directly).\r\n\r\n```\r\n<anon>:8:33: 8:34 error: cannot infer an appropriate lifetime for automatic coercion due to conflicting requirements\r\n<anon>:8     function::<uint, &uint>(|a| a);\r\n                                         ^\r\n<anon>:8:5: 8:28 note: first, the lifetime cannot outlive the expression at 8:4...\r\n<anon>:8     function::<uint, &uint>(|a| a);\r\n             ^~~~~~~~~~~~~~~~~~~~~~~\r\n<anon>:8:5: 8:28 note: ...so that type parameter instantiated with `&uint`, will meet its declared lifetime bounds.\r\n<anon>:8     function::<uint, &uint>(|a| a);\r\n             ^~~~~~~~~~~~~~~~~~~~~~~\r\n<anon>:8:33: 8:34 note: but, the lifetime must be valid for the expression at 8:32...\r\n<anon>:8     function::<uint, &uint>(|a| a);\r\n                                         ^\r\n<anon>:8:33: 8:34 note: ...so that auto-reference is valid at the time of borrow\r\n<anon>:8     function::<uint, &uint>(|a| a);\r\n                                         ^\r\n```\r\n\r\n**Old report**:\r\n\r\n## Iterator.max_by does strange things.\r\n\r\nExample:\r\n\r\n```rust\r\nfn main() {\r\n    assert_eq!((vec![1u8,2,3]).iter().max_by(|n|n).map(|&e|e), Some(1))\r\n}\r\n```\r\nI would really expect this asertion to fail, because the answer should be `Some(3)`."
18894,'nikomatsakis',"Results aren't panics\nA typo about Results being panics crawled in. Fixing it."
18880,'pcwalton','Supplement documentation fixes for fail!() -> panic!()\nI found some occurrences of "failure" and "fails" in the documentation. I changed them to "panics" if it means a task panic. Otherwise I left it as is, or changed it to "errors" to clearly distinguish them.\r\n\r\nAlso, I made a minor fix that is breaking the layout of a module page. "Example" is shown in an irrelevant place from the following page: http://doc.rust-lang.org/std/os/index.html'
18879,'aturon','libsyntax: Forbid type parameters in field expressions.\nThis breaks code like:\r\n\r\n    struct Foo {\r\n        x: int,\r\n    }\r\n\r\n    let f: Foo = ...;\r\n    ... f.x::<int> ...\r\n\r\nChange this code to not contain an unused type parameter. For example:\r\n\r\n    struct Foo {\r\n        x: int,\r\n    }\r\n\r\n    let f: Foo = ...;\r\n    ... f.x ...\r\n\r\nCloses #18680.\r\n\r\n[breaking-change]\r\n\r\nr? @aturon'
18870,'brson',"Use IoResult in the std::os module\nMake old-fashioned functions in the `std::os` module utilize `IoResult`.\r\n\r\nI'm still investigating the possibility to include more functions in this pull request. Currently, it covers `getcwd()`, `make_absolute()`, and `change_dir()`. The issues covered by this PR are #16946 and #16315.\r\n\r\nA few concerns:\r\n\r\n- Should we provide `OsError` in distinction from `IoError`? I'm saying this because in Python, those two are distinguished. One advantage that we keep using `IoError` is that we can make the error cascade down other functions whose return type also includes `IoError`. An example of such functions is `std::io::TempDir::new_in()`, which uses `os::make_absolute()` as well as returns `IoResult<TempDir>`.\r\n- `os::getcwd()` uses an internal buffer whose size is 2048 bytes, which is passed to `getcwd(3)`. There is no upper limitation of file paths in the POSIX standard, but typically it is set to 4096 bytes such as in Linux. Should we increase the buffer size? One thing that makes me nervous is that the size of 2048 bytes already seems a bit excessive, thinking that in normal cases, there would be no filenames that even exceeds 512 bytes.\r\n\r\nFixes #16946.\r\nFixes #16315.\r\n\r\nAny ideas are welcomed. Thanks!"
18868,'pcwalton',"Refactor QPath to take an ast::TraitRef\nThis fixes #17388. \r\n\r\nNote that we don't check type parameters in trait-references and so on, so we accept some nonsense (I opened https://github.com/rust-lang/rust/issues/18865). (It may be easier to just add support for `T::Foo` and deprecate the qpath code until we can implement it more robustly using the trait lookup infrastructure, not sure.)\r\n"
18862,'alexcrichton','Add regression test for #18566\n'
18837,'pnkfelix','Switch to debruijn indices, genericize sub/lub/glb\nMore refactoring in support of HRTB. There should be no change in functionality from these changes.\r\n\r\nr? @pnkfelix '
18833,'brson',"Rogue 'panic' -> 'fail' in guide.\nShould refer to handling panicking tasks like any other computation\r\nthat may _fail_, not any other computation that may _panic_."
18832,'brson','Rename tm_gmtoff to tm_utcoff\nRename the `tm_gmtoff` field of `time::Tm` to `tm_utcoff`.\r\n\r\nAlthough GMT and UTC are commonly used interchangeably, UTC is more appropriate to denote the time standard.\r\n\r\nPython, for example, uses `datetime.utcoffset()` to represent the offset from UTC.\r\n\r\nI think we should fix this while we are allowed to break backward compatibility.'
18830,'aturon','Fix broken documentation link\n'
18827,'aturon','Begin stripping down core::num\nThis implements a considerable portion of rust-lang/rfcs#369 (tracked in #18640). Some interpretations had to be made in order to get this to work. The breaking changes are listed below:\r\n\r\n[breaking-change]\r\n\r\n- `core::num::{Num, Unsigned, Primitive}` have been deprecated and their re-exports removed from the `{std, core}::prelude`.\r\n- `core::num::{Zero, One, Bounded}` have been deprecated. Use the static methods on `core::num::{Float, Int}` instead. There is no equivalent to `Zero::is_zero`. Use `(==)` with `{Float, Int}::zero` instead.\r\n- `Signed::abs_sub` has been moved to `std::num::FloatMath`, and is no longer implemented for signed integers.\r\n- `core::num::Signed` has been removed, and its methods have been moved to `core::num::Float` and a new trait, `core::num::SignedInt`. The methods now take the `self` parameter by value.\r\n- `core::num::{Saturating, CheckedAdd, CheckedSub, CheckedMul, CheckedDiv}` have been removed, and their methods moved to `core::num::Int`. Their parameters are now taken by value. This means that\r\n- `std::time::Duration` no longer implements `core::num::{Zero, CheckedAdd, CheckedSub}` instead defining the required methods non-polymorphically.\r\n- `core::num::{zero, one, abs, signum}` have been deprecated. Use their respective methods instead.\r\n- The `core::num::{next_power_of_two, is_power_of_two, checked_next_power_of_two}` functions have been deprecated in favor of methods defined a new trait, `core::num::UnsignedInt`\r\n- `core::iter::{AdditiveIterator, MultiplicativeIterator}` are now only implemented for the built-in numeric types.\r\n- `core::iter::{range, range_inclusive, range_step, range_step_inclusive}` now require `core::num::Int` to be implemented for the type they a re parametrized over.'
18816,'nikomatsakis','Fixes compilation warnings regarding #![allow(missing_doc)]\nSigned-off-by: zachwick <zach@zachwick.com>'
18795,'aturon','Make Int inherit from Ord.\nPreviously Int inherited from PartialOrd (via Primitive)\r\nbut not Ord.  But integers have a total order, so\r\ninheriting from Ord is appropriate. Fixes #18776.'
18789,'nikomatsakis',"vim: move 'move' to rustStorage\nIt used to be in `rustKeyword`, until commit 5c75f210ba6e450fb1603b50ca0a4805f13173d7 removed it, and then #18782 restored it again.  However, this is now a closure modifier, and I think moving it to `rustStorage` is more appropriate to highlight it similarly to `mut`, `ref`, and the `&` sigil."
18788,'huonw','Make std::io::Buffer object-safe.\nThis moves chars() and lines() out of Buffer and into separate traits (CharsBuffer and LinesBuffer respectively) - this matches the pattern used for bytes() on Reader (with BytesReader).\r\n\r\n(I came across this when I wanted a trait object of a Buffer, so that I could use read_line(); rustc errors about std::io::Buffer not being object-safe.)\r\n\r\n[breaking-change]\r\nAny uses of Buffer::lines() will need to use the new trait std::io::LinesBuffer.\r\nThe same is true for Buffer::chars() with std::io::CharsBuffer.'
18782,'alexcrichton','Added `as` and `move` keywords to Vim syntax file\n`as` (already for a long time) and `move` (which was only added recently, AFAIK) are not marked as keywords in Vim syntax file, so they are not highlighted as keywords in Rust sources. This PR fixes this.'
18771,'brson',"Nightlies have unknown hash\n```\r\n$ TZ='UTC' date \r\nSaturday 8 November  12:42:36 UTC 2014\r\n$ curl https://static.rust-lang.org/rustup.sh > /tmp/rustup.sh && sudo sh /tmp/rustup.sh\r\n...\r\n$ rustc --version=verbose\r\nrustc 0.13.0-nightly\r\nbinary: rustc\r\ncommit-hash: unknown\r\ncommit-date: unknown\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 0.13.0-nightly\r\n```\r\n\r\ncc @brson, @alexcrichton "
18755,'alexcrichton','syntax: Use UFCS in the expansion of `#[deriving(PartialOrd)]`\nCloses #18738\r\ncc #15689\r\n\r\nr? @alexcrichton \r\ncc @cmr '
18750,'nick29581',"Require that objects can only be made from Sized types. Fixes #18333.\nIn the general case, at least, it is not possible to make an object out of an unsized type. This is because the object type would have to store the fat pointer information for the `self` value *and* the vtable -- meaning it'd have to be a fat pointer with three words -- but for the compiler to know that the object requires three words, it would have to know the self-type of the object (is `self` a thin or fat pointer?), which of course it doesn't.\r\n\r\nFixes #18333.\r\n\r\nr? @nick29581 "
18746,'nick29581','Pass the unadjusted type into the unsize_info function\nPass the unadjusted type into the unsize_info function, which seems to be what it expects. Fixes #17322.\r\n\r\nr? @nick29581 \r\n\r\nFull disclosure: still running make check locally ;)'
18743,'pcwalton',"Refactoring in support of higher-ranked traitbounds\nVarious miscellaneous changes pushing towards HRTB support:\r\n\r\n1. Update parser and adjust ast to support `for<'a,'b>` syntax, both in closures and trait bounds. Warn on the old syntax (not error, for stage0).\r\n2. Refactor TyTrait representation to include a TraitRef.\r\n3. Purge `once_fns` feature gate and `once` keyword.\r\n\r\nr? @pcwalton \r\n\r\nThis is a [breaking-change]:\r\n\r\n- The `once_fns` feature is now officially deprecated. Rewrite using normal closures or unboxed closures.\r\n- The new `for`-based syntax now issues warnings (but not yet errors):\r\n  - `fn<'a>(T) -> U` becomes `for<'a> fn(T) -> U`\r\n  - `<'a> |T| -> U` becomes `for<'a> |T| -> U`"
18728,'nikomatsakis','fix maximum object size semantics\nThis fixes the gap in the language definition causing #18726 by defining\r\na clear bound on the maximum size for libraries to enforce.\r\n\r\nCloses #18069'
18721,'alexcrichton','Make EnumSet not silently corrupt data.\nAssert at run time instead. Fixes #13756.\r\n\r\nI’d rather have this be detected at compile-time, but I don’t know how to do that.'
18714,'aturon','libs: add Deref, DerefMut impls for references\nlibs: add Deref, DerefMut impls for references, fixing a bug in compiler in the process that was blocking this.\r\n\r\nr? @aturon '
18713,'alexcrichton','Fixing #18659\n* `from_str_radix_float` gives incorrect results for negative float strings. Changes the accumulator used to start at -0.0 instead of -1.0.\r\n* Adds missing tests'
18708,'aturon',"Updated guide.md, section 14.3 - helpfully implied code sample is broken\nAs a new user, I spent a while confused when flycheck told me the code sample I'd typed in was invalid. I ended up figuring out some of what comes after the code sample more painfully by myself because there was no indication that it was broken in the text beforehand. This one line change makes it clear that the code following it is an experiment that may not work rather than something to assume just works."
18707,'aturon','DSTify more traits\nWe now can do `#[deriving(Default, Encodable, Decodable)]` on structs that contain `Box[T]`.\r\n\r\nr? @aturon / @alexcrichton '
18698,'aturon','Implement Index/IndexMut for [T]\nCloses #16529\r\n\r\nr? @aturon '
18696,'steveklabnik','Update guide.md\nCorrected singular/plural reference to enums'
18694,'pcwalton',"Refactor method dispatch infrastructure\nThis is a pretty major refactoring of the method dispatch infrastructure. It is intended to avoid gross inefficiencies and enable caching and other optimizations (e.g. #17995), though it itself doesn't seem to execute particularly faster yet. It also solves some cases where we were failing to resolve methods that we theoretically should have succeeded with.\r\n\r\nFixes #18674.\r\n\r\ncc #18208 \r\n\r\n"
18691,'brson','Make Filetype Clonable\nFixes #18619\r\n\r\nAdd Clone Trait to FileType struct, so that FileStat itself becomes clone-able.'
18688,'nikomatsakis',"Fix two unboxed closure ICEs\nThis resolves some issues that remained after adding support for monomorphizing unboxed closures in trans.\r\n\r\nThere were a few places where a set of substitutions for an unboxed closure type were dropped on the floor and later recalculated from scratch based on the def ID, but this failed spectacularly when the closure originated from a different param environment.  The substitutions are now plumbed through end-to-end.  Closes #18661\r\n\r\nThere was also a conflict in the meaning of the self param space within the body of the unboxed closure.  Trans attempted to insert the unboxed closure type as the self type, but this could conflict with the self type from the param environment when an unboxed closure was used within a default method on a trait.  Since the body of an unboxed closure cannot refer to its own self type or value, there's no need for it to actually use the self space.  The downstream consumers of the substitutions in trans do not seem to need it either since they look up the type of the closure some other way, so I just stopped setting it.  Closes #18685.\r\n\r\nr? @pcwalton @nikomatsakis "
18684,'pcwalton','Make x86_64-unknown-linux-gnu.json true to its name\n/cc @cmr '
18682,'brson','Make FileType Clonable\nFixes #18619 \r\n\r\nAdd Clone Trait to FileType struct, so that FileStat itself becomes clone-able.'
18674,'nikomatsakis',"resolve: strange corner case in overlapping method names\nThe following code fails to compile:\r\n\r\n```rust\r\nuse std::kinds::Sized;\r\n\r\n// Note: this must be generic for the problem to show up\r\ntrait Foo<A> for Sized? {\r\n    fn foo(&self);\r\n}\r\n\r\nimpl Foo<u8> for [u8] {\r\n    fn foo(&self) {}\r\n}\r\n\r\nimpl<'a, A, T> Foo<A> for &'a T where T: Foo<A> {\r\n    fn foo(&self) {\r\n        Foo::foo(*self)\r\n    }\r\n}\r\n\r\ntrait Bar {\r\n    fn foo(&self);\r\n}\r\n\r\nstruct MyType;\r\n\r\nimpl Bar for MyType {\r\n    fn foo(&self) {}\r\n}\r\n\r\nfn main() {\r\n    let mut m = MyType;\r\n    (&mut m).foo()\r\n}\r\n```\r\n\r\nwith the error\r\n\r\n```\r\n<anon>:31:9: 31:23 error: the trait `Foo<_>` is not implemented for the type `MyType`\r\n<anon>:31         (&mut m).foo()\r\n                  ^~~~~~~~~~~~~~\r\n```\r\n\r\nAs noted above, this seems to depend on one of the traits using generics.\r\n\r\nReal code this is blocking: https://github.com/rust-lang/rust/pull/18638\r\n\r\ncc @nikomatsakis \r\ncc @japaric"
18673,'aturon','Properly escape paths to executables. Fixes #18632.\n1. Introduce `putpathvar` function that prints variable shell-quoted by using `%q` format specifier. This function is used within `probe` to save the result into `config.tmp`.\r\n2. Removes search-and-replace pattern that transforms `\\` into `/` as it messes up shell-quoted strings.\r\n'
18665,'brson','Fix example in HashMap::new() docs\nProbably a copy-paste error.'
18663,'aturon','Fix warnings about renamed lints\n'
18656,'brson','Rename deprecated non_uppercase_statics to non_upper_case_globals\nThis removes some warnings'
18649,'michaelwoerister','debuginfo: Implement time-out for LLDB test runner\nFrom time to time the LLDB test suite hangs on the build bots, which leads to the whole pipeline being blocked for an hour. One way to make this problem a bit less severe is to add a time-out to the LLDB test runner which just kills tests that take longer than a few seconds. This should at least reduce the time until the tests can be restarted.\r\n\r\ncc @alexcrichton '
18648,'pcwalton',"Simplify wording around editor usage\n'$ editor <filename>' makes the docs more wordy, and is more likely to confuse readers who skim."
18643,'nick29581','TEST - DO NOT MERGE\nr? @nick29581'
18639,'nikomatsakis','Implement higher-ranked trait bounds\nTracking https://github.com/rust-lang/rfcs/pull/387.'
18638,'aturon','libcore: DST-ify AsSlice, Equiv, and ops traits\nThis PR changes `AsSlice` to work on unsized types, and changes the\r\n`impl` for `&[T]` to `[T]`. Aside from making the trait more general,\r\nthis also helps some ongoing work with method resolution changes.\r\n\r\nThis is a breaking change: code that uses generics bounded by `AsSlice`\r\nwill have to change. In particular, such code previously often took\r\narguments of type `V` where `V: AsSlice<T>` by value. These should now\r\nbe taken by reference:\r\n\r\n```rust\r\nfn foo<Sized? V: AsSlice<T>>(v: &V) { .. }\r\n```\r\n\r\nA few std lib functions have been changed accordingly.\r\n\r\nThe PR also relaxes constraints on generics and traits within the\r\n`core::ops` module and for the `Equiv` trait.\r\n\r\n[breaking-change]\r\n\r\nr? @nikomatsakis \r\ncc @japaric '
18633,'cmr',"test: correct spelling error & inverted match.\nr? @cmr\r\n\r\n(I don't know if this is correct, but the old code was certainly wrong.)"
18630,'pcwalton','Purge `|:|` notation from types and trait references, in favor of `Foo()`\nFollow up to the paren branch.\r\n\r\nr? @pcwalton \r\n\r\nFixes #17703 (among other things).'
18622,'pcwalton','Paren sugar\nImplement the `Foo()` paren sugar more uniformly as envisioned by the RFC.\r\n\r\nr? @pcwalton \r\n\r\nFixes #17703 (among other things).'
18614,'jakub-','Remove ty_nil and replace with zero-length tuple\nDistinguishing zero-arity tuples as `nil` causes annoying discontinuities in the compiler. We should remove `ty_nil` and just use `ty_tup` with a zero-length list of types. I [tried to do this][branch], though, and encountered errors in the exhaustiveness checker that I did not understand. \r\n\r\n[branch]: https://github.com/nikomatsakis/rust/tree/remove-unit'
18608,'aturon','rustc: Support stability attributes on crates\nThis commit adds support for linting `extern crate` statements for stability\r\nattributes attached to the crate itself. This is likely to be the mechanism used\r\nto deny access to experimental crates that are part of the standard\r\ndistribution.\r\n\r\ncc #18585 \r\n\r\nr? @aturon'
18605,'aturon','Implement low-hanging fruit of collection conventions\n Implement low-hanging fruit of collection conventions\r\n\r\n * Renames/deprecates the simplest and most obvious methods\r\n * Adds FIXME(conventions)s for outstanding work\r\n * Marks "handled" methods as unstable\r\n\r\n NOTE: the semantics of reserve and reserve_exact have changed!\r\n Other methods have had their semantics changed as well, but in a\r\n way that should obviously not typecheck if used incorrectly.\r\n\r\n Lots of work and breakage to come, but this handles most of the core\r\n APIs and most eggregious breakage. Future changes should *mostly* focus on\r\n niche collections, APIs, or simply back-compat additions.\r\n\r\n [breaking-change]\r\n\r\nr? @aturon'
18578,'alexcrichton','Use UFCS in the expansion of `#[deriving(Clone)]`\nChanges the return expression of expanded `clone` method from e.g. `Slice((*__self_0).clone())` to `Slice(::std::clone::Clone::clone(&(*__self_0)))`\r\n\r\nFixes the [second half](https://github.com/rust-lang/rust/issues/15689#issuecomment-49086188) of #15689\r\n\r\n(The [first half](https://github.com/rust-lang/rust/issues/15689#issue-37918558) will be fixed by #18467)\r\n\r\n**Note** #18523 must be merged first or this will ICE during `make`\r\n\r\nr? @alexcrichton \r\n(I can squash the commits after the review)'
18557,'alexcrichton','Remove rtio\nThis PR includes a sequence of commits that gradually dismantles the `librustrt` `rtio` system -- the main trait previously used to abstract over green and native io. It also largely dismantles `libnative`, moving much of its code into `libstd` and refactoring as it does so.\r\n\r\nTL;DR:\r\n\r\n* Before this PR: `rustc hello.rs && wc -c hello` produces 715,996\r\n* After this PR:  `rustc hello.rs && wc -c hello` produces 368,100\r\n\r\nThat is, this PR reduces the footprint of hello world by ~50%.\r\n\r\nThis is a major step toward #17325 (i.e. toward implementing the [runtime removal RFC](https://github.com/rust-lang/rfcs/pull/230).) What remains is to pull out the scheduling, synchronization and task infrastructure, and to remove `libgreen`. These will be done soon in a follow-up PR.\r\n\r\nPart of the work here is eliminating the `rtio` abstraction, which in many cases means bringing the implementation of io closer to the actual API presented in `std::io`.\r\n\r\nAnother aspect of this PR is the creation of two new, *private* modules within `std` that implement io:\r\n\r\n* The `sys` module, which represents a platform-specific implementation of a number of low-level abstractions that are used directly within `std::io` and `std::os`. These "abstractions" are left largely the same as they were in `libnative` (except for the removal of `Arc` in file descriptors), but they are expected to evolve greatly over time. Organizationally, there are `sys/unix/` and `sys/windows/` directories which both implement the entire `sys` module hierarchy; this means that nearly all of the platform-specific code is isolated and you can get a handle on each platform in isolation.\r\n\r\n* The `sys_common` module, which is rooted at `sys/common`, and provides a few pieces of private, low-level, but cross-platform functionality.\r\n\r\nIn the long term, the `sys` modules will provide hooks for exposing high-level platform-specific APIs as part of `libstd`. The first such API will be access to file descriptors from `std::io` abstractions, but a bit of design work remains before that step can be taken. \r\n\r\nThe `sys_common` module includes some traits (like `AsFileDesc`) which allow communication of private details between modules in disparate locations in the hierarchy; this helps overcome the relatively simple hierarchical privacy system in Rust.\r\n\r\nTo emphasize: the organization in `sys` is *very preliminary* and the main goal was to migrate away from `rtio` as quickly and simply as possible. The design will certainly evolve over time, and all of the details are currently private.\r\n\r\nAlong the way, this PR also entirely removes signal handling, since it was only supported on `librustuv` which was removed a while ago. \r\n\r\nBecause of the removal of APIs from `libnative` and `librustrt`, and the removal of signal handling, this is a:\r\n\r\n[breaking-change]\r\n\r\nSome of these APIs will return in public from from `std` over time.\r\n\r\nr? @alexcrichton '
18546,'pcwalton','Fix some cross-crate unboxed closure bugs\nThis fixes some metadata/AST encoding problems that lead to ICEs.  The way this is currently handled will need revisiting if abstract return types are added, as unboxed closure types from extern crates could show up without being inlined into the local crate.\r\n\r\nCloses #16790 (I think this was fixed earlier by accident and just needed a test case)\r\nCloses #18378\r\nCloses #18543\r\n\r\nr? @pcwalton '
18544,'aturon','json: Improve ergonomics by changing &String to &str in methods and adding Indexing\nWorking with external `Json` is pretty unergonomic right now, and has a lot of unnecessary allocations, because everything needs to be converted to `String`.\r\n\r\n`find`, `find_path`, and `search` now use `&str` rather than `&String`.\r\n\r\nIndexing can be done with `&str` and `uint`, depending on whether the `Json` is an `Object` or a `List`.\r\n\r\n[breaking-change]'
18537,'alexcrichton','Replace secret formatting functions with UFCS versions\nThis PR replaces the uses of e.g. the `secret_show` function with `Show::fmt`.\r\n\r\n**Note** #18523 has to be merged first or this will ICE during `make`\r\n\r\nr? @alexcrichton '
18536,'aturon','Clean up string->{float, int} implementation\nI have been meaning to clean up `std::num::strconv` for a long time. This module is too generic and hard to understand, both for maintainers and users.\r\n\r\nI have specialized the underlying string->{float, int} implementations into two separate underlying functions. This will allow it to be more easily optimized in the future, and untangles the logic to make it more easier to understand.\r\n\r\nThe function signatures were also simplified to take only a source string and a radix. `{f32, f64}::from_str_hex` was deprecated in favor of `FromStrRadix::from_str_radix`.\r\n\r\nr? @aturon @alexcrichton '
18531,'huonw','Extend documentation of getopts for arguments\ncc @steveklabnik'
18528,'brson','Doc 18498\nThis addresses https://github.com/rust-lang/rust/issues/18498 by adding a prepopulated search box to do site search on `doc.rust-lang.org` using duckduckgo AND generating a search url against the rust documentation using the internal search facilities.\r\n\r\n* https://duckduckgo.com/?q=type+Option+unwrap_or_else+site%3Adoc.rust-lang.org\r\n* http://doc.rust-lang.org/core/?search=unwrap_or_else'
18527,'nick29581',"Object safety check fixes\n- Always consider static methods object-safe since they can never be called through a trait object anyway.  The RFC doesn't mention static methods at all, so I'm assuming this is reasonable behavior.\r\n- Fix issue #18490 as a side-effect since we avoid trying to take an out-of-bounds slice later in the code\r\n\r\nCloses #18490\r\n\r\nr? @nick29581 "
18523,'nick29581',"Fix UFCS ICE (#18501)\nTranslate def IDs in provenance field of method defs during AST decoding.  Closes #18501 \r\n\r\nr? @nick29581 (or anyone who has time, it's simple enough)"
18507,'nikomatsakis','Implement constant-time nth method for Items #17348\nThis implementation uses offset directly instead of repeated calls to next in loop.'
18506,'pcwalton','Support Sized bounds for associated types\nThis also refactors associated types in various ways, most notably by moving the associated types defined in a trait into their own param space which replaces the associated-types hashmap (which is just removed). We should probably move the synthetic type parameters into yet another namespace, but that can wait.\r\n\r\nFixes #17921 '
18505,'nick29581','Fix trans of index overload expressions with DST result types\nThis brings the code in line with the overloaded deref handling.  Closes #18487.\r\n\r\nr? @nick29581 '
18504,'aturon','libsyntax: Forbid escapes in the inclusive range `\\x80`-`\\xff` in Unicode characters and strings.\nUse `\\u0080`-`\\u00ff` instead. ASCII/byte literals are unaffected.\r\n\r\nThis PR introduces a new function, `escape_default`, into the ASCII\r\nmodule. This was necessary for the pretty printer to continue to\r\nfunction.\r\n\r\nRFC #326.\r\n\r\nCloses #18062.\r\n\r\n[breaking-change]\r\n\r\nr? @aturon'
18500,'alexcrichton','doc: CSS nitpicks\nr? @alexcrichton'
18495,'pcwalton','small fix to output of code sample in intro.md\nThe output of the code sample that explains ownership is not correct. \r\n\r\nThe \r\n\r\n```rust\r\n(*array)[i] += 1;\r\n```\r\n\r\nline in the code actually causes the output to be 2, 3 and 4 (in non-deterministic order) instead of 1, 2 and 3. '
18494,'aturon','Prefer where clauses to impls in trait resolution (not vice versa).\nPrefer where clauses to impls in trait resolution (not vice versa).\r\n\r\nFixes #18453.\r\n\r\nr? @aturon \r\n'
18483,'nikomatsakis',"Replace unsafety in middle::ty with lifetimes.\nAfter more than a month of sitting on this patch, rebasing and tracking down some nasty bugs (there's might be still one out there, but it only manifested in `middle::trans::reflect` which is now gone), I'd like to merge it as it is.\r\n\r\nThis changeset makes middle::ty safe, linking the lifetime of a type to the type context it was created in.\r\nIt's a prerequisite for introducing function-local type contexts to localize types with inference variables, in order to (potentially) free hundreds of MBs from rustc's memory usage peak."
18478,'sfackler','Implement namespaced enums\nTracking issue for [RFC 390](https://github.com/rust-lang/rfcs/pull/390).'
18467,'aturon','DSTify PartialEq, PartialOrd, Eq, Ord\n`eq`, `ne`, `cmp`, etc methods now require one less level of indirection when dealing with `&str`/`&[T]`\r\n\r\n``` rust\r\n"foo".ne(&"bar") -> "foo".ne("bar")\r\nslice.cmp(&another_slice) -> slice.cmp(another_slice)\r\n// slice and another_slice have type `&[T]`\r\n```\r\n\r\n[breaking-change]'
18464,'jakub-','Dead code warning when a constant is used only in a range match\nThis may be related to #18290 but here is some test code for this specific case:\r\n\r\n```rust\r\nconst LOW_RANGE: char = \'0\';\r\nconst HIGH_RANGE: char = \'9\'; \r\n\r\nfn main() {\r\n    let x: char = \'5\';\r\n    \r\n    match x {\r\n        LOW_RANGE...HIGH_RANGE => println!("First Match"),\r\n        _                      => println!("Second Match")\r\n    };\r\n}\r\n```\r\nWhich prints:\r\n```\r\n<anon>:1:1: 1:29 warning: constant item is never used: `LOW_RANGE`, #[warn(dead_code)] on by default\r\n<anon>:1 const LOW_RANGE: char = \'0\';\r\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n<anon>:2:1: 2:30 warning: constant item is never used: `HIGH_RANGE`, #[warn(dead_code)] on by default\r\n<anon>:2 const HIGH_RANGE: char = \'9\'; \r\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nFirst Match\r\n```\r\nIdeally this would not issue a warning.'
18463,'aturon','DSTify BytesContainer\n- The `BytesContainer::container_into_owned_bytes` method has been removed\r\n\r\n- Methods that used to take `BytesContainer` implementors by value, now take them by reference. In particular, this breaks some uses of Path:\r\n\r\n``` rust\r\nPath::new("foo")  // Still works\r\npath.join(another_path) -> path.join(&another_path)\r\n```\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nRe: `container_into_owned_bytes`, I\'ve removed it because\r\n\r\n- Nothing in the whole repository uses it\r\n- Takes `self` by value, which is incompatible with unsized types (`str`)\r\n\r\nThe alternative to removing this method is to split `BytesContainer` into `BytesContainer for Sized?` and `SizedBytesContainer: BytesContainer + Sized`, where the second trait only contains the `container_into_owned_bytes` method. I tried this alternative [in another branch](https://github.com/japaric/rust/commits/bytes) and it works, but it seemed better not to create a new trait for an unused method.\r\n\r\nRe: Breakage of `Path` methods\r\n\r\nWe could use the idea that @alexcrichton proposed in #18457 (add blanket `impl BytesContainer for &T where T: BytesContainer` + keep taking `T: BytesContainer` by value in `Path` methods) to avoid breaking any code.\r\n\r\nr? @aturon \r\ncc #16918'
18462,'aturon','ToSocketAddr trait and unification of network structures constructor methods\nThis is a follow-up to [RFC PR #173](https://github.com/rust-lang/rfcs/pull/173). I was told there that changes like this don\'t need to go through the RFC process, so I\'m submitting this directly.\r\n\r\nThis PR introduces `ToSocketAddr` trait as defined in said RFC. This trait defines a conversion from different types like `&str`, `(&str, u16)` or even `SocketAddr` to `SocketAddr`. Then this trait is used in all constructor methods for `TcpStream`, `TcpListener` and `UdpSocket`.\r\n\r\nThis unifies these constructor methods - previously they were using different types of input parameters (TCP ones used `(&str, u16)` pair while UDP ones used `SocketAddr`), which is not consistent by itself and sometimes inconvenient - for example, when the address initially is available as `SocketAddr`, you still need to convert it to string to pass it to e.g. `TcpStream`. This is very prominently demonstrated by the unit tests for TCP functionality. This PR makes working with network objects much like with `Path`, which also uses similar trait to be able to be constructed from `&[u8]`, `Vec<u8>` and other `Path`s.\r\n\r\nThis is a breaking change. If constant literals were used before, like this:\r\n```rust\r\nTcpStream::connect("localhost", 12345)\r\n```\r\nthen the nicest fix is to change it to this:\r\n```rust\r\nTcpStream::connect("localhost:12345")\r\n```\r\n\r\nIf variables were used before, like this:\r\n```rust\r\nTcpStream::connect(some_address, some_port)\r\n```\r\nthen the arguments should be wrapped in another set of parentheses:\r\n```rust\r\nTcpStream::connect((some_address, some_port))\r\n```\r\n\r\n`UdpSocket` usages won\'t break because its constructor method accepted `SocketAddr` which implements `ToSocketAddr`, so `bind()` calls:\r\n```rust\r\nUdpSocket::bind(some_socket_addr)\r\n```\r\nwill continue working as before.\r\n\r\nI haven\'t changed `UdpStream` constructor because it is deprecated anyway.\r\n'
18458,'nikomatsakis',"trans: use types from argument patterns instead of the function signature.\nThis fixes ICEs caused by late-bound lifetimes ending up in argument\r\ndatum types and being used in cleanup - user Drop impl's would then\r\nfail to monomorphize if the type was used to look up the impl of a\r\nmethod call - which happens in trans now, I presume for multidispatch."
18457,'aturon','DSTify ToCStr\nMethods that used to take `ToCStr` implementors by value, now take them by reference. In particular, this breaks some uses of `Command`:\r\n\r\n``` rust\r\nCommand::new("foo");  // Still works\r\nCommand::new(path) -> Command::new(&path)\r\ncmd.arg(string) -> cmd.arg(&string) or cmd.arg(string.as_slice())\r\n```\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nIt may be sensible to remove `impl ToCstr for String` since:\r\n- We\'re getting `impl Deref<str> for String`, so `string.to_cstr()` would still work\r\n- `Command` methods would still be able to use `cmd.arg(string[..])` instead of `cmd.arg(&string)`.\r\n\r\nBut, I\'m leaving that up to the library stabilization process.\r\n\r\nr? @aturon \r\ncc #16918 '
18453,'nikomatsakis','Unboxed closure + traits bug\nI am not exactly sure what is going on in this bug, so sorry for the vague title. I do have a repro though. The highlighted clone is what causes the issue here.\r\n\r\n```rust\r\n#![feature(unboxed_closures)]\r\n\r\nuse std::sync::Arc;\r\n\r\npub trait Foo<M: Send> : Send {\r\n    fn foo(&mut self, msg: M);\r\n}\r\n\r\nimpl<M: Send, F: Send + FnMut(M)> Foo<M> for F {\r\n    fn foo(&mut self, msg: M) {\r\n        self.call_mut((msg,));\r\n    }\r\n}\r\n\r\npub struct Both<M, F> {\r\n    inner: Arc<(M, F)>,\r\n}\r\n\r\nimpl<M: Send, F: Foo<M>> Clone for Both<M, F> {\r\n    fn clone(&self) -> Both<M, F> {\r\n        Both { inner: self.inner.clone() }\r\n    }\r\n}\r\n\r\nfn repro1<M: Send, F: Foo<M>>(_both: Both<M, F>) {\r\n}\r\n\r\nfn repro2<M: Send + Sync, F: Sync + Foo<M>>(msg: M, foo: F) {\r\n    let both = Both { inner: Arc::new((msg, foo)) };\r\n    repro1(both.clone()); // <--- This clone causes problem\r\n}\r\n\r\npub fn main() {\r\n    println!("hello");\r\n}\r\n```\r\n\r\nGives me the following output:\r\n\r\n```\r\nrustc fnmut.rs\r\nfnmut.rs:30:5: 30:11 error: the trait `core::ops::FnMut<(M),()>` is not implemented for the type `F`\r\nfnmut.rs:30     repro1(both.clone()); // <--- This clone causes problem\r\n                ^~~~~~\r\nfnmut.rs:30:5: 30:11 note: the trait `core::ops::FnMut` must be implemented because it is required by `repro1`\r\nfnmut.rs:30     repro1(both.clone()); // <--- This clone causes problem\r\n                ^~~~~~\r\nerror: aborting due to previous error'
18447,'nikomatsakis','Trait impls\nCloses #17750\r\n\r\nr? @nikomatsakis'
18441,'steveklabnik',"Collect literal examples together in the reference\nCloses #18415\r\n\r\nThis links [`std::str`](http://doc.rust-lang.org/std/str/index.html) documentation to [literals](http://doc.rust-lang.org/reference.html#literals) in the reference guide and collects examples of literals into one group at the beginning of the section. ~~The new tables are not exhaustive (some escapes were skipped) and so I try to link back to the respective sections where more detail is located.~~ The tables are are mostly exhaustive. I misunderstood some of the whitespace codes.\r\n\r\nI don't think the tables actually look that nice if that's important and I'm not sure how it could be improved. I think it does do a good job of collecting available options together. I think listing the escapes together is particularly helpful because they vary with type and are embedded in paragraphs.\r\n\r\n[EDIT]\r\nThe [ascii table](http://man-ascii.com/) is here and may be useful."
18440,'aturon','DSTify Hash\n- The signature of the `*_equiv` methods of `HashMap` and similar structures have changed, and now require one less level of indirection. Change your code from:\r\n\r\n``` rust\r\nhashmap.find_equiv(&"Hello");\r\nhashmap.find_equiv(&&[0u8, 1, 2]);\r\n```\r\n\r\nto:\r\n\r\n``` rust\r\nhashmap.find_equiv("Hello");\r\nhashmap.find_equiv(&[0u8, 1, 2]);\r\n```\r\n\r\n- The generic parameter `T` of the `Hasher::hash<T>` method have become `Sized?`. Downstream code must add `Sized?` to that method in their implementations. For example:\r\n\r\n``` rust\r\nimpl Hasher<FnvState> for FnvHasher {\r\n    fn hash<T: Hash<FnvState>>(&self, t: &T) -> u64 { /* .. */ }\r\n}\r\n```\r\n\r\nmust be changed to:\r\n\r\n``` rust\r\nimpl Hasher<FnvState> for FnvHasher {\r\n    fn hash<Sized? T: Hash<FnvState>>(&self, t: &T) -> u64 { /* .. */ }\r\n    //      ^^^^^^\r\n}\r\n```\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nAfter review I\'ll squash the commits and update the commit message with the above paragraph.\r\n\r\nr? @aturon \r\ncc #16918'
18431,'aturon','DSTify Show\nr? @aturon \r\ncc #16918'
18423,'nikomatsakis',"Box accepts multiple lifetime parameters\nThis should not compile:\r\n\r\n```\r\nstruct Foo<'a> {\r\n    x: Box<'a, int>\r\n}\r\n\r\npub fn main() {\r\n}\r\n```"
18409,'pnkfelix','Diagnostic: resolve bare fn in expected closure\nCloses #15273 (I did not find how to get the identifier in the message :/ ... if someone knows how to do that I would be happy to rebase)\r\n\r\nAlso creates the span_help! macro associated with #18126'
18381,'pcwalton','Small grammar fix in rustdoc.md\nHappened to be reading through the doc.'
18371,'pnkfelix',"Teach variance checker about lifetime bounds from trait object types\nTeach variance checker about the lifetime bounds that appear in trait object types.\r\n\r\n[breaking-change] This patch fixes a hole in the type system which resulted in lifetime parameters that were only used in trait objects not being checked. It's hard to characterize precisely the changes that might be needed to fix target code.\r\n\r\ncc #18262 (this fixes the test case by @jakub- but I am not sure if this is the same issue that @alexcrichton was reporting)\r\n\r\nr? @pnkfelix \r\n\r\nFixes #18205 "
18367,'brson','libcore: Inline atomic constructors.\nServo really wants this.\r\n\r\nr? @brson'
18359,'huonw','fix of #18181 issue\n'
18355,'steveklabnik','Guide: Iterators, Macros and Unsafe wording fixes\nSome more proposed wording fixes for the Guide, this time for the Iterators, Macros and Unsafe chapters. I’m not a native speaker, but this does read better to me, so please do review this critically.'
18353,'nick29581','ICE in translation phase while using DST: "Invalid operand types for ICmp instruction"\nI was playing with DST by reimplementing the `str` primitive as a `struct Str([u8])`, but hit an ICE while testing.\r\n\r\nThe code is in this [gist](https://gist.github.com/japaric/6c5544455d3e8a44fe19)\r\n\r\n### Output\r\n\r\n``` rust\r\n$ RUST_BACKTRACE=1 rustc dstr.rs\r\nrustc: /var/tmp/paludis/build/dev-lang-rust-scm/work/rust-scm/src/llvm/include/llvm/IR/Instructions.h:1001: void llvm::ICmpInst::AssertOK(): Assertion `(getOperand(0)->getType()->isIntOrIntVectorTy() || getOperand(0)->getType()->isPtrOrPtrVectorTy()) && "Invalid operand types for ICmp instruction"\' failed.\r\n[1]    30465 abort (core dumped)  rustc dstr.rs\r\n```\r\n\r\n### Backtrace\r\n\r\n``` rust\r\n#0  0x00007ffff62698a7 in raise () from /lib64/libc.so.6\r\n#1  0x00007ffff626ac3a in abort () from /lib64/libc.so.6\r\n#2  0x00007ffff62627fd in __assert_fail_base () from /lib64/libc.so.6\r\n#3  0x00007ffff62628b2 in __assert_fail () from /lib64/libc.so.6\r\n#4  0x00007ffff3918608 in ?? () from /usr/lib64/librustc_llvm-4e7c5e5c.so\r\n#5  0x00007ffff457b527 in LLVMBuildICmp () from /usr/lib64/librustc_llvm-4e7c5e5c.so\r\n#6  0x00007ffff6e54a7f in middle::trans::builder::Builder$LT$$x27a$C$$x20$x27tcx$GT$::icmp::h4aa6ae27f256fabePje () from /usr/lib64/librustc-4e7c5e5c.so\r\n#7  0x00007ffff6dd7830 in middle::trans::adt::trans_get_discr::ha443b7b22a4caa61VFv () from /usr/lib64/librustc-4e7c5e5c.so\r\n#8  0x00007ffff6e8a6f8 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#9  0x00007ffff6e87858 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#10 0x00007ffff6e17603 in middle::trans::_match::trans_match::he701ef37a38be851Agk () from /usr/lib64/librustc-4e7c5e5c.so\r\n#11 0x00007ffff6e05630 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#12 0x00007ffff6dc85fd in middle::trans::expr::trans_into::h8ae2b7a3d17060a8CD4 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#13 0x00007ffff6dc895f in middle::trans::controlflow::trans_block::h436e3d0d9803e356ST0 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#14 0x00007ffff6e713f8 in middle::trans::base::trans_closure::h231ca5ccc1f2e69at0g () from /usr/lib64/librustc-4e7c5e5c.so\r\n#15 0x00007ffff6dbb07a in middle::trans::base::trans_fn::hadaba5b2481570fcRbh () from /usr/lib64/librustc-4e7c5e5c.so\r\n#16 0x00007ffff6dbd4ce in middle::trans::monomorphize::monomorphic_fn::h4563fac28419b936ik0 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#17 0x00007ffff6df0b7c in middle::trans::callee::trans_fn_ref_with_substs::h8eabc21193fe07d6Hx3 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#18 0x00007ffff6dedd70 in middle::trans::callee::trans_fn_ref::h8d74fc054b8b7de4xl3 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#19 0x00007ffff6dd1ffc in middle::trans::meth::trans_method_callee::hbc28e9cef099c699gom () from /usr/lib64/librustc-4e7c5e5c.so\r\n#20 0x00007ffff6df6dae in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#21 0x00007ffff6dd0221 in middle::trans::callee::trans_call_inner::ha74736412897064crT3 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#22 0x00007ffff6df6bb1 in middle::trans::callee::trans_method_call::h99ff4f13e516b804TO3 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#23 0x00007ffff6e05136 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#24 0x00007ffff6e03e73 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#25 0x00007ffff6dc9a0c in middle::trans::expr::trans::h159a4d5c8110b09awH4 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#26 0x00007ffff6e662f3 in middle::trans::_match::store_local::hd8b63d9160463155Vtk () from /usr/lib64/librustc-4e7c5e5c.so\r\n#27 0x00007ffff6dc7b58 in middle::trans::base::init_local::h4a9b7e04850a284b38f () from /usr/lib64/librustc-4e7c5e5c.so\r\n#28 0x00007ffff6dc6f90 in middle::trans::controlflow::trans_stmt::h89e8a60881dc9d7cMO0 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#29 0x00007ffff6dc8868 in middle::trans::controlflow::trans_block::h436e3d0d9803e356ST0 () from /usr/lib64/librustc-4e7c5e5c.so\r\n#30 0x00007ffff6e713f8 in middle::trans::base::trans_closure::h231ca5ccc1f2e69at0g () from /usr/lib64/librustc-4e7c5e5c.so\r\n#31 0x00007ffff6dbb07a in middle::trans::base::trans_fn::hadaba5b2481570fcRbh () from /usr/lib64/librustc-4e7c5e5c.so\r\n#32 0x00007ffff6db86df in middle::trans::base::trans_item::hfe038ac56abea028avh () from /usr/lib64/librustc-4e7c5e5c.so\r\n#33 0x00007ffff6e7ab99 in middle::trans::base::trans_crate::h88329c3ddbae368c1si () from /usr/lib64/librustc-4e7c5e5c.so\r\n#34 0x00007ffff72c8d15 in driver::driver::phase_4_translate_to_llvm::h16ffd3985d271c57d5z () from /usr/lib64/librustc-4e7c5e5c.so\r\n#35 0x00007ffff72c147a in driver::driver::compile_input::h1a790388d99652637Bz () from /usr/lib64/librustc-4e7c5e5c.so\r\n#36 0x00007ffff734b7bc in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#37 0x00007ffff7349735 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#38 0x00007ffff6a4e108 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#39 0x00007ffff6a4e003 in ?? () from /usr/lib64/librustc-4e7c5e5c.so\r\n#40 0x00007ffff7bafdc2 in ?? () from /usr/lib64/libnative-4e7c5e5c.so\r\n#41 0x00007ffff669566c in ?? () from /usr/lib64/librustrt-4e7c5e5c.so\r\n#42 0x00007ffff6695656 in rust_try () from /usr/lib64/librustrt-4e7c5e5c.so\r\n#43 0x00007ffff6642d03 in unwind::try::h59906d5b05b381f7uFd () from /usr/lib64/librustrt-4e7c5e5c.so\r\n#44 0x00007ffff6642bbc in task::Task::run::h4be314de5a9e0a0fkLc () from /usr/lib64/librustrt-4e7c5e5c.so\r\n#45 0x00007ffff7bafb87 in ?? () from /usr/lib64/libnative-4e7c5e5c.so\r\n#46 0x00007ffff6644621 in ?? () from /usr/lib64/librustrt-4e7c5e5c.so\r\n#47 0x00007ffff597d294 in start_thread () from /lib64/libpthread.so.0\r\n#48 0x00007ffff631e1ed in clone () from /lib64/libc.so.6\r\n```\r\n\r\n### Version\r\n\r\n``` rust\r\nrustc 0.13.0-dev (80e5fe1a5 2014-10-25 09:17:05 +0000)\r\n```\r\n\r\ncc @bkoropoff This seems similar to #17206\r\ncc @nick29581'
18352,'jakub-','Invalid error message about lifetimes when pattern matching with constants\nOn the latest nightly (previously it worked fine) Rust fails to compile this code:\r\n```rust\r\npub struct Namespace(pub HashMap<Option<String>, String>);\r\n\r\nimpl Namespace {\r\n...\r\n    pub fn is_essentially_empty(&self) -> bool {\r\n        let Namespace(ref hm) = *self;\r\n        for (k, v) in hm.iter() {\r\n            match (k.as_ref().map(|k| k.as_slice()), v.as_slice()) {\r\n                (None, NS_EMPTY_URI) |\r\n                (Some(NS_XMLNS_PREFIX), NS_XMLNS_URI) |\r\n                (Some(NS_XML_PREFIX), NS_XML_URI) => {},\r\n                _ => return false\r\n            }\r\n        }\r\n        true\r\n    }\r\n...\r\n}\r\n```\r\nIt emits this error message:\r\n```\r\n   Compiling rust-xml v0.1.0 (file:///home/dpx-infinity/dev/lang/rust/projects/rust-xml)\r\nsrc/namespace.rs:41:23: 41:29 error: cannot infer an appropriate lifetime for pattern due to conflicting requirements\r\nsrc/namespace.rs:41         let Namespace(ref hm) = *self;\r\n                                          ^~~~~~\r\nsrc/namespace.rs:43:54: 43:55 note: first, the lifetime cannot outlive the expression at 43:53...\r\nsrc/namespace.rs:43             match (k.as_ref().map(|k| k.as_slice()), v.as_slice()) {\r\n                                                                         ^\r\nsrc/namespace.rs:43:54: 43:55 note: ...so that pointer is not dereferenced outside its lifetime\r\nsrc/namespace.rs:43             match (k.as_ref().map(|k| k.as_slice()), v.as_slice()) {\r\n                                                                         ^\r\nsrc/namespace.rs:42:23: 42:25 note: but, the lifetime must be valid for the expression at 42:22...\r\nsrc/namespace.rs:42         for (k, v) in hm.iter() {\r\n                                          ^~\r\nsrc/namespace.rs:42:23: 42:25 note: ...so that pointer is not dereferenced outside its lifetime\r\nsrc/namespace.rs:42         for (k, v) in hm.iter() {\r\n                                          ^~\r\n```\r\n\r\nI managed to strip it down to this example:\r\n```rust\r\nconst X: &\'static str = "12345";\r\n\r\npub fn test(s: String) -> bool {\r\n    match s.as_slice() {\r\n        X => true,\r\n        _ => false\r\n    }\r\n}\r\n```\r\nIt fails to compile with this error:\r\n```\r\n/tmp/rs/lifetimes/src/lib.rs:18:11: 18:12 error: `s` does not live long enough\r\n/tmp/rs/lifetimes/src/lib.rs:18     match s.as_slice() {\r\n                                          ^\r\nnote: reference must be valid for the static lifetime...\r\n/tmp/rs/lifetimes/src/lib.rs:17:32: 22:2 note: ...but borrowed value is only valid for the block at 17:31\r\n/tmp/rs/lifetimes/src/lib.rs:17 pub fn test(s: String) -> bool {\r\n/tmp/rs/lifetimes/src/lib.rs:18     match s.as_slice() {\r\n/tmp/rs/lifetimes/src/lib.rs:19         X => true,\r\n/tmp/rs/lifetimes/src/lib.rs:20         _ => false\r\n/tmp/rs/lifetimes/src/lib.rs:21     }\r\n/tmp/rs/lifetimes/src/lib.rs:22 }\r\n```\r\n\r\nIf `X =>` is replaced with `"12345" =>`, then it compiles fine, so the error seems to be related to matching on `const`s.'
18350,'jakub-','Failed to build because of incompatible type\nI just upgraded my `rustc` to `rustc 0.13.0-nightly (f168c12c5 2014-10-25 20:57:10 +0000)`. But when I tried to rebuild my project, it failed with the following errors:\r\n\r\n```\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:179:11: 179:17 error: cannot infer an appropriate lifetime due to conflicting requirements\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:179     match method {\r\n                                                                             ^~~~~~\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:178:69: 246:2 note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the block at 178:68...\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:178 pub fn with_name(method: &str, key: &[u8]) -> Option<CipherVariant> {\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:179     match method {\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:180         #[cfg(feature="cipher-aes-cfb")]\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:181         CIPHER_AES_128_CFB => Some(OpenSSLCrypto(openssl::OpenSSLCipher::new(CipherTypeAes128Cfb, key))),\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:182         #[cfg(feature="cipher-aes-cfb")]\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:183         CIPHER_AES_128_CFB_1 => Some(OpenSSLCrypto(openssl::OpenSSLCipher::new(CipherTypeAes128Cfb1, key))),\r\n                                                                   ...\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:179:11: 179:17 note: ...so that types are compatible (expected `&str`, found `&str`)\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:179     match method {\r\n                                                                             ^~~~~~\r\nnote: but, the lifetime must be valid for the static lifetime...\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:238:9: 238:23 note: ...so that types are compatible (expected `&str`, found `&\'static str`)\r\n/Users/zonyitoo/Projects/shadowsocks-rust/src/crypto/cipher.rs:238         CIPHER_RC2_CFB => Some(OpenSSLCrypto(openssl::OpenSSLCipher::new(CipherTypeRc2Cfb, key))),\r\n                                                                           ^~~~~~~~~~~~~~\r\nerror: aborting due to previous error\r\n```\r\n\r\n`CIPHER_AES_128_CFB`, `CIPHER_AES_128_CFB_1`, etc... are constants of type `&\'static str`.\r\n\r\nWhat does the error mean? I am confused.'
18340,'steveklabnik','Guide: Closures: minor wording fixes\nSome minor wording fixes to the Closures chapter; my brain tripped a few times when reading it, so I tried to come up with something a bit smoother. I’m not a native speaker, so please do review this critically.'
18339,'steveklabnik','Guide: Patterns: use non-x variables in match blocks\nI think it helps to show that the variables introduced in match blocks are indeed independent from the matched variable `x` (especially when `x` is still reachable inside those blocks and might be useful), so this renames them accordingly. Maybe some linter (or language-level warning?) will eventually warn about shadowing `x` in such cases. ;)\r\n\r\nI’m not super happy about the matching-on-range example, as it’s too contrived (`e` and `x` are exactly the same here), but I couldn’t come up with something both simple and non-redundant.'
18338,'steveklabnik','Guide: Pointers: cruft removal + minor clarifications\nThis removes some leftover line-numbering cruft from elided error examples and brings some minor clarifications.\r\n\r\nI’m not super happy about the ‘we cannot have two mutable pointers that point to the same memory’ wording (to the best of my understanding we can’t even have one mutable and one immutable), but other attempts to word this were derailing the flow a bit too much.'
18337,'pcwalton',"Assorted unboxed closure fixes\nThe most substantial change here is that we disallow capture-by-value `FnMut` closures from mutating upvars that are not declared `mut`, which is consistent with the behavior of procs and of other unboxed closure varieties, although it is notable that the equivalent desugaring would permit it since structure fields cannot have individual mutability.\r\n\r\nThis also fixes an ICE, upvars sometimes not being marked as used mutably, and some bad diagnostic messages.  There are still some improvements to be made here (#18330), but it's a longstanding issue that I'll try to address with a different PR.\r\n\r\nCloses #18238\r\nCloses #18335\r\nCloses #18336\r\n\r\nr? @pcwalton "
18326,'alexcrichton','Finish cfg syntax transition\nr? @alexcrichton '
18321,'aturon','Guide: refresh Testing\nThis refreshes the Cargo commands’ output for the ‘Testing’ chapter to match current reality.\r\n\r\nThis also drops the ‘Wait a minute, zero tests?’ paragraph, which is no longer relevant when one actually follows the steps in the Guide.\r\n\r\nAlso, when following the steps in the Guide dilligently, the warning about unused `main` does not show up again, as `src/main.rs` is not recompiled when unchanged; these changes address this as well.'
18320,'huonw',"Guide: drop :d formatting where unnecessary\nI'm working my way through the Guide and it seems the `:d` formatting in these places is unnecessary. As the Guide doesn’t explain it before the first use, I’d say plain `{}` interpolation (which was explained) is better in these places."
18303,'thestinger','Make the Vec data structure layout match raw::Slice.\nFixes #18302\n\nr? @thestinger'
18291,'aturon',"DSTify [T]/str extension traits\nThis PR changes the signature of several methods from `foo(self, ...)` to `foo(&self, ...)`/`foo(&mut self, ...)`, but there is no breakage of the usage of these methods due to the autoref nature of `method.call()`s. This PR also removes the lifetime parameter from some traits (`Trait<'a>` -> `Trait`). These changes break any use of the extension traits for generic programming, but those traits are not meant to be used for generic programming in the first place. In the whole rust distribution there was only one misuse of a extension trait as a bound, which got corrected (the bound was unnecessary and got removed) as part of this PR.\r\n\r\nI've kept the commits as small and self-contained as possible for reviewing sake, but I can squash them when the review is over.\r\n\r\nSee this [table] to get an idea of what's left to be done. I've already DSTified [`Show`][show] and I'm working on `Hash`, but bootstrapping those changes seem to require a more recent snapshot (#18259 does the trick)\r\n\r\nr? @aturon \r\ncc #16918 \r\n\r\n[show]: https://github.com/japaric/rust/commits/show\r\n[table]: https://docs.google.com/spreadsheets/d/1MZ_iSNuzsoqeS-mtLXnj9m0hBYaH5jI8k9G_Ud8FT5g/edit?usp=sharing"
18268,'alexcrichton',"Don't use range as variable name\nIf you're trying out more code snippets from http://doc.rust-lang.org/guide.html#iterators ```let mut range = ...``` is shadowing the ```range()``` function and therefore on further usage errors are thrown."
18257,'brson','Plugin Guide: nicer creation of the parser\nThis simplifies the call to create the parser.'
18254,'huonw','Improved examples on Vec documentation\n- shrink_to_fit example is now more clear by asserting the capacity value\r\n- annotation [0, mid) changed for [0, mid]'
18244,'nikomatsakis',"Fixed single quote around string slice and simplify example\nThis patch contains a fix for:\r\n- single quote around string slice\r\n- string: String is confusing for newbies and it's more readble if the\r\n  argument name is different that the argument type name"
18239,'alexcrichton',"rustc: Fail immediately if linking returns status code != 0\nIf rustc fails to link a library (as described in #17951), it still tries to rename the non-existent file on Windows. I'm not sure how to test this as we'd have to reproduce a linking failure...\r\n\r\nCloses #17951\r\n"
18235,'nick29581','Use local cache more often\nUse local cache when there are unbound type variables and where clauses are in scope.\r\n\r\nFixes #18209.\r\n\r\nr? @nick29581 '
18223,'pcwalton','Adjust orphan rules to consider all input types, not just self type.\nAdjust orphan rules to consider all input types, not just self type.\r\n\r\nFixes #18222.\r\n\r\nr? @pcwalton '
18220,'huonw',"Starting to de-glob std\nThis #11983 looked idle.  Could someone check if I'm going about this in the right way? @brson @alexcrichton \r\n"
18217,'nikomatsakis','Fix issue #17848 (Questionable advice in bug report instructions)\nFixed as per @pnkfelix comments in #17848'
18213,'aturon','enable parallel codegen by default\nEnable parallel codegen (2 units) by default when --opt-level is 0 or 1.  This\r\ngives a minor speedup on large crates (~10%), with only a tiny slowdown (~2%)\r\nfor small ones (which usually build in under a second regardless).  The current\r\ndefault (no parallelization) is used when the user requests optimization\r\n(--opt-level 2 or 3), and when the user has enabled LTO (which is incompatible\r\nwith parallel codegen).\r\n\r\nThis commit also changes the rust build system to use parallel codegen\r\nwhen appropriate.  This means codegen-units=4 for stage0 always, and\r\nalso for stage1 and stage2 when configured with --disable-optimize.\r\n(Other settings use codegen-units=1 for stage1 and stage2, to get\r\nmaximum performance for release binaries.)  The build system also sets\r\ncodegen-units=1 for compiletest tests (compiletest does its own\r\nparallelization) and uses the same setting as stage2 for crate tests.\r\n\r\nr? @aturon'
18209,'nikomatsakis',"Regression around `Trait::method -> Self`\nI have this trait definition:\r\n\r\n```rs\r\npub trait LoadableMessage {\r\n    fn load<R: Reader>(reader: &mut R) -> IoResult<Self> {\r\n        let mut stream = InputStream::new();\r\n        LoadableMessage::load_from_stream(&mut stream)\r\n    }\r\n}\r\n```\r\n\r\nAnd this usage:\r\n\r\n```rs\r\npub fn load<'a, M: LoadableMessage, R: Reader>(reader: &mut R) -> IoResult<M> {\r\n    LoadableMessage::load(reader)\r\n}\r\n```\r\n\r\nAnd I get this error upon compilation:\r\n\r\n```text\r\n-gnu/release/deps --extern nix=/home/wycats/Code/skylight-rust/target/x86_64-unknown-linux-gnu/release/deps/libnix-13dc7f065ef11e3c.rlib`\r\n/home/wycats/Code/skylight-rust/libs/buffoon/src/lib.rs:19:5: 19:34 error: mismatched types: expected `core::result::Result<M,std::io::IoError>`, found `core::result::Result<Self,std::io::IoError>` (expected type parameter, found Self)\r\n/home/wycats/Code/skylight-rust/libs/buffoon/src/lib.rs:19     LoadableMessage::load(reader)\r\n                                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```\r\n\r\nThis was compiling recently (I believe last week), but does not compile with today's nightly."
18208,'nikomatsakis','Typechecking pass takes an extreme amount of time on trivial programs\n```rust\r\nfn main() {\r\n    println!("Hello, world");\r\n}\r\n```\r\nTake this simple program and modify it by adding more consecutive `println!("Hello world");` lines. Compile it with `-Z time-passes` and observe how long typechecking takes. I\'ve compiled a table below.\r\n\r\nCalls to `println!` | Typechecking time (seconds)\r\n------------ | -------------\r\n1 | 0.001\r\n2 | 0.001\r\n4 | 0.003\r\n8 | 0.003\r\n16 | 0.007\r\n32 | 0.014\r\n64 | 0.048\r\n128 | 0.119\r\n256 | 0.386\r\n512 | 1.316\r\n1024 | 4.893\r\n2048 | 19.227\r\n4096 | 82.713\r\n8192 | Sits at typechecking for minutes, then fails with "Illegal instruction"\r\n\r\nHere\'s the full output of `time-passes` for the 4096 case, to see the enormous disparity between typechecking and the other passes (though liveness is another offender):\r\n```\r\ntime: 0.022 s   parsing\r\ntime: 0.002 s   gated feature checking\r\ntime: 0.000 s   crate injection\r\ntime: 0.003 s   configuration 1\r\ntime: 0.003 s   plugin loading\r\ntime: 0.000 s   plugin registration\r\ntime: 0.474 s   expansion\r\ntime: 0.036 s   configuration 2\r\ntime: 0.036 s   maybe building test harness\r\ntime: 0.032 s   prelude injection\r\ntime: 0.005 s   checking that all macro invocations are gone\r\ntime: 0.045 s   assigning node ids and indexing ast\r\ntime: 0.005 s   external crate/lib resolution\r\ntime: 0.008 s   language item collection\r\ntime: 0.120 s   resolution\r\ntime: 0.009 s   lifetime resolution\r\ntime: 0.006 s   looking for entry point\r\ntime: 0.004 s   looking for plugin registrar\r\ntime: 0.030 s   region resolution\r\ntime: 0.004 s   loop checking\r\ntime: 0.004 s   stability index\r\ntime: 0.004 s   static item recursion checking\r\ntime: 0.024 s   type collecting\r\ntime: 0.009 s   variance inference\r\ntime: 0.080 s   coherence checking\r\ntime: 82.713 s  type checking\r\ntime: 0.057 s   check static items\r\ntime: 0.065 s   const marking\r\ntime: 0.005 s   const checking\r\ntime: 0.025 s   privacy checking\r\ntime: 0.020 s   intrinsic checking\r\ntime: 0.015 s   effect checking\r\ntime: 0.226 s   match checking\r\ntime: 55.143 s  liveness checking\r\ntime: 2.312 s   borrow checking\r\ntime: 0.104 s   rvalue checking\r\ntime: 0.002 s   reachability checking\r\ntime: 0.115 s   death checking\r\ntime: 0.190 s   lint checking\r\ntime: 0.001 s   resolving dependency formats\r\ntime: 1.998 s   translation\r\n  time: 0.108 s llvm function passes\r\n  time: 0.025 s llvm module passes\r\n  time: 0.902 s codegen passes\r\n  time: 0.002 s codegen passes\r\ntime: 1.179 s   LLVM passes\r\n  time: 0.359 s running linker\r\ntime: 0.363 s   linking\r\n```\r\nThis seems to contradict our usual excuse for compiler slowness of "it\'s not our fault, it\'s LLVM".'
18197,'sfackler','Doc\'s example code for BufferedWriter is wrong and also generate warnings\nStruct std::io::BufferedWriter has the example code : \r\n\r\n```rust\r\nuse std::io::{BufferedWriter, File};\r\n\r\nlet file = File::open(&Path::new("message.txt"));\r\nlet mut writer = BufferedWriter::new(file);\r\n\r\nwriter.write_str("hello, world");\r\nwriter.flush();\r\n```\r\n\r\nBut this code opens the file as read only, it should open it for writing or creating a new file, for example : \r\n\r\n    let file = File::create(&Path::new("message.txt"));\r\n\r\nIt also generates two warnings : \r\n\r\n```\r\nbuff_writer.rs:7:2: 7:35 warning: unused result which must be used, #[warn(unused_must_use)] on by default\r\nbuff_writer.rs:7 \twriter.write_str("hello, world");\r\n                 \t^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nbuff_writer.rs:8:2: 8:17 warning: unused result which must be used, #[warn(unused_must_use)] on by default\r\nbuff_writer.rs:8 \twriter.flush();\r\n```\r\n\r\nby `unwrap()`ing both these remove the errors, and in the case where `File::open` is used to successfully crash the sample app when attempting to append to a read only file.'
18194,'nikomatsakis','mk/rt: "export CC" does not seem to work (gcc observed), use explicit shell variables instead\nThis was run into while attempting to integrate rust with bitbake\'s build system. I expect it\'s caused by some other environment variables being set to gcc but didn\'t track down the exact cause myself.'
18192,'brson','split platform definitions out of mk/platform.mk\nThe goal here is to make it easier to add new platform definitions,\r\nespecially when the additions are programmatic (ie: in build scripts).'
18187,'nikomatsakis',"Inference replaces bounded type parameter with sole implementer (was: action-at-a-distance regression)\nThe following code does not compile:\r\n\r\n```Rust\r\n\r\n\r\npub trait ScanCursor {\r\n\tfn pop_ws(&self) -> Self;\r\n}\r\n\r\npub struct Cursor;\r\n\r\nimpl ScanCursor for Cursor {\r\n\tfn pop_ws(&self) -> Cursor { unreachable!() }\r\n}\r\n\r\npub trait Scanner {\r\n\tfn scan<Cur: ScanCursor>(cursor: &Cur) -> Self;\r\n}\r\n\r\nfn main() {\r\n    let cur : Cursor = Cursor;\r\n    // \r\n    let _tmp = &cur.pop_ws(); // removing this still fails\r\n    // let _ : Stmt = Scanner::scan(_tmp)\r\n    let _ : Stmt = Scanner::scan(&cur.pop_ws());\r\n}\r\n\r\nstruct Stmt;\r\n\r\n// Moving this above main compiles\r\nimpl Scanner for Stmt {\r\n    fn scan<Cur: ScanCursor>(cur: &Cur) -> Stmt {\r\n        // Fails to compile\r\n        let _s: Stmt = Scanner::scan(&cur.pop_ws());\r\n        loop{}\r\n   }\r\n}\r\n\r\n// Added 2014-10-21\r\n#[cfg(compiles)]\r\nimpl ScanCursor for ((),(()),((),(()))) /* or whatever */ {\r\n    fn pop_ws(&self) ->  ((),(()),((),(()))) { unreachable!() }\r\n}\r\n```\r\n\r\nWith an error in scan:\r\n```\r\n<anon>:29:38: 29:51 error: mismatched types: expected `&Cursor`, found `&Cur` (expected struct Cursor, found type parameter)\r\n<anon>:29         let _s: Stmt = Scanner::scan(&cur.pop_ws());\r\n                                               ^~~~~~~~~~~~~\r\nerror: aborting due to previous error\r\n```\r\nHowever, doing any of the 2 fixes suggested in the comments fixes this, which is strange, as the fixes don't touch the affected function.\r\n\r\nThe issue started at commit ```590a61f788e058d7ae95806f55258bce3ae45567``` (2014-10-13), which fixed issue #18019. The code compiles on older version of rustc."
18160,'alexcrichton',"Fix printing negative signed literal in print_literal\nFix for issue #18091 \r\n\r\nThe problem seems to be that `ast_util::int_ty_to_string` takes unsigned number, and no one adds `-` to result string. I've fixed it by putting `-` before result string using `format!`.\r\n\r\nI've also added `test_signed_int_to_string()` to check if implementation is valid.\r\n\r\n"
18145,'aturon','[Docs] intro typo\nNoticed a type while reading through the intro'
18144,'nikomatsakis','Fix monomorphization of unboxed closures\nThis allows unboxed closures that reference free type/region parameters to be monomorphized correctly in trans.\r\n\r\nIt was necessary to make `ty_unboxed_closure` carry around a `Substs` to accomplish this.  Plumbing this through typeck revealed several areas where type/region parameters in unboxed closure types are possibly not being handled correctly.  Since my goal was just to fix trans, I decided to leave FIXME comments on areas that still need attention and seek feedback on the best way to clean them up, possibly as a follow-up PR.\r\n\r\nCloses #16791'
18141,'brson','Parser: Fix spans of explicit self arg idents\nHello! I noticed spans are wrong for the PatIdents of self args. (I use spans a lot in racer)'
18140,'steveklabnik',"Fix the reason for calling a file lib.rs\nThe reason given didn't make any sense when I read it when reading through the docs. I think this is more clear. Please let me know it is also more correct."
18139,'steveklabnik','[Docs] Fix fold explanation in the guide\nThe explanation of fold talks about three elements that should be summed, but it uses different values in the provided code.'
18138,'alexcrichton','Mark lt as inline in PartialOrd\nFixes issue #18090'
18125,'nikomatsakis','Split CString::new into CString::new and CString::new_owned\nThis is a fix for #18117'
18122,'pcwalton','Split CString::new into CString::new and CString::new_owned\nThis is a fix for #18117\r\n'
18121,'pcwalton','Make method calls use trait matching infrastructure\nConvert trait method dispatch to use new trait matching machinery.\r\n\r\nThis fixes about 90% of #17918. What remains to be done is to make inherent dispatch work with conditional dispatch as well. I plan to do this in a future patch by generalizing the "method match" code slightly to work for inherent impls as well (the basic algorithm is precisely the same).\r\n\r\nFixes #17178.\r\n\r\nThis is a [breaking-change] for two reasons:\r\n\r\n1. The old code was a bit broken. I found various minor cases, particularly around operators, where the old code incorrectly matched, but an extra `*` or other change is now required. (See commit e8cef25 ("Correct case where the old version of method lookup...") for examples.)\r\n2. The old code didn\'t type check calls against the method signature from the *trait* but rather the *impl*. The two can be different in subtle ways. This makes the new method dispatch both more liberal and more conservative than the original. (See commit 8308332 ("The new method lookup mechanism typechecks...") for examples.)\r\n\r\nr? @pcwalton since he\'s been reviewing most of this series of changes\r\nf? @nick29581 for commit 39df55f ("Permit DST types to unify like other types")\r\ncc @aturon as this relates to library stabilization\r\n\r\n\r\n'
18120,'pcwalton','Use match expression directly in guide.md\nUse a match expression directly in the println statement, instead of creating a second variable.  It seems weird that the current guide.md complains about creating an extra variable, when the same feature could be demonstrated without creating the extra variable.'
18105,'pcwalton',"Check object lifetime bounds in coercions, not just trait bounds. \nCheck object lifetime bounds in coercions, not just trait bounds.  Fixes #18055.\r\n\r\nr? @pcwalton \r\n\r\nThis is a [breaking change]. Change code like this:\r\n\r\n    fn foo(v: &[u8]) -> Box<Clone+'static> { ... }\r\n\r\nto make the lifetimes agree:\r\n\r\n    // either...\r\n    fn foo(v: &'static[u8]) -> Box<Clone+'static> { box v }\r\n\r\n    // or ...\r\n    fn foo<'a>(v: &'a [u8]) -> Box<Clone+'a> { box v }\r\n"
18103,'nick29581','libstd: Inline more methods on bitflags.\nServo really wants this.\r\n\r\nr? @nick29581 '
18064,'nick29581','Remove reflection\nOut goes reflection! This means your code will break if you used the `:?` format specifier, anything else from libdebug, or the `visit_tydesc` intrinsic directly.\r\n\r\nCloses #18046.\r\n\r\n[breaking-change]'
18061,'nick29581','UFCS: ICE in trans when using method from linked crate as function\n### STR\r\n\r\n``` rust\r\n// seq.rs\r\nuse std::collections::HashMap;\r\nuse std::hash::Hash;\r\n\r\npub trait Seq<T> {\r\n    #[cfg(ice)]\r\n    fn add_elem(&mut self, T);\r\n\r\n    #[cfg(not(ice))]\r\n    fn add_elem(&mut Self, T);\r\n\r\n    fn new() -> Self;\r\n}\r\n\r\nimpl<K, V> Seq<(K, V)> for HashMap<K, V> where K: Eq + Hash {\r\n    #[cfg(ice)]\r\n    fn add_elem(&mut self, (key, value): (K, V)) {\r\n        self.insert(key, value);\r\n    }\r\n\r\n    #[cfg(not(ice))]\r\n    fn add_elem(m: &mut HashMap<K, V>, (key, value): (K, V)) {\r\n        m.insert(key, value);\r\n    }\r\n\r\n    fn new() -> HashMap<K, V> {\r\n        HashMap::new()\r\n    }\r\n}\r\n```\r\n\r\n``` rust\r\n// app.rs\r\nextern crate seq;\r\n\r\nuse std::collections::HashMap;\r\n\r\nfn main() {\r\n    let _: HashMap<char, String> = {\r\n        let mut temp = ::seq::Seq::new();\r\n\r\n        ::seq::Seq::add_elem(&mut temp, (\'a\', "apple".to_string()));\r\n\r\n        temp\r\n    };\r\n}\r\n```\r\n\r\n```\r\n$ rustc --cfg ice --crate-type=lib seq.rs\r\n$ rustc -L . app.rs\r\n```\r\n\r\nIf you omit the `--cfg ice` flag, compiling `app.rs` doesn\'t ICE. In that case UFCS is not used at all.\r\n\r\n### Backtrace\r\n\r\n``` rust\r\nerror: internal compiler error: unexpected failure\r\nnote: the compiler hit an unexpected failure path. this is a bug.\r\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\r\nnote: run with `RUST_BACKTRACE=1` for a backtrace\r\ntask \'rustc\' failed at \'assertion failed: `(left == right) && (right == left)` (left: `11`, right: `0`)\', /var/tmp/paludis/build/dev-lang-rust-scm/work/rust-scm/src/librustc/middle/trans/callee.rs:504\r\n\r\nstack backtrace:\r\n   1:     0x7f8c4420a530 - rt::backtrace::imp::write::hc0bea45eeb94b4f2gDq\r\n   2:     0x7f8c4420d660 - <unknown>\r\n   3:     0x7f8c449ac890 - unwind::begin_unwind_inner::h7a44b117581e2f74Gxd\r\n   4:     0x7f8c449ac3d0 - unwind::begin_unwind_fmt::h45039a117ffe43968ud\r\n   5:     0x7f8c4518e740 - middle::trans::callee::trans_fn_ref_with_substs::h5c6fbb3c911b1c9bsm2\r\n   6:     0x7f8c4518bd60 - middle::trans::callee::trans_fn_ref::h76d352f707b079480a2\r\n   7:     0x7f8c45194650 - <unknown>\r\n   8:     0x7f8c4516c1b0 - middle::trans::callee::trans_call_inner::h1363a864f6bb88c0aI2\r\n   9:     0x7f8c451943a0 - middle::trans::callee::trans_call::hdf5a1e27fb88e0bavC2\r\n  10:     0x7f8c451a3530 - <unknown>\r\n  11:     0x7f8c45164440 - middle::trans::expr::trans_into::h51830a680129f037ss3\r\n  12:     0x7f8c45163830 - middle::trans::controlflow::trans_stmt_semi::h4f58c2f4320d1330KEZ\r\n  13:     0x7f8c45162de0 - middle::trans::controlflow::trans_stmt::h46e53ff7f38da11cxAZ\r\n  14:     0x7f8c45164860 - middle::trans::controlflow::trans_block::ha4ca6acf3ba4f0c5DFZ\r\n  15:     0x7f8c451a3530 - <unknown>\r\n  16:     0x7f8c451a2170 - <unknown>\r\n  17:     0x7f8c45165990 - middle::trans::expr::trans::h1177439ad486cf5emw3\r\n  18:     0x7f8c4520b8f0 - middle::trans::_match::store_local::hde75dbf3d187178beZi\r\n  19:     0x7f8c45163a20 - middle::trans::base::init_local::h9df9f875fba43791YJe\r\n  20:     0x7f8c45162de0 - middle::trans::controlflow::trans_stmt::h46e53ff7f38da11cxAZ\r\n  21:     0x7f8c45164860 - middle::trans::controlflow::trans_block::ha4ca6acf3ba4f0c5DFZ\r\n  22:     0x7f8c452150f0 - middle::trans::base::trans_closure::h56e66481b064a22boBf\r\n  23:     0x7f8c45156370 - middle::trans::base::trans_fn::hcc6c7d7c981b98c0MMf\r\n  24:     0x7f8c451539d0 - middle::trans::base::trans_item::h1fa8cc7bd69d090855f\r\n  25:     0x7f8c452206b0 - middle::trans::base::trans_crate::he0691a6f7c0f1264B4g\r\n  26:     0x7f8c45671e10 - driver::driver::phase_4_translate_to_llvm::hfb1745881244cd9ayEx\r\n  27:     0x7f8c45668110 - driver::driver::compile_input::hc2b446e7823ca44dtbx\r\n  28:     0x7f8c456f3980 - <unknown>\r\n  29:     0x7f8c456f3830 - <unknown>\r\n  30:     0x7f8c44db9d80 - <unknown>\r\n  31:     0x7f8c44db9b60 - <unknown>\r\n  32:     0x7f8c45f65980 - <unknown>\r\n  33:     0x7f8c449fd4b0 - <unknown>\r\n  34:     0x7f8c449fd4a0 - rust_try\r\n  35:     0x7f8c449aa150 - unwind::try::h18af68ce3545f05domd\r\n  36:     0x7f8c449a9fd0 - task::Task::run::he7074020ac841b032Bc\r\n  37:     0x7f8c45f656c0 - <unknown>\r\n  38:     0x7f8c449ab8a0 - <unknown>\r\n  39:     0x7f8c43cd21d0 - start_thread\r\n  40:     0x7f8c446851b9 - clone\r\n  41:                0x0 - <unknown>\r\n```\r\n\r\n### Version\r\n\r\n``` rust\r\nrustc 0.13.0-dev (e4761c85b 2014-10-15 09:57:18 +0000)\r\n```\r\n\r\ncc @nick29581 '
18055,'nikomatsakis','Trait objects can be created with lifetime bounds that ignore input lifetimes\n```rust\r\nfn foo() -> Box<Reader + \'static> {\r\n    let v = [1, 2, 3];\r\n    box std::io::BufReader::new(v)\r\n}\r\n\r\nfn main() {\r\n    let mut foo = foo();\r\n    println!("{}", foo.read_to_end());\r\n}\r\n```\r\n\r\nThis should not compile, since `v` is `&\'a [u8]` for some non-`\'static` `\'a` and thus `BufReader<\'a>` will contain `&\'a [u8]` as well. It compiles fine however and results in the varying output depending on the optimization level (which shows that this is an UB out of the "safe" code).\r\n\r\nTested with `rustc 0.13.0-nightly (1c3ddd297 2014-10-13 23:27:46 +0000)` and playpen.'
18052,'aturon','A typo in the description of raw byte string literals\nHello,\r\n\r\n\r\nThe pull request fixes a typo in the description of raw string literals in [reference.md](https://github.com/rust-lang/rust/blob/master/src/doc/reference.md#byte-and-byte-string-literals).\r\n\r\n\r\nRegards,\r\nIvan'
18049,'alexcrichton','Add implementation of nth() for slice Items and MutItems\nThis adds an implementation of the nth() method for the Iterator trait that overrides the default for slice Items and MutItems.'
18044,'pcwalton','rustc: implement lint conventions (RFC 344)\n[RFC 344](https://github.com/rust-lang/rfcs/pull/344) proposes a set of naming conventions for lints. This PR\r\nrenames existing lints to follow the conventions.\r\n\r\nUse the following sed script to bring your code up to date:\r\n\r\n```\r\ns/unnecessary_typecast/unused_typecasts/g\r\ns/unsigned_negate/unsigned_negation/g\r\ns/type_limits/unused_comparisons/g\r\ns/type_overflow/overflowing_literals/g\r\ns/ctypes/improper_ctypes/g\r\ns/owned_heap_memory/box_pointers/g\r\ns/unused_attribute/unused_attributes/g\r\ns/path_statement/path_statements/g\r\ns/unused_must_use/unused_must_use/g\r\ns/unused_result/unused_results/g\r\ns/non_uppercase_statics/non_upper_case_globals/g\r\ns/unnecessary_parens/unused_parens/g\r\ns/unnecessary_import_braces/unused_import_braces/g\r\ns/unused_unsafe/unused_unsafe/g\r\ns/unsafe_block/unsafe_blocks/g\r\ns/unused_mut/unused_mut/g\r\ns/unnecessary_allocation/unused_allocation/g\r\ns/missing_doc/missing_docs/g\r\ns/unused_imports/unused_imports/g\r\ns/unused_extern_crate/unused_extern_crates/g\r\ns/unnecessary_qualification/unused_qualifications/g\r\ns/unrecognized_lint/unknown_lints/g\r\ns/unused_variable/unused_variables/g\r\ns/dead_assignment/unused_assignments/g\r\ns/unknown_crate_type/unknown_crate_types/g\r\ns/variant_size_difference/variant_size_differences/g\r\ns/transmute_fat_ptr/fat_ptr_transmutes/g\r\n```\r\n\r\nSince a large number of lints are being renamed for RFC 344, this PR\r\nadds some basic deprecation/renaming functionality to the pluggable lint\r\nsystem. It allows a simple mapping of old to new names, and can warn\r\nwhen old names are being used.\r\n\r\nThis change needs to be rolled out in stages. In this PR, the\r\ndeprecation warning is commented out, but the old name is forwarded to\r\nthe new one.\r\n\r\nOnce the PR lands and we have generated a new snapshot of the\r\ncompiler, we can add the deprecation warning and rename all uses of the\r\nlints in the rust codebase. I will file a PR to do so.\r\n\r\nCloses #16545\r\nCloses #17932\r\n\r\nr? @pcwalton '
18041,'nikomatsakis','Properly fail on type size overflows in LLVM\nShould fix #17913.\r\n\r\nAlso clean-up u64/u32-ness. I really should split this commit and add tests (I have no idea how to add them).'
18036,'nikomatsakis','Add tests for issues #11384 and #12909\nCloses #11384\r\nCloses #12909\r\n\r\nr? @nikomatsakis '
18024,'brson','Fix var name in doc for ops.rs\nMake the doc more consistent & runnable.\r\n\r\n* Use `_index` instead of `_rhs` when appropriate.\r\n* Use `_from` and `_to` to avoid warning.\r\n* Remove unnecessary `::core::ops`'
18022,'pcwalton','Avoid false ambiguity in multidispatch trait resolution\nOnly consider impliciy unboxed closure impl if the obligation is actually for `Fn`, `FnMut`, or `FnOnce`.\r\n\r\nFixes #18019\r\n\r\nr? @pcwalton '
18015,'pcwalton','Improve the error message for missing else clauses in if expressions\nCloses #4201.'
18013,'alexcrichton',"Fix typo in char's from_digit error message\n"
18008,'brson','Doc: Clarify the meaning of "copy" in std::mem::swap/replace\nThe use of "without copying" in the std::mem docs was a source of confusion to those less familiar with Rust, as it could refer to either semantic copying or byte copying. This clarifies which meaning was intended.'
17995,'nikomatsakis','librustc: Introduce a "quick reject" mechanism to quickly throw out\nmethod candidates and prevent method lookup from being invoked at all\r\nfor overloaded operators.\r\n\r\n40%-50% improvement in typechecking time.\r\n\r\nr? @nikomatsakis '
17993,'pcwalton','Doc: Fix C-Code Example in FFI Docs\nAdd missing void* for passed RustObject.'
17992,'pcwalton','Guide: specify that both shared and mutable borrows can be re-lent.\n@steveklabnik, you can re-lend both mutable and immutable borrows, and the rules for returning them are the same, no?'
17979,'pcwalton','Guide: remove promise of a counter in the guessing game.\nIssue #17964.  cc @steveklabnik '
17977,'steveklabnik','Doc: fix broken link in guide-strings.md\n'
17973,'huonw',"Stop ICE when referring to foreign static values in statics and consts\n(I am new to Git and Github so I'm really sorry if I messed up somewhere)"
17971,'pcwalton',"Add subsecond resolution to 'std::io::fs::change_file_times'\nAs described on issue #17946, the function 'change_file_times' does not update the milliseconds portion of the file timestamp when running under Unix.\r\n\r\nAs per the suggestion of @mahkoh, I have modified the function 'native::io::file::utime' so that it uses the native 'utimes' function, which does allow for millisecond granularity."
17966,'nikomatsakis',"Link to Unicode SpecialCasing.txt document\nThe document is mentioned, but doesn't link to it, so it's a little confusing"
17962,'steveklabnik','Guide: develop the exposition of arrays, vectors, and slices.\nThe array is the fundamental concept; vectors are growable arrays, and\r\nslices are views into either.  Show common array ops up front: length\r\nand iteration.  Mention arrays are immutable by default.  Highlight\r\ndefinite initialization and bounds-checking as safety features.  Show\r\nthat you only need a type suffix on one element of initializers.\r\nExplain that vectors are a value-add library type over arrays, not a\r\nfundamental type; show they have the same "interface." Motivate slices\r\nas efficient views into arrays; explain you can slice vectors, Strings,\r\n&str because they\'re backed by arrays.  Show off new, easy-to-read\r\n[a..b] slice syntax.'
17955,'brson','Tweak copy and formatting of Tasks guide\n'
17953,'aturon',"io: Implement Seek for MemWriter\nMemReader implements the Seek trait while MemWriter doesn't. I don't see any reason not to implement Seek for MemWriter."
17947,'huonw','Renamed AsciiStr::to_lower and AsciiStr::to_upper\nAsciiStr::to_lower is now AsciiStr::to_lowercase and AsciiStr::to_upper is AsciiStr::to_uppercase to match Ascii trait.\r\n\r\nPart of issue #17790.\r\n\r\nThis is my first pull request so let me know if anything is incorrect.\r\n\r\nThanks!\r\n\r\n[breaking-changes]'
17945,'aturon','Disable compilation on some extensionless files\nThis commit prevents the compiler from overwriting certain extensionless source files with a binary.\r\n\r\nAs it stands, if you have /home/joe/file1:\r\n\r\n     fn main(){}\r\n\r\nand compile it\r\n\r\n    rustc /home/joe/file1\r\n\r\nIt will replace the source (file1) with a binary called file1, destroying the source without warning or error.\r\n\r\nThis commit completely disallows compiling without a file extension, but still allows compiling with an inccorect (i.e not .rs) extension.\r\n'
17934,'pnkfelix','librustc: Improve method autoderef/deref/index behavior more, and enable IndexMut on mutable vectors.\nlibrustc: Improve method autoderef/deref/index behavior more, and enable IndexMut on mutable vectors.\r\n\r\nThis fixes a bug whereby the mutability fixups for method behavior were\r\nnot kicking in after autoderef failed to happen at any level. It also\r\nadds support for `Index` to the fixer-upper.\r\n\r\nCloses #12825.\r\n\r\nr? @pnkfelix '
17923,'steveklabnik',"The Guide to the Rust Runtime needs to be updated\nAs a consequence of https://github.com/rust-lang/rust/issues/17325 (removing of `libgreen`), the [Guide to the Rust Runtime](http://static.rust-lang.org/doc/master/guide-runtime.html) needs to be updated. Currently, there are many references to `libgreen` thar aren't valid anymore."
17910,'alexcrichton','Update README.md to add 64-bit Windows support.\nAdded 64-bit Windows support to the list of platforms. Support for 64-bit Windows was added in Rust 0.12.0. See  https://mail.mozilla.org/pipermail/rust-dev/2014-October/011267.html for the release notes.'
17903,'steveklabnik',"Guide: show Rust has range comments; doc comments as convention.\nRange comments are much more friendly for writing large blocks of text.\r\nReading the Guide, I was a bit alarmed that Rust might not have them.\r\nSpeaking of, they're very useful for doc comments, which are just a\r\nconvention for formatting comments, not a separate type of comment."
17880,'alexcrichton','librustc: Forbid duplicate name bindings in the same parameter or type\nparameter list.\r\n\r\nThis breaks code like:\r\n\r\n    fn f(a: int, a: int) { ... }\r\n    fn g<T,T>(a: T) { ... }\r\n\r\nChange this code to not use the same name for a parameter. For example:\r\n\r\n    fn f(a: int, b: int) { ... }\r\n    fn g<T,U>(a: T) { ... }\r\n\r\nCode like this is *not* affected, since `_` is not an identifier:\r\n\r\n    fn f(_: int, _: int) { ... } // OK\r\n\r\nCloses #17568.\r\n\r\nr? @alexcrichton \r\n[breaking-change]'
17879,'aturon',"implement Entry API for SmallIntMap\nThe contents of this PR make me legit mad. I really hope that I'm just completely stupid tonight, and there's a way better way to do this. It doesn't help that this API is *basically* pointless to provide on SmallIntMap. But we've gotta provide a uniform interface, so...\r\n\r\nyeah \r\n\r\n:rage:"
17869,'nikomatsakis',"Fix closure upvar soundness bug in regionck\nThis PR is based on #17784, which fixes closure soundness problems in borrowck.  Only the last two commits are unique to this PR.\r\n\r\nMy understanding of regionck is still evolving, so I'm not sure if this is the right approach.  Feedback is appreciated.\r\n\r\n- In `link_reborrowed_region`, we account for the ability of upvars to\r\n  change their mutability due to later processing.  A map of recursive\r\n  region links we may want to establish in the future is maintained,\r\n  with the links being established when the mutability of the borrow\r\n  is adjusted.\r\n- When asked to establish a region link for an upvar, we link it to\r\n  the region of the closure body.  This creates the necessary\r\n  constraint to stop unsound reborrows from the closure environment.\r\n\r\nThis partially (maybe completely) solves issue #17403.  Remaining work:\r\n\r\n- This is only known to help with by-ref upvars.  I have not looked at\r\n  by-value upvars yet to see if they can cause problems.\r\n- The error diagnostics that result from failed region inference are\r\n  pretty inscrutible."
17868,'alexcrichton','Add support for run-pass-valgrind tests\nr? @alexcrichton '
17859,'alexcrichton','enable parallel codegen by default\nEnable parallel codegen (2 units) by default when --opt-level is 0 or 1.  This gives a minor speedup on large crates (~10%), with only a tiny slowdown (~2%) for small ones (which usually build in under a second regardless).  The current default (no parallelization) is used when the user requests optimization (--opt-level 2 or 3), and when the user has enabled LTO (which is incompatible with parallel codegen).\r\n\r\nThis commit also changes the rust build system to use parallel codegen when appropriate.  This means codegen-units=4 for stage0 always, and also for stage1 and stage2 when configured with --release-channel=source.  (Other release channel settings use codegen-units=1 for stage1 and stage2, to get maximum performance for release binaries.)  The build system also sets codegen-units=1 for compiletest tests (compiletest does its own parallelization) and uses the same setting as stage2 for crate tests.  The overall result (for release-channel=source) is 35% reduction in `make all` time, and 25% reduction in `make check` time.\r\n\r\nr? @alexcrichton'
17853,'pcwalton','rustc: Add `const` globals to the language\nThis change is an implementation of [RFC 69][rfc] which adds a third kind of\r\nglobal to the language, `const`. This global is most similar to what the old\r\n`static` was, and if you\'re unsure about what to use then you should use a\r\n`const`.\r\n\r\nThe semantics of these three kinds of globals are:\r\n\r\n* A `const` does not represent a memory location, but only a value. Constants\r\n  are translated as rvalues, which means that their values are directly inlined\r\n  at usage location (similar to a #define in C/C++). Constant values are, well,\r\n  constant, and can not be modified. Any "modification" is actually a\r\n  modification to a local value on the stack rather than the actual constant\r\n  itself.\r\n\r\n  Almost all values are allowed inside constants, whether they have interior\r\n  mutability or not. There are a few minor restrictions listed in the RFC, but\r\n  they should in general not come up too often.\r\n\r\n* A `static` now always represents a memory location (unconditionally). Any\r\n  references to the same `static` are actually a reference to the same memory\r\n  location. Only values whose types ascribe to `Sync` are allowed in a `static`.\r\n  This restriction is in place because many threads may access a `static`\r\n  concurrently. Lifting this restriction (and allowing unsafe access) is a\r\n  future extension not implemented at this time.\r\n\r\n* A `static mut` continues to always represent a memory location. All references\r\n  to a `static mut` continue to be `unsafe`.\r\n\r\nThis is a large breaking change, and many programs will need to be updated\r\naccordingly. A summary of the breaking changes is:\r\n\r\n* Statics may no longer be used in patterns. Statics now always represent a\r\n  memory location, which can sometimes be modified. To fix code, repurpose the\r\n  matched-on-`static` to a `const`.\r\n\r\n      static FOO: uint = 4;\r\n      match n {\r\n          FOO => { /* ... */ }\r\n          _ => { /* ... */ }\r\n      }\r\n\r\n  change this code to:\r\n\r\n      const FOO: uint = 4;\r\n      match n {\r\n          FOO => { /* ... */ }\r\n          _ => { /* ... */ }\r\n      }\r\n\r\n* Statics may no longer refer to other statics by value. Due to statics being\r\n  able to change at runtime, allowing them to reference one another could\r\n  possibly lead to confusing semantics. If you are in this situation, use a\r\n  constant initializer instead. Note, however, that statics may reference other\r\n  statics by address, however.\r\n\r\n* Statics may no longer be used in constant expressions, such as array lengths.\r\n  This is due to the same restrictions as listed above. Use a `const` instead.\r\n\r\n[breaking-change]\r\nCloses #17718 \r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/pull/246'
17843,'brson','Guide: Fix inconsistency in \'Marcos\' section\nThe old version switched in between examples from the value `5i` to `"Hello"` and back.\r\n\r\nAdditionally, the code generated by `rustc print.rs --pretty=expanded` is not as verbose anymore.'
17837,'thestinger',"use saner parameter order for reallocate / reallocate_inplace\nI wasn't really thinking about it when I added the `old_size` parameter and just put it at the end since it was a new addition. It would be better to match the order used by other APIs like `mremap` by putting the old size before the new size because it's more intuitive (old_ptr, old_size, new_size)."
17836,'huonw','Guide: Clarify that assigning/comparing different tuple types doesn\'t work\nCurrently, the Guide says tuples "are only equivalent if the arity, types, and values are all identical", before presenting an example that uses `==` to compare two tuples whose arity and contained types match. This is misleading, because it implies that `==` can dynamically check whether two tuples have the same arity and contained types, whereas trying to do this would lead to a compiler error.\r\n\r\nI tried to avoid destroying the flow of this section, but I\'m not sure if I\'ve been successful.'
17827,'aturon','identify traits in libstd that should use multidispatch \nas a subtask of #17307, once the multi-dispatch part of associated types is implemented, we will want to update libstd to use it.\r\n\r\nMy google doc from #17826 includes a column for multidispatch; I copied the link again below.\r\n\r\nUnsurprisingly, the vast majority of the cases I identified were in the `core::ops` numeric traits, though there may also be candidates in `librand` and *maybe* `core::iter`.\r\n\r\nhttps://docs.google.com/spreadsheets/d/1Y_NAgzEK3FWcG0LjcykyKJEAibSFI3w-v-ekZ4GU8n4/edit?usp=sharing'
17815,'brson',"Bug fixes for struct+enum representability check\nThe representability-checking routine ```is_type_representable``` failed to detect structural recursion in some cases, leading to stack overflow later on.\r\n\r\nThe first problem was in the loop in the ```find_nonrepresentable``` function. We were improperly terminating the iteration if we saw a ```ContainsRecursive``` condition. We should have kept going in case a later member of the struct (or enum, etc) being examined was ```SelfRecursive```. The example from #17431 triggered this issue:\r\n\r\n```rust\r\nuse std::sync::Mutex;\r\nstruct Foo { foo: Mutex<Option<Foo>> }\r\nimpl Foo { fn bar(self) {} }\r\nfn main() {}\r\n```\r\n\r\nI'm not 100% sure, but I think the ```ty_enum``` case of ```fn type_structurally_recursive``` had a similar problem, since it could ```break``` on ```ContainsRecursive``` before looking at all variants. I've replaced this with a ```flat_map``` call.\r\n\r\nThe second problem was that we were failing to identify code like ```struct Foo { foo: Option<Option<Foo>> }``` as SelfRecursive, even though we correctly identified ```struct Foo { foo: Option<Foo> }```. This was caused by using DefId's for the ```ContainsRecursive``` check, which meant the nested ```Option```s were identified as illegally recursive (because ```ContainsRecursive``` is not an error, we would then keep compiling and eventually hit a stack overflow).\r\n\r\nIn order to make sure that we can recurse through the different ```Option``` invocations, I've changed the type of ```seen``` from ```Vec<DefId>``` to ```Vec<t>``` and added a separate ```same_type``` function to check whether two types are the same when generics are taken into account. Now we only return ```ContainsRecursive``` when this stricter check is satisfied. (There's probably a better way to do this, and I'm not sure my code is entirely correct--but my knowledge of rustc internals is pretty limited, so any help here would be appreciated!)\r\n\r\nNote that the ```SelfRecursive``` check is still comparing ```DefId```s--this is necessary to prevent code like this from being allowed:\r\n\r\n```rust\r\nstruct Foo { x: Bar<Foo> }\r\nstruct Bar<T> { x: Bar<Foo> }\r\n```\r\n\r\nAll four of the new ```issue-17431``` tests cause infinite recursion on master, and errors with this pull request. I wrote the extra ```issue-3008-4.rs``` test to make sure I wasn't introducing a regression.\r\n\r\nFixes #17431."
17807,'aturon','Slicing renaming and feature gating\nr? @aturon'
17805,'alexcrichton','Add ability to change memory protection on std::os::MemoryMap.\n'
17799,'aturon','Fix cfg syntax warnings in libnative\nProbably fallen through the cracks in #17630.'
17793,'huonw',"Fix target-feature codegen option syntax in rustc man page.\nThe man page stated that the list of features was space-separated when\r\nit's actually comma-separated."
17777,'alexcrichton','docs: Fix short hash link to github\nThe escaped newline in the middle of the variable reference breaks the\r\nshort hash substitution, leaving the link text exmpty; rewrap so that\r\neach replacement is on its own line.'
17774,'alexcrichton','docs: Reference hoedown instead of sundown\nRust 0.11.0 switched from sundown to the actively maintained hoedown; update the rustdoc documention to mention this.'
17766,'brson','Make examples for AtomicInt refer to AtomicInt\nThe examples for fetch_or, fetch_and and fetch_xor for\r\nstd::sync::atomic::AtomicInt used AtomicUint instead of AtomicInt.'
17762,'nick29581','Fix ICE generating drop glue for `Box<str>`\nCloses issue #17734\r\n\r\nr? @nick29581 '
17754,'steveklabnik','Just a few minor updates to guide.md\nHi,\r\n\r\nThese are a few small edits to the Guide that I made while reading online. Really well done and approachable.\r\n\r\nI have a few questions below, but I don\'t know if this is the proper place to ask them, so feel free to ignore the below.\r\n\r\n1. Trailing commas seem to be a convention in Rust and are used quite a bit throughout the Guide, but are never explicitly mentioned. Maybe adding a short mention about them when they first appear in the Structs section might be helpful to those who are unfamiliar with or don\'t use them in other languages.\r\n\r\n2. In the Iterators section, there is a block of code like this:\r\n\r\n```rust\r\nlet mut range = range(0i, 10i);\r\n\r\nloop {\r\n    match range.next() {\r\n        Some(x) => {\r\n            println!("{}", x);\r\n        }  // no comma needed?\r\n        None => { break }\r\n    }\r\n}\r\n```\r\n\r\nMy inclination would be to put a comma where the comment is to separate the two arms to get this to compile, but it runs fine either way. Is there a convention on commas for scenarios like this where each arm is enclosed in `{}`?\r\n\r\nAll the best,\r\nO-I'
17750,'nick29581',"DST: cannot provide inherent impl for traits\nThis code:\r\n\r\n```rust\r\ntrait Foo {}\r\n\r\nimpl Foo {\r\n    fn foo(&self) {}\r\n}\r\n```\r\n\r\ngenerates this error:\r\n\r\n```\r\nimpl-dst.rs:3:1: 5:2 error: duplicate definition of type or module `Foo`\r\nimpl-dst.rs:3 impl Foo {\r\nimpl-dst.rs:4     fn foo(&self) {}\r\nimpl-dst.rs:5 }\r\nimpl-dst.rs:1:1: 1:13 note: first definition of type or module `Foo` here\r\nimpl-dst.rs:1 trait Foo {}\r\n              ^~~~~~~~~~~~\r\n```\r\n\r\nI couldn't find any existing issue on this, but this is expected to work, right?"
17747,'aturon',"Implement error interoperation\nTracking issue for https://github.com/rust-lang/rfcs/pull/201\r\n\r\nI'm not nominating this because this is a library issue, which is handled with stabilization rather than nomination."
17735,'nikomatsakis','Update\nUpdate'
17724,'nick29581',"This is a test don't land!\nr? @nick29581"
17718,'alexcrichton','Implement global constants, alter the meaning of `static`\nTracking issue for https://github.com/rust-lang/rfcs/pull/246\r\n\r\nNominating'
17704,'nikomatsakis','implement new object safety rules\nr? @nikomatsakis '
17703,'nikomatsakis',"unboxed closure sugar not working in trait objects\n#17041 implemented unboxed closure sugar parsing for trait bounds, but it doesn't seem to be implemented for trait objects.\r\n\r\nI realize that this example probably wouldn't work anyway due to the lack of [higher-rank lifetimes](https://github.com/rust-lang/rust/issues/15067), but the point is that the compiler yields a parser error.\r\n\r\n[playpen sample](http://is.gd/XyeDz2)\r\n\r\n``` rust\r\ntrait Router {\r\n  fn route(&mut self, p: &Path) -> Path;\r\n}\r\n\r\nimpl<'a> Router for Box<FnMut(&'a Path) -> Path + 'a> {\r\n  fn route(&mut self, p: &Path) -> Path {\r\n    (*self).call_mut((p,))\r\n  }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\n@p1start observed this as well."
17698,'aturon',"Guide: clarify exporting\nMention that using `pub` is called exporting.\r\n\r\nRemove that `use` is called re-exporting, because `pub use` should be\r\ncalled re-exporting. The guide currently doesn't cover `pub use`."
17681,'alexcrichton','Teach --dep-info how to escape filenames containing spaces\ncc #17627 '
17670,'nick29581','Tracking issue for enforcing object safety when coercing to an object\nRFC PR: https://github.com/rust-lang/rfcs/pull/255'
17661,'nikomatsakis','Implement higher-ranked trait bounds\nThis is on the 1.0 schedule, but there is no issue and no RFC.'
17653,'alexcrichton','Closes #12660 and #16973 (ICE)\nFixes that unit-like structs cannot be used if they are re-exported and used in another crate. (ICE)\r\nThe relevant changes are in `rustc::metadata::{decoder, encoder}` and `rustc::middle::ty`.\r\n\r\nA test case is included.\r\n\r\nThe problem is that the expressoin `UnitStruct` is an `ExprPath` to an `DefFn`, which is of expr kind `RvalueDatumExpr`, but for unit-struct ctors the expr kind should be `RvalueDpsExpr`. I fixed this (in a I guess clean way) by introducing `CtorFn` in the metadata and including a `is_ctor` flag in `DefFn`.'
17644,'alexcrichton','Merge pull request #1 from rust-lang/master\nUpdate'
17625,'aturon',"Update ANTLR float suffix grammar\n- Removes `f128` from the grammar, which is no longer supported in rustc\r\n- The `fragment` modifier is added so it won't parse a float suffix as a separate token (this fixes an issue in [VisualRust](https://github.com/PistonDevelopers/VisualRust), where the ANTLR lexer is used for syntax highlighting)"
17619,'huonw',"rustc: Fix permission denied error in 'ar' when lto is enabled\nThe reason that 'ar' can fail with permission denied is that when\r\nlink-time optimizations are enabled, rustc copies libraries into a\r\ntemporary directory, preserving file permissions, and subsequently\r\nmodifies them using 'ar'.\r\n\r\nThe modification can fail because some package managers may install\r\nlibraries in system directories as read-only files, which means the\r\ntemporary file also becomes read-only when it is copied.\r\n\r\nI have fixed this by giving the temporary file's owner read+write\r\npermissions after the copy.\r\n\r\nI have also added a regression test for this issue."
17603,'nikomatsakis','Remove ty_bot from the type system\nWe now instead use a fresh variable for expressions that diverge.\r\n\r\nCloses #14973.\r\nCloses #13847.\r\n\r\n[Work in progress]\r\n\r\ncc @nikomatsakis'
17601,'alexcrichton','Remove `Select` structure; implement inline `select!` macro\nThe old `Select` structure was very inefficient and required the user\r\nto use unsafe code (and manually maintain a "this variable will never\r\nmove" invariant). Searching through several popular repositories, the\r\nonly instance I found of it being used was in servo --- to avoid the\r\nsetup cost of putting `select!` in a loop, which would create a new\r\n`Select` on every iteration.\r\n\r\nThis commit deletes the `Select` structure entirely and moves all of\r\nits code into the `select!` macro. The benefit of this is that there\r\nis no more need for allocations, no more need for unsafe code, and\r\nno setup costs (so servo can now use `select!` directly).\r\n\r\nThis also changes the interface to select! to fix #12902.\r\n\r\nFixes #12902.\r\n\r\n[breaking-change]'
17598,'nick29581','Reject casts to unsized types\nThis closes issue #17441 and generally gives more helpful diagnostics.'
17589,'aturon','Uppercase errors in std::io::fs\n'
17581,'alexcrichton','Implement `entry_equiv` for HashMap\n'
17580,'nick29581','migrate libnum issues to the new repository\nhttps://github.com/rust-lang/num\r\n\r\n* https://github.com/rust-lang/rust/issues/8937\r\n* https://github.com/rust-lang/rust/issues/13555\r\n* https://github.com/rust-lang/rust/issues/11749\r\n* https://github.com/rust-lang/rust/issues/16782\r\n* https://github.com/rust-lang/rust/issues/16386\r\n* https://github.com/rust-lang/rust/issues/8466\r\n* https://github.com/rust-lang/rust/issues/5738'
17577,'pcwalton','Correct stability marker in string.rs\n'
17565,'nikomatsakis',"tiny linguistic correction in docs: s/its'/its/\nSee e.g.: http://dictionary.reference.com/browse/its"
17556,'brson','Higher Kinded Types (WIP)\nMy initial attempts at adding higher kinded types to the type system.'
17544,'nikomatsakis','fix a misspelling in the configure script\nHi, this fixes a simple misspelling in the configure script.'
17508,'pnkfelix','Stability lint for nested macros\nFinishes the job of #17286.\r\n\r\nNow the stability lint will successfully detect patterns such as:\r\n```\r\nfirst_macro!(second_macro!(deprecated_function()));\r\n```\r\n```\r\nmacro_rules! foo (\r\n    ($e: expr) => (bar!($e))\r\n)\r\nfoo!(deprected_function());\r\n```\r\nand\r\n```\r\nprintln!("{}", deprecated_function());\r\n```\r\neven with more levels of nesting, such as\r\n```\r\nprintln!("{}", foo!(bar!(deprecated_function())));\r\n```'
17496,'nick29581',"make release builds the default\nThis cuts the compilation time for a trivial Rust program by 15-20% on\r\nWindows due to a massive improvement in `rustc` start-up time. The debug\r\nlogging has a very high cost because it makes extensive use of mutable\r\nglobal variables and those result in expensive relocations.\r\n\r\nCreating debug builds by default discourages the usage of debug\r\nassertions. The few debug assertions not removed before landing a pull\r\nrequest are a significant performance problem for types like `RefCell`.\r\n\r\nThe defaults should cater to users or packagers building Rust rather\r\nthan compiler developers. A compiler developer can be expected to\r\noverride a default flag, but the same cannot be said of someone who\r\nlacks the same in-depth knowledge of the project.\r\n\r\nEven someone working on the standard libraries is not going to want to\r\npay the high cost for debug logging. Many people who contribute to the\r\ncompiler don't use the feature either, because a debugger tends to work\r\na lot better than inconsistent / bit-rotted logging code.\r\n"
17490,'sfackler','Overhaul the `#[cfg(..)]` pattern syntax\nTracking issue for https://github.com/rust-lang/rfcs/pull/194.\r\n\r\nNominating as the changes are backwards-incompatible.'
17489,'steveklabnik','Rename task failure to task panic\nTracking issue for https://github.com/rust-lang/rfcs/pull/221\r\n\r\nNominating, as renaming the `fail!` macro to `panic!` is backwards incompatible. I believe updating all the documentation does not necessarily need to block 1.0.'
17403,'zwarich','Aliasing rules are broken for closures\nThis compiles and runs:\r\n```rust\r\nlet mut v = vec![0i];\r\nlet f = |i: uint| v.get_mut(i);\r\nlet x = f(0);\r\nlet y = f(0);\r\n(*x,*y)\r\n```\r\n`x` and `y` are not supposed to live at the same time. Results in an UB (in a more complex case)\r\nRust:\r\n>rustc 0.12.0-nightly (af3889f69 2014-09-18 21:20:38 +0000)'
17402,'nikomatsakis',"Update manual\nBecause I'm still :mask: :mask: :mask: , I figured some mindless tasks would be better than trying to finish the ownership guide. \r\n\r\nThe manual has long been waiting for some :heart: :heart: :heart: , and so I gave it a quick once-over. I made small commits in case any of the changes are a bit weird, I mostly did a few things:\r\n\r\n1. changed 'manual' to 'reference.' I feel like this name is better. If it's not, It's not a huge deal. it shouldn't be `rust.md` though.\r\n2. word wrapped everything appropriately. Changes 1&2 are in the first commit, so that its' easier to see the changes in the later ones.\r\n3. fixed other small style issues\r\n4. removed references to things that are in the standard library, and not the language itself\r\n\r\nThere's still lots of gross in here, but I didn't want to pile on too too many changes.\r\n\r\n/cc @brson @nikomatsakis "
17388,'nikomatsakis',"ICE with associated types: unbound path\nThe version is `rustc 0.12.0-nightly (9508faa22 2014-09-17 23:45:36 +0000)`\r\n\r\nCode:\r\n```\r\ntrait Foo<T> {\r\n    type Bar;\r\n    fn get_bar() -> <Self as Foo<T>>::Bar;\r\n}\r\n```\r\n\r\nError:\r\n```\r\nC:\\Users\\Tomaka17\\Projets\\test\\src\\main.rs:5:34: 5:35 error: internal compiler e\r\nrror: unbound path path(T)\r\nC:\\Users\\Tomaka17\\Projets\\test\\src\\main.rs:5     fn get_bar() -> <Self as Foo<T>\r\n>::Bar;\r\n                                                                              ^\r\nnote: the compiler hit an unexpected failure path. this is a bug.\r\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugr\r\neport.html\r\nnote: run with `RUST_BACKTRACE=1` for a backtrace\r\ntask 'rustc' failed at 'Box<Any>', C:\\bot\\slave\\nightly-win32\\build\\src\\libsynta\r\nx\\ast_util.rs:751\r\n```\r\n\r\n(because of some issues with my shell I can't print a backtrace for now)\r\n"
17387,'huonw',"Include ChaCha pseudorandom generator\nThis commit introduces a [ChaCha](http://cr.yp.to/chacha.html)-based pseudorandom number generator to librand. Here's why I prefer it to the default, ISAAC:\r\n\r\n - While ISAAC is meant to be cryptographically secure, it stands on relatively shaky ground. Its design is inspired by the much-maligned RC4, and the [existing analysis](https://eprint.iacr.org/2006/438) reveals some suboptimal properties, although not particularly devastating. ISAAC64, the default on 64-bit architectures, doesn't seem to have been analyzed at all.\r\n - ISAAC has large storage requirements. An ISAAC64 state consumes 4128 bytes, which is ~12.5% of a typical CPU's L1 cache. This ChaCha implementation consumes 136 bytes, and can be further reduced to 105, at the cost of slightly higher implementation complexity. The performance impact of cache hoarding is hard to demonstrate in synthetic benchmarks.\r\n - ISAAC is inherently sequential, and its speed is somewhat limited by data-dependent memory accesses, not unlike RC4. ChaCha, on the other hand, is not and can be vectorized easily for significant speedups, at the cost of larger state. \r\n\r\nIn my tests, an SSE2 (using only what `#[simd]` types allow at the moment) ChaCha20 roughly matches ISAAC in speed, and an AVX2 implementation matches ISAAC64. Better SIMD support (particularly shuffles) would improve these results further. \r\n\r\nI'm currently using the 20-round ChaCha, as originally specified. However, 12 and 8-round variants are also possible (and [believed to be](https://eprint.iacr.org/2007/472) [secure](http://link.springer.com/chapter/10.1007%2F978-3-642-37682-5_24)), and those would provide an additional speedup factor of roughly 20/{12,8}. I have not included SIMD implementations in this commit to avoid the complexity of figuring out which instruction set to use."
17352,'brson','rustc no longer prints the version number\n```\r\nrustc  (b88d1030e 2014-09-17 18:26:14 +0000)\r\n```'
17325,'aturon','Remove libgreen and runtime abstractions\nTracking https://github.com/rust-lang/rfcs/pull/230'
17273,'nick29581',"Merge the slice methods from ops::Slice with methods in core::slice\nNeeds a snapshot so we can use indexing, otherwise there's a bunch of changes to something ugly which will change again post-snapshot."
17178,'nick29581','Unify unsized types in type inference\nIn order not have a tonne of coherence errors, we currently do not unify unsized types with type variables in type inference. For example, `[T]` with `U`. This mimics our old behaviour where unsized types were not types.\r\n\r\nThis prevents us having an impl for `&T` which will use an impl for `[T]`, i.e., we need a separate impl for `&[T]`. This is one of the primary benefits of DST. It also causes problems when the compiler needs to infer a DST for a type parameter, e.g., in function calls. See #17122 for one example.\r\n\r\nBlocks #16918, #12938'
17092,'thestinger','optimize dynamic allocation alignment\nThe non-jemalloc allocator implementation should branch on the Rust end in order to use `malloc` / `realloc` / `free`. It will optimize out in essentially every real-world case, since alignment is rarely dynamic.\r\n\r\nExposing functions without the alignment parameter may also make sense, and having a branch on the Rust side for jemalloc would eliminate a branch for the low alignment case inside the allocator.'
17009,'pnkfelix','Avoid building as root with `sudo make install`\nWhen running `sudo make install`, we only want to run the actual install\r\nas root, the building of the documentation and the distribution folder\r\nshould happen as the non-root user.\r\n\r\nRelated to #13728.'
16810,'aturon','Implement conventions for ownership variants\nTracking RFC for https://github.com/rust-lang/rfcs/pull/199'
16649,'brson','Outdated nightlies on Travis-CI\n@brson, is Cloudfront (that we seem to be using for HTTPS) doing any caching? I’m somehow getting an outdated Cargo nigthly (2014-08-19 instead of 2014-08-20) on Travis-CI https://travis-ci.org/servo/rust-url/builds/33162181\r\n\r\nThe other suspect is Travis, if they’re doing caching themselves.'
16545,'aturon','Lint warning names should be more consistent\nI noticed some inconsistencies in the naming of compiler warnings. For example, compare:\r\n\r\n```rust\r\n#[allow(unused_variable)]\r\n#[allow(unused_imports)]\r\n#[allow(unused_attribute)]\r\n#[allow(non_snake_case_functions)]\r\n#[allow(uppercase_variables)]\r\n```\r\n\r\nThis jumps back and forth between singular and plural. `uppercase` also feels a bit inconsistent with `snake_case` and `camel_case`, but it\'s less clear-cut. Maybe `non_snakecase_functions` would make the grouping more obvious than `non_snake_case_functions`, to avoid the parse error "non-snake case-functions".\r\n\r\nPerhaps part of the reason for the inconsistency is that the warning names are scattered across `lint/builtin.rs`, which doesn\'t make it easy for contributors to have a global view in mind.'
16489,'brson','nightly-mac bot is regularly segfaulting\nlogs: http://buildbot.rust-lang.org/builders/nightly-mac\r\n\r\nrelevant bits:\r\n\r\n```\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/libcore\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/liblibc\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/libcore\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/liblibc\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/librand\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/liballoc\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/libunicode\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/librand\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/liballoc\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/libunicode\r\nrustc: x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/libcollections\r\nmake: *** [x86_64-apple-darwin/stage1/lib/rustlib/i686-apple-darwin/lib/stamp.rand] Segmentation fault: 11 (core dumped)\r\nmake: *** Waiting for unfinished jobs....\r\n```\r\n\r\nI wish I knew more sadly :('
16457,'brson',"Run full test suite on windows bots\nWe can't seriously have full support without running the tests. Nominating."
16312,'brson','Set up automation for 64-bit windows\n64-bit windows support is in-tree. We need to update the bots to support it properly. Nominating.\r\n\r\n* [x] auto builds\r\n* [x] snapshots\r\n* [x] nightlies\r\n* [x] dist\r\n* [x] try'
16123,'brson','rust-lang.org, the nightly archives, and rustup.sh should be served over https\nI just noticed that the rust-lang.org, the nighty archives, and rustup.sh are not being served over https. We should set this up to protect users from man-in-the-middle attacks. Nominating for this to be done before we release 1.0.\r\n\r\n* [x] set up https for static.rust-lang.org\r\n* [x] change binary links on website\r\n* [x] change binary links on wiki\r\n* [x] change binary links in docs\r\n* [x] change rustup links in docs\r\n* [x] modify rustup.sh to download over ssl\r\n* [x] move rustup.sh to static.rust-lang.org\r\n* [x] deprecate www.rust-lang.org/rustup.sh\r\n* [x] change makefiles to download snapshots over ssl?'
16094,'zwarich','Remove special borrowck treatment of Box\nhttps://github.com/rust-lang/rfcs/pull/130'
15887,'cmr',"Trailing comma in method definition doesn't parse\n```Rust\r\nfn bar(a: int,) {}\r\nstruct Foo;\r\nimpl Foo {\r\n    fn bar(a: int,) {} //~ error: unexpected token: `)`\r\n}\r\n```\r\nIt works for functions—it should also work for methods.\r\nMay be related to #14240.\r\n"
15711,'brson',"Version of 'make dist' that produces cross-compiler snapshots\nCurrently, Servo uses snapshots generated from `make dist`. This works great for self-targeting builds, but there's no support today for generating cross-compilation snapshots. This feature is required to support Servo Android test machines on Travis CI.\r\n\r\nI see that `make install` handles cross-compilation:\r\nhttps://github.com/rust-lang/rust/pull/13314\r\n\r\nIt would be great if there were a different `make dist` (`make dist-all-the-targets`?), too, to support this scenario."
15517,'nikomatsakis',"Matching of `Self` doesn't take lifetime parameters into account\nThe following code compiles:\r\n\r\n    struct Foo<'a,'b> {\r\n        x: &'a int,\r\n        y: &'b int,\r\n    }\r\n\r\n    trait Tr {\r\n        fn foo(x: Self) {}\r\n    }\r\n\r\n    impl<'a,'b> Tr for Foo<'a,'b> {\r\n        fn foo(x: Foo<'b,'a>) {} // <-- bad\r\n    }\r\n\r\n    fn main(){}\r\n\r\nNominating for 1.0, P-backcompat-lang. I may well just fix this along with #14022, since the solution is likely going to be similar to what @nikomatsakis pointed out, but I want to get it on the radar."
15177,'thestinger','read_to_end is very slow (>30x slower than 0.10)\nmaster:\r\n```\r\n    #[bench]\r\n    fn read_to_end(b: &mut Bencher) {\r\n        let bytes = Vec::from_elem(100, 10u8);\r\n        b.iter(|| {\r\n            let mut reader = BufReader::new(bytes.as_slice());\r\n            black_box(reader.read_to_end())\r\n        })\r\n    }\r\n```\r\n```\r\nrunning 1 test\r\ntest bench::read_to_end ... bench:      2534 ns/iter (+/- 88)\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\r\n```\r\n\r\n0.10:\r\n```\r\n    #[bench]\r\n    fn read_to_end(b: &mut BenchHarness) {\r\n        let bytes = Vec::from_elem(100, 10u8);\r\n        b.iter(|| {\r\n            let mut reader = BufReader::new(bytes.as_slice());\r\n            black_box(reader.read_to_end())\r\n        })\r\n    }\r\n```\r\n```\r\nrunning 1 test\r\ntest bench::read_to_end ... bench:        80 ns/iter (+/- 1)\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 1 measured\r\n```'
14987,'sfackler','Tracking issue for adding partial_cmp to PartialOrd\nTracking issue for https://github.com/rust-lang/rfcs/pull/100.\r\n\r\nNominating.'
14684,'zwarich',"Mutating matched value in pattern guard causes segfault in safe code\nThe following example causes a segfault for me on OS X / x86_64:\r\n\r\n```rust\r\nenum Enum<'a> {\r\n    A(&'a int),\r\n    B(bool),\r\n}\r\n\r\nfn foo() -> int {\r\n    let mut n = 42;\r\n    let mut x = A(&mut n);\r\n    match x {\r\n        A(_) if { x = B(false); false } => 1,\r\n        A(p) => *p,\r\n        B(_) => 2,\r\n    }\r\n}\r\n\r\nfn main() {\r\n    foo();\r\n}\r\n```"
14587,'nikomatsakis','Binding subpattern with @ allows for illegal mutation\n```\r\nfn main() {\r\n    match &mut Some(1) {\r\n        ref mut z @ &Some(ref a) => {\r\n            **z = None;\r\n            println!("{}", *a);\r\n        }\r\n        _ => ()\r\n    }\r\n}\r\n```\r\nThis code compiles even though it should be rejected since writing to z invalidates the a variable.'
14470,'alexcrichton',"Eliminate crate_id's\ncc https://github.com/mozilla/rust/issues/14468\r\n\r\nCompletely remove the concept of `crate_id`s. In a cargo world, nothing but the crate name matters to rustc. It's not clear yet whether `crate_id` needs to be replaced with `crate_name`, or whether rustc can get by without any of this metadata.\r\n\r\nNominating."
14468,'alexcrichton','Remove crate_id support from `extern crate`\nIt looks like crate ID\'s are unlikely to carry over into the cargo world. Right now our `extern crate` syntax supports a form like\r\n\r\n```\r\nextern crate foo = "foo:1.0#path"; // or something similar\r\n```\r\n\r\nRemove the `= "string"` syntax.\r\n\r\nBecause we do still need to support renaming, add something like the following:\r\n\r\n```\r\nextern crate foo = bar;\r\n```\r\n\r\nNominating.'
14309,'cmr','Tracking bug for RFC 18 - undefined struct layout\nhttps://github.com/rust-lang/rfcs/pull/79\r\n\r\nNominating.'
14240,'cmr','Trailing comma in method call doesn’t parse\n```rust\r\nfn main() {\r\n    bar(baz,);\r\n    foo::bar(baz,);\r\n    foo.bar(baz,);  //~ ERROR unexpected token: `)`\r\n}\r\n```\r\n\r\nIt works for functions and static methods—it should also work for instance methods.'
14117,'thestinger','use the glibc malloc hooks to replace the libc allocator on Linux\nOn Linux, we can replace the glibc allocator via [the malloc hooks](https://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html). This will reduce external fragmentation by moving allocation used by C libraries to jemalloc.'
13660,'aturon','Inconsistent naming of mut methods (get_mut vs. mut_iter)\nThe Rust stdlib sometimes uses prefix `mut_` and other times suffix `_mut`.  This is a really minor papercut, but it does cause me to mistype names on a regular basis.\r\n\r\nFor example, we have:\r\n```\r\nfind_mut\r\nget_mut\r\nfront_mut\r\nback_mut\r\nborrow_mut\r\n```\r\n...but also:\r\n```\r\nmut_iter\r\nmut_slice\r\nmut_last\r\nmut_split_at\r\n```'
13559,'nikomatsakis',"Remove special root for `@`\nThis patch removes the special auto-rooting for `@` from the borrow checker. With `@` moving into a library, it doesn't make sense to keep this code around anymore. It also simplifies `trans` by removing root checking from there \r\n\r\n@nikomatsakis\r\n\r\nCloses: #11586"
13542,'nikomatsakis','Tighten up the auto-deref algorithm\n@nikomatsakis has mentioned that it has some unpredictable interactions with type checking. Hard to spec and understand as-is. Nominating.'
13503,'nikomatsakis',"Combine lifetime parameters when instantiating default methods\nWhen instantiating trait default methods for certain implementation,\r\n`typeck` correctly combined type parameters from trait bound with those\r\nfrom method bound, but didn't do so for lifetime parameters. Applies\r\nthe same logic to lifetime parameters.\r\n\r\nCloses #13204"
13501,'brson','rustc.exe depends on winpthreads\nBuildbot seems to use mingw-w64 package from mingw-builds with "thread=posix" option. In this setting, `libstdc++-6.dll` depends on `libwinpthread-1.dll`. Thus llvm binaries and rustc.exe/rustdoc.exe depend on it.\r\nThe dependency can be dropped by re-installing mingw-builds with "thread=win32" option.\r\n\r\ncc @brson @vadimcn'
13398,'nikomatsakis','DST syntax\nNow with proper checking of enums and allows unsized fields as the last field in a struct or variant. This PR only checks passing of unsized types and distinguishing them from sized ones. To be safe we also need to control storage.\r\n\r\nCloses issues #12969 and #13121, supersedes #13375 (all the discussion there is valid here too).'
13259,'brson','libnative: main task has bad thread local data on windows\nMore investigation from #13073.\r\n\r\n```Rust\r\nextern crate native;\r\nextern crate green;\r\nextern crate rustuv;\r\n\r\nuse std::libc::{c_void, LPWSTR, LPVOID, DWORD};\r\n\r\nextern "system" {\r\n    fn MessageBoxA(hWnd: u32, lpText: *u8, lpCaption: *u8, uType: u32) -> i32;\r\n\r\n    fn FormatMessageW(flags: DWORD,\r\n                      lpSrc: LPVOID,\r\n                      msgId: DWORD,\r\n                      langId: DWORD,\r\n                      buf: LPWSTR,\r\n                      nsize: DWORD,\r\n                      args: *c_void)\r\n                      -> DWORD;\r\n\r\n    fn GetLastError() -> u32;\r\n}\r\n\r\nfn test() {\r\n    let mut buf: [u16, ..50] = [0, ..50];\r\n    let ret = unsafe {\r\n        FormatMessageW(0x1000, 0 as *mut c_void, 1, 0x400,\r\n                       buf.as_mut_ptr(), buf.len() as u32, 0 as *c_void)\r\n    };\r\n    if ret == 0 {\r\n        let err = unsafe { GetLastError() };\r\n        println!("err: {:?}", err);\r\n    }\r\n    let s = std::str::from_utf16(buf);\r\n    println!("{:?}", s);\r\n\r\n    //unsafe {\r\n    //    MessageBoxA(0, "ABC".as_ptr(), "ABC".as_ptr(), 0);\r\n    //}\r\n}\r\n\r\nfn main() {\r\n    if cfg!(spawn) {\r\n        spawn(proc() {\r\n            test();\r\n        });\r\n    } else {\r\n        test();\r\n    }\r\n}\r\n\r\n#[start]\r\npub fn start(argc: int, argv: **u8) -> int {\r\n    if cfg!(green) {\r\n        green::start(argc, argv, rustuv::event_loop, main)\r\n    } else if cfg!(raw) {\r\n        main();\r\n        0\r\n    } else {\r\n        native::start(argc, argv, main)\r\n    }\r\n}\r\n```\r\n\r\nIf the code is bulit with `--cfg green`, `--cfg raw` or `--cfg spawn`, it works as expected. However, if it is built with no cfg, it behaves strangely: `FormatMessageW()` fails to get system locale mssage, and `MessageBoxA()` shows gui message box with non-system-themed border.\r\n\r\nI guess the main task has bad thread-local data due to `libnative::start()`.\r\n\r\ncc @alexcrichton'
13250,'brson',"Cannot run make '/bin/sh: 1: : Permission denied'\nHere's the sequence of events that lead up to the error:\r\n1. I updated a dirty directory to the newest master via `git pull` this morning to commit b8ef9fd9c9f642ce7b8aed82782a1ed745d08d64\r\n2. I ran `make -j8 || make -j8`\r\n3. I ran `sudo make install`\r\n\r\nAt this point I was greeted with:\r\n~~~\r\n/bin/sh: 1: : Permission denied\r\ncfg: build triple \r\ncfg: host triples \r\ncfg: target triples \r\ncfg: enabling more debugging (CFG_ENABLE_DEBUG)\r\ncfg: using \r\nmk/platform.mk:131: *** please try on a system with gcc or clang.  Stop.\r\n~~~\r\n\r\nInvoking `make` again (even under `sudo`) produces the same set of messages.\r\n\r\nOS: Ubuntu 13.10"
13192,'brson','DESTDIR currently broken\nRunning `make install` with `DESTDIR` no longer works.'
13190,'brson','make; sudo make install leaves files owned by root\nrunning:\r\nmake\r\nmake check\r\nsudo make install\r\n\r\nleaves:\r\n./config.tmp\r\n./tmp/dist\r\n\r\nowned by root in the build directory.\r\n'
13128,'brson','`make install` is broken\nHello,\r\n\r\nLooks like `make install` is broken:\r\n\r\n```\r\nmake install\r\ncfg: build triple x86_64-unknown-linux-gnu\r\ncfg: host triples x86_64-unknown-linux-gnu\r\ncfg: target triples x86_64-unknown-linux-gnu\r\ncfg: enabling more debugging (CFG_ENABLE_DEBUG)\r\ncfg: host for x86_64-unknown-linux-gnu is x86_64\r\ncfg: os for x86_64-unknown-linux-gnu is unknown-linux-gnu\r\ncfg: using gcc\r\ncfg: no llnextgen found, omitting grammar-verification\r\ncfg: including prepare rules\r\ncfg: including install rules\r\nmake: *** No rule to make target `prepare-everything\', needed by `install\'.  Stop.\r\n```\r\n\r\n```\r\nfind . -name \'*\'|xargs egrep \'prepare\\-everything\'\r\n./mk/install.mk:install: prepare-everything\r\n...\r\n```\r\ndigging a bit:\r\n\r\n```\r\ncommit d62163188a21e5afc3d0f476eaf7856d91f715b2\r\nAuthor: Brian Anderson <banderson@mozilla.com>\r\nDate:   Mon Mar 24 12:04:27 2014 -0700\r\n\r\n    Revert "mk: Run \'make install\' through install.sh"\r\n    \r\n    This reverts commit e93709a911637194835268420e67d768ee19b5df.\r\n```\r\n\r\nand\r\n\r\n```\r\ngit diff c796f89dbc3e61845d1e44d117acc471f583c417 d62163188a21e5afc3d0f476eaf7856d91f715b2 |less\r\n...\r\n+install: PREPARE_HOST=$(CFG_BUILD)\r\n+install: PREPARE_TARGETS=$(CFG_TARGET)\r\n+install: PREPARE_DIR_CMD=$(DEFAULT_PREPARE_DIR_CMD)\r\n+install: PREPARE_BIN_CMD=$(DEFAULT_PREPARE_BIN_CMD)\r\n+install: PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\r\n+install: PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\r\n+install: PREPARE_SOURCE_DIR=$(PREPARE_HOST)/stage$(PREPARE_STAGE)\r\n+install: PREPARE_SOURCE_BIN_DIR=$(PREPARE_SOURCE_DIR)/bin\r\n+install: PREPARE_SOURCE_LIB_DIR=$(PREPARE_SOURCE_DIR)/$(CFG_LIBDIR_RELATIVE)\r\n+install: PREPARE_SOURCE_MAN_DIR=$(S)/man\r\n+install: PREPARE_DEST_BIN_DIR=$(DESTDIR)$(CFG_PREFIX)/bin\r\n+install: PREPARE_DEST_LIB_DIR=$(DESTDIR)$(CFG_LIBDIR)\r\n+install: PREPARE_DEST_MAN_DIR=$(DESTDIR)$(CFG_MANDIR)/man1\r\n+install: prepare-everything\r\n...\r\n```\r\n\r\nThanks'
12825,'nikomatsakis',"Improve method lookup auto-deref behavior (subissue of trait reform)\nPreviously to #12491, there were no real issues with the current method lookup implementation, which collects candidates and picks the first one in the auto-deref chain, without caring too much about mutability.\r\n\r\nThe problematic case #12491 introduces was `(*x).foo()` where `*x` is an overloaded dereference, calling either `Deref::deref` or `DerefMut::deref_mut`.\r\n\r\nHowever, the method could take `&mut self` - which we can't know until we've picked one of `deref` or `deref_mut` and continued to the lookup of `.foo`.\r\n\r\nThe choice I've made was to always try `deref_mut` (if not obviously immutable, e.g. x having a type of `&T` instead of `&mut T` or `T`) first, and that will work for `RefCell`'s `RefMut`, which only had a mutable `.get()` method previously.\r\n\r\nIn #12610 it gets worse as the issue can happen at any auto-deref level, and here's a test case that fails to compile:\r\n```rust\r\n// Generic unique/owned smaht pointer.\r\nstruct Own<T> {\r\n    value: *mut T\r\n}\r\n\r\nimpl<T> Deref<T> for Own<T> {\r\n    fn deref<'a>(&'a self) -> &'a T {\r\n        unsafe { &*self.value }\r\n    }\r\n}\r\n\r\nimpl<T> DerefMut<T> for Own<T> {\r\n    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\r\n        unsafe { &mut *self.value }\r\n    }\r\n}\r\n\r\nstruct Point {\r\n    x: int,\r\n    y: int\r\n}\r\n\r\nimpl Point {\r\n    fn get(&self) -> (int, int) {\r\n        (self.x, self.y)\r\n    }\r\n}\r\n\r\nfn test(x: Own<Point>) {\r\n    // This method call will attempt a deref_mut call, which succeeds\r\n    // (because type checking doesn't have the mem_categorization\r\n    // information borrow checking uses to confirm the sanity of such\r\n    // borrows), but causes a borrow error later.\r\n    // Ideally, auto-deref should recognize x as immutable and call\r\n    // deref instead of deref_mut` Also, method lookup could use\r\n    // the self type of the method to pick deref instead of deref_mut.\r\n    let _ = x.get();\r\n}\r\n```\r\ncc @nikomatsakis"
12799,'brson',"`make install` broken on windows\n```\r\n$ ../configure --prefix=/home/it/usr/rust-62f1d68 && make\r\n...\r\n\r\n$ make install VERBOSE=1\r\ncfg: build triple i686-pc-mingw32\r\ncfg: host triples i686-pc-mingw32\r\ncfg: target triples i686-pc-mingw32\r\ncfg: enabling more debugging (CFG_ENABLE_DEBUG)\r\ncfg: host for i686-pc-mingw32 is i386\r\ncfg: os for i686-pc-mingw32 is pc-mingw32\r\ncfg: using gcc\r\ncfg: disabling valgrind due to its unreliability on this platform\r\n/home/it/stone/rust-vanilla/mk/stage0.mk:7: warning: overriding recipe for target `i686-pc-mingw32/stage0/bin/'\r\n/home/it/stone/rust-vanilla/mk/stage0.mk:4: warning: ignoring old recipe for target `i686-pc-mingw32/stage0/bin/'\r\ncfg: no pdflatex found, omitting doc/rust.pdf\r\ncfg: no pandoc found, omitting PDF and EPUB docs\r\ncfg: no node found, omitting PDF and EPUB docs\r\ncfg: no llnextgen found, omitting grammar-verification\r\ncfg: including prepare rules\r\ncfg: including install rules\r\numask 022 && mkdir -p /home/it/usr/rust-62f1d68/bin\r\numask 022 && mkdir -p /home/it/usr/rust-62f1d68/bin\r\numask 022 && mkdir -p /home/it/usr/rust-62f1d68/share/man/man1\r\n\r\n$ make install VERBOSE=1 --debug\r\n File `install' does not exist.\r\n   File `prepare-everything' does not exist.\r\n     File `prepare-host' does not exist.\r\n       File `prepare-host-tools' does not exist.\r\n         File `prepare-host-tool-rustdoc-3-i686-pc-mingw32' does not exist.\r\n           File `prepare-host-lib-rustdoc-3-i686-pc-mingw32' does not exist.\r\n             File `prepare-host-lib-rustc-3-i686-pc-mingw32' does not exist.\r\n               File `prepare-host-lib-syntax-3-i686-pc-mingw32' does not exist.\r\n...\r\n```"
11971,'nikomatsakis','Owned trait objects are erroneously permitted to contain references\n(pnkfelix: Here is a test case.  This behavior is not sound.)\r\n```rust\r\npub trait IntMaker { fn i(&self) -> int; }\r\n\r\nimpl<\'a> IntMaker for &\'a int {\r\n    fn i(&self) -> int { let & &x = self; x }\r\n}\r\n\r\n#[cfg(does_not_and_should_not_compile)]\r\nfn main_forbidden_soundly() -> ~IntMaker {\r\n    let x = 2;\r\n    ~&x as ~IntMaker\r\n}\r\n\r\nfn main_unsound() -> ~IntMaker: {\r\n    let x = 3;\r\n    ~&x as ~IntMaker:\r\n}\r\n\r\npub fn main() {\r\n    let m2 = main_unsound();\r\n    println!("m2: {}", m2.i());\r\n}\r\n```\r\n\r\nTranscript of a run:\r\n```\r\n% rustc --version\r\n/Users/fklock/opt/rust-dbg/bin/rustc 0.10-pre (caf17fe 2014-03-21 02:21:50 -0700)\r\nhost: x86_64-apple-darwin\r\n% rustc  /tmp/demo.rs && ./demo\r\nm2: 140306048614800\r\n```\r\n\r\n\r\nOriginal bug report follows\r\n----\r\n\r\nConsider the errors you get with trying to use references inside a managed trait object such as `@Any:` (remove the `:` and you get a `\'static` bound failure error plus the same error):\r\n\r\n```\r\n<anon>:1:38: 1:40 error: value may contain references\r\n<anon>:1 #[feature(managed_boxes)];fn main(){@&2 as @Any:;}\r\n                                              ^~\r\nerror: aborting due to previous error\r\n```\r\n\r\nNow, the problem: owned trait objects do not have this contains-references check.\r\n\r\nWith the default constraints, `~&2 as ~Any` does not compile, because something with references is not `Send`. This is good and proper.\r\n\r\nOn the other hand, `~&2 as ~Any:` *does* compile successfully. (Complete example: `fn main() { ~&2 as ~Any:; }`, should not compile.) This is unsound and should be forbidden in the same way that `@T:` forbids references.'
11870,'brson',"RFC: remove `pub use` globs\nA recent chat I had with pcwalton led me to believe that many of the difficulties we have with globs in `use` declarations would be resolved if we simply restricted globs solely to imports, i.e. removed glob re-exports via `pub use`.\r\n\r\nRemoving `pub use` globs would imply that when `rustc` looks at the text of a module, it can locally determine all of the names that it exports.   I think this would enable us to make a much simpler `resolve` algorithm: one pass to associate each module with the set of names it exports, and then a second pass to wire up the glob imports.  (It still doesn't necessarily know which of the type/value namespaces the imported/exported names belong to, so `resolve` still remains non-trivial, but I think that's okay.)\r\n\r\nThis is meant as an alternative more-conservative option to #11825.  In particular, Servo's use-case as [documented by jack](11825#issuecomment-33439223) should continue to function under this plan, if I'm correct in inferring that the auto-generated code-bindings are solely creating imports.\r\n\r\n(globs are feature-guarded for 1.0, so choosing a strategy here need not block the release.  But it would probably make people more comfortable knowing how drastic a change to globs we might make.)\r\n\r\n(I have been careful in my weasel wording above not to claim that all problems with globs stem from `pub use` alone, since bugs like #3352 do not even use `pub use`.  But I suspect such bugs are artifacts of an complicated implementation strategy necessitated *by* `pub use`, and so I still think this route is worth considering.)\r\n\r\n----\r\n\r\nI will admit up front: glob imports are not a must-have feature for me; I'd be okay if #11825 landed instead of this approach.  But I do think there is value in providing a way for people who want to play with some library to snag all of the functionality it provides trivially, especially for humans who learn via play."
11782,'brson',"Package all required components of the MinGW toolchain\nEasier than #9367. We're already packaging a few of MinGW's binaries. There are probably just a few more pieces needed to have a completely self contained toolchain. This will require either using the linker directly on windows or packaging all of gcc with Rust.\r\n\r\nNominating."
11751,'zwarich','Constructing an iterator from a slice or Vec doesn\'t optimise completely\n```rust\r\n#![crate_type = "lib"]\r\n\r\npub fn slice(s: &[uint]) -> uint {\r\n    for &j in s.iter() {\r\n        if j > 10 { return j }\r\n    }\r\n    0\r\n}\r\npub fn vec(s: Vec<uint>) -> uint {\r\n    for &j in s.iter() {\r\n        if j > 10 { return j }\r\n    }\r\n    0\r\n}\r\n\r\npub fn owned(s: ~[uint]) -> uint {\r\n    for &j in s.iter() {\r\n        if j > 10 { return j }\r\n    }\r\n    0\r\n}\r\n\r\n```\r\n\r\nCompiled with `-O --lib --emit-llvm -S` gives the following. The only major difference between `&[]`/`Vec` and `~[]`  are two lines marked `THIS CHECK`, which, we think, is because when constructing an iterator from `~[]` we do a pointer offset and dereference, so LLVM knows the pointers are non-null (in the slice/`Vec` case, the `match it.next() { None => ... }` part of the for loop isn\'t removed).\r\n\r\n```llvm\r\n; ModuleID = \'11751.rs\'\r\ntarget datalayout = "e-i64:64-f80:128-n8:16:32:64-S128"\r\ntarget triple = "x86_64-unknown-linux-gnu"\r\n\r\n%"struct.std::vec::Vec<uint>[#1]" = type { i64, i64, i64* }\r\n\r\n; Function Attrs: nounwind readonly uwtable\r\ndefine i64 @_ZN5slice20h084d58a6edab0287daa4v0.0E({ i64*, i64 }* noalias nocapture nonnull readonly) unnamed_addr #0 {\r\nentry-block:\r\n  %1 = getelementptr inbounds { i64*, i64 }* %0, i64 0, i32 0\r\n  %2 = load i64** %1, align 8\r\n  %3 = getelementptr inbounds { i64*, i64 }* %0, i64 0, i32 1\r\n  %4 = load i64* %3, align 8\r\n  %5 = getelementptr inbounds i64* %2, i64 %4\r\n  br label %loop_body\r\n\r\nloop_body:                                        ; preds = %match_else, %entry-block\r\n  %6 = phi i64* [ %9, %match_else ], [ %2, %entry-block ]\r\n  %7 = icmp eq i64* %6, %5\r\n  %8 = icmp eq i64* %6, null     ; THIS CHECK!\r\n  %or.cond = or i1 %7, %8\r\n  br i1 %or.cond, label %return, label %match_else\r\n\r\nmatch_else:                                       ; preds = %loop_body\r\n  %9 = getelementptr inbounds i64* %6, i64 1\r\n  %10 = load i64* %6, align 8\r\n  %11 = icmp ugt i64 %10, 10\r\n  br i1 %11, label %return, label %loop_body\r\n\r\nreturn:                                           ; preds = %loop_body, %match_else\r\n  %__make_return_pointer.0 = phi i64 [ %10, %match_else ], [ 0, %loop_body ]\r\n  ret i64 %__make_return_pointer.0\r\n}\r\n\r\n; Function Attrs: uwtable\r\ndefine i64 @_ZN3vec20h4963a1d1a9f58c9eUaa4v0.0E(%"struct.std::vec::Vec<uint>[#1]"* noalias nocapture nonnull readonly) unnamed_addr #1 {\r\nentry-block:\r\n  %1 = getelementptr inbounds %"struct.std::vec::Vec<uint>[#1]"* %0, i64 0, i32 2\r\n  %2 = load i64** %1, align 8\r\n  %3 = getelementptr inbounds %"struct.std::vec::Vec<uint>[#1]"* %0, i64 0, i32 0\r\n  %4 = load i64* %3, align 8\r\n  %5 = getelementptr inbounds i64* %2, i64 %4\r\n  br label %loop_body\r\n\r\nloop_body:                                        ; preds = %entry-block, %match_else\r\n  %6 = phi i64* [ %2, %entry-block ], [ %9, %match_else ]\r\n  %7 = icmp eq i64* %6, %5\r\n  %8 = icmp eq i64* %6, null      ; THIS CHECK!\r\n  %or.cond = or i1 %7, %8\r\n  br i1 %or.cond, label %clean_custom_6, label %match_else\r\n\r\nmatch_else:                                       ; preds = %loop_body\r\n  %9 = getelementptr inbounds i64* %6, i64 1\r\n  %10 = load i64* %6, align 8\r\n  %11 = icmp ugt i64 %10, 10\r\n  br i1 %11, label %clean_custom_6, label %loop_body\r\n\r\nclean_custom_6:                                   ; preds = %loop_body, %match_else\r\n  %__make_return_pointer.0 = phi i64 [ %10, %match_else ], [ 0, %loop_body ]\r\n  %12 = getelementptr inbounds %"struct.std::vec::Vec<uint>[#1]"* %0, i64 0, i32 1\r\n  %13 = load i64* %12, align 8\r\n  %14 = icmp eq i64 %13, 0\r\n  br i1 %14, label %"_ZN25std..vec..Vec$LT$uint$GT$14glue_drop.115917h10684057aba082a7E.exit", label %then-block-549-.i.i\r\n\r\nthen-block-549-.i.i:                              ; preds = %clean_custom_6\r\n  %15 = bitcast i64* %2 to i8*\r\n  tail call void @je_dallocx(i8* %15, i32 3)\r\n  br label %"_ZN25std..vec..Vec$LT$uint$GT$14glue_drop.115917h10684057aba082a7E.exit"\r\n\r\n"_ZN25std..vec..Vec$LT$uint$GT$14glue_drop.115917h10684057aba082a7E.exit": ; preds = %clean_custom_6, %then-block-549-.i.i\r\n  ret i64 %__make_return_pointer.0\r\n}\r\n\r\ndeclare void @je_dallocx(i8*, i32) unnamed_addr #2\r\n\r\n; Function Attrs: uwtable\r\ndefine i64 @_ZN5owned20h3f7b4426165c9e96Bba4v0.0E({ i64, i64, [0 x i64] }* noalias nonnull) unnamed_addr #1 {\r\nentry-block:\r\n  %1 = getelementptr inbounds { i64, i64, [0 x i64] }* %0, i64 0, i32 2, i64 0\r\n  %2 = getelementptr inbounds { i64, i64, [0 x i64] }* %0, i64 0, i32 0\r\n  %3 = load i64* %2, align 8\r\n  %4 = lshr i64 %3, 3\r\n  %5 = getelementptr inbounds { i64, i64, [0 x i64] }* %0, i64 0, i32 2, i64 %4\r\n  br label %loop_body\r\n\r\nloop_body:                                        ; preds = %entry-block, %match_else\r\n  %6 = phi i64* [ %1, %entry-block ], [ %8, %match_else ]\r\n  %7 = icmp eq i64* %6, %5\r\n  br i1 %7, label %"_ZN17_$UP$$x5buint$x5d14glue_drop.120017hf14aae96f6d219c9E.exit", label %match_else\r\n\r\nmatch_else:                                       ; preds = %loop_body\r\n  %8 = getelementptr inbounds i64* %6, i64 1\r\n  %9 = load i64* %6, align 8\r\n  %10 = icmp ugt i64 %9, 10\r\n  br i1 %10, label %"_ZN17_$UP$$x5buint$x5d14glue_drop.120017hf14aae96f6d219c9E.exit", label %loop_body\r\n\r\n"_ZN17_$UP$$x5buint$x5d14glue_drop.120017hf14aae96f6d219c9E.exit": ; preds = %loop_body, %match_else\r\n  %__make_return_pointer.0 = phi i64 [ %9, %match_else ], [ 0, %loop_body ]\r\n  %11 = bitcast { i64, i64, [0 x i64] }* %0 to i8*\r\n  tail call void @je_dallocx(i8* %11, i32 3)\r\n  ret i64 %__make_return_pointer.0\r\n}\r\n\r\nattributes #0 = { nounwind readonly uwtable "split-stack" }\r\nattributes #1 = { uwtable "split-stack" }\r\nattributes #2 = { "split-stack" }\r\n```'
11747,'brson',"Stop relying on rpath\nFollowup to #5219 and #11746. Can we completely eliminate our usage of rpath? Doing so would make our linkage more consistent across platforms since it doesn't work on windows. Nominating."
11602,'brson',"feature gate log_syntax macro\nNobody even remembers what it does but it's presumably for debugging macros. Nominating."
11189,'brson','Timer functions should maybe not take milliseconds as an argument\nSystem timers often expose a granularity much more fine than one millisecond. Right now this is an artifact of libuv\'s api, but in a 1:1 context you can get much finer-grained control over this.\r\n\r\nPerhaps the arguments should be a (second/nsec) struct (like in C), with sugar to do the "easy thing"'
11076,'alexcrichton',"comm_adapters is not compiling\nI accidentally deleted the line of `mod comm_adapters;` so the module isn't compiling and needs some fixup.\r\n\r\nMy bad :("
11062,'alexcrichton',"LittleLock should protect against spurious wakeups\nSomething like this shouldn't be baked directly into `Mutex`, but `LittleLock` knows more about how it's being used so it can actually prevent against spurious wakeups on cvars.\r\n\r\nThis would probably involve moving `signal` into the lock guard because there would have to be an invariant that the lock is held before signaling."
11054,'alexcrichton',"Green schedulers need a bootstrap task\nThis is a weird requirement and means that booting a scheduler requires allocating a one-off task that almost always immediately exits. There's not really a need to do this and the function should be `fn bootstrap(~self);`"
10398,'nikomatsakis','once fn/proc() allows use-after-move of captured variable\nand crashes, inevitably.\r\n\r\n    fn main() {\r\n        let x = ~"foo";\r\n        let f: proc() = proc() {\r\n            let _a = x;\r\n            drop(x);\r\n        };\r\n        f();\r\n    }'
10387,'aturon','Flatten numeric trait hierarchy and allow for user extensibility.\nI am growing increasingly concerned that we are locking ourselves into a substandard numeric API heading toward 1.0 that will be hard to alter in the future without breaking a significant amount of client code.\r\n\r\nPerhaps we could investigate simplifying the numeric trait hierarchy to be centered around built-in types. Perhaps the traits could be removed from the prelude as default instead using free, method wrapper functions as the primary form of using the numeric functions. This would make the API more amenable to being extended by users in the future. Perhaps an algebraic hierarchy could be included in `extra`.\r\n\r\nFor example the `Round`, `Fractional`, `Algebraic`, `Trigonometric`, `Exponential`, `Hyperbolic`, `Real` and `Float` could be consolidated into a single `Float` trait. Then the primary way of accessing the functions would be via the wrapper functions, eg. `num::atan2(x, y)`.\r\n\r\n~~~rust\r\npub trait Float {\r\n    fn floor(x: Self) -> Self;\r\n    fn ceil(x: Self) -> Self;\r\n    fn round(x: Self) -> Self;\r\n    fn trunc(x: Self) -> Self;\r\n    fn fract(x: Self) -> Self;\r\n\r\n    fn recip(x: Self) -> Self;\r\n\r\n    fn pow(x: Self, n: Self) -> Self;\r\n    fn sqrt(x: Self) -> Self;\r\n    fn rsqrt(x: Self) -> Self;\r\n    fn cbrt(x: Self) -> Self;\r\n    fn hypot(x: Self, other: Self) -> Self;\r\n\r\n    fn sin(x: Self) -> Self;\r\n    fn cos(x: Self) -> Self;\r\n    fn tan(x: Self) -> Self;\r\n\r\n    fn asin(x: Self) -> Self;\r\n    fn acos(x: Self) -> Self;\r\n    fn atan(x: Self) -> Self;\r\n\r\n    fn atan2(x: Self, y: Self) -> Self;\r\n    fn sin_cos(x: Self) -> (Self, Self);\r\n\r\n    fn sinh(x: Self) -> Self;\r\n    fn cosh(x: Self) -> Self;\r\n    fn tanh(x: Self) -> Self;\r\n\r\n    fn asinh(x: Self) -> Self;\r\n    fn acosh(x: Self) -> Self;\r\n    fn atanh(x: Self) -> Self;\r\n\r\n    fn exp(x: Self) -> Self;\r\n    fn exp2(x: Self) -> Self;\r\n\r\n    fn ln(x: Self) -> Self;\r\n    fn log(x: Self, base: Self) -> Self;\r\n    fn log2(x: Self) -> Self;\r\n    fn log10(x: Self) -> Self;\r\n\r\n    fn pi() -> Self;\r\n    fn two_pi() -> Self;\r\n    fn frac_pi_2() -> Self;\r\n    fn frac_pi_3() -> Self;\r\n    fn frac_pi_4() -> Self;\r\n    fn frac_pi_6() -> Self;\r\n    fn frac_pi_8() -> Self;\r\n    fn frac_1_pi() -> Self;\r\n    fn frac_2_pi() -> Self;\r\n    fn frac_2_sqrtpi() -> Self;\r\n    fn sqrt2() -> Self;\r\n    fn frac_1_sqrt2() -> Self;\r\n    fn e() -> Self;\r\n    fn log2_e() -> Self;\r\n    fn log10_e() -> Self;\r\n    fn ln_2() -> Self;\r\n    fn ln_10() -> Self;\r\n\r\n    fn to_degrees(x: Self) -> Self;\r\n    fn to_radians(x: Self) -> Self;\r\n\r\n    fn nan() -> Self;\r\n    fn infinity() -> Self;\r\n    fn neg_infinity() -> Self;\r\n    fn neg_zero() -> Self;\r\n\r\n    fn is_nan(self) -> bool;\r\n    fn is_infinite(self) -> bool;\r\n    fn is_finite(self) -> bool;\r\n    fn is_normal(self) -> bool;\r\n    fn classify(self) -> FPCategory;\r\n\r\n    fn mantissa_digits(_: Option<Self>) -> uint;\r\n    fn digits(_: Option<Self>) -> uint;\r\n    fn epsilon() -> Self;\r\n    fn min_exp(_: Option<Self>) -> int;\r\n    fn max_exp(_: Option<Self>) -> int;\r\n    fn min_10_exp(_: Option<Self>) -> int;\r\n    fn max_10_exp(_: Option<Self>) -> int;\r\n\r\n    fn ldexp(x: Self, exp: int) -> Self;\r\n    fn frexp(x: Self) -> (Self, int);\r\n\r\n    fn exp_m1(x: Self) -> Self;\r\n    fn ln_1p(x: Self) -> Self;\r\n    fn mul_add(x: Self, a: Self, b: Self) -> Self;\r\n    fn next_after(x: Self, other: Self) -> Self;\r\n}\r\n\r\n#[inline] fn floor<T:Float>(x: T) -> T { Float::floor(x) }\r\n#[inline] fn ceil<T:Float>(x: T) -> T { Float::ceil(x) }\r\n#[inline] fn round<T:Float>(x: T) -> T { Float::round(x) }\r\n#[inline] fn trunc<T:Float>(x: T) -> T { Float::trunc(x) }\r\n#[inline] fn fract<T:Float>(x: T) -> T { Float::fract(x) }\r\n\r\n#[inline] fn recip<T:Float>(x: T) -> T { Float::recip(x) }\r\n\r\n#[inline] fn pow<T:Float>(x: T, n: T) -> T { Float::pow(x, n) }\r\n#[inline] fn sqrt<T:Float>(x: T) -> T { Float::sqrt(x) }\r\n#[inline] fn rsqrt<T:Float>(x: T) -> T { Float::rsqrt(x) }\r\n#[inline] fn cbrt<T:Float>(x: T) -> T { Float::cbrt(x) }\r\n#[inline] fn hypot<T:Float>(x: T, y: T) -> T { Float::hypot(x, y) }\r\n\r\n#[inline] fn sin<T:Float>(x: T) -> T { Float::sin(x) }\r\n#[inline] fn cos<T:Float>(x: T) -> T { Float::cos(x) }\r\n#[inline] fn tan<T:Float>(x: T) -> T { Float::tan(x) }\r\n\r\n// ...\r\n~~~\r\n\r\nThis is related to the numeric trait reform tracked at #4819'
10231,'nikomatsakis','The Cell type may be unsound as it is currently implemented\n```rust\r\nuse std::cell::Cell;\r\n\r\nstruct A;\r\n\r\nimpl A {\r\n    fn id<\'a>(&\'a mut self) -> &\'a mut A { self }\r\n\r\n    fn bar(&mut self) {\r\n        println!("oh no!");\r\n    }\r\n}\r\n\r\nfn foo(f: &fn()) { f() }\r\n\r\nfn main() {\r\n    let c = Cell::new_empty();\r\n    let mut a = A;\r\n    let d = Cell::new(&mut a);\r\n    do d.with_mut_ref |this| {\r\n        c.put_back(this.id());\r\n    }\r\n    do d.with_mut_ref |this1| {\r\n        do c.with_mut_ref |this2| {\r\n            this1.bar();\r\n            this2.bar();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nNear the end `this` and `this2` are two mutable pointers to the same object, which I believe is unsound.\r\n\r\nNominating, this is not good.'
10157,'nikomatsakis','TypeContents code is inscrutable\nI can say that because I wrote it. Anyway, I have a refactoring I think is cleaner -- it does a better job of distinguishing *owned* from *reachable* properties and so forth. Coming soon to a PR near you.'
9876,'brson',"Make binary installers for mac and linux\nWe need the installation experience to be very easy everywhere. Currently we require unixes to build from source, but that shouldn't be strictly necessary - we already distribute snapshot binaries that work.\r\n\r\nAdd a new build target that creates a binary installer similarly to the snapshots."
9874,'steveklabnik','Rewrite the intro tutorial\n\r\nWe have major questions about how to best present Rust: as the language \r\nhas evolved it\'s character has taken shape, but how to express its \r\nunique strengths in a cohesive and compelling narrative is still \r\nelusive. A great writer should be able to unveil the language gradually, \r\nleading the reader to understand why Rust is powerful, and to understand \r\nwhich *patterns* will lead to success. That last point is very \r\nimportant: many people come to Rust, try to apply the patterns they are \r\nfamiliar with from other languages, and become frustrated. It\'s critical \r\nthat we show how to be effective in Rust. What is "the philosophy of \r\nRust" and how should it be taught?'
9784,'aturon',"option: rename unwrap to get or remove get_ref in favour of as_ref().unwrap()\nThere are already nearly identical methods named `get_ref()` and `get_mut_ref()` and `std::hashmap` names the equivalent method `get`. This method doesn't always move, it's just a normal by-value method, so it should follow the same convention as other get-or-fail methods. If it used the shorter naming, replacing `get_mut_ref()` with `as_mut().get()` would only add a character."
9669,'alexcrichton','Interesting format! specifiers are rejected\nThese combinations are all rejected, when some should probably be accepted.\r\n\r\n```rust\r\nformat!("{1:#<0$s}", "", 10) // seems like a parser bug\r\nformat!("{:#<name$}", "", name=10) // seems like a nice parser feature\r\n```\r\n\r\nAccepting names of arguments for width/precision needs to make sure that it doesn\'t create ambiguities with the existing syntax.'
9629,'nikomatsakis','Allow immutable access of &mut struct field through &self\nI can access a `&mut int` through a `& &mut int` pointer:\r\n\r\n     let x = &mut ~3; let y = &x; ***y   // evaluates to `3`\r\n\r\nBut not access a `&mut` struct field through `&self`:\r\n\r\n    struct Ref<\'self, T>(&\'self mut T);\r\n    let mut it = range(0,3);\r\n    let r = &Ref(&mut it);\r\n    r.size_hint()\r\n    // error: cannot borrow an `&mut` in a `&` pointer; try an `&mut` instead\r\n\r\nThe use case is precisely `Ref` above, in essence, I want to implement a "by-ref" (by mutable ref) adaptor for iterators. And it works fine for implementing `Iterator::next` but not for `Iterator::size_hint` for the reason above.'
9587,'alexcrichton',"Rustdoc generates invalid code for struct-like enums\nFor example, the enum\r\n```rust\r\npub enum FrontendMessage<'self> {\r\n    Bind {\r\n        portal: &'self str,\r\n        statement: &'self str,\r\n        formats: &'self [i16],\r\n        values: &'self [Option<~[u8]>],\r\n        result_formats: &'self [i16]\r\n    },\r\n    Close {\r\n        variant: u8,\r\n        name: &'self str\r\n    },\r\n    Describe {\r\n        variant: u8,\r\n        name: &'self str\r\n    },\r\n    Execute {\r\n        portal: &'self str,\r\n        max_rows: i32\r\n    },\r\n    Parse {\r\n        name: &'self str,\r\n        query: &'self str,\r\n        param_types: &'self [i32]\r\n    },\r\n    PasswordMessage {\r\n        password: &'self str\r\n    },\r\n    Query {\r\n        query: &'self str\r\n    },\r\n    StartupMessage {\r\n        version: i32,\r\n        parameters: &'self [(~str, ~str)]\r\n    },\r\n    Sync,\r\n    Terminate\r\n}\r\n```\r\nshows up in rustdoc as\r\n```rust\r\npub enum FrontendMessage<'self> {\r\nstruct Bind {\r\n    portal: &'self str,\r\n        statement: &'self str,\r\n        formats: &'self [i16],\r\n        values: &'self [std::option::Option],\r\n        result_formats: &'self [i16],\r\n    }struct Close {\r\n    variant: u8,\r\n        name: &'self str,\r\n    }struct Describe {\r\n    variant: u8,\r\n        name: &'self str,\r\n    }struct Execute {\r\n    portal: &'self str,\r\n        max_rows: i32,\r\n    }struct Parse {\r\n    name: &'self str,\r\n        query: &'self str,\r\n        param_types: &'self [i32],\r\n    }struct PasswordMessage {\r\n    password: &'self str,\r\n    }struct Query {\r\n    query: &'self str,\r\n    }struct StartupMessage {\r\n    version: i32,\r\n        parameters: &'self [(~str, ~str)],\r\n    }    Sync,\r\n    Terminate,\r\n}\r\n```"
9566,'alexcrichton','rustdoc: Wrong page suggestion on search\nSearching `insert` on rustdoc leads [here](http://static.rust-lang.org/doc/master/std/container/MutableMap/trait.MutableMap.html) (broken link) rather than [here](http://static.rust-lang.org/doc/master/std/container/trait.MutableMap.html).\r\n\r\nSame for searching `zip`. ([the suggested link](http://static.rust-lang.org/doc/master/std/iter/Iterator/trait.Iterator.html))'
9530,'alexcrichton',"Rust-master doesn't compile any more on Ubuntu Lucid/amd64\nIt used to compile fine until yesterday:\r\n\r\n    link: x86_64-unknown-linux-gnu/rustllvm/librustllvm.so\r\n    cp: x86_64-unknown-linux-gnu/stage0/lib/rustc/x86_64-unknown-linux-gnu/lib/librustllvm.so\r\n    compile_and_link: x86_64-unknown-linux-gnu/stage0/lib/rustc/x86_64-unknown-linux-gnu/lib/librustc.so\r\n    error: internal compiler error: encode_symbol: id not found 321678\r\n    make: *** [x86_64-unknown-linux-gnu/stage0/lib/rustc/x86_64-unknown-linux-gnu/lib/librustc.so] Error 101"
9524,'alexcrichton','Struct fields are dead links in rustdoc search\nThe search index includes struct fields, that link to nonexistant pages, for example if you search for "buckets" in libstd you get this link:\r\n\r\nhttp://static.rust-lang.org/doc/master/std/hashmap/HashMap/structfield.buckets.html\r\n\r\ncc @alexcrichton '
9460,'alexcrichton','Highlight function names in rustdoc_ng\nAll function names should be wrapped in a `<span class="fnname">...</span>` and the following CSS applied:\r\n\r\n    .fnname {\r\n        color: #8c6067;\r\n    }\r\n\r\nIt\'ll make scanning long lists of fn declarations a bit easier.\r\n\r\n/cc @alexcrichton '
9410,'alexcrichton',"Rustdoc (rustdoc_ng) should hide priv items and methods by default\nRustdoc should hide private and *should be private* items like statics, functions, structs where `priv` or *non-pub* is effectively malfunctioning today.\r\n\r\nLots of non-pub methods, functions, structs are now showing up in the official Trunk documentation, and thanks to bugs it's possible to use some of these as well (for example `std::hashmap::resize_at` is can be called).\r\n\r\n* Documentation is easier to understand if only `pub` items are shown\r\n* We want to avoid users starting to rely on non-pub items.\r\n\r\nTag #8125 "
9341,'alexcrichton',"libuv process tests are ignored\nIt turns out that libuv processes register SIGCHLD handlers, but these handlers aren't registered with SA_RESTART, so when we receive a SIGCHLD syscalls are interrupted and `std::io` doesn't handle the `EINTR` return value. Currently the tests which exercise libuv process bindings are ignored, and they currently aren't used anywhere else in the code.\r\n\r\nWe have two options to un-ignore these tests\r\n\r\n1. Teach all of `std::io` and various `libc` bindings to handle `EINTR`\r\n2. Wait for `std::io` to be removed.\r\n\r\nI'm in favor of option 2, but mainly just because it means that it's less effort :)"
9117,'alexcrichton',"Rust triggers LLVM ARM backend bug\nRust triggers [LLVM bug 17180](http://llvm.org/bugs/show_bug.cgi?id=17180). I haven't figured out the exact condition yet, but using LLVM's integrated assembler is required, so this started to happen only when we switched to LLVM's integrated assembler from Android NDK's external assembler(#8931).\r\n\r\nThe bug is fixed upstream in r190417. Should I upgrade to the latest LLVM, or just cherry-pick the fix? The fix is trivial, so cherry-picking is not hard. @alexcrichton?"
8996,'brson',"Use Mingw-w64 for Win32\nWe currently use mingw for win32 platform. However mingw does not support win64 (#1237), so we have to use mingw-w64 (or msvc: #1768).\r\nAlthough mingw and mingw-w64 looks similar, implementations differ: we have issues due to mingw which are already solved on mingw-w64. (#8663, #8859)\r\n\r\nInstead, we may switch to mingw-w64 for win32. (Yes, mingw-w64 supports win32 despite its name.) then we can reduce platform/runtime differences between win32/win64.\r\n\r\nPreviously @thadguidry [posted](https://mail.mozilla.org/pipermail/rust-dev/2013-July/004962.html) about Qt's discussion on mingw/mingw-w64. ([original discussion](http://lists.qt-project.org/pipermail/development/2012-August/005984.html))\r\n\r\nalso cc @vadimcn :)"
8938,'alexcrichton','`format!` stops early on spurious `\'}\'`  \n`format!("foo } bar")` yields `"foo "`. Should probably just error.'
8826,'alexcrichton',"libuv has it's `target_arch` specified incorrectly\nRight now when you're building a 64-bit build it may error because libuv is built as a 32-bit library. It looks like gyp doesn't understand `x86_64`, but rather `x64`\r\n\r\ncc @pnkfelix who was having problems with this."
8730,'nikomatsakis','Casting 0 to `extern "C" fn` is permitted\nNow that #8666 is in place, there is not a good way to make a NULL `extern "C" fn`.  You can do it, but you have to specify the whole type of the function pointer again with `as`:\r\n\r\n````rust\r\n0 as extern "C" fn(args...) -> ReturnType\r\n````\r\n\r\nusing `std::ptr::null()` will not compile, and gives:\r\n````text\r\nhello_nullfuncptrs.rs:4:8: 4:25 error: mismatched types: expected `extern "C" fn(int, int) -> int` but found `*<V0>` (expected extern fn but found *-ptr)\r\n````\r\n\r\nSome C APIs really do need to have NULL passed in for function pointers.  Right now, using `as` like the code above is the only way to create such a null pointer;   For those cases where you need to pass a NULL into a C API, it would be nice if `std::ptr::null()` would work for that, without having to repeat the whole type (including all arguments and return type) of the function pointer in order to do it.\r\n\r\n**UPDATE:** Title amended by @nikomatsakis to reflect the real issue at hand.'
8625,'nikomatsakis',"Dereferencing of mutable &mut paths found in borrowed paths should not be permitted\nIn particular this program ought to be illegal:\r\n\r\n```\r\nstruct S<'self> {\r\n    pointer: &'self mut int\r\n}\r\n\r\nfn copy_borrowed_ptr2<'a>(p: &'a mut S<'a>) -> S<'a> {\r\n    S { pointer: &mut *p.pointer }\r\n}\r\n\r\nfn main() {\r\n    let mut x = 1;\r\n\r\n    {\r\n        let mut y = S { pointer: &mut x };\r\n        let z = copy_borrowed_ptr2(&mut y);\r\n        *y.pointer += 1; // ERROR EXPECTED HERE\r\n        *z.pointer += 1;\r\n    }\r\n}\r\n```\r\n\r\nSee also #8624 "
8624,'nikomatsakis',"Reborrowing mutable pointers is overly permissive\nThis example program should not type check:\r\n\r\n```\r\nstruct S<'self> {\r\n    pointer: &'self mut int\r\n}\r\n\r\nfn copy_borrowed_ptr<'a, 'b>(p: &'a mut S<'b>) -> S<'b> {\r\n    S { pointer: &mut *p.pointer }\r\n}\r\n\r\nfn main() {\r\n    let mut x = 1;\r\n    let mut y = S { pointer: &mut x };\r\n    let z = copy_borrowed_ptr(&mut y);\r\n    *y.pointer += 1;\r\n    *z.pointer += 1;\r\n}\r\n```\r\n\r\nThe problem is that the rules which limit reborrowing of mut data to unique paths do not consider the lifetime of those unique paths.\r\n\r\nThe legal signatures for `copy_borrowed_ptr` would be either:\r\n\r\n- `fn copy_borrowed_ptr<'a>(&'a mut S<'a>) -> S<'a>`; or\r\n- `fn copy_borrowed_ptr<'a, 'b>(&'a mut S<'b>) -> S<'a>`"
8393,'nikomatsakis','Macros that operate on attributes\nThere is no way to write a macro that takes a list of attributes as input, like e.g. this one:\r\n\r\n```\r\n\r\nmacro_rules! test ( ($nm:ident,\r\n                     $a:inner_attr,\r\n                     $i:item) => (mod $nm { $a $i }); )\r\n\r\ntest!(a,\r\n      #[cfg(qux)],\r\n      pub fn bar() { })\r\n\r\ntest!(b,\r\n      #[cfg(not(qux))],\r\n      pub fn bar() { })\r\n\r\n#[qux]\r\nfn main() {\r\n    a::bar();\r\n    //~^ ERROR use of undeclared module `a`\r\n    //~^^ ERROR unresolved name\r\n    //~^^^ ERROR unresovled name `a::bar`\r\n    b::bar();\r\n}\r\n\r\n```\r\n\r\nI need this for #3678, since I have a macro there for generating wrappers around extern fns and it needs attributes. Pull request forthcoming.'
7852,'alexcrichton','Optional lang_items may not work cross crates\n@huonw points out that [some code](https://github.com/mozilla/rust/blob/master/src/librustc/middle/lang_items.rs#L97) still assumes all lang items are present. This is only called when dealing with metadata on crates.\r\n\r\nI need to figure out if multiple crates with optional lang items works or not.'
7502,'nikomatsakis',"appropriate lifetime and match\nfollowing code does not compile:\r\n```\r\nstruct Vec { x:float, y:float, z:float }\r\nimpl Vec {\r\n    pub fn getRef<'a>(&'a mut self, i:uint) -> &'a mut float {\r\n        // if(i==0) { &mut self.x }\r\n        // else if(i==1) { &mut self.x }\r\n        // else {&mut self.x }\r\n        \r\n        match(i) {\r\n            0 => &mut self.x,\r\n            1 => &mut self.y,\r\n            _ => &mut self.z\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nI get following errors:\r\n```\r\nrustc test.rs -o test-test --test\r\ntest.rs:122:17: 122:28 error: cannot infer an appropriate lifetime due to conflicting requirements\r\ntest.rs:122             _ => &mut self.z\r\n                             ^~~~~~~~~~~\r\ntest.rs:121:17: 121:28 note: first, the lifetime must be contained by the expression at 121:17...\r\ntest.rs:121             1 => &mut self.y,\r\n                             ^~~~~~~~~~~\r\ntest.rs:121:17: 121:28 note: ...due to the following expression\r\ntest.rs:121             1 => &mut self.y,\r\n                             ^~~~~~~~~~~\r\ntest.rs:120:17: 120:28 note: but, the lifetime must also be contained by the expression at 120:17...\r\ntest.rs:120             0 => &mut self.x,\r\n                             ^~~~~~~~~~~\r\ntest.rs:120:17: 120:28 note: ...due to the following expression\r\ntest.rs:120             0 => &mut self.x,\r\n                             ^~~~~~~~~~~\r\nerror: aborting due to previous error\r\nmake: *** [test-test] Error 101\r\n```\r\n\r\nThe commented version that is using if statements does compile correctly.\r\n\r\nI haven't tried yet with very latest build, so I'm not sure whether the problem is still there with rust 0.7\r\n\r\ncheers,\r\n\r\nRémi\r\n\r\n\r\n"
7444,'nikomatsakis','Allows moving in owned values into multiple closures\nThe following testcase crashes at runtime when call_f is called the second time. It appears rustc accepts to move the value t into "both" heap closures.\r\n\r\n    fn call_f(f: ~fn:Owned() -> int) -> int {\r\n        f()\r\n    }\r\n\r\n    fn main() {\r\n        let t = ~3;\r\n\r\n        call_f(|| { *t + 1 });\r\n        call_f(|| { *t + 1 });\r\n    }\r\n\r\nTested with version f1e09d6 / rustc 0.6 (f1e09d6 2013-06-26 23:07:41 -0700)\r\n\r\nAssign to @bblum '
7087,'aturon',"RFC: standardizing on naming functions that convert from one type to another\nIt's time to handle another one of the hardest things in computer science, how to name conversion functions. Rust supports essentially three ways of converting from one type to another. First there is doing a copy, such as these in the `str` mod:\r\n\r\n```\r\npub fn from_bytes(vv: &[u8]) -> ~str { ... }\r\n\r\npub trait StrSlice<'self> {\r\n     fn to_str(&self) -> ~str { ... }\r\n     fn to_owned(&self) -> ~str { ...}\r\n}\r\n```\r\n\r\nThen we have some that can do a no-allocation moves, such as `either`'s:\r\n\r\n```\r\npub fn to_result<T, U>(eith: Either<T, U>) -> Result<U, T> { ... }\r\n```\r\n\r\nFinally, we have ones that can get a no-copy reference, as in `str`'s:\r\n\r\n```\r\npub fn from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str { ... }\r\n\r\npub trait StrSlice<'self> {\r\n    fn as_bytes(&self) -> &'self [u8]\r\n}\r\n```\r\n\r\nWhile they share similar names, it's not consistent what exactly is happening in each case. I would like to standardize on a style so I can know how to name things for the standard library.\r\n\r\nSome options that came up in IRC are:\r\n\r\n* `as` for conversions, and `to` for moves or copies. Simple, but then we end up with functions named like `to_str_consume` to distinguish between the two cases, which is a little ugly.\r\n* `as` for conversions, `to` for moves, and `into` for copies. This is nice in that we try to push users to use our no-copy solutions, but this will make `.to_str` a little more ugly.\r\n* `as` for conversions, `to` for copies, and `into` for moves. This keeps `.to_str` pretty, but people might tend to the copy functions instead of the moves.\r\n* Use a standard trait for conversions, as in #7080. This won't help when we have options for how to convert. For example, `from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str` which handles byte slices that don't end with a null character, or  `str::from_bytes_with_null<'a>(vv: &'a [u8]) -> &'a str` which does.\r\n\r\nAnyone have an opinion on what we should use?"
6897,'brson','Compare jemalloc performance\nhttps://github.com/mozilla/rust/pull/6895 converts Rust to jemalloc. This is a big change and we should really capture some performance numbers to have an idea of the effect this has.\r\n\r\nI am thinking just a few workloads:\r\n\r\n* build rustc (with --no-trans)\r\n* A multithreaded test using treemap (like in core-map)\r\n\r\nFor each collect the running time and max memory used, both before and after jemalloc, on linux, mac and win.'
6428,'brson',"valgrind errors around stacks and context switches in newsched\nI think these are probably because we're not calling VALGRIND_STACK_REGISTER, but sometimes I see many instances of this type of error:\r\n\r\n```\r\n==936== Invalid read of size 8\r\n==936==    at 0xAA8598: rt::uv::uvio::__extensions__::write::anon::expr_fn_40723 (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA72E1F: rt::sched::__extensions__::meth_39073::run_cleanup_job::_d89672ea64dda16::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA6F383: rt::sched::__extensions__::meth_38960::resume_task_immediately::_a2575627634c4428::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA9A0CB: rt::uv::uvio::__extensions__::tcp_connect::anon::anon::expr_fn_40192 (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xABC2AB: rt::uv::net::__extensions__::connect_cb::__rust_abi (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xABC49C: rt::uv::net::__extensions__::connect_cb::__rust_stack_shim (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0x5BFBAEB: upcall_call_shim_on_rust_stack (rust_upcall.cpp:103)\r\n==936==    by 0xABC0B7: rt::uv::net::__extensions__::connect_cb::_bca9d17c2f9fc276::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0x5C0FD95: uv__stream_io (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/librustrt.so)\r\n==936==    by 0x5C162BC: uv__io_poll (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/librustrt.so)\r\n==936==    by 0x5C0B40D: uv_run (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/librustrt.so)\r\n==936==    by 0xAB33D4: rust_uv_run__c_stack_shim (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==  Address 0x1abd4100 is 9,998,528 bytes inside a block of size 10,000,048 alloc'd\r\n==936==    at 0x4C2B4F0: realloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==936==    by 0x5BFF2EE: rust_exchange_alloc::realloc(void*, unsigned long) (rust_exchange_alloc.cpp:32)\r\n==936==    by 0x5BF37FF: vec_reserve_shared (rust_util.h:75)\r\n==936==    by 0x4248F9: vec::rustrt::vec_reserve_shared::_d93fcb2da81ef4d::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0x4246AA: vec::reserve_11902::_feb243f343efb87f::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0x749204: vec::with_capacity_20601::_d069f83199a42fd0::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xAC5255: rt::stack::__extensions__::meth_41483::new::_2f39639a42826edf::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA74579: rt::stack::__extensions__::meth_39135::take_segment::_2f39639a42826edf::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA73DE6: rt::sched::__extensions__::meth_39126::with_local::_03fe2be4efca6ed::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA84686: rt::test::spawntask_immediately::_866c76cd73dffbc7::_07pre (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA85A23: rt::io::net::tcp::test::multiple_connect_serial::anon::expr_fn_39598 (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n==936==    by 0xA74E95: rt::sched::__extensions__::build_start_wrapper::anon::anon::expr_fn_39150 (in /opt/dev/rust3/build/x86_64-unknown-linux-gnu/test/coretest.stage1-x86_64-unknown-linux-gnu)\r\n\r\n```"
6312,'brson','Remove Durable\nIt still exists'
6298,'nikomatsakis','Convert dataflow (and liveness, and region-inference) to use a common graph abstraction\nA needed refactoring for borrowck/liveness/etc to share code. Also to make dataflow more comphrensible and to address performance limitaitons with the current impl.'
6258,'brson',"coretest aborts in uv loop\nIt happens infrequently but script will sometimes end in a call to abort:\r\n\r\n```\r\nfor i in `seq 1 100`; do rm tmp/*ok; make check-stage1-core || break; done\r\n```\r\n\r\nI think this has happened on the bots a few time. I don't have a backtrace at the moment."
6248,'nikomatsakis',"Fix trans cleanups to be more flexible\nRight now trans introduces cleanup scopes at semi-arbitrary times. This was fine when first designed but now it is user visible because it affects the maximum lifetimes of values and hence causes errors in the borrow checker.\r\n\r\nIt interacts *particularly poorly* with `@mut` freezes. For example, if I write:\r\n\r\n    let some_map: @mut HashMap<K,V> = ...;\r\n    let foo = *some_map.get(some_key);\r\n\r\nthis will cause `some_map` to be frozen *for the entire enclosing block* rather than just the `let foo` statement, because trans would not introduce a cleanup scope there. I at least issue a rather cryptic warning in this case (citing this issue #). The workaround is to introduce a block or a method:\r\n\r\n    // Option 1: add a method that combines the `*` and the call to `get` into one thing\r\n    // In this case, HashMap defines get_copy:\r\n    let foo = some_map.get_copy(some_key);\r\n\r\n    // Option 2: introduce a block and store the borrowed @mut into a local variable\r\n    let foo = {\r\n        let some_map = &mut *some_map;\r\n        *some_map.get(some_key)\r\n    };\r\n\r\nWe should permit cleanups after every expression exits. If we do this with the existing system, though, it'll cause a flood of basic blocks and jack up compilation times significantly. I want to modify the system so that rather than adding cleanups to a block scope, as we do now, you would instead associate cleanups with an expr id (in trans, I mean). The cleanup generation would thus be driven off the AST. I have added various FIXMEs in the code referencing this issue or #3511 where this might be relevant."
6225,'nikomatsakis','soundness holes in let\nRelated to #3235 because the same holes don\'t exist in `match`.\r\n\r\n```rust\r\nstruct Foo {\r\n    n: uint\r\n}\r\n\r\nimpl Drop for Foo {\r\n    fn finalize(&self) {\r\n        for self.n.times {\r\n            println("pew");\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let x = Foo{n: 5};\r\n    let &_y = &x;\r\n}\r\n```'
6165,'brson','Implement non-blocking TCP\nImplement non-blocking TCP in the new scheduler, on top of uv.'
6163,'brson','Design and implement I/O error handling strategy\nGetting error handling right is difficult. Lot of ins, lot of outs, etc.\r\n\r\nDiscussion here: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003746.html'
6143,'pcwalton','surprises in resolve\nThere are a number of ... surprises in resolve, which may be intentional, may not be, or may represent the need to make backwards-incompatible changes. I _think_ they\'re related, but I\'m not sure. I\'m collecting them into a metabug here.\r\n\r\nThe ones I see are #4536 , #5238 , #5248 , #5269 and #3352 (though the last seems less likely related, it provokes a similarly-unclear "shouldn\'t this work?" feeling from me, and I\'m not sure how to classify the bug)'
6141,'nikomatsakis','Borrowing ~fn to &fn leaks\nFallout from demoding. This will leave a dangling allocation on the exchange heap.\r\n\r\n```\r\nfn run(f: &fn()) {\r\n    f()\r\n}\r\n\r\nfn main() {\r\n    let f: ~fn() = || ();\r\n    run(f);\r\n}\r\n```\r\n'
6112,'nikomatsakis',"managed box annihilator sometimes reads freed memory\nI found a problem with the managed box annihilator. It sometimes can read freed memory. This can happen when running the drop glue causes a unique-managed box (`~` containing `@`) to be freed, in which case the `next` pointer that we walk to is out of date. Fix forthcoming, though I don't have a small test case that causes it to happen."
6042,'brson','Building without node, with pandoc results in error\nI have node installed but I do not have pandoc. I type `make docs` and see\r\n\r\n```\r\ncfg: build triple x86_64-unknown-linux-gnu\r\ncfg: host triples x86_64-unknown-linux-gnu\r\ncfg: target triples x86_64-unknown-linux-gnu\r\ncfg: host for x86_64-unknown-linux-gnu is x86_64\r\ncfg: os for x86_64-unknown-linux-gnu is unknown-linux-gnu\r\ncfg: using gcc\r\ncfg: no node found, omitting doc/tutorial.html\r\ncfg: no pdflatex found, omitting doc/rust.pdf\r\ncfg: no node found, omitting doc/tutorial.html\r\ncfg: no llnextgen found, omitting grammar-verification\r\nversion-info: doc/version_info.html\r\nsed -e "s/VERSION/0.6/; s/SHORT_HASH/f4530230/;\\\r\n                    s/STAMP/f4530230934fed47f65e0c94d0b4361222e869a8/;" /home/brian/dev/rust/doc/version_info.html.template >doc/version_info.html\r\nmake: *** No rule to make target `doc/rust.css\', needed by `doc/rustpkg.html\'.  Stop.\r\n```\r\n\r\nRustpkg docs are missing a nodejs dependency'
6039,'brson',"Task local storage leaks memory\nThe recent conversion from `reinterpret_cast` to `transmute` introduced a memory leak to TLS. It does not reveal itself though because the box annihilator happily destroys the leaked boxes. In my branch, newsched has TLS but does not have the annihilator, so I'm seeing leaks.\r\n\r\nTook all afternoon to figure that out. I'll have a fix soon."
5985,'brson','fasta-redux and threadring failing on bots\nhttp://buildbot.rust-lang.org/builders/incoming-full-mac/builds/1002/steps/test/logs/stdio\r\n\r\nThreadring is running out of memory and fasta-redux does not typecheck on x86. I will xfail them.\r\n'
5910,'nikomatsakis',"@mut freezing bugs\nYou can unfreeze with a temporary borrowed pointer, because it doesn't restore the previous state:\r\n\r\n```rust\r\nfn main() {\r\n    let x = @mut 5;\r\n\r\n    let a = &*x;\r\n    {\r\n        let b = &*x;\r\n    }\r\n    let c = &mut *x;\r\n}\r\n```\r\n\r\nMutable borrows aren't tracked:\r\n\r\n```rust\r\nfn main() {\r\n    let x = @mut 5;\r\n\r\n    let a = &mut *x;\r\n    let b = &mut *x;\r\n    let c = &*x;\r\n}\r\n```\r\n\r\nI think freezing needs to be `enum Borrow { Mutable, Immutable, Nothing }` with an immutable borrow failing if there was a Mutable one, and a mutable borrow failing on any freeze."
5884,'nikomatsakis','LLVM assertion failure with with borrowed pointer in struct\nThis program\r\n```rust\r\npub struct Foo {\r\n  a: int,\r\n}\r\n\r\nstruct Bar<\'self> {\r\n  a: ~Option<int>,\r\n  b: &\'self Foo,\r\n}\r\n\r\nfn check(a: @Foo) {\r\n  let mut _ic = Bar{ b: a, a: ~None };\r\n}\r\n\r\nfn main(){}\r\n```\r\n\r\nyields\r\n\r\n```\r\n$ rustc foo.rs\r\nAssertion failed: ((i >= FTy->getNumParams() || FTy->getParamType(i) == Args[i]->getType()) && "Calling a function with a bad signature!"), function init, file /Users/alex/code/rust-src/src/llvm/lib/IR/Instructions.cpp, line 281.\r\n```\r\n\r\nThis cropped up after the new self lifetimes as I tried to change field `b` from `@Foo` to `&\'self Foo`. If the owned pointer from `Bar` is removed (even just the sigil), the assertion still trips.\r\n\r\nOne solution I found is:\r\n\r\n```rust\r\nfn check(b: @Foo) {\r\n  let a = ~None;\r\n  let mut _ic = Bar{ b: b, a: a };\r\n}\r\n```'
5835,'brson','Incoming is broken on Arch Linux after LLVM upgrade\nhttps://gist.github.com/Jeaye/c98b280b5ca9055ed114\r\n\r\nI did drop our patch to fix python detection, thinking it was fixed upstream. It appears not to be and reapplying our patch to fix python detection does not appear to fix the problem.'
5771,'nikomatsakis',"Can not create pointer like types in Rust (without excessive gunk)\nI wanted to wrap the OpenGL API to create a safer interface. Like many other APIs the OpenGL API gives away integer tokens representing created objects. For example, the call glCreateProgram creates a GLuint token representing a shader program object. These tokens in the OpenGL API (and other similar APIs) are basically the same idea as pointer types. Because these tokens behave similarly to pointers I would like to wrap them in a type which has similar behaviours. For example, the glGetAttribLocation call gets a token representing an attribute, or buffer to fill with data of a shader program. I would like to wrap the token returned by glGetAttribLocation in a structure which has the same lifetime as the program token returned by glCreateProgram, but to do this I have to use an unneeded amount of pointers (to get proper lifetime guarantees.) Basically, I would like my wrapped glGetAttribLocation call to be like:\r\n\r\n     impl GLContext {\r\n      fn get_attrib_location <'r> (\r\n         &self,\r\n         program: Program <'r>,\r\n         name: ~str\r\n      ) -> Option <AttributeLocation <'r>> { /* Definition Omitted */ }\r\n\r\nInstead of:\r\n\r\n     impl GLContext {\r\n      fn get_attrib_location <'r> (\r\n         &self,\r\n         program: &'r Program,\r\n         name: ~str\r\n      ) -> Option <AttributeLocation <'r>> { /* Definition Omitted */ }\r\n"
5728,'nikomatsakis','Reason about nested lifetimes that appear in types\nThis is a kind of subtle change to the type system needed for #5656.  An explanantion is here: http://smallcultfollowing.com/babysteps/blog/2013/04/04/nested-lifetimes/'
5723,'nikomatsakis',"Lifetimes can escape in traits / objects\nThis code from the `io` library is definitely wrong as the lifetime of the parameter `s` is lost:\r\n\r\n```\r\npub fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\r\n    str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\r\n}\r\n```\r\n\r\nThe lifetime of the `s` is lost.  I have a fix for this in a branch I want to land (currently commented out with a FIXME) but I don't want to turn on the check because to do this right we need `&` objects working. I'm not even sure where to insert strategic transmutes to get `with_str_reader` working.\r\n\r\nThis signature for example should really be:\r\n```\r\npub fn with_str_reader<T>(s: &str, f: &fn(&Reader) -> T) -> T {...}\r\n```\r\nor even \r\n```\r\npub fn str_reader<'a, T>(s: &'a str) -> &'a Reader {...}\r\n```\r\n\r\nThere is a test that was supposed to be defending against this case, but it was basically accidentally reporting an error.\r\n"
5671,'nikomatsakis',"using 'self in return values doesn't appear to require a 'self parameter\nas shown by https://github.com/mozilla/rust/pull/5670/files\r\n\r\nI was already using `'self` in the return values for `find` and `find_mut` in the `Map` trait.\r\n\r\nI'm not entirely sure this is a bug.... but it's an inconsistency."
5598,'nikomatsakis',"&mut self and structs containing pointers don't mix because 'self is ambiguous\n@nikomatsakis is working on this, just filing it so I have an issue to refer to"
5533,'brson','rustdoc hides priv impls, but ignores overrides on methods themselves\n'
5495,'pcwalton','RFC: Forbid `pub` and `priv` in positions where they do not change the default behavior\nRight now structs are private-by-default and struct fields are public-by-default. And yet this is legal:\r\n```rust\r\npriv struct Foo {\r\n    pub bar: int\r\n}\r\n\r\nfn main() {}\r\n```\r\nThe `pub` and `priv` declarations there are meaningless. Allowing them in those positions will increase confusion over what the defaults actually are. I propose that this be forbidden.'
5490,'pcwalton',"rust could use linkonce_odr instead of internal on instantiations of generic functions\nThis is how clang tells LLVM to merge C++ template instantiations. It's somewhat complicated for C++ as shown by their [IR output tests](https://llvm.org/viewvc/llvm-project/cfe/trunk/test/CodeGenCXX/template-instantiation.cpp?view=markup) but Rust might just need `linkonce_odr` without the exceptions.\r\n\r\nIt's possible this isn't actually useful because of the compilation model of crates though. @pcwalton: any idea if this would have any meaning in Rust's world?"
5423,'nikomatsakis','After snapshot, update the abi constants in syntax/abi.rs\nIn syntax/abi.rs (not yet merged in), I had to hardcode various constants due to limitations in the stage0 compiler that appear to have been fixed by others in the meantime.'
5382,'pcwalton','Failure during stage1 libsyntax when removing drop block from core::task::mod\nThe "DeferInterrupts" struct. Here\'s the error:\r\n```\r\ncompile_and_link: x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libsyntax.so\r\nrustc: /media/linhaus/rust/src/rt/rust_sched_loop.cpp:323: void rust_sched_loop::transition(rust_task*, rust_task_state, rust_task_state, rust_cond*, const char*): Assertion `task->get_state() == src\' failed.\r\nAborted\r\nmake: *** [x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libsyntax.so] Error 134\r\n```'
5380,'pcwalton','Failure in the test suite when removing drop block from core::task::mod\nThe struct "DisallowFailure" in core::task::mod. Here\'s the error:\r\n```\r\ncompile_and_link: x86_64-unknown-linux-gnu/test/stdtest.stage2-x86_64-unknown-linux-gnu\r\n/media/linhaus/rust/src/libstd/std.rc:31:7: 31:23 warning: unknown `deny` attribute: `deprecated_self`\r\n/media/linhaus/rust/src/libstd/std.rc:31 #[deny(deprecated_self)];\r\n                                                ^~~~~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libstd/net_tcp.rs:1470:24: 1470:75 warning: unused import\r\n/media/linhaus/rust/src/libstd/net_tcp.rs:1470                     use net::tcp::test::tcp_ipv4_server_and_client_test::*;\r\n                                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libstd/sort.rs:758:8: 758:25 warning: unused import\r\n/media/linhaus/rust/src/libstd/sort.rs:758     use core::prelude::*;\r\n                                                   ^~~~~~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libstd/sort.rs:713:8: 713:25 warning: unused import\r\n/media/linhaus/rust/src/libstd/sort.rs:713     use core::prelude::*;\r\n                                                   ^~~~~~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:941:8: 956:9 warning: argument 1 uses by-copy mode\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:941         fn test_try_recv_none4<P:BytePort>(+loader: PortLoader<P>) {\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:942             fail_unless!(do task::try || {\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:943                 const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:944                 // The control word is followed by a valid length,\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:945                 // then undeserializable garbage\r\n/media/linhaus/rust/src/libstd/flatpipes.rs:946                 let len_bytes = do io::u64_to_be_bytes(\r\n                                                ...\r\nrun: x86_64-unknown-linux-gnu/test/stdtest.stage2-x86_64-unknown-linux-gnu\r\n\r\nrunning 355 tests\r\nstdtest.stage2-x86_64-unknown-linux-gnu: /media/linhaus/rust/src/rt/rust_task.cpp:647: void rust_task::allow_kill(): Assertion `disallow_kill > 0 && "Illegal allow_kill(): already killable!"\' failed.\r\nrust: task failed at \'assertion failed: *one == 2\', /media/linhaus/rust/src/libstd/arc.rs:565\r\nAborted\r\nmake: *** [tmp/check-stage2-T-x86_64-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-std.ok] Error 134\r\n```'
5379,'pcwalton','Endless hang during stage1 when removing drop block from core::task::mod\nThe AllowFailure struct in core::task::mod. Hangs infinitely while compiling stage1 libcore, with 0% CPU utilization from rustc.'
5378,'pcwalton','Failure during stage1 libcore when removing a drop block from core::unstable\nThe `Unlock` struct in core::unstable contains a drop block. Removing it causes this error:\r\n```\r\ncompile_and_link: x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libcore.so\r\n/media/linhaus/rust/src/libcore/core.rc:54:7: 54:23 warning: unknown `deny` attribute: `deprecated_self`\r\n/media/linhaus/rust/src/libcore/core.rc:54 #[deny(deprecated_self)];\r\n                                                  ^~~~~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libcore/flate.rs:20:4: 20:18 warning: unused import\r\n/media/linhaus/rust/src/libcore/flate.rs:20 use rand::RngUtil;\r\n                                                ^~~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libcore/stackwalk.rs:83:20: 83:33 warning: argument 1 uses by-copy mode\r\n/media/linhaus/rust/src/libcore/stackwalk.rs:83 fn frame_address(f: &fn(++x: *u8)) {\r\n                                                                    ^~~~~~~~~~~~~\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:225:8: 235:9 warning: argument 3 uses by-copy mode\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:225         extern fn read_cb(stream: *uvll::uv_stream_t,\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:226                           nread: ssize_t, ++buf: Buf) {\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:227             rtdebug!("buf addr: %x", buf.base as uint);\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:228             rtdebug!("buf len: %d", buf.len as int);\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:229             let mut stream_watcher: StreamWatcher =\r\n/media/linhaus/rust/src/libcore/rt/uv.rs:230                 NativeHandle::from_native_handle(stream);\r\n                                             ...\r\npthread_mutex_destroy(&_mutex) failed in /media/linhaus/rust/src/rt/sync/lock_and_signal.cpp at line 67, result = 16 (Device or resource busy)\r\nAborted\r\nmake: *** [x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libcore.so] Error 134\r\n```'
5377,'pcwalton','Failure in the test suite when removing a drop block from core::pipes\nThe `DropState` struct in core::pipes still contains a drop block. Converting it to a trait causes an error while running the test suite:\r\n```\r\nerror: test run failed!\r\ncommand: x86_64-unknown-linux-gnu/test/run-pass/issue-3168.stage2-x86_64-unknown-linux-gnu\r\nstdout:\r\n------------------------------------------\r\n\r\n------------------------------------------\r\nstderr:\r\n------------------------------------------\r\nrust: ~"\\"sibling fails\\""\r\nrust: task failed at \'explicit failure\', /media/linhaus/rust/src/test/run-pass/issue-3168.rs:20\r\nrust: ~"\\"child blocks\\""\r\nrust: task failed at \'killed\', /media/linhaus/rust/src/libcore/pipes.rs:322\r\nrust: ~"\\"parent tries\\""\r\nrust: task failed at \'assertion failed: !p.recv().try_send(())\', /media/linhaus/rust/src/test/run-pass/issue-3168.rs:29\r\nrust: domain main @0xbac9c0 root task failed\r\n\r\n------------------------------------------\r\n\r\nrust: task failed at \'explicit failure\', /media/linhaus/rust/src/compiletest/runtest.rs:697\r\n```'
5362,'nikomatsakis',"borrow check doesn't distinguish different tuple elements in match expression\n```rust\r\nenum Foo {\r\n    X, Y(uint, uint)\r\n}\r\n\r\nfn main() {\r\n    // works\r\n    let mut x = (1, 2);\r\n    let (ref _k, ref mut _v) = x;\r\n\r\n    // doesn't work\r\n    let mut y = Y(1, 2);\r\n    match y {\r\n      Y(ref _v, ref mut _k) => {}\r\n\r\n      // error: loan of enum content as mutable conflicts with prior loan\r\n      // Y(ref _v, ref mut _k) => {}\r\n      //           ^~~~~~~~~~~\r\n      // note: prior loan as immutable granted here\r\n      // Y(ref _v, ref mut _k) => {}\r\n      //   ^~~~~~~\r\n\r\n      X => ()\r\n    }\r\n}\r\n```\r\n"
5347,'brson','segfault on i686-unknown-linux-gnu returning a struct from C\n```\r\nstruct rust_dbg_struct {\r\n    a: uint,\r\n    b: uint\r\n}\r\n\r\nextern {\r\n    fn rust_dbg_return_struct() -> rust_dbg_struct;\r\n}\r\n\r\nfn main() {\r\n    unsafe {\r\n        let s = rust_dbg_return_struct();\r\n        fail_unless!(s.a == 10);\r\n        fail_unless!(s.b == 20);\r\n    }\r\n}\r\n```\r\n\r\nThe C code:\r\n\r\n```\r\nstruct rust_dbg_struct {\r\n    uintptr_t a;\r\n    uintptr_t b;\r\n};\r\n\r\nextern "C" rust_dbg_struct\r\nrust_dbg_return_struct() {\r\n    struct rust_dbg_struct s;\r\n    s.a = 10;\r\n    s.b = 20;\r\n    return s;\r\n}\r\n```\r\n\r\nRelated to #2064'
5321,'nikomatsakis','LLVM assertion using bare self value\n```rust\r\ntrait FTErrorMethods {\r\n    fn succeeded(self) -> bool;\r\n}\r\n\r\nimpl FTErrorMethods for int {\r\n    fn succeeded(self) -> bool { self == 0 }\r\n}\r\n\r\nfn main() {\r\n    5.succeeded();\r\n}\r\n```\r\n```\r\nrustc: /run/media/jdm/ssd/rust/src/llvm/lib/VMCore/Instructions.cpp:2383: static llvm::CastInst* llvm::CastInst::CreatePointerCast(llvm::Value*, llvm::Type*, const llvm::Twine&, llvm::Instruction*): Assertion `S->getType()->isPointerTy() && "Invalid cast"\' failed.\r\n```\r\n\r\n```\r\n#4  0x00007ffff62dc216 in llvm::CastInst::CreatePointerCast(llvm::Value*, llvm::Type*, llvm::Twine const&, llvm::Instruction*) () from /usr/local/bin/../lib/librustllvm.so\r\n#5  0x00007ffff6268fe0 in llvm::IRBuilder<true, llvm::ConstantFolder, llvm::IRBuilderDefaultInserter<true> >::CreatePointerCast(llvm::Value*, llvm::Type*, llvm::Twine const&) ()\r\n   from /usr/local/bin/../lib/librustllvm.so\r\n#6  0x00007ffff6265f35 in LLVMBuildPointerCast () from /usr/local/bin/../lib/librustllvm.so\r\n#7  0x00007ffff74191c2 in LLVMBuildPointerCast__c_stack_shim () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#8  0x00007ffff54e7649 in __morestack () from /usr/local/bin/../lib/librustrt.so\r\n#9  0x00007ffff54d8104 in call_on_c_stack (fn_ptr=0x7ffff7419180, args=0x7fffe849a998, this=0x7ffff0108830) at /run/media/jdm/ssd/rust/src/rt/rust_task.h:478\r\n#10 upcall_call_shim_on_c_stack (args=0x7fffe849a998, fn_ptr=0x7ffff7419180) at /run/media/jdm/ssd/rust/src/rt/rust_upcall.cpp:64\r\n#11 0x00007ffff6d9c09a in middle::trans::build::PointerCast::_aee05de3d6b51f11::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#12 0x00007ffff6ddd6ce in middle::trans::callee::trans_call_inner::anon::expr_fn_27457 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#13 0x00007ffff6d991cc in middle::trans::base::with_scope::_518696e6502795b0::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#14 0x00007ffff6dcf435 in middle::trans::callee::trans_method_call::_12bb7b81ca47a09::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#15 0x00007ffff6de983c in middle::trans::expr::trans_rvalue_dps_unadjusted::_cbdc4c02519225::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#16 0x00007ffff6de4b64 in middle::trans::expr::trans_to_datum_unadjusted::_a2a3224b30364953::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#17 0x00007ffff6d50cc0 in middle::trans::expr::trans_to_datum::_a2a3224b30364953::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#18 0x00007ffff6de7d4e in middle::trans::expr::trans_rvalue_datum_unadjusted::_a2a3224b30364953::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#19 0x00007ffff6de47fa in middle::trans::expr::trans_to_datum_unadjusted::_a2a3224b30364953::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#20 0x00007ffff6d50cc0 in middle::trans::expr::trans_to_datum::_a2a3224b30364953::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#21 0x00007ffff6d4e7ca in middle::trans::controlflow::trans_if::_fcc7ad9922f2f49::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#22 0x00007ffff6de9c99 in middle::trans::expr::trans_rvalue_dps_unadjusted::_cbdc4c02519225::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#23 0x00007ffff6d4de34 in middle::trans::expr::trans_into::_cbdc4c02519225::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#24 0x00007ffff7434814 in __morestack () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#25 0x00007ffff6d4cf3d in middle::trans::base::trans_stmt::_d936d389a86c7a66::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#26 0x00007ffff6d4c426 in middle::trans::controlflow::trans_block::anon::expr_fn_21837 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#27 0x00007ffff6d4a66e in middle::trans::controlflow::trans_block::_84b7ff1756c49e1::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#28 0x00007ffff6e513b7 in middle::trans::base::trans_closure::_33dc6c6bc3c467::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#29 0x00007ffff6d03624 in middle::trans::base::trans_fn::_bbb928f648ebbdfa::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#30 0x00007ffff6cfb180 in middle::trans::base::trans_item::_e5c80d83455a852::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#31 0x00007ffff6e57e30 in middle::trans::base::trans_mod::_f6b5437a924015ec::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#32 0x00007ffff6e75e5b in middle::trans::base::trans_crate::_685731d1dcd33aec::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#33 0x00007ffff73f4993 in driver::driver::compile_rest::_3dc0cd32a85c34a0::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#34 0x00007ffff7434814 in __morestack () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#35 0x00007ffff73f6ef7 in driver::driver::compile_upto::_23bd5d90dda9e867::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#36 0x00007ffff7434814 in __morestack () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#37 0x00007ffff73f72f9 in driver::driver::compile_input::_594ffb6142f762a7::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#38 0x00007ffff742542f in run_compiler::_c936523e1243e7f::_06 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#39 0x00007ffff7432151 in monitor::anon::expr_fn_82369 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#40 0x00007ffff742e57b in task::__extensions__::try_81880::anon::expr_fn_82143 () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#41 0x00007ffff7434814 in __morestack () from /usr/local/bin/../lib/librustc-c84825241471686d-0.6.so\r\n#42 0x00007ffff7df363a in task::spawn::spawn_raw::make_child_wrapper::anon::expr_fn_11480 () from /usr/local/bin/../lib/libcore-c3ca5d77d81b46c1-0.6.so\r\n#43 0x00007ffff7e5aa20 in __morestack () from /usr/local/bin/../lib/libcore-c3ca5d77d81b46c1-0.6.so\r\n#44 0x00007ffff54d70a4 in task_start_wrapper (a=0x7ffff0109660) at /run/media/jdm/ssd/rust/src/rt/rust_task.cpp:162\r\n#45 0x0000000000000000 in ?? ()\r\n```'
5280,'nikomatsakis','LLVM assertion when creating region pointer for bare self value\n```rust\r\ntype FontTableTag = u32;\r\n\r\ntrait FontTableTagConversions {\r\n  fn tag_to_str(self);\r\n}\r\n\r\nimpl FontTableTagConversions for FontTableTag {\r\n  fn tag_to_str(self) {\r\n    &self;\r\n  }\r\n}\r\n\r\nfn main() {\r\n    5.tag_to_str();\r\n}\r\n```\r\n\r\n```rustc: /run/media/jdm/ssd/rust/src/llvm/lib/VMCore/Instructions.cpp:2383: static llvm::CastInst* llvm::CastInst::CreatePointerCast(llvm::Value*, llvm::Type*, const llvm::Twine&, llvm::Instruction*): Assertion `S->getType()->isPointerTy() && "Invalid cast"\' failed.```'
5121,'nikomatsakis',"Only `'static` is permitted within type bounds (causes ICE: Cannot relate bound region)\nOnce we can declare lifetime parameters, there is no reason not to permit them in type bounds.  Also, I am not entirely sure if the way we are handling them is correct/sound.  I've tagged places where such bounds appear with FIXMEs so that I can look into them later. \r\n\r\n---\r\n\r\nExample:\r\n\r\n```rust\r\ntrait Iterable<'a> {\r\n    fn my_iter(&'a self);\r\n}\r\n\r\nfn foo<'a, C: Iterable<'a>>(c: C) {\r\n    c.my_iter();\r\n}\r\n\r\nfn main() { }\r\n```\r\n\r\n```\r\n5121.rs:6:5: 6:6 error: internal compiler error: Cannot relate bound region: ReLateBound(12, BrNamed(syntax::ast::DefId{crate: 0u32, node: 21u32}, a)) <= ReInfer(1)\r\nThis message reflects a bug in the Rust compiler. \r\nWe would appreciate a bug report: https://github.com/mozilla/rust/wiki/HOWTO-submit-a-Rust-bug-report\r\n5121.rs:6     c.my_iter();\r\n              ^\r\ntask 'rustc' failed at 'explicit failure', /home/huon/rust/src/libsyntax/diagnostic.rs:41\r\ntask '<main>' failed at 'explicit failure', /home/huon/rust/src/librustc/lib.rs:440\r\n```\r\n\r\n----\r\n\r\npnkfelix: I am adding a checklist to the bottom of this bug, where the unchecked issues represent problems that still remain unfixed (and the entire list of issues were closed as duplicates of this ticket).\r\n\r\n * [x] #10391\r\n * [x] #10467 \r\n * [x] #10841 \r\n * [x] #10868\r\n * [x] #11016 \r\n * [x] #11446 \r\n * [x] #11881 \r\n * [x] #12008 \r\n * [x] #12851 \r\n * [x] #5715\r\n * [x] #11971 \r\n * [x] #12856 \r\n * [x] #12857 "
5087,'nikomatsakis','Make object types not implement their associated trait\nCurrently we have some rather complex rules for when an object type `@T` (or `&T` etc) for a trait `T` implements the trait `T`.  I think we should just say that `@T` does not implement `T`.  \r\n\r\nWe can instead add a deriving mode `#[deriving_self(managed|borrowed|owned)]` to derive an implementation of `T` for `@T`, `&T`, or `~T`.\r\n\r\n## Problems that this avoids\r\n\r\nThere are a number of unsoundness issues that can result from object types implementing their associated trait.  Consider the following examples:\r\n\r\n    fn foo<T: Eq>(x: &T, y: &T) { ... x.eq(y) ... }\r\n    foo::<@Eq>(1 as @Eq, @"hi" as @Eq) // now we are comparing 1.eq("hi")!\r\n\r\n    trait AtFoo { fn foo(@self, ...) { ... } }\r\n    fn bar<T: AtFoo>(x: @T) { x.foo(); }\r\n    bar::<~AtFoo>(@(x as ~AtFoo)) // now we are calling `bar()` with a `~Foo` receiver!\r\n\r\n    trait MakeMe { fn foo() -> Self { ... } }\r\n    fn bar<T: MakeMe>(x: T) { ... let y = MakeMe::foo(); ... }\r\n    bar::<@MakeMe>(1 as @MakeMe); // now x has type @MakeMe but y has type int\r\n\r\nWe can come up with rules that prevent these examples, but those rules ultimately get quite complex.  Simply saying that `@T does not implement T` avoids all these problems.  Then we can add a deriving rule.  All of the scenarios above would result in a type check violation when you tried to actually write out that impl.'
5074,'nikomatsakis',"Meta: Borrow checker rules rewrite\nThe current borrow checker rules are not *quite* sound and also insufficient expressive.  They don't support nested calls nor are they flow-sensitive.  I have a rewrite in progress to address these 3 issues."
4920,'nikomatsakis','RFC: Change operator method lookup to be less magical\nRight now, operator "methods" proceed according to the same logic as any other method.  But this leads to surprising results like this: https://gist.github.com/bstrie/4948410\r\n\r\nAlso, operators are already handled somewhat specially because we auto-ref their arguments.  This means that you can write `val1-of-my-linear-type == val2-of-my-linear-type` and it doesn\'t move or do anything creepy (to call eq explicitly, in contrast, you\'d write `val1-of-my-linear-type.eq(&val2-of-my-linear-type)`).\r\n\r\nI think method lookup for operators should never apply any automatic transformations to the receiver or arguments, other than the current auto-ref behavior (which means that `a OP b` is kind of implicitly `(&a).OP(&b)`)\r\n\r\n@pcwalton I expect you in particular might have an opinion about this.\r\n\r\n'
4903,'nikomatsakis','Borrow checker is not flow sensitive\nThis results in spurious errors.  Proper fix is a bit tricky so as to avoid re-encoding the control flow that liveness/trans already know about.  May come about as part of a refactoring I want to do to liveness to accommodate once fns.'
4846,'nikomatsakis','New syntax for lifetimes\nAs described in this mailing list thread:\r\n\r\nhttps://mail.mozilla.org/pipermail/rust-dev/2013-February/003105.html'
4821,'nikomatsakis','Use of Option<~T> (at least sometimes...) considered a copy\nIn this test case:\r\n\r\n```\r\n// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\r\n// file at the top-level directory of this distribution and at\r\n// http://rust-lang.org/COPYRIGHT.\r\n//\r\n// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\r\n// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\r\n// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\r\n// option. This file may not be copied, modified, or distributed\r\n// except according to those terms.\r\n\r\nextern mod std;\r\nuse core::cmp::Ord;\r\nuse core::option::swap_unwrap;\r\n\r\nstruct TreeNode<K> {\r\n    key: K,\r\n    left: Option<~TreeNode<K>>,\r\n    right: Option<~TreeNode<K>>,\r\n    level: uint\r\n}\r\n\r\nfn split<K: Ord>(node: ~TreeNode<K>) -> ~TreeNode<K> {\r\n    match node.right {\r\n      Some(right) => {\r\n        match right.right {\r\n          Some(right2) => {\r\n            if right2.level != node.level {\r\n                node\r\n            } else { // double horizontal link\r\n                let mut node = node;\r\n                let mut save = swap_unwrap(&mut node.right);\r\n                node.right <-> save.left; // save.left now None\r\n                save.left = Some(node);\r\n                save.level += 1;\r\n                save\r\n            }\r\n          }\r\n          None => node\r\n        }\r\n      }\r\n      None => node\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nThe `match node.right` seems to be considered a copy, not a move.  This appears to be a bug in the kind code.  I will dig more to be sure.  \r\n\r\nHat tip: @thestinger'
4759,'nikomatsakis','Segfault moving out of a struct and then calling a move-out-of-self method\nThis code segfaults:\r\n\r\n```\r\nstruct T { a: ~int }\r\n\r\ntrait U {\r\n    fn f(self);\r\n}\r\n\r\nimpl ~int: U {\r\n    fn f(self) { }\r\n}\r\n\r\nfn main() {\r\n    let T { a: a } = T { a: ~0 };\r\n    a.f();\r\n}\r\n```\r\n\r\nwith this output:\r\n\r\n```\r\ntest(9593,0x10b268000) malloc: *** error for object 0xffffffffffffffff: pointer being freed was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\n```\r\n\r\nand this stack trace:\r\n\r\n```\r\n#0  0x00007fff8dd2a558 in malloc_error_break ()\r\n#1  0x00007fff8dd2b912 in free ()\r\n#2  0x000000010028a727 in __morestack () at rust_task.cpp:1327\r\n#3  0x00000001002790c5 in rust_task::call_on_c_stack (this=0x100500000, args=0x1010051e0, fn_ptr=0x10027a5c0) at rust_task.h:494\r\n#4  0x000000010027a591 in upcall_exchange_free (ptr=0xffffffffffffffff) at rust_upcall.cpp:45\r\n#5  0x000000010000192f in glue_free_1935 ()\r\n#6  0x00000001000018d1 in glue_drop_1933 ()\r\n#7  0x000000010000187d in __extensions__::meth_1925::f::_e2974ddf553dde8::_00 ()\r\n#8  0x00000001000019c3 in main::_e2974ddf553dde8::_00 ()\r\n#9  0x0000000100001a5e in _rust_main ()\r\n#10 0x0000000100278ca5 in task_start_wrapper (a=0x150b) at rust_task.cpp:164\r\n```\r\n\r\nWhen getting rid of the unique pointer, I instead get an llvm assertion. Here\'s the code:\r\n\r\n```\r\nstruct T { a: int }\r\n\r\ntrait U {\r\n    fn f(self);\r\n}\r\n\r\nimpl int: U {\r\n    fn f(self) { }\r\n}\r\n\r\nfn main() {\r\n    let T { a: a } = T { a: 0 };\r\n    a.f();\r\n}\r\n```\r\n\r\nand the output:\r\n\r\n```\r\nAssertion failed: (S->getType()->isPointerTy() && "Invalid cast"), function CreatePointerCast, file /Users/erickt/Projects/rust/rust/src/llvm/lib/VMCore/Instructions.cpp, line 2383.\r\n```\r\n\r\nand this stack trace:\r\n\r\n```\r\n#0  0x00007fff8ee60212 in __pthread_kill ()\r\n#1  0x00007fff8dd13af4 in pthread_kill ()\r\n#2  0x0000000101f57706 in abort ()\r\n#3  0x0000000101f57758 in __assert_rtn ()\r\n#4  0x0000000101edb490 in llvm::CastInst::CreatePointerCast ()\r\n#5  0x0000000101e4b8d2 in llvm::IRBuilder<true, llvm::ConstantFolder, llvm::IRBuilderDefaultInserter<true> >::CreatePointerCast ()\r\n#6  0x0000000101e44838 in LLVMBuildPointerCast ()\r\n#7  0x0000000100feb8a2 in LLVMBuildPointerCast__c_stack_shim ()\r\n#8  0x000000010143c727 in __morestack () at rust_task.cpp:1327\r\n#9  0x000000010142b0c5 in rust_task::call_on_c_stack (this=0x10270c4e0, args=0x104018e78, fn_ptr=0x104018e78) at rust_task.h:494\r\n#10 0x000000010142be69 in upcall_call_shim_on_c_stack (args=0x104018e78, fn_ptr=0x100feb860) at rust_upcall.cpp:60\r\n#11 0x000000010098f50d in middle::trans::build::PointerCast::_3e38238393e5948d::_06 ()\r\n#12 0x00000001009cbaa9 in middle::trans::callee::trans_call_inner::anon::expr_fn_26727 ()\r\n#13 0x000000010098cd5f in middle::trans::base::with_scope::_fc26e1201346c1::_06 ()\r\n#14 0x00000001009bf41c in middle::trans::callee::trans_method_call::_921043a626596462::_06 ()\r\n#15 0x00000001009d6e25 in middle::trans::expr::trans_rvalue_dps_unadjusted::_6ab5e6d9b19a6bf::_06 ()\r\n#16 0x0000000100941de4 in middle::trans::expr::trans_into::_6ab5e6d9b19a6bf::_06 ()\r\n#17 0x00000001009410ed in middle::trans::base::trans_stmt::_7d7890c648bcf45::_06 ()\r\n#18 0x000000010094086f in middle::trans::controlflow::trans_block::anon::expr_fn_21347 ()\r\n#19 0x000000010093f58e in middle::trans::controlflow::trans_block::_f6936ad596fe591::_06 ()\r\n#20 0x0000000100a3b97c in middle::trans::base::trans_closure::_a0aad068b0e5e392::_06 ()\r\n#21 0x00000001008f7ffb in middle::trans::base::trans_fn::_13f9f715bbcfc56a::_06 ()\r\n#22 0x00000001008edd67 in middle::trans::base::trans_item::_2b701e478e1eb5f::_06 ()\r\n#23 0x0000000100a4203f in middle::trans::base::trans_mod::_e154c83e57d2e40::_06 ()\r\n#24 0x0000000100a5cfda in middle::trans::base::trans_crate::_23f87efa473f426::_06 ()\r\n#25 0x000000010100d295 in __morestack ()\r\n```'
4734,'nikomatsakis','Finalizer not run if struct with dtor is not assigned to a variable.\nThis leaks.  (and it fails to perform all the other side-effects one might expect from relevant destructors.)\r\n\r\n```rust\r\nuse std::cast::transmute;\r\nuse std::libc::c_void;\r\n\r\nstruct Rattle { croak: ~str }\r\n\r\nimpl Drop for Rattle {\r\n    fn drop(&mut self) {\r\n        println!("Goodbye {}",self.croak);\r\n    }\r\n}\r\n\r\nstruct NonCopyable {\r\n    r: Rattle,\r\n    p: *c_void\r\n}\r\n\r\nimpl Drop for NonCopyable {\r\n    fn drop(&mut self) {\r\n        let p = self.p;\r\n        let _v = unsafe { transmute::<*c_void, ~int>(p) };\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let t = ~0;\r\n    let p = unsafe { transmute::<~int, *c_void>(t) };\r\n\r\n    let _x = NonCopyable { r: Rattle{ croak: ~"assigned" }, p: p };\r\n    // assigning this to a variable makes it not leak\r\n    NonCopyable { r: Rattle{ croak: ~"unassigned" }, p: p };\r\n}\r\n```\r\n\r\nNamely, running it prints:\r\n```\r\n% rustc /tmp/issue4734.rs && /tmp/issue4734\r\nwarning: no debug symbols in executable (-arch x86_64)\r\nGoodbye assigned\r\n```\r\n'
4723,'nikomatsakis',"Region parameterization inference does not consider inheritance\nSee this code:\r\n\r\n```\r\npub trait Map<K, V> {\r\n    pure fn f(&self) -> Option<&self/V>;\r\n}\r\n \r\npub trait MutableMap<K, V>: Map<K, V> {\r\n}\r\n \r\nfn main() { }\r\n```\r\n\r\nIt fails with:\r\n\r\n```\r\nfoo.rs:7:28: 7:37 error: to use region types here, the containing type must be declared with a region bound\r\nfoo.rs:7 pub trait MutableMap<K, V>: Map<K, V> {\r\n                                     ^~~~~~~~~\r\nerror: aborting due to previous error\r\n```\r\n\r\nI'm not quite sure what to do in this case. Is this an error? If not, how do I pass a region bound to a parent trait?"
4716,'nikomatsakis','Disallow "partial" borrows of `@mut` \nRight now if you have an `@mut` data structure and you borrow a sub-field, you wind up freezing the whole box and its confusing.  We should only permit you to borrow the whole `@mut`, which makes this particular error a bit harder to do.  '
4715,'nikomatsakis',"Better message when illegal moves result from a binding\nWhen you have a by-move binding in a match, it causes a move of the discriminant.  It'd be nice if any errors resulting from this move identified the binding that caused the move.  This requires some modifications to `moves` (to identify the binding and track it), `liveness` (to report the error in terms of the binding) and possibly `borrowck` (which also can report errors related to illegal moves)"
4679,'nikomatsakis',"Segfault from incorrect capture\nI've hit this several times recently.\r\n\r\n```\r\nuse core::pipes::*;\r\n\r\nfn main() {\r\n    let (po, ch) = stream();\r\n    let ch = SharedChan(ch);\r\n\r\n    for 100.times {\r\n        do task::spawn {\r\n            // ch should not be copyable\r\n            ch.send(());\r\n        }\r\n    }\r\n}\r\n```"
4666,'nikomatsakis',"Odd loaning errors when similar code works\nFor this code\r\n\r\n```rust\r\nuse core::hashmap::linear::LinearMap;\r\n \r\nfn fun1() {\r\n  let mut map = LinearMap::new();\r\n  map.insert(1, 2);\r\n  // ok\r\n  let size;\r\n  size = *map.get(&1);\r\n  map.insert(2, size);\r\n}\r\n \r\nfn fun2() {\r\n  let mut map = LinearMap::new();\r\n  map.insert(1, 2);\r\n  let size = *map.get(&1); // note: prior loan of immutable granted here\r\n  map.insert(2, size); // error: loan of mutable local variable as mutable conflicts with prior loan\r\n}\r\n \r\nfn fun3() {\r\n  let mut map = LinearMap::new();\r\n  map.insert(1, 2);\r\n  // more bad, same as fun2\r\n  map.insert(2, *map.get(&1));\r\n}\r\n \r\nfn main() {}\r\n```\r\n\r\n`fun1` passes through the compiler, but both `fun2` and `fun3` generate an error (listed in `fun2`) and I'm not sure why `fun2` is invalid while `fun1` is valid."
4645,'pcwalton',"Forbid structural records\nr? @pcwalton - Disallow structural records by default, allow them at the crate level where necessary. (I already pushed patches to remove uses of structural records for most run-pass and run-fail tests; haven't gotten as far as compile-fail and docs yet, so this won't build, but I won't push as-is.)"
4634,'nikomatsakis','Allow region pointer to unsafe pointer casts in const expressions.\nr? @nmatsakis'
4542,'nikomatsakis','Segfault matching copy of dereferenced owned string\n```\r\nfn main() {\r\n    for os::args().each |arg| {\r\n        match copy *arg {\r\n            s => { }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\n#0  0x000000395a835935 in raise () from /lib64/libc.so.6\r\n#1  0x000000395a8370e8 in abort () from /lib64/libc.so.6\r\n#2  0x000000395a874e8b in __libc_message () from /lib64/libc.so.6\r\n#3  0x000000395a87c00e in _int_free () from /lib64/libc.so.6\r\n#4  0x00007ffff7dae669 in __morestack () from /tmp/../usr/local/lib/rustc/x86_64-unknown-linux-gnu/lib/librustrt.so\r\n#5  0x00007ffff7d9dc68 in call_on_c_stack (fn_ptr=0x7ffff7d9cb70, args=0x7ffff0101650, this=0x407180) at /run/media/jdm/ssd/rust/src/rt/rust_task.h:494\r\n#6  call_upcall_on_c_stack (fn_ptr=0x7ffff7d9cb70, args=0x7ffff0101650, task=<optimized out>) at /run/media/jdm/ssd/rust/src/rt/rust_upcall.cpp:45\r\n#7  upcall_exchange_free (ptr=<optimized out>) at /run/media/jdm/ssd/rust/src/rt/rust_upcall.cpp:208\r\n#8  0x0000000000401d7f in glue_free_1939 ()\r\n#9  0x00000000004021c7 in main::anon::expr_fn_1955 ()\r\n#10 0x000000000040175b in vec::__extensions__::each_1861::anon::expr_fn_1914 ()\r\n#11 0x0000000000401472 in vec::each_1864::anon::expr_fn_1894 ()\r\n#12 0x00000000004011a2 in vec::as_imm_buf_1867::_43d6e68cf6296159::_00 ()\r\n#13 0x00000000004022b4 in __morestack ()\r\n#14 0x0000000000401087 in vec::each_1864::_83f0fe0dda0fc51::_00 ()\r\n#15 0x0000000000400fe5 in vec::__extensions__::each_1861::_a7cec32bfdc93c6::_00 ()\r\n#16 0x0000000000401f83 in main::_fe18229bb2f275::_00 ()\r\n#17 0x000000000040203e in _rust_main ()\r\n#18 0x00007ffff7d9b4e4 in task_start_wrapper (a=0x407fd0) at /run/media/jdm/ssd/rust/src/rt/rust_task.cpp:164\r\n#19 0x0000000000000000 in ?? ()\r\n```'
4541,'nikomatsakis','Segfault when matching a copy of a owned box\nI am very new to rust, so please bear with me :).\r\n\r\nWhen trying to do a small routine to parse the arguments of a program, I stumbled on a nice segfault. Here is the prototype of what I tried.\r\n\r\n```rust\r\nfn parse_args() -> ~str {\r\n    let args = core::os::args();\r\n    let mut n = 0;\r\n\r\n    while n < args.len() {\r\n        match copy args[n] {\r\n            ~"-v" => (),\r\n            s => {\r\n                return s;\r\n            }\r\n        }\r\n        n += 1;\r\n    }\r\n\r\n    return ~""\r\n}\r\n\r\nfn main() {\r\n    io::println(parse_args());\r\n}\r\n```\r\n\r\nThis example is meaningless and only illustrates the issue. I managed to write what I wanted in a cleanier style afterwards but I still think it\'s a bug.\r\n\r\nIt compiles without a warning but it crashes violently when running it.'
4538,'nikomatsakis',"Remove last-use analysis\nI noticed that liveness still produces a ```last_use_map``` though as far as I know, trans doesn't use the results of the last-use analysis anymore and neither does anything else. It's time to remove this code."
4492,'nikomatsakis',"ICE from regions (Cannot encode region variables)\nI'll try cutting this down to a small test case later, but for now here are some in my TreeMap implementation (commented out):\r\n\r\n* https://github.com/thestinger/rust/blob/f94da6e7d7e304204d10bcd4100b829f1ddd0ca0/src/libstd/treemap.rs#L51\r\n* https://github.com/thestinger/rust/blob/f94da6e7d7e304204d10bcd4100b829f1ddd0ca0/src/libstd/treemap.rs#L673\r\n* https://github.com/thestinger/rust/blob/f94da6e7d7e304204d10bcd4100b829f1ddd0ca0/src/libstd/treemap.rs#L683\r\n"
4480,'pcwalton',"Don't switch to the C stack when there is room on the Rust stack\nIf there is sufficient room on the Rust stack to run a particular foreign function then we don't need to switch stacks. Each scheduler has a native stack size so we just need the Rust segment to be larger than that (and they can be much larger).\r\n\r\nAt that point we can annotate specific functions in core with their required stack size. It could significantly reduce the number of stack switches we do."
4479,'pcwalton',"Run Rust code on native stack segments\nCurrently when we call into C code we don't update the stack pointer to account for the native stack segment, and when we call back into Rust code we immediately switch back to a Rust stack, wasting space on the native stack.\r\n\r\nInstead, we should treat the foreign segment the same as any other - putting it into the TCB. Instead of an explicit stack switch to call Rust code, we'll just Run it on the foreign stack. Then the Rust code will start adding new stack segments as needed.\r\n\r\nThis will give uv callbacks better performance, and will eliminate some of performance concerns around calls from SpiderMonkey into the Rust DOM.\r\n\r\nIt will also eliminate the need to set the TCB stack pointer to 0 when entering the native stack, eliminating some of the need for `no_split_stack`. (#1804, #1226)"
4384,'nikomatsakis','Generalize moves to allow moves out of any owned content\nThis program should be legal\r\n\r\n```\r\nstruct Foo {\r\n    v: ~[uint]\r\n}\r\n\r\nfn make_foo() -> Foo {\r\n    Foo { v: ~[1, 2, 3] }\r\n}\r\n\r\nfn main() {\r\n    let v = make_foo().v;\r\n    for v.each |i| { io::println(fmt!("%u", *i)); }\r\n}\r\n```\r\n\r\nBut it yields:\r\n\r\n```\r\n/Users/nmatsakis/tmp/bar.rs:10:12: 10:24 error: moving out of immutable field\r\n/Users/nmatsakis/tmp/bar.rs:10     let v = make_foo().v;\r\n                                           ^~~~~~~~~~~~\r\n```'
4318,'nikomatsakis','Segfault with explicit, by-value self and vectors\nThe following code compiles but segfaults when run:\r\n\r\n    trait F<T> {\r\n        fn f(self);\r\n    }\r\n\r\n    impl <T> ~[T] : F<T> {\r\n        fn f(self) {}\r\n    }\r\n\r\n    fn main() {\r\n        (~[1]).f();\r\n    }\r\n\r\nChanging `f` to take `&self` makes it work.\r\n\r\nThis might be related to https://github.com/mozilla/rust/issues/4132'
4269,'pcwalton','Deriving cmp::Ord\nIt would be useful to be able to derive a cmp::Ord impl, similarly to how you can derive cmp::Eq impls.'
4216,'pcwalton','Paths should terminate at module scope\n'
4188,'pcwalton',"ICE with generic new-type structs\n~~~\r\nstruct Foo<T>(T);\r\n\r\nfn main() {\r\n    let _ = Foo(42);\r\n}\r\n~~~\r\n\r\n~~~\r\n$ RUST_LOG=rustc=1,::rt::backtrace rustc --out-dir . src/test.rs\r\nrust: task failed at 'unknown node type in type_use', /usr/local/src/rust/src/librustc/middle/trans/type_use.rs:139\r\nerror: internal compiler error: unexpected failure\r\nnote: the compiler hit an unexpected failure path. this is a bug\r\nnote: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues\r\nrust: task failed at 'explicit failure', /usr/local/src/rust/src/librustc/rustc.rc:483\r\nrust: domain main @0x7fd7fa00bc10 root task failed\r\nrust: task failed at 'killed', /usr/local/src/rust/src/libcore/task/mod.rs:630\r\n~~~"
4183,'nikomatsakis',"Problem with `self` when inheriting generic traits.\n~~~\r\nextern mod std;\r\nuse std::cmp::FuzzyEq;\r\n\r\ntrait Float: FuzzyEq<Self> {\r\n    static pure fn two_pi() -> Self;\r\n}\r\n\r\nimpl f32: Float {\r\n    static pure fn two_pi() -> f32 { 6.28318530717958647692528676655900576_f32 }\r\n}\r\n\r\nstruct Radians<T>(T);\r\n\r\nimpl<T:Copy Float> Radians<T> {\r\n    static pure fn full_turn() -> Radians<T> { Radians(Float::two_pi())    }\r\n}\r\n\r\nfn main() {}\r\n~~~\r\n\r\n~~~\r\nsrc/float.rs:16:55: 16:68 error: mismatched types: expected `@FuzzyEq<'a>` but found `@FuzzyEq<self>` (expected type parameter but found self)\r\nsrc/float.rs:16     static pure fn full_turn() -> Radians<T> { Radians(Float::two_pi())    }\r\n                                                                       ^~~~~~~~~~~~~\r\nerror: aborting due to previous error\r\n~~~\r\n\r\nUpdate: changed to capitalized `Self`\r\nUpdate: Use `FuzzyEq` trait from `std::cmp`"
4173,'brson',"Paths in error messages for file modules contain dots now\nThese `./` path elements shouldn't exist.\r\n\r\n```\r\n/home/brian/dev/rust3/src/librustdoc/./astsrv.rs:67:15: 67:35 error: unresolved name: task::spawn_listener\r\n/home/brian/dev/rust3/src/librustdoc/./astsrv.rs:67         ch: do task::spawn_listener |move parse, po| {\r\n```"
4165,'brson',"ICE with static methods\n~~~\r\npub struct Vec2<T> { x: T, y: T }\r\n\r\npub impl<T:Copy Number> Vec2<T> {\r\n    static pure fn zero() -> Vec2<T> {\r\n        let _0 = Number::from(0f);    // FIXME: causes ICE\r\n        Vec2 { x: _0, y: _0 }\r\n    }\r\n}\r\n\r\npub trait Number: NumConv {\r\n    static pure fn from<T:Number>(n: T) -> self;\r\n}\r\n\r\npub impl float: Number {\r\n    static pure fn from<T:Number>(n: T) -> float { n.to_float() }\r\n}\r\n\r\npub trait NumConv {\r\n    pure fn to_float(&self) -> float;\r\n}\r\n\r\npub impl float: NumConv {\r\n    pure fn to_float(&self) -> float { *self }\r\n}\r\n\r\nfn main() {\r\n    let _: Vec2<float> = Vec2::zero();\r\n}\r\n~~~\r\n~~~\r\n $ RUST_LOG=rustc=1,::rt::backtrace rustc src/vec.rs\r\nrust: task failed at 'index out of bounds: the len is 1 but the index is 1', /usr/local/src/rust/src/librustc/middle/trans/common.rs:1327\r\nerror: internal compiler error: unexpected failure\r\nnote: the compiler hit an unexpected failure path. this is a bug\r\nnote: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues\r\nrust: task failed at 'explicit failure', /usr/local/src/rust/src/librustc/rustc.rc:483\r\nrust: domain main @0x7f8a0c800010 root task failed\r\nrust: task failed at 'killed', /usr/local/src/rust/src/libcore/task/mod.rs:630\r\n~~~\r\n\r\nContext:\r\n\r\n- https://github.com/bjz/lmath-rs/blob/master/src/num/types.rs#L7\r\n- https://github.com/bjz/lmath-rs/blob/master/src/mat.rs#L351"
4135,'brson',"run-pass/trait-inheritance-overloading-xc-exe fails\nWasn't sure why it was failing, so I xfailed it."
4132,'brson','Vector impls don\'t work well with explicit self\nThis doesn\'t work because method.rs needs to do *2* auto refs. Can\'t convert `BaseIter` to explicit self without.\n\n```\n// Testing that method lookup automatically both borrows vectors to slices\n// and also references them to create the &self pointer\n\ntrait MyIter {\n    pure fn test_imm(&self);\n    pure fn test_const(&const self);\n}\n\nimpl &[int]: MyIter {\n    pure fn test_imm(&self) { assert self[0] == 1 }\n    pure fn test_const(&const self) { assert self[0] == 1 }\n}\n\nimpl &str: MyIter {\n    pure fn test_imm(&self) { assert *self == "test" }\n    pure fn test_const(&const self) { assert *self == "test" }\n}\n\nfn main() {\n    // NB: Associativity of ~, etc. in this context is surprising. These must be parenthesized\n\n    ([1]).test_imm();\n    (~[1]).test_imm();\n    (@[1]).test_imm();\n    (&[1]).test_imm();\n    ("test").test_imm();\n    (~"test").test_imm();\n    (@"test").test_imm();\n    (&"test").test_imm();\n\n    ([1]).test_const();\n    (~[1]).test_const();\n    (@[1]).test_const();\n    (&[1]).test_const();\n    ("test").test_const();\n    (~"test").test_const();\n    (@"test").test_const();\n    (&"test").test_const();\n\n    // NB: We don\'t do this double autoreffing for &mut self because that would\n    // allow creating a mutable pointer to a temporary, which would be a source\n    // of confusion\n}\n```'
4129,'brson',"Quote misc\nThis gets the new token-tree quasiquoter up to the point of being able to stand in for of `#ast` in the pipe protocol compiler; `#ast` is only there in `#[cfg(stage0)]`, whereas it's `quote_expr!` and `quote_type!` in `#[cfg(stage1)]` and `[#cfg(stage2)]`.  Also makes the splicing machinery much more robust and extensible (you are allowed to splice anything that implements `ToTokens`).\n\nWhile this looks like a lot of sound and noise for nothing, it enables (post-snapshot) cutting out substantial portions of the redundant macro machinery in the frontend. `#ast` and the quasiquoter is sort of the last thread holding it in place (from _last_ summer)."
4117,'brson','Teach the parser to associate the mod hierarchy in a file with directories\nAs part of #2176 I removed directory modules from the language. As a result, crates make heavy use of #[path] to create directory structure.\r\n\r\nRight now we have this pattern in some crates:\r\n\r\n```\r\nmod foo {\r\n  #[path = "foo/bar.rs"]\r\n  mod bar;\r\n}\r\n```\r\n\r\n`foo` is a directory and a module containing no external source, but the parser doesn\'t know that foo is a directory and tries to load `bar` from `bar.rs` instead of `foo/bar.rs`. It probably makes sense to track a stack of module names in the parser and use them to decide the path to external modules. I didn\'t implement this at the time because it seemed like some odd state for the parser to maintain, but it is *probably* what people expect.'
4108,'brson','XC inlining of static methods\nsee https://github.com/mozilla/rust/pull/4098'
4092,'nikomatsakis','LLVM assertion failure when calling insert on a std::map::Hashmap<(@str, T), T>\nGiven this code:\n\n    extern mod std;\n\n    fn main() {\n        let x = std::map::HashMap();\n        x.insert((@"abc", 0), 0);\n    }\n\nrustc produces:\n\n    rustc: /home/gareth/projects/rust/src/llvm/lib/VMCore/Instructions.cpp:1062: void  llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"\' failed.\n    Aborted (core dumped)\n'
4090,'brson','Update docs for crate file changes\n'
4061,'brson',"Remove commas from trait inheritance list\nThe trait inheritance list is a list of type bounds, but for traits. These two constructs mean very similar, if not the same, things, 'in order for a type to be Foo it must be Bar'.\n\n```\nfn f<Foo: Bar>() { }\n\ntrait Foo: Bar { }\n```\n\nbut the syntaxes suggest dissimilarity with more than one bound:\n\n```\nfn f<Foo: Bar Baz>() { }\n\ntrait Foo: Bar, Baz { }\n```\n\nUsing space instead of comma in the trait declaration would be more consistent and looks fine.\n\n\n```\nfn f<Foo: Bar Baz>() { }\n\ntrait Foo: Bar Baz { }\n```\n"
4056,'brson','trait inheritance and kinds\nTrait inheritance needs to work with kinds'
4025,'nikomatsakis','if b { x } else { y } requires identical types for x and y\nThis fails:\n\n    fn print(b: bool, s1: &str, s2: &str) {\n        io::println(if b { s1 } else { s2 });\n    }\n\n>     foo.rs:2:33: 2:39 error: mismatched types: expected `&/str` but found `&/str` (lifetime mismatch)\n>     foo.rs:2     io::println(if b { s1 } else { s2 });\n>                                               ^~~~~~\n>     foo.rs:1:38: 3:1 note: the anonymous lifetime #1 defined on the block at 1:38...\n>     [...]\n>     foo.rs:1:38: 3:1 note: ...does not necessarily outlive the anonymous lifetime #2 defined on the block at 1:38\n>     [...]\n\nwhile this works (giving the two borrowed pointers the same lifetime):\n\n    fn print(b: bool, s1: &r/str, s2: &r/str) {\n        io::println(if b { s1 } else { s2 });\n    }\n\nas does this (not returning the pointers through if {} else {}):\n\n    fn print(b: bool, s1: &str, s2: &str) {\n        let mut s: &str;\n        if b { s = s1; } else { s = s2; }\n        io::println(s);\n    }\n\n@nikomatsakis suggested the first example should work and that the type checker\nshould be content if the types of the two arms of the `if{}else{}` expression\nhave a common supertype, rather than requiring them to be the same.\n'
4006,'brson',"'privileged scope' coherence checks must extend to trait supertypes\n`trait B: A;`\r\n\r\nIf A is not defined our crate then we must define the type when implementing B."
3983,'brson',"overlapping instances should be allowed for traits with no methods\nThis is what will make inherited kinds work:\r\n\r\n```\r\ntrait Bar : Copy {\r\n    fn g();\r\n}\r\n\r\nstruct A {\r\n    x: int\r\n}\r\n\r\nimpl A : Bar {\r\n    fn g() { }\r\n}\r\n\r\nfn main() {\r\n}\r\n```\r\n\r\nThe user is implementing `Copy`, but the compiler also implements `Copy` implicitly.\r\n\r\nThis will also allow kind-based 'assertions':\r\n\r\n```\r\nstruct Foo { ... }\r\n\r\n// Overlapping instance guarantees that `Foo` is copyable\r\nimpl Foo: Copy;\r\n```\r\n"
3982,'brson','overlapping instances should be detected for inherited traits\nA simple example\n\n```\n// error-pattern: what\n\ntrait Foo {\n    fn f();\n}\n\ntrait Bar : Foo {\n    fn g();\n}\n\nstruct A {\n    x: int\n}\n\nimpl A : Bar {\n    fn g() { }\n    fn f() { }\n}\n\nimpl A : Foo {\n    fn f() { }\n}\n\nfn main() {\n}\n```\n'
3978,'brson',"'make' no longer builds through stage2\nAnother episode in the continuing saga of me breaking the build system."
3946,'brson','Fix testing prerequisites\nA change I made recently to add the new libraries to the install target made running tests require building all the tool libraries'
3944,'pcwalton','Convert compiler to use Drop trait\npcwalton asserts that the `Drop` trait is implemented, though perhaps buggy. Use this to replace the `drop` block in structs.'
3904,'nikomatsakis','&fn is non-copyable\nThis test suggests that `&fn` is noncopyable. I do not believe this should be the case.\r\n\r\n```\r\ntype ErrPrinter = &fn(&str, &str);\r\n\r\nfn example_err(prog: &str, arg: &str) {\r\n    io::println(fmt!("%s: %s", prog, arg))\r\n}\r\n\r\nfn exit(+print: ErrPrinter, prog: &str, arg: &str) {\r\n    print(prog, arg);\r\n}\r\n\r\nstruct X {\r\n    mut err: ErrPrinter\r\n}\r\n\r\nimpl X {\r\n    fn boom() {\r\n        exit(self.err, "prog", "arg");\r\n    }\r\n}\r\n\r\nfn main(){\r\n    let val = &X{\r\n        err: example_err,\r\n    };\r\n    val.boom();\r\n}\r\n```\r\n\r\nThe test yields: \r\n\r\n```\r\nRunning /Users/nmatsakis/versioned/rust-gold/build/x86_64-apple-darwin/stage2/bin/rustc:\r\n/Users/nmatsakis/tmp/foo.rs:17:13: 17:21 error: copying a noncopyable value\r\n/Users/nmatsakis/tmp/foo.rs:17         exit(self.err, "prog", "arg");\r\n                                            ^~~~~~~~\r\n/Users/nmatsakis/tmp/foo.rs:17:13: 17:21 note: function arguments must be copyable\r\n/Users/nmatsakis/tmp/foo.rs:17         exit(self.err, "prog", "arg");\r\n```'
3892,'brson','Struct initializers allow missing fields\n```\r\nstruct BuildData {\r\n    foo: int,\r\n    bar: ~int\r\n}\r\n\r\nfn main() {\r\n    let foo = BuildData {\r\n        foo: 0\r\n    };\r\n\r\n    debug!("%?", foo.bar);\r\n}\r\n```\r\n\r\nThis will crash'
3888,'nikomatsakis','region error "Cannot encode region variables"\nThe following code causes the compiler to fail.  Conversation on IRC suggests this is a known issue, but I could not find this specific error by searching tickets for "Cannot encode region variables" nor any of the hits for "region variables".\r\n\r\nI apologize if this is a duplicate.\r\n\r\n```\r\n$ cat ./vecpeek.rs\r\nextern mod std; // Only for tests.\r\n\r\n\r\nfn vec_peek<T>(v: &r/[T]) -> Option< (&r/T, &r/[T]) > {\r\n    if v.len() == 0 {\r\n        None\r\n    } else {\r\n        let head = &v[0];\r\n        let tail = v.view(1, v.len());\r\n        Some( (head, tail) )\r\n    }\r\n}\r\n\r\n\r\nmod tests {\r\n    /* Testing the different storage locations covers features which\r\n     * should be completely orthogonal (ie: that regions work with any\r\n     * storage area, but the language is young, so we do test just\r\n     * in case.\r\n     */\r\n    #[test]\r\n    fn test_peek_empty_stack() {\r\n        let v : &[int] = &[];\r\n        assert (None == vec_peek(v));\r\n    }\r\n\r\n    #[test]\r\n    fn test_peek_empty_unique() {\r\n        let v : ~[int] = ~[];\r\n        assert (None == vec_peek(v));\r\n    }\r\n\r\n    #[test]\r\n    fn test_peek_empty_managed() {\r\n        let v : @[int] = @[];\r\n        assert (None == vec_peek(v));\r\n    }\r\n\r\n    /*\r\n    #[test]\r\n    fn test_peek_full_stack() {\r\n        let v: &[int] = &[1, 2, 3];\r\n        let head: &int = &v[0];\r\n        let tail: &[int] = v.view(1, v.len());\r\n\r\n        match\r\n\r\n        assert (None == vec_peek(v));\r\n    }\r\n    */\r\n}\r\n\r\n$ rustc --test ./vecpeek.rs\r\nerror: internal compiler error: Cannot encode region variables\r\n\r\n$ rustc --version\r\nrustc 0.5 (07edf90 2012-10-13 05:57:13 -0700)\r\nhost: x86_64-unknown-linux-gnu\r\n```'
3874,'nikomatsakis','ref pattern nested inside let LHS causes LLVM assertion failure\nThe following code (which may not be correct rust) causes an llvm abort on my build.\r\n\r\n```\r\n$ cat ./experiment.rs\r\n\r\nenum PureCounter { PureCounter(uint) }\r\n\r\nimpl PureCounter : iter::BaseIter<uint> {\r\n    pure fn each(blk: fn(v: &uint) -> bool) {\r\n        let PureCounter(ref x) = self;\r\n        match blk(x) {\r\n          true => PureCounter( (*x) + 1 ).each(blk),\r\n          false => ()\r\n        }\r\n    }\r\n\r\n    pure fn size_hint() -> Option<uint> { None }\r\n}\r\n\r\nfn main() {\r\n    do PureCounter(0).each |nbox| {\r\n        io::println( (*nbox).to_str() );\r\n        (*nbox) < 5\r\n    }\r\n}\r\n\r\n$ rustc ./experiment.rs\r\nrustc: /home/n/sandbox/3p/rust/src/llvm/lib/VMCore/Instructions.cpp:1062: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"\' failed.\r\nAborted\r\n\r\n$ rustc --version\r\nrustc 0.5 (07edf90 2012-10-13 05:57:13 -0700)\r\nhost: x86_64-unknown-linux-gnu\r\n```'
3850,'nikomatsakis','Refactor region granularity\nAs described in [this comment on #3387][comment], the current region granularity is too coarse.  I decided to open a second issue for this.  It should be considered as blocking #3387, I suppose.\r\n\r\n[comment]: https://github.com/mozilla/rust/issues/3387#issuecomment-9740284'
3828,'nikomatsakis','Borrowck doesn\'t propagate mutability to supercomponents correctly\nBorrowck doesn\'t always propagate mutability correctly to base components.\r\n\r\nHere is an example:\r\n\r\n```\r\nstruct Foo {\r\n    x: uint\r\n}\r\n\r\nstruct Bar {\r\n    foo: Foo\r\n}\r\n\r\nfn main() {\r\n    let mut b = Bar { foo: Foo { x: 3 } };\r\n    let p = &b;\r\n    let q = &mut b.foo.x;\r\n    let r = &p.foo.x;\r\n    io::println(fmt!("*r = %u", *r));\r\n    *q += 1;\r\n    io::println(fmt!("*r = %u", *r));\r\n}\r\n```\r\n\r\nHere, r has type `&uint` and thus `*r` should always yield the same result.  The problem is that when creating the loan for `&mut` we propagate `&const` as the required type for base loans.  This causes us to miss the conflict.\r\n\r\nI have a fix for this already prepared.'
3821,'brson','ICE with slice in a generic struct\nThe following code causes an internal compiler error:\r\n\r\n```\r\nfn foo<T>() {\r\n    let _x: Bar<T> = Bar{ arr: &[] };\r\n}\r\n\r\nstruct Bar<T> {\r\n    arr: &[T],\r\n}\r\n\r\nfn test_foo() {\r\n    foo::<()>();\r\n}\r\n```\r\n\r\nSwitching the `&[T]` to a `Option<T>` makes it go away.\r\n\r\nBacktrace here: https://gist.github.com/3924593'
3817,'nikomatsakis','Implement generic cross-crate trait inheritance\nr? @nikomatsakis '
3804,'alexcrichton',"unsafe-ness not visible in library reference doc\n\r\n[local_data.rs line 55](https://github.com/mozilla/rust/blob/master/src/libcore/task/local_data.rs#L55) declares this function unsafe:\r\n\r\n```\r\npub unsafe fn local_data_get<T: Owned>(\r\n```\r\n\r\nbut the [docs for task_local_data](http://dl.rust-lang.org/doc/0.4/core/task_local_data.html) doesn't show the unsafe keyword:\r\n\r\n```\r\nfn local_data_get<T: Owned>(key: LocalDataKey<T>) -> Option<@T>\r\n```\r\n\r\nIs this a rustdoc limitation?\r\n"
3742,'nikomatsakis','Rewrite how trait-impl matching works in typeck\nRight now, we have this hokey thing where it walks the tree at the end, but sometimes (to help with inference) does resolution eagerly, and it\'s all a big mess.  Besides being hard to understand and inefficient, this also means that inference often fails where it could succeed.  An example is the overloading example I gave in [my blog post][bp], where the result type often fails to be inferred (at least according to some folk on IRC, I haven\'t experimented much with this myself, so I don\'t have a precise test case).\r\n\r\nI want to have it work something like this:\r\n\r\n- There is a list in the fn_ctxt of pending type-trait pairs that need to be resolved\r\n- We add new pairs to this list as we do our type check, assigning each pair an index.\r\n  - We can then create a mapping from the expr.id and probably some other stuff to this index so we can uncover the result in trans, this is tied up a bit in #3446\r\n- When we add a new pair to the list, we can try to eagerly resolve it at that time, which helps with type inference\r\n- Actually, we are free to try and resolve whenever we like, so we can even wait to try and resolve when we encounter types whose structure is not known but needs to be\r\n- At the end, we walk the list and make sure all pairs are resolvable\r\n\r\nThese pairs more-or-less correspond to Haskell\'s type contexts.  "Eager resolution" is context simplification.  The only reason it\'s reasonable to use pairs is if we decide to enforce overload freedom, as I described in [my blog post][bp].  \r\n\r\nAlso, to ensure termination, it may be necessary to add a depth to these pairs, unless we decide to enforce something like Haskell\'s Paterson or Basic conditions (which I am not sure how I feel about).\r\n\r\n[bp]: http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/'
3741,'nikomatsakis','ICE with per-type serializer\n@erickt\'s implementation of #3740 leads to an ICE with this backtrace:\r\n\r\n```\r\n#0  upcall_fail (expr=0x1293624f0 "option::get none", file=0x1016671c0 "/Users/nmatsakis/versioned/rust-green/src/rustc/rustc.rc", line=1) at rust_upcall.cpp:94\r\n#1  0x00000001001120f7 in rt::rustrt::rust_upcall_fail::_74a64c4360d2dcec::_04 ()\r\n#2  0x000000010003c5c7 in rt::rt_fail_::_74a64c4360d2dcec::_04 ()\r\n#3  0x0000000100b8d5a8 in option::get_23338::_29fe71a392a4924::_04 ()\r\n#4  0x0000000100b8d43d in option::__extensions__::get_23335::_f0c217aeadcb2131::_04 ()\r\n#5  0x00000001015012b9 in metadata::decoder::get_impl_method::_783f8d1a39c49ab::_04 ()\r\n#6  0x0000000100d3b393 in metadata::csearch::get_impl_method::_6b7fc67f87eddc92::_04 ()\r\n#7  0x0000000100d38f74 in middle::trans::meth::method_with_name::_ba3c2a2e023f72d::_04 ()\r\n#8  0x0000000100bd2362 in middle::trans::meth::trans_static_method_callee::_f9ec6ca09ccac979::_04 ()\r\n#9  0x0000000100bcb78d in middle::trans::callee::trans::trans_def::_67363582be12cd36::_04 ()\r\n#10 0x0000000100bcb2ce in middle::trans::callee::trans::_f48ed4270a0c3c0::_04 ()\r\n#11 0x0000000100bd6cd8 in middle::trans::callee::trans_call::anon::expr_fn_24271 ()\r\n#12 0x0000000100bef739 in middle::trans::callee::trans_call_inner::anon::expr_fn_25077 ()\r\n#13 0x0000000100b8ca0f in middle::trans::base::with_scope::_996fb23bb7f2845::_04 ()\r\n#14 0x0000000100bd6bdb in middle::trans::callee::trans_call_inner::_ff61dbd7aaf3bd3::_04 ()\r\n#15 0x0000000100bd6983 in middle::trans::callee::trans_call::_64631445544261e3::_04 ()\r\n#16 0x0000000100c06c0c in middle::trans::expr::trans_rvalue_dps_unadjusted::_ead42a4b3d1be38a::_04 ()\r\n#17 0x0000000100bff841 in middle::trans::expr::trans_into_unadjusted::_ead42a4b3d1be38a::_04 ()\r\n#18 0x0000000100b73177 in middle::trans::expr::trans_into::_ead42a4b3d1be38a::_04 ()\r\n#19 0x0000000100c8de0b in middle::trans::base::init_local::_a0ad6e37ca3614::_04 ()\r\n#20 0x0000000100c8f93a in middle::trans::base::trans_stmt::anon::expr_fn_27842 ()\r\n#21 0x0000000100b71492 in vec::each_22729::anon::expr_fn_22735 ()\r\n#22 0x0000000100b713ba in vec::as_imm_buf_22732::_2bccd72f7286ea4a::_04 ()\r\n#23 0x0000000100b71298 in vec::each_22729::_74aecc843b4616d::_04 ()\r\n#24 0x0000000100b72f0a in middle::trans::base::trans_stmt::_cb45203fc1c777f9::_04 ()\r\n#25 0x0000000100b7162b in middle::trans::controlflow::trans_block::anon::expr_fn_22743 ()\r\n#26 0x0000000100b71492 in vec::each_22729::anon::expr_fn_22735 ()\r\n#27 0x0000000100b713ba in vec::as_imm_buf_22732::_2bccd72f7286ea4a::_04 ()\r\n#28 0x0000000100b71298 in vec::each_22729::_74aecc843b4616d::_04 ()\r\n#29 0x0000000100b6fafe in middle::trans::controlflow::trans_block::_2448b950a43ba10::_04 ()\r\n#30 0x0000000100c0e499 in middle::trans::expr::trans_rvalue_dps_unadjusted::anon::expr_fn_25395 ()\r\n#31 0x0000000100b8ca0f in middle::trans::base::with_scope::_996fb23bb7f2845::_04 ()\r\n#32 0x0000000100c0585b in middle::trans::expr::trans_rvalue_dps_unadjusted::_ead42a4b3d1be38a::_04 ()\r\n#33 0x0000000100bff841 in middle::trans::expr::trans_into_unadjusted::_ead42a4b3d1be38a::_04 ()\r\n#34 0x0000000100b73177 in middle::trans::expr::trans_into::_ead42a4b3d1be38a::_04 ()\r\n#35 0x0000000100b6fba2 in middle::trans::controlflow::trans_block::_2448b950a43ba10::_04 ()\r\n#36 0x00000001015b6a3a in __morestack ()\r\n#37 0x0000000100b6f8fc in middle::trans::controlflow::trans_block::_2448b950a43ba10::_04 ()\r\n#38 0x0000000100bdccdb in vec::__extensions__::each_24341::anon::expr_fn_24344 ()\r\n#39 0x0000000100b71492 in vec::each_22729::anon::expr_fn_22735 ()\r\n#40 0x0000000100b713ba in vec::as_imm_buf_22732::_2bccd72f7286ea4a::_04 ()\r\n#41 0x0000000100b71298 in vec::each_22729::_74aecc843b4616d::_04 ()\r\n#42 0x0000000100bdcc64 in vec::__extensions__::each_24341::_f660f04d53d71191::_04 ()\r\n#43 0x0000000100d1ea90 in middle::trans::alt::trans_alt_inner::_a9d346c11893b647::_04 ()\r\n#44 0x0000000100d1ded1 in middle::trans::alt::trans_alt::anon::expr_fn_30846 ()\r\n#45 0x0000000100b8ca0f in middle::trans::base::with_scope::_996fb23bb7f2845::_04 ()\r\n#46 0x0000000100c0e33f in middle::trans::alt::trans_alt::_9296d11856c4ec4::_04 ()\r\n#47 0x0000000100c04fd2 in middle::trans::expr::trans_rvalue_dps_unadjusted::_ead42a4b3d1be38a::_04 ()\r\n#48 0x0000000100bff841 in middle::trans::expr::trans_into_unadjusted::_ead42a4b3d1be38a::_04 ()\r\n#49 0x0000000100b73177 in middle::trans::expr::trans_into::_ead42a4b3d1be38a::_04 ()\r\n#50 0x0000000100b6fba2 in middle::trans::controlflow::trans_block::_2448b950a43ba10::_04 ()\r\n#51 0x0000000100c9d86f in middle::trans::base::trans_closure::_de391e1ab6ebccc::_04 ()\r\n#52 0x0000000100ac4296 in middle::trans::base::trans_fn::_f5531fab3be1a3c1::_04 ()\r\n#53 0x0000000100abcdb9 in middle::trans::base::trans_item::_85f94bc13edd0::_04 ()\r\n#54 0x0000000100cad24d in middle::trans::base::trans_mod::anon::expr_fn_28568 ()\r\n#55 0x0000000100b71492 in vec::each_22729::anon::expr_fn_22735 ()\r\n#56 0x0000000100b713ba in vec::as_imm_buf_22732::_2bccd72f7286ea4a::_04 ()\r\n#57 0x0000000100b71298 in vec::each_22729::_74aecc843b4616d::_04 ()\r\n#58 0x0000000100cac801 in middle::trans::base::trans_mod::_a57b1d56f5ce85ad::_04 ()\r\n#59 0x0000000100abc4d1 in middle::trans::base::trans_item::_85f94bc13edd0::_04 ()\r\n#60 0x0000000100cad24d in middle::trans::base::trans_mod::anon::expr_fn_28568 ()\r\n#61 0x0000000100b71492 in vec::each_22729::anon::expr_fn_22735 ()\r\n#62 0x0000000100b713ba in vec::as_imm_buf_22732::_2bccd72f7286ea4a::_04 ()\r\n#63 0x0000000100b71298 in vec::each_22729::_74aecc843b4616d::_04 ()\r\n#64 0x0000000100cac801 in middle::trans::base::trans_mod::_a57b1d56f5ce85ad::_04 ()\r\n#65 0x0000000100abc4d1 in middle::trans::base::trans_item::_85f94bc13edd0::_04 ()\r\n#66 0x0000000100cad24d in middle::trans::base::trans_mod::anon::expr_fn_28568 ()\r\n#67 0x0000000100b71492 in vec::each_22729::anon::expr_fn_22735 ()\r\n#68 0x0000000100b713ba in vec::as_imm_buf_22732::_2bccd72f7286ea4a::_04 ()\r\n#69 0x0000000100b71298 in vec::each_22729::_74aecc843b4616d::_04 ()\r\n#70 0x0000000100cac801 in middle::trans::base::trans_mod::_a57b1d56f5ce85ad::_04 ()\r\n#71 0x0000000100cdf908 in middle::trans::base::trans_crate::_3c3db3d1abf0159a::_04 ()\r\n#72 0x00000001015b6a3a in __morestack ()\r\n```\r\n\r\nI haven\'t gotten very far in tracking this down.  It seems to have something to do with cross-crate static functions.'
3677,'nikomatsakis','Remove fn expressions\nExpressions like `fn(S) { ... }` are deprecated in favor of `|s| t`. I have a patch removing them and also implemented #3320 (better inference) but it is blocked on #2263.'
3602,'brson','Remove mention of records from tutorial\n'
3594,'nikomatsakis','core::at_vec::append_test fails\nTest fails due to not being able to find the impl of the ```add``` trait for ```@```-vecs. I commented it out.'
3511,'nikomatsakis','RFC: Rvalue lifetimes\nWe need to clarify our story on rvalues.  @graydon, @bblum and I have discussed this.  I wrote up my latest thoughts on the situation more here:\n\n    http://smallcultfollowing.com/babysteps/blog/2012/09/15/rvalue-lifetimes/\n\nCurrently I am tending towards the "DWIM"-style rule (obviously I\'d have to spell it out more specifically).  I was thinking that a purely inference-based solution, while flexible, seems less specifiable.  Or rather, to standardize it, you\'d have to specify the inference technique, which seems undesirable.\n'
3503,'brson',"Turn on the non_camel_case_types warning by default\nI'm in favor of being opinionated about syntax."
3501,'nikomatsakis','segfault in repr with references\n```\nstruct A {\n    x: ~int,\n    mut y: ~[&~int],\n}\n\nfn A() -> A {\n    let a = A { x: ~1, y: ~[] };\n    vec::push(a.y, &a.x);\n    a\n}\n\nfn main() {\n    let a = A();\n    error!("%?", a);\n}\n```\n\nResults in a secgault. The stack trace suggests it\'s in the repr function:\n\n```\n0x000000010007309d in repr::__extensions__::meth_10746::visit_self_describing_heap_alloc::_b764c3ece7f574bd::_04 ()\n(gdb) bt\n#0  0x000000010007309d in repr::__extensions__::meth_10746::visit_self_describing_heap_alloc::_b764c3ece7f574bd::_04 ()\n#1  0x0000000000000000 in ?? ()\n```'
3486,'brson',"Struct literal syntax allows repeated fields\nRight now, you can write:\n\n```\nT { foo: 1, foo: 2 }\n```\n\nif ```T``` is a struct with a ```foo``` field. (I haven't checked if this is only accepted if ```T``` has exactly two fields, but it's definitely accepted if so.) The typechecker should reject this because it duplicates a field."
3470,'nikomatsakis','~"" == "" fails to borrow\nIf I use "Function eq - Bytewise string equality", only I put mutable and also there is limited type..\n\nhmm.. Isn\'t here any good way to compare variables?'
3463,'nikomatsakis','How can I compare string..?\n  1 import io::*;\n  2 import core::*;\n  3 fn main(){\n  4     let price;\n  5 \n  6     let item = io::stdin().read_line();\n  7 \n  8     if str::eq(item,"salad"){\n  9         price = 3.5;\n 10     }else if str::eq(item,"kiwie"){\n 11         price = 2.25;\n 12     }else{\n 13         price = 5.0;\n 14     }\n 15 \n 16     io::println(#fmt("%f",price));\n 17 }\n\nI used to develope with C but there is a function "strcmp" but here. I don\'t know which I can use comparing the string..\n\nLet me know them how to use.     \n\nAlso I\'d like to know about how to use API document properly. I can find and see the function and some kind of that. But I don\'t know how to use exactly'
3452,'pcwalton',"priv impls do not create private methods\nThis suprised me:\n\n```\nimpl foo {\n  // This method is private\n  priv fn bar() { }\n}\n\npriv impl foo {\n  // This method is public even though the impl is private.\n  fn bar() { }\n}\n```\n\n`priv impl` doesn't do anything."
3446,'nikomatsakis','Make `a.b()` always a method call, refactor how methods are represented in the compiler\nWe have agreement that the syntax `expr.m()` will always represent a method call (and never a call to the field `expr.m`).  This allows us to make a change to the compiler AST so that we have `expr_mcall()` (method call) and not `expr_call(expr_field())`, which in turn allows various other simplifications in borrowck, trans, and elsewhere.  In the process---or, perhaps, as first steps---I want to do some smaller refactorings:\n\n- Represent vtables as a tree and not the current flattened representation.  This will simplify code all over the place.\n\n- Remove the `callee_id` and just hang method information off in different tables (this basically requires an expr_mcall)\n\n- Maybe: change how operator overloading is implemented so that, from the front end\'s point of view, *all* overloadable operations are method calls, but some of them call "intrinsic" methods.  Constant expressions are therefore restricted to such intrinsics, and of course trans will generate `a+b` the same way it does today.  '
3443,'nikomatsakis',"Refactor handling autoref, autoderef, and borrowing\nI've got a refactoring in process to the way we deal with borrowing, which has grown beyond its original design and is now a horrible mess.  I realize this I hope to land this before 0.4 but there is no open issue on it!"
3436,'brson','RFC: Remove "unchecked" blocks\nUnchecked blocks can be used to write `reinterpret_cast`, which can cast an unsafe function to a safe one and call it. Thus there\'s no real difference between an unchecked block and an unsafe block. So I propose removing `unchecked` from the language.'
3424,'nikomatsakis','unused arguments vs borrowed pointers\nThe test case below fails to compile, apparently because the borrow checker doesn\'t think an unused argument is (not) used safely.\n\n```\n\n// rustc --test ignores2.rs && ./ignores2\nuse std;\nuse path::{Path};\n\ntype rsrc_loader = fn~ (path: &Path) -> result::Result<~str, ~str>;\n\n#[test]\nfn tester()\n{\n    let loader: rsrc_loader = |_path| {result::Ok(~"more blah")};\n    \n    let path = path::from_str("blah");\n    assert loader(&path).is_ok();\n}\n\n// ignores2.rs:10:25: 10:82 error: mismatched types: expected `rsrc_loader` but found `fn~(&core::path::Path) -> core::result::Result<~str,~str>` (lifetime re_bound(br_anon(0)) does not necessarily outlive the static lifetime)\n// ignores2.rs:10     let loader: rsrc_loader = |_path| {result::Ok(~"unbalanced {{curly}} {{braces}")};\n//                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```'
3407,'brson',"Change the example on rust-lang.org\nThe current example is too cute - the `times` method is not well loved. Let's come up with another one. Maybe something that shows more of the language."
3402,'nikomatsakis',"Trans refactor was major perf perturbance\nI can't say _exactly_ whether it's good or bad, but the perf numbers went sideways a fair bit with the refactoring of trans in 5e36a997945ddc3964a1fe937bc5390cc5b526c8. Some numbers dropped, some went up a lot (factor of 2 on fibo and sudoku), and we lost about 5s on self-compile time.\n\nAll of this is potentially tolerable, I'm not suggesting we back it out (so nice!) but it's probably worth looking at a couple of the smaller benchmarks at least, maybe comparing a count-llvm-insns graph and/or the LLVM bitcode output, to see if something changed obviously (by mistake) in the code we're generating."
3387,'nikomatsakis',"Borrow check does not detect moves in overloaded operators\nThis test crashes:\n\n```\nenum foo = ~uint;\n\nimpl foo: add<foo, foo> {\n    pure fn add(f: foo) -> foo {\n        foo(~(**self + **f))\n    }\n}\n\nfn main() {\n    let x = foo(~3);\n    let y = x + move x;\n}\n```\n\nThe fix is already in my trans refactor branch, just wanted to make a note of it here.  The error is that the region hierarchy tables don't consider overloadable operators as possible scopes."
3384,'brson','Remove semicolon as struct field separator\n'
3372,'nikomatsakis',"hashmap each should be pure\nI have an impl of BaseIter which needs to call each on a hashmap, but I can't because the hashmap's each is not pure.\n\nNot sure how to work around this other than not using BaseIter which isn't very cool."
3359,'brson',"spurious camel case warning\nDon't have a good repro for this (tho I can get an icky one once I push my project), but when compiling with `-W non-camel-case-types` I'm getting the following warning:\n```\n<intrinsic>:23:4: 115:5 warning: type, variant, or trait must be camel case\n<intrinsic>:23     trait ty_visitor {\n<intrinsic>:24         fn visit_bot() -> bool;\n<intrinsic>:25         fn visit_nil() -> bool;\n<intrinsic>:26         fn visit_bool() -> bool;\n<intrinsic>:27 \n<intrinsic>:28         fn visit_int() -> bool;\n               ...\n```"
3332,'brson',"Sidebar links on the website are confusing beginners\nThe website's documentation links on the side keep confusing beginners (I've seen this popup a number of times on #rust). They click the tutorial link under documentation thinking it's the same documentation for their version, but instead it's for the latest git master and then they get confused as to why the example code is broken."
3330,'brson','Add implementations of the io traits using uv async file i/o\nOur current i/o implementation is thread blocking. We need one build around async i/o. I believe uv does or will provide such an interface.'
3324,'brson','Reduce keyword list to something more reasonable, hopefully "finished"\nThere are still lots of vestigial keywords. We should get this as close to a fixed-set for good as we can.'
3320,'nikomatsakis','Remove bare function types, replace with inference\nWe should remove the types for bare functions altogether and just infer the appropriate closure type when referring to an item.'
3314,'nikomatsakis','ICE with traits, tuples, and anonymous functions\nI ran into some troubles trying to rewrite the serializer, and distilled an ICE down to the smallest form I could make:\n\nhttps://gist.github.com/3548953\n\nI\'ve included the stack trace. The meat of it is:\n\n```\n#0  upcall_fail (expr=0x100c2f7ff "bounds check", file=0x100c303b0 "/Users/etryzelaar/Projects/rust/rust/src/rustc/middle/trans/base.rs", line=2186) at /Users/etryzelaar/Projects/rust/rust/src/rt/rust_upcall.cpp:96\n#1  0x000000010075969e in middle::trans::base::make_mono_id::anon::anon ()\n#2  0x00000001007594a7 in middle::trans::base::make_mono_id::anon ()\n#3  0x0000000100758d12 in vec::map2_27038::_7f52c241d6fc91ca::_04 ()\n```\n\nThe relevant code is:\n\n```\nfn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                vtables: Option<typeck::vtable_res>,\n                param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n    let precise_param_ids = match vtables {\n      Some(vts) => {\n        let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n        let mut i = 0u;\n        vec::map2(*bounds, substs, |bounds, subst| {\n            let mut v = ~[];\n            for vec::each(*bounds) |bound| {\n                match bound {\n                  ty::bound_trait(_) => {\n                    vec::push(v, impl::vtable_id(ccx, vts[i]));  // <--- ICE HERE\n                    i += 1u;\n                  }\n                  _ => ()\n                }\n            }\n            (subst, if v.len() > 0u { Some(v) } else { None })\n        })\n      }\n      None => {\n        vec::map(substs, |subst| (subst, None))\n      }\n    };\n...\n```'
3305,'nikomatsakis',"Autoderef on trait methods in a monomorphized caller doesn't work\nThe following crashes:\n\n```\ntrait double {\n    fn double() -> uint;\n}\n\nimpl uint: double {\n    fn double() -> uint { self * 2u }\n}\n\nfn is_equal<D: double>(x: @D, exp: uint) {\n    assert x.double() == exp;\n}\n\nfn main() {\n    let x = @(3u as double);\n    is_equal(x, 6);\n}\n```\n\nThis is because the autoderef code is not being used if the call occurs in a monomorphized context.  My trans refactoring should fix this."
3291,'nikomatsakis',"copy bindings in pattern guards are broken\nThis test segfaults:\n```\nfn foo(x: option<~int>, b: bool) -> int {\n    match x {\n      none => { 1 }\n      some(copy x) if b => { *x }\n      some(_) => { 0 }\n    }\n}\n\nfn main() {\n    foo(some(~22), true);\n    foo(some(~22), false);\n    foo(none, true);\n    foo(none, false);\n}\n```\n\nthe reason is that copy bindings (currently, anyhow) create a temporary that is only used in the guard, copy into it, and then free it on exit from the match.  But this temporary is never initialized.  If you wind up in an arm that doesn't use the temporary, then, you try to free uninitialized data.  Bad.\n\nIt would be better for copy bindings to perform the copy, test the guard, then free the data if the guard is false---but *reuse* the data if the guard is true.  I'm going to see how much surgery that would be.\n\nOr maybe copy bindings and guards should just be incompatible?"
3289,'nikomatsakis','borrowed pointers should be compared\nThe following example try to compare two pointers:\n\nfn do_cmp(a: &int, b: &int) {\n    io::println("do_cmp");\n    if a == b { io::println("same ref"); }\n}\n\nfn main() {\n    let a = @10;\n    let b = @10;\n    do_cmp(a, b);\n    do_cmp(a, a);\n}\n\nWe have the following message:\ntry.rs:3:12: 3:13 error: mismatched types: expected `&int` but found `&int` (the anonymous lifetime #2 defined on the block at 1:28 does not necessarily outlive the anonymous lifetime #1 defined on the block at 1:28)\ntry.rs:3     if a == b { io::println("same ref"); }\n                     ^\nerror: aborting due to previous error\n\nI think that it should compile. I think it should also compile if we have this prototype:\nfn do_cmp(a: &int, b: @int)\n'
3256,'nikomatsakis','"ref" in guarded patterns trips LLVM asserts\nThis crashes if you try to compile it:\n```\nfn main() {\n    let x = some(unsafe::exclusive(false));\n    match move x {\n        some(ref z) if z.with(|b| *b) => {\n            do z.with |b| { assert *b; }\n        },\n        _ => fail\n    }\n}\n```\nRelated #2329, #3255'
3243,'nikomatsakis','stack allocated vecs can be returned from functions\nSee this gist: https://gist.github.com/3419521, with the attached llvm bitcode. Rust compiles it fine, but looking through the bitcode, it appears that rust is returning a stack pointer.'
3238,'nikomatsakis','defer reasoning about region relationships until after regionck\nRight now, if you try to relate two regions, you either get back an immediate error or---more likely---you generate a constraint that will later be processed by region inference.  In the former case, the error message is generally clearler: this is because the error is reported by the code that is relating the regions, and it can say something more specific about why the relation came about.  In the latter case, the inferencer is reporting the error, and all it really knows is something like "due to the code at this span, r1 should be a subregion of r2".  So the message is correspondingly vague.\r\n\r\nInstead of merely passing in a span to the inferencer, we should pass in something like ty::type_err().  Then the region inferencer could use this to report a more intelligent message about why the constraint which could not be satisfied came about.  This would also mean that you get more consistent errors.'
3235,'nikomatsakis','Irrefutable bindings matching code is broken\n```\r\nfn main() {\r\n    let x = "hello";\r\n    let ref y = x;\r\n    // let y = match x { ref y => y };  // this way works fine\r\n    error!("%?", *y);\r\n}\r\n```\r\nproduces:\r\n```\r\nrustc: /home/bblum/rust/src/llvm/lib/VMCore/Instructions.cpp:280:\r\nvoid llvm::CallInst::init(llvm::Value*, llvm::ArrayRef<llvm::Value*>,\r\nconst llvm::Twine&): Assertion `(i >= FTy->getNumParams() ||\r\nFTy->getParamType(i) == Args[i]->getType()) && "Calling a function\r\nwith a bad signature!"\' failed.\r\nAborted (core dumped)\r\n```\r\nHappens with structs, tuples, etc too.'
3233,'pcwalton',"crate-method-reexport-grrrrrrr.rs broken by recent (metadata?) changes\nThe run-pass test `crate-method-reexport-grrrrrrr.rs` doesn't work any more. I'm pretty sure the culprit is @pcwalton's recent changes to metadata.\n\nI xfail'd the test because the tree had been burning for a long time, but it should really be looked into."
3202,'brson',"Use correct constructor naming conventions in core/std\nAfter changing the names of types to camel case, constructors will be in a weird place where they all have the same name as their types, but lowercase. There doesn't seem to be a consensus on what convention constructors should use yet."
3172,'pcwalton','Structs initialised with new syntax don\'t run destructors.\n```\nstruct foo {\n    x: ~str;\n    drop { #error["%s", self.x]; }\n}\n\nfn main() {\n    let _z = foo { x: ~"Hello" };\n}\n```\nThis leaks ```x``` instead of printing it.'
3162,'nikomatsakis',"Borrow check doesn't properly deal with references into mutable record fields\nThe following code compiles and outputs `&10`.\n\n```\nfn each<T>(x: &[T], op: fn(elem: &T) -> bool) {\n    uint::range(0, x.len(), |i| op(&x[i]));\n}\n\nfn main() {\n    let x = ~[{mut a: 0}];\n    for each(x) |y| {\n        let z = &y.a;\n        x[0].a = 10;\n        log(error, z);\n    }\n}\n```\n\nIt also fails if you use `vec::each`, which uses reference modes instead of region pointers. It should be rejected."
3148,'nikomatsakis',"region inference doesn't capture all dependencies between regions\nIn this test case (`src/test/run-pass/region-return-interior-of-option-in-self.rs`):\n\n```\n// xfail-test \n\nstruct cell<T> {\n    value: T;\n}\n\nstruct cells<T> {\n    vals: ~[option<cell<T>>];\n}\n\nimpl<T> &cells<T> {\n    fn get(idx: uint) -> &self/T {\n        match self.vals[idx] {\n          some(ref v) => &v.value,\n          none => fail\n        }\n    }\n}\n\nfn main() {}\n```\n\nan error is reported.  The reason is that the region `R` for `v` is inferred to be too narrow, because it doesn't realize `R` must be as wide as the region for `&v.value`.  "
3141,'brson','non_camel_case_types lint check should allow trailing underscores\nWe occasionally use trailing underscore to differentiate items.'
3138,'nikomatsakis',"Slice regions upset in only one case\nI don't quite see why but the regions being generated for `c` and `cc` in `test/run-pass/estr-slice.rs` are no longer popular with the compiler as of the fix for compiling const slices. Uncommenting the cases there makes them fail to compile, despite appearing almost identical to the `a` and `b` cases above."
3133,'brson',"Remove *_implicit traits\nTo get around a parsing/snapshot problem I'm giving names to implicit traits. After old-style traits are removed (#3129) then these can be removed."
3129,'brson','Remove old-style impls\nNamed impls and imples without coherence are still in the language'
3097,'nikomatsakis','Moves into patterns (also irrefutable patterns) always copy\nThe following test:\n\n```\nstruct foo {\n    x: int;\n\n    new(x: int) {\n        self.x = x;\n    }\n\n    drop {\n        error!{"Hello, world!"};\n    }\n}\n\nfn main() {\n    let x = ~foo(1);\n    error!{"x.x: %d", x.x};\n    let ~y <- x;\n    error!{"y.x: %d", y.x};\n\n    alt move y {\n      copy z {}\n    }\n}\n```\n\nprints Hello World! three times.  I think that patterns (both refutable/irrefutable, which are different code paths) just always copy in trans.    \n\n'
3079,'brson','Commas should be optional between alt arms even when not required\nCurrently block alt arms do not end in a comma, but all other arms do.'
3076,'brson',"Alt arms with block structured expressions shouldn't require commas?\n```\nalt foo {\n    true => do spawn {\n        baz\n    } // currently need a comma here\n    false => ()\n}\n````"
3075,'brson',"Alt arms with effect blocks don't parse the same as plain blocks\n```\nalt foo {\n    true => unsafe { }, // requires a comma. normal blocks don't\n    _ => { }\n}\n```"
3074,'brson','Rustdoc should support structs\nMore and more code is going into structs, so we should make sure they show up in the docs.'
3063,'brson',"Keyword changes\nWe've agreed on some keyword changes\n\nret -> return\nmod -> module\nalt -> match\n\nAnd we are going to reserve 'pub' and 'priv'\n"
3060,'brson','Camel case types\nConvert existing rust code to camel case types, variants and traits.'
3059,'pcwalton','RFC: Infer the type of float literals\nRoadmap says "There is general consensus that floating point literals are too long; 1.0f will likely become sugar for 1.0f32. This is purely a backwards-compatible change."\n\nNot sure the details - I think we already have a `f` literal though for `float`.'
3057,'brson','Drop braces from alt, make arrow required\nPer roadmap'
3053,'nikomatsakis',"rooting of boxes in borrowck fails to take moves into account\nThe following code:\n\n```\n// exec-env:RUST_POISON_ON_FREE=1\n\nfn free<T>(-x: @T) {}\n\nfn lend(+x: @{f: @{g: int}}) -> int {\n    let y = &x.f.g;\n    free(x);\n    *y\n}\n\nfn main() {\n    assert lend(@{f: @{g: 22}}) == 22;\n}\n```\n\nis handled incorrectly by borrowck right now.  It will opt not to root the `x.f` box even though it ought to.  This is because it sees that `x.f` is found in immutable data which will outlive the lifetime of the borrow: but it doesn't consider moves.  To be correct, it should either (1) know which variables might be moved (liveness can tell us) and conservatively root boxes that are found in those variables or (2) take out a loan on `x` so that an error would be reported.  But (2) seems suboptimal since this is not really an *error*, just a failure of borrowck to make the right call on whether to root `x.f`.\n"
3027,'pcwalton',"improve resolve error messages\n```\nimport model::{msg, deregister_msg, foobar, register_msg};\nsrc/handlers/get_query.rs:5 import model::{msg, deregister_msg, foobar, register_msg};\n                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\nabove error points to the wrong location and doesn't indicate the actual problem (which is foobar).\n\n```\nimport foobar::{msg, deregister_msg, register_msg};\n\nsrc/handlers/get_query.rs:5:7: 5:51 error: unresolved name\nsrc/handlers/get_query.rs:5 import foobar::{msg, deregister_msg, register_msg};\n                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\npoints to the right place, but does not say that that name is the problem (again foobar).\n\n\n"
3026,'nikomatsakis','LLVM failure compiling borrow\nAn LLVM failure results from compiling this program:\n\n```\nuse std;\nimport std::map::hashmap;\nimport std::map;\n\nfn main() {\n    let buggy_map :hashmap<uint, &uint> = hashmap::<uint, &uint>(uint::hash, uint::eq);\n    let x = ~1;\n    buggy_map.insert(42, x);\n}\n```'
3024,'nikomatsakis','Borrow check needs to consider moves into patterns\n```\r\nstruct Dummy {\r\n    x: int\r\n}\r\n\r\nimpl Dummy {\r\n    fn new(x: int) -> Dummy {\r\n        Dummy { x: x }\r\n    }\r\n}\r\n\r\nimpl Drop for Dummy {\r\n    fn drop(&self) {\r\n        error!("Destructor %d", self.x);\r\n    }\r\n}\r\n\r\nfn welp<T>(a: ~T) -> T {\r\n    let ~x = a;\r\n    x\r\n}\r\n\r\nfn main() {\r\n    let o = ~Dummy::new(5);\r\n    welp(o);\r\n}\r\n```\r\n(edit: a similar problem appears for ```let a@b = c```; see comment below.)'
2981,'nikomatsakis','Treatment of bound / free regions is wrong\nThe current code for handling bound regions is not right.  We need to track node-ids uniformly and not only for free regions.  Here is an example of a test case that fails.  I have a partial fix for this, but not yet committed.\n\n```\n// Ensure that you cannot use generic types to return a region outside\n// of its bound.  Here, in the `return_it()` fn, we call with() but\n// with R bound to &int from the return_it.  Meanwhile, with()\n// provides a value that is only good within its own stack frame. This\n// used to successfully compile because we failed to account for the\n// fact that fn(x: &int) rebound the region &.\n\nfn with<R>(f: fn(x: &int) -> R) -> R {\n    f(&3)\n}\n\nfn return_it() -> &int {\n    with(|o| o) //~ ERROR mismatched types\n        //~^ ERROR reference is not valid outside of its lifetime\n}\n\nfn main() {\n    let x = return_it();\n    #debug["foo=%d", *x];\n}\n```'
2980,'nikomatsakis',"Derefs of newtypes give the wrong mutability\nDerefs of newtypes should inherit the mutability of their container, just as record fields do. I have a fix for this but haven't committed it yet."
2979,'nikomatsakis',"Change how scope of & is computed\nRight now we compute the scope of an expression like `&expr` in a pre-determined fashion.  What we *should* do is to create a region variable and use that instead, with a lower bound of the `&expr` itself but no upper bound (we should also use this technique for implicit borrows).  Inference will then select the smallest scope it can for the resulting region.  Finally, in borrowck, make sure that `expr` can be guaranteed for the result.  This will require some modifications to borrowck, I think, to be sure it takes loops and so forth into account for rooting—but that code makes sense to have anyway. \n\nThe reason to make this change is that it allows us to select the lifetime of `&expr` in a variety of ways.  If `expr` is a shared box, or owned by a shared box, we can use the rooting rules which can sometimes be the best.  Otherwise, we can use the lifetime of `expr` itself, which is sometimes the right choice.   Basically we can't know until after inference what would be the true upper bound and so we have to check later in a second pass.  This isn't a very clear bug report but I'll draw up some examples in the code of what I mean.\n\nThis enhancement helps with sendable hashtables and would allow us to do things like return pointers to the interior of data structures in more cases."
2978,'nikomatsakis',"Borrowck doesn't consider calls to fn~ to be borrows\nThis program should fail:\n\n```\nfn call(x: @{mut f: fn~()}) {\n    x.f(); //~ ERROR foo\n    //~^ NOTE bar\n}\n\nfn main() {}\n```\n\nthe reason is that it would be possible for the closure to cause itself to be freed.  well, of course it's not actually possible in *this* case but it'd require alias analysis to know that."
2977,'nikomatsakis','Borrowck doesn\'t correctly handle lifetime of ~rvalue\ngood day. the following intentionally buggy program crashes rustc:\n\n```\n//buggy.rs\nuse std;\nimport std::map::hashmap;\nimport std::map;\n\nfn main() {\n    let buggy_map :hashmap<uint, &uint> = hashmap::<uint, &uint>(uint::hash, uint::eq);\n    buggy_map.insert(42, ~1);\n    buggy_map.insert(43, ~2);\n}\n```\n\nhere is the result of "rustc buggy.rs":\n```\nrustc: /home/varnie/rust/src/llvm/lib/VMCore/Instructions.cpp:1056: void llvm::StoreInst::AssertOK(): Assertion `getOperand(0)->getType() == cast<PointerType>(getOperand(1)->getType())->getElementType() && "Ptr must be a pointer to Val type!"\' failed.\nAborted (core dumped)\n```\n\nrustc version is:\nrustc 0.3 (6081eb7 2012-07-15 05:41:24 -0700)\nhost: i686-unknown-linux-gnu'
2962,'nikomatsakis','inference for regions fails to find GLB for two region parameters\nThis example fails to compile:\n\n```\nfn takes_two(x: &int, y: &int) -> int { *x + *y }\n\nfn has_two(x: &a/int, y: &b/int) -> int {\n    takes_two(x, y)\n}\n\nfn main() {\n    assert has_two(&20, &2) == 22;\n}\n```\n\nbut it shouldn\'t.  The problem is that `has_two()` tries to intersect `a` and `b` and fails.  What ought to happen however is that the GLB of two lifetime parameters ought to be the same as the method body itself.\n\nThere is a workaround, you can rewrite `has_two()` to be:\n\n```\nfn has_two(x: &a/int, y: &b/int) -> int {\n    let x1: &blk/&int = x;\n    let x1: &blk/&int = x;\n    takes_two(x, y)\n}\n```\n\nthis basically specifies the GLB.  Here `blk` is a special region name for "the region of the innermost enclosing block".'
2934,'nikomatsakis','tranactional facilities inconsistently implement for borrowings table\nThe borrowings table is versioned on `try` but not `commit` nor `probe`.  In general those three methods ought to be consolidated.'
2933,'nikomatsakis','transactional facilities are not implemented for ty_ivar\nThe infer module has transactional capabilities for rolling back changes to type/region variables, but these are not being used for integral type variables.  We have to modify the methods `commit()`, `try()`, and `probe()` to do something comparable to what is being done for the `tvb` variable.\n\nHere is a test that displays undesirable behavior as a result:\n\n```\nimpl methods for uint {\n    fn foo() -> ~str { ~"uint" }\n}\nimpl methods for int {\n    fn foo() -> ~str { ~"int" }\n}\nfn main() {\n    assert 22.foo() == ~"int";\n}\n```\n\nActually a naive fix for this will probably lead to an ambig method call error.  I am not sure if this is the right thing or not.'
2926,'nikomatsakis',"ICE when trying to access shared-access-boxed vector in iface impl\nFor the following code:\n\n    import io::*;\n    import to_str::*;\n    \n    impl <T : to_str copy> of to_str for @[mut T] {\n        fn to_str() -> str {\n            let tmp = copy self;\n            tmp.map(|x| { x.to_str() }).to_str()\n        }\n    }\n    \n    fn main() {\n        println((@[mut 1, 2, 3]).to_str());\n    }\n\nrustc-0.3 produces an ICE:\n\n    example.rs:7:8: 7:11 error: internal compiler error: aliased ptr with a non-none lp\n    example.rs:7         tmp.map(|x| { x.to_str() }).to_str()\n                         ^~~\n\nThis is not happens with unique boxes (`~[mut 1,2,3]`/`for ~[mut T]`)\n\nAlso tested on git snapshot (`rustc 0.3 (6081eb7 2012-07-15 05:41:24 -0700)`) -- same thing, except i had to change `str` to `~str` to make it not fail with `error: bare 'str' is not a type`"
2915,'pcwalton','error: unresolved import\nI know that there are a multitude of resolve tickets, but after grabbing commit 57e160b29dda534f34efb9b2044ad051719259bc (which I think is 0.3) I am completely unable to build https://github.com/jesse99/rparse\n\nI get the following:\n```\nrustc --test -o bin/test-rparse src/rparse.rc\nerror: failed to resolve imports\nsrc/rparse.rs:8:7: 8:15 error: unresolved import\nsrc/rparse.rs:8 import misc::*;\n                       ^~~~~~~~\nsrc/misc.rs:4:7: 4:16 error: unresolved import\nsrc/misc.rs:4 import types::*;\n                     ^~~~~~~~~\nsrc/types.rs:3:7: 3:31 error: unresolved import\nsrc/types.rs:3 import result = result::result;\n                      ^~~~~~~~~~~~~~~~~~~~~~~~\nsrc/tests/test_parsers.rs:1:7: 1:23 error: unresolved import\nsrc/tests/test_parsers.rs:1 import test_helpers::*;\n                                   ^~~~~~~~~~~~~~~~\nsrc/tests/test_primitives.rs:2:7: 2:10 error: unresolved import\nsrc/tests/test_primitives.rs:2 import io;\n                                      ^~~\nsrc/tests/test_expr.rs:2:7: 2:23 error: unresolved import\nsrc/tests/test_expr.rs:2 import test_helpers::*;\n                                ^~~~~~~~~~~~~~~~\nsrc/tests/test_xml.rs:4:7: 4:22 error: unresolved import\nsrc/tests/test_xml.rs:4 import to_str::to_str;\n                               ^~~~~~~~~~~~~~~\nsrc/tests/test_c99_parser.rs:1:7: 1:23 error: unresolved import\nsrc/tests/test_c99_parser.rs:1 import test_helpers::*;\n                                      ^~~~~~~~~~~~~~~~\nsrc/tests/test_helpers.rs:2:7: 2:10 error: unresolved import\nsrc/tests/test_helpers.rs:2 import io;\n                                   ^~~\nerror: aborting due to 10 previous errors\nmake: *** [bin/test-rparse] Error 101\nexited with code 2\n```\n\nI haven\'t made any progress whatsoever with these errors. Not sure what\'s going on. Maybe there is a problem with my code somewhere, but "unresolved import" is certainly not helping me find anything. Note that the code did build a week or two ago (when brson went through all the cargo packages and fixed them up). \n\nI also tried head as of evening Friday, Jul 13 PST with the same results.'
2872,'brson','ICE with reexported methods and external crates\nCrate the first\n\n```\n#[link(name = "crate_method_reexport_grrrrrrr2")];\n\nexport rust;\n\nimport name_pool::methods;\n\nmod name_pool {\n    import libc::c_char;\n\n    type name_pool = @{\n        mut strbufs: ~[str]\n    };\n\n    fn name_pool() -> name_pool {\n        @{mut strbufs: ~[]}\n    }\n\n    impl methods for name_pool {\n        fn add(-s: str) -> *c_char {\n            let c_str = str::as_c_str(s, |bytes| bytes);\n            self.strbufs += ~[s]; // in theory, this should *move* the str in here..\n            ret c_str; // ...and so this ptr ought to be valid.\n        }\n    }\n}\n\nmod rust {\n\n    export rt;\n    export methods;\n\n    type rt = @();\n\n    impl methods for rt {\n        fn cx() {\n        }\n    }\n}\n```\n\nCrate the second\n\n```\n// aux-build:crate-method-reexport-grrrrrrr2.rs\n\nuse crate_method_reexport_grrrrrrr2;\n\nfn main() {\n    import crate_method_reexport_grrrrrrr2::rust::methods;\n    let x = @();\n    x.cx();\n}\n```\n\nThis runs into missing metadata, presumably because `name_pool::methods` isn\'t reachable.'
2806,'nikomatsakis','track which value is "expected"/"actual" in infer\nRight now, infer does not track which value (the sub vs super type) is the "expected" one---that is, it does not track which value came from the user and which did not.  This basically requires an extra boolean to be passed around.   This leads to confusing error messages such as #2721.'
2797,'nikomatsakis','ICE when promoting @[] to slice\nThe following code fails with an ICE\n```\nfn foo(_x: &[int]) {}\nfn main() {\n    let x = @[1,2,3];\n    foo(x);\n}\n```\nThe output:\n```\nnubs/box-borrow-ice.rs:4:8: 4:9 error: internal compiler error: aliased ptr with a non-none lp\nnubs/box-borrow-ice.rs:4     foo(x);\n```'
2714,'nikomatsakis','pattern bindings can be mutable\nI just realized that my recent fix opened up another hole in borrowck.  I believe that pattern bindings over mutable memory will be considered mutable but are only guaranteed to be const.  This discrepancy should be fixed (also probably need a test case ensuring that the data is not considered immutable)'
2701,'brson','Eliminate need for -fno-strict-aliasing in lock_free_queue.h\nAs per fixme.'
2657,'nikomatsakis',"segfault: `alt` allows uniqueness violation\nWe shouldn't be able to duplicate a reference to a unique value. But:\n````Ruby\nlet x = some(~1);\nalt x {\n  some(y) {\n    let a <- x;\n    let b <- y;\n    // disaster ensues, eventually, potentially, distantly\n  }\n}\n````\nThe `some()` isn't even necessary."
2586,'nikomatsakis','Failed `get` in util::ppaux::re_scope_id_to_str, followed by ICE\nGist of the backtrace: https://gist.github.com/2926927\n\nThis came up because I had set `RUST_LOG=rustc::middle::typeck::infer=3` in order to debug an unrelated issue in infer, and turning logging on for infer caused this.'
2575,'nikomatsakis','Infer length of @-box borrows (or just borrow for the whole block)\nIt would be very nice if we could borrow for the whole block when borrowing an @ when passing it as a function parameter.\n\nAlso if we could say what we think the liveness ranges are that would help the error messages.'
2573,'nikomatsakis',"Borrow check doesn't look through newtypes\n```\nenum foo = { mut bar: baz };\n\nenum baz = @quux_;\n\nclass quux_ { let mut baz: option<baz>;\n             new(baz: option<baz>) { self.baz = baz; } }\n\nimpl quuux for foo {\n    fn frob() {\n        really_impure(self.bar);\n    }\n}\n\nfn really_impure(bar: baz) {\n    bar.baz = none;\n}\n\nfn main() {}\n```\n\nThis gets the error message:\n\n```\n/Users/tchevalier/rust/src/test/run-pass/borrowck-newtype.rs:11:22: 11:30 error: illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n/Users/tchevalier/rust/src/test/run-pass/borrowck-newtype.rs:11         really_impure(self.bar);\n                                                                                      ^~~~~~~~\n/Users/tchevalier/rust/src/test/run-pass/borrowck-newtype.rs:11:8: 11:21 note: impure due to access to impure function\n/Users/tchevalier/rust/src/test/run-pass/borrowck-newtype.rs:11         really_impure(self.bar);\n```\n\nI think it should be legal, since ```baz``` is operationally a boxed type."
2525,'nikomatsakis',"allow nominal types to be declared non-copyable\nThere are many times when, for correctness or performance, we would like to guarantee that instances of a class are not copyable.  This can be synthesized now by including a `drop()` method or by embedding a resource, but that's a hack that adds unnecessary overhead."
2504,'nikomatsakis',"internal compiler error: type_of with ty_param\nSo I was trying to add an `insert_with_key` method to `map` like [so](https://github.com/killerswan/rust/compare/map_improvement), and I don't yet know how to avoid this error.\n\nOn one of the branches where I'm playing with this, [this is a commit](https://github.com/killerswan/rust/commit/5ef00957cb8be764564f5a7297ff26abf5edb205) before which things compile, and after which I see [error like so](https://gist.github.com/2873108).  All that change does is change the argument type from `fn(uint)` to `fn(V)`.\n\nWhat's more, I haven't been able to reduce this to a problem outside of the standard library.  For example, [this](https://gist.github.com/2873116) compiles just fine.   :P\n\nAny ideas?"
2493,'nikomatsakis','crash using by-value records with mutable fields\nThe following program will segfault, double free, leak, and generally misbehave:\n\n    type T = {mut f: @int};\n    fn foo(++x: T) { x.f = @4; }\n    fn main() {\n        let x = {mut f: @3};\n        foo(x);\n    }\n\nThe reason is our by-value protocol: we copy the data for the record but do not invoke the take-glue (nor drop-glue).  As a result, the assignment `x.f = @4` within `foo()` causes the original `@3` to be freed, but never arranges for the new `@4` to be released.  When `foo()` returns, `main()` tries to drop *its* copy of `x`, which still contains the original `@3` pointer.  \n\nOf course the same badness would happen if the type T included a unique pointer.  Or really anything that requires take/drop-glue.'
2484,'brson',"rustdoc spawns too many threads\nIf I don't configure with docs disabled, my machine becomes unresponsive when I do a ```make check``` and it gets to building the docs. Just now, I had to reboot because it was completely frozen for about 5-8 minutes.\n\nMacBook Pro with OS 10.7, 4 GB of RAM. Sorry, don't have better information than this right now, but I wanted to report it."
2447,'nikomatsakis',"liveness in stack closures\nThe liveness pass should be extended to treat stack closures just like a loop body.  This is relatively straightforward.  It would allow for a couple of nice things:\n\n- it'd be more efficient in some cases (I believe the last_use code I replaced actually did this right) because we could move values in if there were a loop like\n\n    let mut v = [];\n    uint::range(...) { |i|\n        use(v);\n        v = [some new vec];\n    }\n\n- it allows us to right fold for arbitrary iteration with only moves:\n\n    let mut b = b0;\n    for as.each { |a|\n        b <- op(a, b);\n    }\n    ret b;\n\n    In this case, the value in `op(e, b)` is actually moved out temporarily but always restored by the end of the loop.  This would work today with a while loop but not with a closure-based loop."
2444,'nikomatsakis','ICE with cross-crate resources and channels\nHere\'s a test program:\n\n```\nimport comm::{port, chan, methods};\nuse std;\nimport std::arc;\n\nenum e<T: send> { e2, e(chan<arc::arc<T>>) }\n\nresource r<T: send>(x : comm::chan<e<T>>) {\n    x.send(e2);\n}\n \nfn foo<T: send const>(-x : T) -> r<T> {\n    fail\n}\n\nfn main() {\n    foo([some(1)]);\n}\n```\n\nThis gives an internal compiler error. The problem is that type variable leaks into trans. If I define a resource like `arc::arc` in the same file and use that instead, the program compiles successfully. Here is some of the log from compiling this:\n\n```\nrust: "cleanup_and_leave: leaving [block 389]"\nrust: "new insn_ctxt: cleanup_and_Br"\nrust: "new insn_ctxt: cleanup_and_leave"\nrust: "cleanup_and_leave: leaving [block 7fb923853d50]"\nrust: "cleanup_and_leave: leaving [block 391]"\nrust: "new insn_ctxt: finish_fn"\nrust: "new insn_ctxt: tie_up_header_blocks"\nrust: "new insn_ctxt: trans_args"\nrust: "new insn_ctxt: alloc_ty"\nrust: upcall fail \'Assertion !ty::type_has_params(t) failed\', /Users/eholk/Documents/projects/mozilla/rust/src/rustc/middle/trans/base.rs:4233\n```\n\nThe uninstantiated type variable is the data field in the arc.'
2432,'nikomatsakis','bound regions and resolving inferable types\nI think there is an error lurking in the `universally_quantify_*()` routines: they do a shallow `structure_of` but maybe they need to do something deeper?  Actually it is probably ok, but think it over in any case.'
2411,'brson','typestate has very bad performance on large vectors\nThis takes 5 minutes to compile:\n\n```\nfn main() {\n    let x = [\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        .... x8000 lines ...\n    ];\n}\n```\n\nSeems like a silly use case but that is what `#include_bin` desugars to.'
2405,'nikomatsakis',"Typechecker can't pass copies to functions taking [const T]/&\nConsider this code from base.rs:\n\n```\n        vec::riter(copy cleanups) {|cu|\n            ...\n        }\n```\n\nWhen I change `riter` to take a `[const T]/&`, I get the following error message:\n\n```\n/Users/eholk/Documents/projects/mozilla/rust/src/rustc/middle/trans/base.rs:4011:24: 4011:32 error: mismatched types: expected `[const <V10>]/&<R0>` but found `[middle::trans::common::cleanup]` (vector vs vector)\n/Users/eholk/Documents/projects/mozilla/rust/src/rustc/middle/trans/base.rs:4011         vec::riter(copy cleanups) {|cu|\n                                                                                                         ^~~~~~~~\nerror: aborting due to previous errors\n```\n\nThese types should be coercible..."
2378,'nikomatsakis','reachability export map does not consider overloaded operators\nRight now the reachability export map does not consider overloaded operators.  So if you define an overloaded operator in crate A, and use it in crate B, then you run into trouble in crate C that uses crate B (you may need generics and a few other things too).  The problem is pretty clear: `traverse_expr()` does not consider expr_binary, expr_unary, and friends.'
2372,'nikomatsakis','self type should be "just a type"\nRight now the `self` type is a type constructor / higher-kinded type, but it is the only part of our type system like that and so is not terribly useful.  We should change it be like other type parameters---but a bit special, since it is implicitly defined---and maybe later add higher-kinded types in a more disciplined way.\r\n\r\nNote: I have a patch that does this, it is in its final testing phases.\r\n'
2361,'pcwalton','Implement stack maps for unwinding\nThis issue tracks implementation of stack maps in LLVM. The goal is to have stack maps working for unwinding for 0.3 or 0.4.\n\nThe idea is to use precise stack maps instead of landing pads to run destructors of unique pointers and resources during task failure. This will allow unwinding to work on Windows and should also lead to dramatic code size reduction. Unwinding performance should be slightly improved as well. Eventually this can be extended to support accurate tracing garbage collection for shared boxes (either as a backup for reference counting or in lieu of reference counting).\n\nThis requires fairly invasive changes to LLVM. All optimization passes will be turned off at first, and will be reenabled one by one. They should not be hard to reenable.\n\nAt the moment, I believe the LLVM steps needed here are:\n\n1. ☑ Add a `llvm.gcregroot` intrinsic. Translate it in the fast instruction selector. This needs to be done during call lowering, to make sure that the register roots end up within the call sequence.\n\n2. ☑ Add `llvm.gcregroot` intrinsics automatically after call sites based on the types of SSA values. This must be done very late in IR transformation, probably right around the `CodeGenPrepare` pass.\n\n3. ☑ Lower `llvm.gcregroot` intrinsics properly in the fast instruction selector. This requires creating a new, fake `MachineInstr` that tracks GC roots and their address spaces.\n\n4. ☑ Add infrastructure to the GC strategy class to support register roots.\n\n5. ☑ Translate `llvm.gcroot` intrinsics in the fast instruction selector as well.\n\n6. ☑ Add a generic GC strategy and metadata printer. We should be able to use this for Rust.\n\n7. ☑ Track callee-saved registers in the GC metadata object. Update the generic GC strategy to record the locations of these registers.\n\n8. ☑ Allow `getelementptr` instructions that reference an `alloca` instruction to be rooted with `llvm.gcroot`. This allows structs containing pointers to be rooted without complex type encoding schemes.\n\n9. ☑ Implement an LLVM pass that automatically roots allocas that contain traceable pointers with `llvm.gcroot`, and uses the metadata field to track the locations of the pointers therein. (I have a patch for this that needs to be resurrected.)\n\n10. ☑ Implement a pass in LLVM that computes liveness on the SSA graph. This used to be present in LLVM but was removed due to the lack of use and poor performance. It should be rewritten.\n\n11. ☑ Using this new liveness pass, augment the `llvm.gcregroot` insertion pass to throw out dead register roots.\n\n12. ☑ Modify the `llvm.gcregroot` insertion pass to root only pointer origins, not any derived pointers. Consider pointer origins and derived pointers a single value for the purposes of liveness.\n\n13. ☐ Add support to the SelectionDAG-based instruction selector for GC register roots. This requires a new SDNode. We will need to ensure that it is inside the call sequence, so this requires changing the signature of `LowerCall` and/or `LowerCallTo`. Thus all targets will need to be updated.\n\nWe will eventually need to have a comprehensive LLVM-level test suite before all of this can be sent upstream.\n\nOn the `rustc` side, we will need to tag all shared and unique boxes with `addrspace(1)`. (This currently happens for shared boxes, but not for uniques.) Unique boxes will need to become self-describing; this is not necessary in theory, but in practice it helps the LLVM side of things if all that needs to be tracked for each virtual register is a single address space value. Additionally, we will need to use the `llvm.gcroot` intrinsics to root (a) every enum that contains shared pointers, unique pointers, or resources; and (b) every resource.\n\nIn the Rust runtime, we will need to implement the stack crawler. (I have a prototype of this written already.) We will then need to use it to locate all of the roots during unwinding and then run their destructors. This may require fixes to (or replacement of) the shape code.\n\nI intend to keep this issue up to date with the latest changes to our strategy here.'
2333,'nikomatsakis',"is_null method no longer works because of unconstrained types\nCan't determine a type for `p.is_null()`\r\n\r\n```\r\nfn main() {\r\n  let p: *int = ptr::null();\r\n  assert p.is_null();\r\n}\r\n```"
2327,'nikomatsakis','Confusing error message when same-named field and method both in scope\n```\r\n/home/brian/dev/rust/src/test/run-pass/act.rs:178:18: 178:29 error: mismatched types: expected function or native function but found @mut bool\r\n/home/brian/dev/rust/src/test/run-pass/act.rs:178               _ { msg.defer() }\r\n```\r\n\r\nI had both a field and a method called `defer`. rustc should say that both are defined and show me where.'
2321,'brson',"Make channel 0 invalid\nI've seen one bug where unsafe code accidentally sent data to channel 0. We should start them at 1 and assert in the runtime when looking up channel 0."
2312,'brson','type variables in method names are resolved in wrong scope\nThis does not work:\r\n\r\n```\r\niface clam<A> { }\r\n\r\n\r\nimpl foo<A> for [A] {\r\n   fn bar<B,C:clam<B>>(c: C) -> B { fail; }\r\n}\r\n\r\nfn main() { }\r\n```\r\n\r\nIt yields:\r\n\r\n```\r\n/Users/nmatsakis/tmp/iface-res-bug.rs:5:19: 5:20 \x1berror: unresolved typename: B\r\n/Users/nmatsakis/tmp/iface-res-bug.rs:5    fn bar<B,C:clam<B>>(c: C) -> B { fail; }\r\n```'
2310,'nikomatsakis',"Type parameter confusingly inferred to bogus type\nI wrote the equivalent of this earlier and it baffled me for several minutes.\r\n\r\n```\r\nfn size_of<T>() -> uint {\r\n    // Expecting (though unreasonably) the type parameter to be\r\n    // inferred to T, it is actually inferred to something byte-sized (nil?)\r\n    sys::size_of()\r\n}\r\n\r\nfn main() {\r\n    // Why does size_of::<u32>() return 1?\r\n    assert size_of::<u32>() == 4u;\r\n}\r\n```\r\n\r\nIt works correctly when you write `sys::size_of::<T>()`. I don't think this should typecheck.\r\n"
2303,'brson','Shape and LLVM disagree about the alignment of 64-bit ints on 32-bit x86\nOn x86 our shape code does not agree with llvm, clang, or gcc about the alignment of structs containing 64-bit integer fields.\r\n\r\nIn C this struct is 4-byte aligned on 32-bit x86:\r\n\r\n```\r\nstruct s {\r\n    uint64_t t;\r\n};\r\n```\r\n\r\nWhen we produce the equivalent struct in Rust, LLVM produces code that uses C\'s 4-byte alignment, but the shape code thinks it has 8-byte alignment and things go bad. Let\'s take a look!\r\n\r\n```\r\n\r\n// This is the type with the questionable alignment\r\ntype inner = {\r\n    c64: u64\r\n};\r\n\r\n// This is the type that contains the type with the questionable alignment, for testing\r\ntype outer = {\r\n    c8: u8,\r\n    t: inner\r\n};\r\n\r\n#[cfg(target_arch = "x86")]\r\nfn main() {\r\n\r\n    let x = {c8: 22u8, t: {c64: 44u64}};\r\n\r\n    // Send it through the shape code\r\n    let y = #fmt["%?", x];\r\n\r\n    #debug("align inner = %?", sys::align_of::<inner>()); // 8\r\n    #debug("size outer = %?", sys::size_of::<outer>());    // 12\r\n    #debug("y = %s", y);                                                        // (22, (0))\r\n\r\n    // per clang/gcc the alignment of `inner` is 4 on x86.\r\n    // we say it\'s 8\r\n    assert sys::align_of::<inner>() == 4u; // fails\r\n\r\n    // per clang/gcc the size of `outer` should be 12\r\n    // because `inner`s alignment was 4.\r\n    // LLVM packs the struct the way clang likes, despite\r\n    // our intents regarding the alignment of `inner` and\r\n    // we end up with the same size `outer` as clang\r\n    assert sys::size_of::<outer>() == 12u; // passes\r\n\r\n    // But now our shape code doesn\'t find the inner struct\r\n    // We print (22, (0))\r\n    assert y == "(22, (44))"; // fails\r\n}\r\n```\r\n\r\nThis affects enums too.\r\n\r\nI think we should just do what LLVM wants us to do and accept the 4-byte alignment.\r\n\r\nInteresting tidbit I guess: while clang and gcc agree on the alignment of the struct containing a `uint64_t` (it\'s 4), they don\'t agree on the alignment of `uint64_t` itself - clang says 4, gcc says 8'
2282,'nikomatsakis','infer variance for region parameters\nIt occurs to me that we are always treating regions covariantly.  This is clearly wrong.  We should either (1) not allow regions to appear in in- or contravariant positions within nominal types or (2) allow variance to be declared.  I am leaning towards (1) at the moment.'
2280,'nikomatsakis',"Bug borrowing certain rvalues, maybe\nI'm not sure exactly what's causing these, but the compiler fails during codegen for a few cases of borrowing. It has something to do with borrowing temporary expressions. I think. I'll put FIXME markers connected to this bug in the files in question (a foreach loop in cargo/cargo.rs, another in rustc/middle/trans/base.rs, another in rustc/middle/tstate/auxiliary.rs, and a final one in test/bench/shootout-mandelbrot.rs). The commit that changes those (and will be linked here momentarily) shows the change I had to make to get it working with borrowed regions.\r\n"
2279,'brson',"Make unique boxes self-describing\nUnique boxes will need to be self describing so that the unwinder knows what's in them."
2278,'nikomatsakis','self type is incorrect w/r/t region parameter\nIn `fixup_self_param()`, we check that the TPS for the self type are the same but not the region parameter.'
2277,'brson','Put shared and unique boxes into their own LLVM addrspace\nWe are going to use the addrspaces to identify boxes for our stack maps.\r\n\r\nShared boxes go into addrspace 1, uniques addrspace 2.'
2272,'brson',"Memory leak when calling `span_fatal` from trans\nCommit 68f88125115fb239c79efa655570fdcae821765c introduces a check that can't easily be done in any pass before trans. The test case in that commit is disabled because currently it will cause a memory leak (12 objects lost) when compiled."
2271,'brson',"Stop running tidy on the test suite\nHaving the build fail because a test includes a long line seems a bad use of everybody's time."
2259,'brson','temporary hack to make testing std::time reliable\nThis is a quick hack to address #2160 until we get some kind of global, static, singleton or whatever to fix the setenv threading problem.'
2256,'nikomatsakis','Resolve the static region during typechecking, not in the parser\nAs per a FIXME in the parser (```region_from_name```): "To be consistent with our type resolution, the static region should probably be resolved during type checking, not in the parser."'
2254,'brson',"`mutable` keyword is still parsed\nIt's mentioned in at least `parse_instance_var`"
2242,'pcwalton',"Cannot import impls from diamond-shaped libraries\nHere's an example of the bug:\r\n\r\nhttps://gist.github.com/2421363\r\n\r\nIt seems that libraries re-export the ifaces/impls of libraries they're using, which triggers a duplicate symbol error when libraries are used in a diamond shaped pattern."
2226,'brson','Upgrade LLVM to 3.1 RC\nLLVM has branched for 3.1. We should probably rebase our fork to make sure we are up to speed. I think we are several months behind.'
2225,'nikomatsakis','add a region-based alt& statement\n`alt` today creates implicit references.  We should make a temporary `alt&` that creates regions for bindings, deprecate `alt`, and gradually perform the migration.'
2221,'brson','Declare enums as LLVM named structs\nOur new GC infrastructure will need to distinguish enum types so we should name them. They will still just be structs of i8s.'
2212,'nikomatsakis','Method calls don\'t autoderef\nField access does.\r\n\r\n```\r\nimpl i for int {\r\n    fn val() -> str { "wut" }\r\n}\r\n\r\nfn main() {\r\n    let j = @{\r\n        val: 10\r\n    };\r\n    // This autoderefs\r\n    assert j.val == 10;\r\n\r\n    let i = @10;\r\n    // This does not\r\n    assert i.val() == "wut";\r\n}\r\n```\r\n\r\n```\r\n../src/test/run-pass/method-autoderef.rs:12:11: 12:16 error: attempted access of field val on type @int, but no public field or method with that name was found\r\n../src/test/run-pass/method-autoderef.rs:12     assert i.val() == "wut";\r\n```'
2204,'nikomatsakis',"Handle borrowing of unique pointers correctly\nBorrowing a unique pointer temporarily invalidates its type (the pointer is no longer unique).  We need to ensure that the original unique pointer is inaccessible while the borrow alias exists (except, possibly to create other borrows).  This will be done in a separate pass (I've actually implemented most of the code as part of #2046) which will check when a `~T` is borrowed that either:\r\n\r\n1. the borrowee is an rvalue, in which case the only accessible copy is the borrowed ptr and everything is fine.\r\n2. the borrowee is an lvalue that is rooted in a local variable. This local variable is then made inaccessible for the scope of the borrow."
2203,'nikomatsakis','Prevent regions from being closed over and hidden from view\nBecause a `&T` type is copyable, it is currently possible to close over them using an `fn@()` (and, eventually, `iface@`).  This is clearly wrong.  We need a new kind---perhaps `heap` or `gc`?---indicating data which is not only copyable but also copyable into a shared closure.  This goes in between copy/send, I think.'
2202,'nikomatsakis','Closure reform\n**UPDATE:**\r\n\r\nThis is a meta-bug now for tracking the work on completing closures. Now that #6801 has landed, the remaining pieces of work are:\r\n\r\n* Issue #3696: Define region hierarchy for closures\r\n* Issue #10553: We should not be accepting `\'a ||` as syntax\r\n* Issue #8622: Unboxed closures -- for the purposes of #2202, just having a design and ensuring our treatment of closures is compatible with it is enough.\r\n* Issue #12224: Calling a closure is a kind of borrow.\r\n* Issue #13621: Explain closures much better in the tutorial \r\n\r\n**ORIGINAL FOLLOWS:**\r\nWe need to revamp function types in light of regions.  I think `fn()` (the "any" function) will go away, and `fn@()` and `fn~()` will be coercable to `fn&()`, just as with poiners/vectors/slices/etc.  Also, `fn&()` becomes `fn&r()` (that is, r is a region), though the user won\'t typically need to write it.  We can probably leave the representation as is, though we could also tweak `fn&()` to not have a ref count since there will be an explicit borrowing that occurs.'
2201,'nikomatsakis',"Nominal types containing region ptrs\nThe current handling for nominal types that contain region pointers is insufficient.  We need to include a `ty::region` in the `ty_enum` (`ty_class` etc).  To make this easier, we need to know which enums etc may contain region ptrs.  This could in principle be inferred but it's painful, so I plan to augment the declaration of an enum/class to indicate if the type can contain region pointers or not.  This will also affect the kind of the type, so it makes sense.  Something like `enum expr` vs `enum expr&`.  "
2200,'nikomatsakis','Subregions for nested functions\nThe current code assumes that scoped regions are always subregions of those for region parameters.  This is not true for nested functions like fn@().'
2199,'nikomatsakis',"Borrowing\nBasic borrowing is in place, but more is needed:\r\n\r\n- if the borrowed value lives in mutable memory, we need to increase (temporarily) the ref count of boxes (or else prohibit this mutable memory from being changed and/or prohibit the borrowing).\r\n- evec/estr borrowing does not type check nor trans.  Not sure why the former doesn't work but the latter is just unimplemented."
2196,'brson','metadata decode error with libraries, modules, and impls\nI tracked down a pretty odd error, which can be found here: https://gist.github.com/2381410. It seems that with a pretty complicated use of libraries and the sharing of names for types, modules, and impls ultimately confuses the metadata decoder.'
2189,'brson',"RFC: Remove bind\nI think it's time for bind to go.  My reasons:\r\n\r\n- The language will have that many fewer keywords and syntactic constructs.\r\n- The semantics are incompatible with closures.  Right now, if I write `foo(_, f())` this evaluates `f()` right away and binds the result into the closure.  This is quite different from `{|x| foo(x, f())}` which is surprising.  This has led to bugs.\r\n- The type system is complex enough.  Bind is a weird corner case we tend to forget about.  We already found one such problem (move mode arguments) and I am confident there are more lurking.  Let's simplify our lives and only think about closures, which are hard enough.\r\n\r\nAs a side effect of this change, naming a method like `a.b` without calling it will presumably become an error.  "
2179,'nikomatsakis','integrate reachability map computation with export\nCurrently, we build up a reachability map as a pre-pass and then use this to avoid emitting metadata we don\'t have to emit.  I was wondering if it would be possible instead to emit the metadata in a "DFS" fashion, wherein we never build a reachability map but instead just start by emitting metadata for exported/inlined things and then gradually emit metadata for other things that are referenced from those. \r\n\r\n@marijnh does this seem plausible or is there an obvious reason it wouldn\'t work?'
2176,'brson','Remove the difference between .rc and .rs files\nThis distinction seems to be confusing for newcomers and there is very little practical difference between the two. This would also help eliminate some of the confusing behavior of crate companion mods (#1277).\r\n\r\nWe would still need a way to signal to cargo which file is the crate file, so we could either keep the .rc extension (having it be the same as .rs), have it scan .rs files for a specific attribute, or add it to the cargo manifest.'
2175,'nikomatsakis','fail: print_type shouldn\'t see a ty_infer\n<pre>\r\nfn main() {\r\n        let v = [];\r\n        let mut i = 0;\r\n        v.each {|x| i = i + 1; }\r\n}\r\n</pre>\r\n\r\nyields\r\n\r\n<pre>\r\n#0  upcall_fail (expr=0x102b1ebf0 "print_type shouldn\'t see a ty_infer", file=0x1005c6bf0 "../src/librustsyntax/print/pprust.rs", line=385) at ../src/rt/rust_upcall.cpp:130\r\n#1  0x000000010051541e in print::pprust::print_type::_40f9364acb2e29cf ()\r\n#2  0x0000000100514b0a in print::pprust::to_str3548::_2ea226c1c51d6827 ()\r\n#3  0x0000000100514a09 in print::pprust::ty_to_str::_381315eb53c8cdbb ()\r\n#4  0x0000000100fc9a97 in middle::tstate::ck::check_states_against_conditions::_f6c9a5dc26d64dd1 ()\r\n#5  0x0000000100fcb787 in middle::tstate::ck::check_fn_states::_f6c9a5dc26d64dd1 ()\r\n#6  0x0000000100fcbf34 in middle::tstate::ck::fn_states::_eb311fc189ead655 ()\r\n#7  0x0000000100cd5267 in visit::visit_expr3370::_4918fd88449fd53a ()\r\n#8  0x00000001011fef18 in __morestack ()\r\n</pre>\r\n\r\nInterestingly enough, using v.iter yields a program that builds without incident.'
2165,'brson','float::from_str and NaN/inf/-inf\nShould float::from_str do the following conversions?\r\n"NaN" -> float::NaN\r\n"inf" -> float::infinity\r\n"-inf" -> float::neg_infinity\r\n\r\nThat\'d match what float::to_str does (if my pull request #2164 is merged.)\r\n\r\nIf this sounds good I\'ll chuck a patch in.\r\n'
2156,'brson','failure in closure causing a pointer being freed was not allocated\nHi all,\r\n\r\nI tracked down a malloc error with this code:\r\n\r\n\r\n```\r\nuse std;\r\nimport io::{reader, reader_util};\r\n\r\nfn main() {\r\n    io::with_str_reader("") { |rdr|\r\n        alt rdr.read_char() { \'=\' { } _ { fail } }\r\n    }\r\n}\r\n```\r\n\r\nErrors out with:\r\n\r\n```\r\nwarning: no debug symbols in executable (-arch x86_64)\r\nrust: upcall fail \'explicit failure\', test2.rs:6\r\ntest2(64191,0x10061a000) malloc: *** error for object 0x100500040: pointer being freed was not allocated\r\n*** set a breakpoint in malloc_error_break to debug\r\n[1]    64191 abort      ./test2\r\n```'
2155,'brson','Can\'t use the same function from two different crates with the same name\nIf I have crate B (vers = "0.1") and crate B (vers = "0.2") and they both contain function `f` and I use both crates, then I can\'t call function `f` from both crates because of name collisions. This is partly because of c83d61de936f2910001fe72de01ac58479d90524 (which I will revert), and partly because of other missing parts of the versioning story.'
2152,'nikomatsakis','allow mutation of moved upvars\nSomething like this should work:\r\n\r\n```\r\nfn foo() {\r\n    let mut x = [mut ...];\r\n    task::spawn(fn~[move x]() {\r\n        x += [3];\r\n    }):\r\n}\r\n```'
2148,'nikomatsakis',"Basic Block does not have terminator!\n    fn three() -> uint { 3u }\r\n    fn main() { &three(); }\r\n\r\nfails to compile:\r\n\r\n    Basic Block in function '_ZN4main213E' does not have terminator!\r\n    label %4\r\n    LLVM ERROR: Broken module, no Basic Block terminator!\r\n"
2144,'brson','Block unwind leak\n    fn useBlock(f: fn~() -> uint) { useBlock({|| 22u }) }\r\n    fn main() {\r\n        useBlock({|| 22u });\r\n    }\r\n\r\nleaks after it runs out of stack space:\r\n\r\n    leaked memory in rust main loop (3 objects)\r\n    Assertion failed: (false), function ~memory_region, file ../src/rt/memory_region.cpp, line 172.\r\n'
2140,'nikomatsakis',"I disabled test/compile-fail/vec-concat-bug.rs\nIt passes just fine after its for-loop was changed to the new style, which suggests that the bug it was checking for isn't properly fixed yet."
2135,'brson',"Make crate linkage rules less error-prone\nLately we've been hitting a lot of problems where rustc picks the wrong version of a crate from multiple candidates. Sometimes this happens from picking the 0.1 crate when it should pick 0.2, sometimes because there are multiple 0.2 crates and it picks the wrong one randomly.\r\n\r\nThere are two parts to this solution. This first is just being more disciplined about our `use` statements (#2069).\r\n\r\nThe second part involves adding a check to creader that there is only a single match.  When there are multiple matching crates it will list them and their associated linkage metadata then error. In order to recover from the error the code must create more specific `use` statements until there is no ambiguity.\r\n\r\nThis leaves an open problem when there are two matching crates with the same linkage metadata. Usually in this case you just want do delete the old ones, but we could also allow `use` to match on the crate hash itself."
2131,'brson','rustdoc-generated docs do not include typedefs\nThe type `le`, for example, is not defined in <http://doc.rust-lang.org/doc/std/sort.html>.'
2123,'pcwalton',"Reported path for unresolved named imports is wrong\n```\r\n// error-pattern:unresolved import: m::f\r\nimport x = m::f;\r\n\r\nmod m {\r\n}\r\n\r\nfn main() {\r\n}\r\n```\r\n\r\n```\r\n../src/test/compile-fail/unresolved-named-import.rs:2:7: 2:16 error: unresolved import: m::x\r\n../src/test/compile-fail/unresolved-named-import.rs:2 import x = m::f;\r\n```\r\n\r\nThe error says we failed to resolve `m::x` but that is incorrect. We failed to resolve `x`, we failed to find `m::f`, and `m::x` doesn't identify a real thing."
2113,'brson','"De-ajax\'d issues" link on website broken\nThe link to de-ajax\'d issues on the homepage of rust-lang.org doesn\'t work.'
2101,'nikomatsakis','strings in arenas causes leak\nThis program compiles cleanly and runs, but aborts at the end with a leak message.  Changing str to int does not leak.\r\n\r\n```\r\nuse std;\r\nimport std::arena;\r\nimport std::arena::arena;\r\n\r\nenum hold { s(str) }\r\n\r\nfn init(ar: &a.arena::arena, str: str) -> &hold {\r\n    new(*ar) s(str)\r\n}\r\n\r\nfn main(args: [str]) {\r\n    let ar = arena::arena();\r\n\tlet leak = init(&ar, args[0]);\r\n\talt *leak {\r\n\t\ts(astr) {\r\n            io::println(#fmt("%?", astr));\r\n\t\t}\r\n\t};\r\n}\r\n```\r\n\r\n\r\n```\r\nrust: fatal, \'leaked memory in rust main loop (1 objects)\' failed, ../src/rt/memory_region.cpp:169 1 objects\r\nAbort trap: 6\r\n```\r\n'
2082,'pcwalton','Change "use" to "extern mod"\nHello,\r\n\r\nI was recently reading about the 0.2 release of Rust, and it looks really interesting!  One thing that bugged me that I wanted to bring up - I\'m not a fan of the "crust" keyword.  The word "crust" has an intrinsic meaning in English, and my brain insists on reading it incorrectly at first read.  I\'d like to suggest changing it to "externc", which mimics C\'s `extern "C"`, and also doesn\'t have any other intrinsic meaning.\r\n\r\nThanks!'
2071,'brson',"Should vec::reserve reserve the exact amount or in powers of two?\nCurrently it's exact, but there are places in `vec` that use it in conjuction with `next_power_of_two` to do it the other way, and #2062 also wants to reserve in powers of two.\r\n\r\nClearly there should be two different versions. Should the default be exact? If so, what should the `next_power_of_two` version be called?"
2069,'brson','Crates need to specify which versions they use\nDuring the switch to 0.2 I ran into several baffling cases of crates not linking to the correct versions of their dependencies. If our versioning is going to work correctly (allowing versions to live alongside each other) then we need to actually specify version numbers in our `use` statements. Probably every crate in the main repo should be explicit about which versions they require.'
2063,'nikomatsakis','typeck hang with recursive type\nThis hangs the compiler in typeck:\r\n\r\n    enum t = @t;\r\n    fn main() {\r\n        let x : t;\r\n        x.next = x;\r\n    }\r\n'
2060,'nikomatsakis',"cci pretty-print failure\nhttp://bot.rust-lang.org/logs/2012/02/28/2012-03-28T06:00:32Z-2de5fb11-4865-4bb6-ae98-070cab87c645.html\r\n\r\nFailure here appears to be pretty printing some cci cases. It's blocking distcheck on the build host. Probably minor."
2058,'brson','main task needs to run on the main OS thread\nIn some operating systems (mac, win) the main thread is special and can do special things (on mac you have to be on the main thread to do cocoa API calls). Somehow we probably need to arrange for the main task to run on the main thread, which is a pain.'
2050,'nikomatsakis','Detect and fail when hashmap is modified during iteration\nRelated to #2049, I think we ought to detect attempts to modify hashmaps and other mutable data structures during iteration and fail fast.  This should be relatively easy to do thanks to the use of methods to define when iteration is occurring.  We can also allow certain kinds of modifications (for example, only the current key) if desired.'
2047,'brson',"A destructor that fails when run from the cycle collector will do terrible things\nFailing inside a destructor is broken to begin with, but failing from within the cycle collector is even worse:\r\n\r\n1) The cycle collector won't catch the failure and continue\r\n2) The cycle collector jumps from the C stack to the Rust stack to run the destructor but does not do the proper maintenance if the destructor throws\r\n3) The logic that prevents failure in crust functions is in effect because of reentry into the Rust stack, so the runtime will abort\r\n4) The final cycle collection happens outside of any try-catch block so the runtime will abort"
2046,'nikomatsakis','RFC: Add immutability-based checks in place of safe ref checker\nI would like to implement the [solution for Dan\'s Bug based on immutability][sol] that I proposed earlier.  I have updated the page to describe my latest version, which does not include the separate class of "assignable types".  Instead, we make use of #1273 (explicitly mutable local variables) and the work on regions to ensure that the type system can always distinguish immutable and mutable state.  \r\n\r\n[sol]: https://github.com/mozilla/rust/wiki/Proposal-to-address-Dan%27s-bug\r\n\r\nThe main change is to prohibit dangerous patterns (as described in [the proposal][sol]) from being matched against potentially mutable state.  An additional change would be to introduce `copy` patterns, which cause the value being matched to be copied out into a temporary, immutable space (this is more of a convenience than a requirement).\r\n\r\nEven if we scale back regions, I think that this approach is simpler and less error-prone than the existing one.  It does however require distinguishing "const" references from "immutable" references (right now, both are `&&`).  With region pointers, this is done for us, as we have `&T`, `&const T`, and `&mut T`.'
2044,'brson','Extract stack management code from rust_task\nA large portion of rust_task is now dedicated to fiddling with stacks. This code should probably be extracted into another class.'
2036,'nikomatsakis',"Leak when binding a stack closure\nThis example from the language reference leaks\r\n\r\n```\r\nfn main() {\r\n    fn add(x: int, y: int) -> int {\r\n        ret x + y;\r\n    }\r\n\r\n    type single_param_fn = fn(int) -> int;\r\n\r\n    let add4: single_param_fn = bind add(4, _);\r\n    let add5: single_param_fn = bind add(_, 5);\r\n\r\n    assert (add(4,5) == add4(5));\r\n    assert (add(4,5) == add5(4));\r\n}\r\n```\r\n\r\n```\r\nUnreclaimed object found at 0x678b7a0: ((), (5))\r\nUnreclaimed object found at 0x678b730: ((), (4))\r\nrust: fatal, 'leaked memory in rust main loop (2 objects)' failed, ../src/rt/memory_region.cpp:158 2 objects\r\n```"
2031,'brson','Rename unsafe::leak to forget\n'
2028,'brson','Convert rust_task_thread::running_tasks list to a queue\nRight now it is a list, and scheduling a task involves using a the rng to pick a task and blocking involves removing it from the middle of the list. It would be more efficient (and probably more fair) as a queue. Sort of depends on #1189 and on #2027 in that it would be nice to get rid of the blocked_tasks list as well.'
2022,'brson',"Remove lock_and_signal::lock_held_by_current_thread\nThis is used for two purposes: 1) to assert that we aren't retaking a lock that we already own and 2) to enable a single recursive lock in rust_task_thread.\r\n\r\nThis functionality entails calling pthread_self a lot which is not free and imposes significant overhead (maybe 30%?) on all our locking.\r\n\r\nTo get rid of this we would need to get rid of the one recursive lock. Probably we would want to leave it in debug builds because it does some very useful sanity checks."
2021,'brson',"rustdoc doesn't print type parameters in function signatures\n"
2013,'brson','rustdoc: Printed backslashes must be triple-escaped\nIn order to display `\\n` in the docs you have to write `\\\\\\\\n`. Pretty silly.'
2003,'brson',"rustdoc shouldn't consider more than one period to be the end of a sentence\nhttp://doc.rust-lang.org/doc/core/str.html\r\n\r\nThe brief description for `slice` gets cut off at `..` because rustdoc thinks that's the end of the first sentence."
1991,'brson','doc-tutorial tests don\'t always get regenerated?\nAt revision 561511e62813840e930ff60e6918ccaea4f00f00 I got a test failure with ```test/doc-tutorial/syntax_basics_14.rs```:\r\n\r\n```\r\nx86_64-apple-darwin/test/doc-tutorial/syntax_basics_14.rs:3:0: 3:16 error: unresolved modulename: io\r\nx86_64-apple-darwin/test/doc-tutorial/syntax_basics_14.rs:3 std::io::println(#env("PATH"));\r\n```\r\n\r\nManually deleting the contents of the directory ```x86_64-apple-darwin/test/doc-tutorial``` fixed the problem. But the ```doc-tutorial``` tests should get rebuilt automatically without having to do that.'
1989,'nikomatsakis',"RUST_CC_ZEAL crash with box closure\n    enum maybe_pointy {\r\n        none,\r\n        p(@pointy)\r\n    }\r\n    \r\n    type pointy = {\r\n        mut a : maybe_pointy,\r\n        mut f : fn@()->(),\r\n    };\r\n    \r\n    fn empty_pointy() -> @pointy {\r\n        ret @{\r\n            mut a : none,\r\n            mut f : fn@()->(){},\r\n        }\r\n    }\r\n    \r\n    fn main()\r\n    {\r\n        let v : [mut @pointy] = [mut];\r\n    \r\n        uint::range(0u, 2u) {|_i|\r\n            v += [mut empty_pointy()];\r\n        }\r\n    \r\n        v[0].a = p(v[0]);\r\n    }\r\n\r\n\r\nGives me a crash or\r\n\r\n    Assertion failed: (box->ref_count >= 1), function box_body_td, file ../src/rt/rust_shape.h, line 703.\r\n\r\nOnce this is fixed I'll run my CC mini-fuzzer again ;)"
1988,'brson','Check for failure in core::comm::port_ptr\nFIXME just before a call to ```yield()```: " If this fails then we\'re going to leave our port in a bogus state."'
1987,'brson',"In core::comm, native function call_with_retptr shouldn't take a boxed closure\nJust transcribing FIXMEs."
1984,'brson','Improve compiletest\nFIXME in ```compiletest/compiletest.rs```:  "The way this module sets up tests is a relic and more convoluted\r\n// than it needs to be". I don\'t know what was intended, but I\'m trying to make more FIXMEs go with issue numbers.'
1976,'brson',"add rustdoc to 'make install' and the windows installer\n"
1974,'brson','Crash when returning inside while-loop\nWhen I try to run the following program it crashes with an error message from glibc.\r\n\r\n```\r\nfn main() {\r\n  let s = "hej";\r\n  while s != "" {\r\n    ret;\r\n  }\r\n}\r\n```\r\n\r\nThe error message is\r\n\r\n    *** glibc detected *** ./crash: double free or corruption (fasttop): 0x0000000001a2c7d0 ***\r\n\r\nI tried running the program with valgrind. It then produced a different error message:\r\n\r\n    rust: fatal, \'live_allocs < 1\' failed, ./src/rt/memory_region.cpp:54 \r\n\r\nIf I change the loop to "while true", the program finishes without error.'
1966,'brson','Change all the somemod::t types to be named after their mod\n'
1961,'brson',"rustdoc html pages don't have a title\nThey should"
1959,'brson','Rustdoc: inconsistent treatment of modules and native modules\nFor example, the `os` module page: http://doc.rust-lang.org/doc/std/os.html\r\n\r\nThe docs for the module `os::libc_constants` are split out into their own page ( http://doc.rust-lang.org/doc/std/os_libc_constants.html ) while the two native modules `os::libc` and `os::rustrt` just have their docs appended to the bottom of the `os` page. (Note also that the links at the top of the page to the native module sections are broken.)\r\n\r\nNative modules should probably be treated as any other module and be given a page of their own.'
1957,'brson','document rustdoc\nProbably a wiki page is sufficient'
1956,'brson',"rustdoc doesn't document reexports of implementations\nhttp://doc.rust-lang.org/doc/core/index.html\r\n\r\nThis page should list vec_len, reexported from core::vec"
1953,'brson',"rustdoc generates incorrect links for impls\nTOC entries for impls contain special characters like `impl x of <A> for [fn@]` etc and the links are not sanitized correctly per pandoc's rules."
1951,'brson','Use consistent names for constructors in libs\nWe have some named `mk`, some `init`, some `create`.'
1942,'brson','Parse rustdocs out of markdown-formatted doc strings\nThis is an example of a current rustdoc from core:\r\n\r\n```\r\n#[doc(\r\n    desc = "\r\n\r\nConvert a string to a float\r\n\r\nThis function accepts strings such as\r\n\r\n* \'3.14\'\r\n* \'+3.14\', equivalent to \'3.14\'\r\n* \'-3.14\'\r\n* \'2.5E10\', or equivalently, \'2.5e10\'\r\n* \'2.5E-10\'\r\n* \'\', or, equivalently, \'.\' (understood as 0)\r\n* \'5.\'\r\n* \'.5\', or, equivalently,  \'0.5\'\r\n\r\nLeading and trailing whitespace are ignored.\r\n\r\n",\r\n    args(\r\n        num = "A string"\r\n    ),\r\n    return = "\r\n\r\nnone if the string did not represent a valid number.  Otherwise, some(n) where\r\nn is the floating-point number represented by [num].\r\n\r\n")]\r\n```\r\n\r\nAll of the extra attribute stuff is noise. Without much difficulty we could parse markdown like:\r\n\r\n```\r\n#[doc = "\r\n\r\nConvert a string to a float\r\n\r\nThis function accepts strings such as\r\n\r\n* \'3.14\'\r\n* \'+3.14\', equivalent to \'3.14\'\r\n* \'-3.14\'\r\n* \'2.5E10\', or equivalently, \'2.5e10\'\r\n* \'2.5E-10\'\r\n* \'\', or, equivalently, \'.\' (understood as 0)\r\n* \'5.\'\r\n* \'.5\', or, equivalently,  \'0.5\'\r\n\r\nLeading and trailing whitespace are ignored.\r\n\r\nArguments:\r\n\r\n* num - A string\r\n\r\nReturns:\r\n\r\nnone if the string did not represent a valid number.  Otherwise, some(n) where\r\nn is the floating-point number represented by [num].\r\n\r\n"]\r\n```'
1937,'brson',"Something is still broken in port detach\nJust saw this log from the bots http://bot.rust-lang.org/logs/2012/02/06/2012-03-06T10:19:41Z-50cd8e15-3023-4ec6-afde-e627de1a0f2d.html\r\n\r\nRelated to the hack here: ee991cae81c644a5f536acb49fff59ec769e61c7\r\n\r\nPorts are supposed to be completely dereffed before `del_port` but that isn't happening."
1935,'pcwalton','Clean up / rewrite resolve\nResolve has organically grown into a very complicated, rather slow, probably partially redundant tangle. When a decision is made on #1893 , some work should be done on cleaning it up.'
1932,'brson','(core::str) Boyer-Moore string searching\nHere, I\'ve added a Boyer-Moore string search.  It computes a pair of tables based on the "needle" being searched for, and then uses them to go faster through the "haystack"...\r\n\r\nI\'ve used it within str::find_str_between and str::iter_matches, and also added these functions:\r\n * str::findn_str_between\r\n * str::findn_str\r\n * vec::ends_with\r\n * str::chars_iteri'
1929,'brson','test runner should sort list of failures\nAt the end of a test run, the test runner prints all failures, but it does so in the order they failed. It should print the alphabetically.'
1926,'nikomatsakis','assertion failures in quasi-quoting\nThe following test fails with assertion failures about the "gather" ordering not being properly setup:\r\n\r\n```\r\nuse rustc;\r\nimport rustc::driver::diagnostic;\r\nimport rustc::syntax::ast;\r\nimport rustc::syntax::codemap;\r\nimport rustc::syntax::print::pprust;\r\n\r\nfn new_parse_sess() -> parser::parse_sess {\r\n    let cm = codemap::new_codemap();\r\n    let handler = diagnostic::mk_handler(option::none);\r\n    let sess = @{\r\n        cm: cm,\r\n        mutable next_id: 1,\r\n        span_diagnostic: diagnostic::mk_span_handler(handler, cm),\r\n        mutable chpos: 0u,\r\n        mutable byte_pos: 0u\r\n    };\r\n    ret sess;\r\n}\r\n\r\niface fake_ext_ctxt {\r\n    fn session() -> fake_session;\r\n}\r\n\r\ntype fake_options = {cfg: ast::crate_cfg};\r\n\r\ntype fake_session = {opts: @fake_options,\r\n                     parse_sess: parser::parse_sess};\r\n\r\nimpl of fake_ext_ctxt for fake_session {\r\n    fn session() -> fake_session {self}\r\n}\r\n\r\nfn mk_ctxt() -> fake_ext_ctxt {\r\n    let opts : fake_options = {cfg: []};\r\n    {opts: @opts, parse_sess: new_parse_sess()} as fake_ext_ctxt\r\n}\r\n\r\n\r\nfn main() {\r\n    let ext_cx = mk_ctxt();\r\n    let s = #ast(expr){__s};\r\n    let e = #ast(expr){__e};\r\n    let f = #ast(expr){$(s).foo {|__e| $(e)}}; // THIS IS THE PROBLEM EXPR\r\n    pprust::print_expr(f);\r\n}\r\n```'
1924,'brson',"rust_port_detach is very inefficient\nThis function does a busy wait until there are no outstanding references to the port. I believe this is what's causing #1922 - under valgrind it serializes threads so we end up waiting a very long time."
1922,'brson','Valgrind sometimes takes a very long time on some tests\nOne of the bots has currently been spending 30 minutes valgrinding task-perf-word-count. This makes me think something is going terribly wrong with memory management. Possibly related to native stacks.'
1919,'brson',"fs::list_dir should only return the contents of the directory\nCurrently using fs::list_dir will append the directory name to the front of every entry. I think fs::list_dir should only return the contents of the directory, and maybe another utility function should use fs::list_dir to give the current behavior.\r\n\r\nThe only other way I can see to access the contents of a directory is with os_fs::list_dir, but that seems like it's not supposed to be public. A comment in the source code has:\r\n\r\n```\r\n// FIXME: generic_os and os_fs shouldn't be exported\r\nexport generic_os, os, os_fs;\r\n```"
1918,'brson',"Replace the kernel task map with a port map\nrust_kernel currently maintains a map from `task_id` to `rust_task*`, and it is protected by a lock. The primary use of this is to look up ports in a task's port map which is protected by another lock. Other uses of this map could be eliminated and would be faster for it.\r\n\r\nGetting rid of this map will make port lookup faster, task creation and destruction less contentious, the runtime model simpler, and will discourage accessing arbitrary tasks from arbitrary threads (since there's no way to get to them), at the expense of making port construction and destruction more contentious."
1902,'nikomatsakis','Show all pointers in hex in leak reports\nSTR: leak some resources (e.g. #1482)\r\n\r\nResult:\r\n\r\n    Unreclaimed object found at 0x7fb101c14e30: res(140398219647488)\r\n    Unreclaimed object found at 0x7fb101c14c20: @res(140398219647488)\r\n    Unreclaimed object found at 0x7fb101e08d10: res(140398228512256)\r\n    Unreclaimed object found at 0x7fb101e08ce0: @res(140398228512256)\r\n\r\nExpected:\r\n\r\n    Unreclaimed object found at 0x7fb101c14e30: res(0x7fb102025a00)\r\n    Unreclaimed object found at 0x7fb101c14c20: @res(0x7fb102025a00)\r\n    Unreclaimed object found at 0x7fb101e08d10: res(0x7fb102899e00)\r\n    Unreclaimed object found at 0x7fb101e08ce0: @res(0x7fb102899e00)'
1899,'nikomatsakis','glue_free crash\nThis crashes in glue_free:\r\n\r\n    fn main()\r\n    {\r\n        let _b = [bind (fn~() { })()];\r\n    }\r\n\r\nIf I use `fn@` instead of `fn~`, or if I add a bound argument, I get different crashes.'
1896,'nikomatsakis','closure in record triggers a memory leak and abort\nThere seems to be an issue with closures in records and the type checker. This code segfaults with a leaked memory message:\r\n\r\n    type t<T> = { f: fn() -> T };\r\n    \r\n    fn f<T>(_x: t<T>) {}\r\n    \r\n    fn main() {\r\n        let x: t<()> = { f: { || () } };\r\n        f(x);\r\n    }\r\n\r\nHowever, if you remove `: t<()>` from `let x: t<()> = { f: { || () } };`, it works just fine.'
1893,'pcwalton',"RFC: Exports on individual items (pub and priv)\nInstead of `export` lists, we could have exports on individual items.\r\n\r\nSo, instead of:\r\n\r\n    fn foo() { ... }\r\n    export foo;\r\n\r\nWe would have:\r\n\r\n    pub fn foo() { ... }\r\n\r\nAnd instead of:\r\n\r\n    import foo::bar;\r\n    export bar;\r\n\r\nWe would have:\r\n\r\n    pub import foo::bar;\r\n\r\n(Here I changed `export` to `pub` to better match classes and to avoid exceeding the 5-character limit, but I'm ok either way.)\r\n\r\nThis change would help avoid the pain of managing export lists and should make libraries easier to write. Often people look at the definitions of items and want to know then and there whether the item is public or not."
1873,'pcwalton','import foo::* sometimes fails to import foo::foo\nThe file below fails with `unresolved name: foo` (in the main fn). When moving the import and main out of the extra module, the problem goes away. It also does not happen if `fn foo` has a name different from its enclosing module.\r\n\r\n```\r\nmod foo {\r\n    fn foo() {}\r\n}\r\nmod blah {\r\n    import foo::*;\r\n    fn main() { foo(); }\r\n}\r\n```'
1864,'nikomatsakis','RFC: Require explicit syntax to declare boxed, unique closures\nSo, currently, the sugared closure syntax `{||...}` can be used for any kind of closure.  @brson and I wanted this so that task spawning looks nice:\r\n\r\n    task::spawn {||...}\r\n\r\nbut I\'ve since soured on it (and I think he has too).  The basic reason is that it is not explicit whether the closure is a boxed or unique closure: this depends on the definition of the callee function.  But this distinction is important to the semantics and cost model.  Therefore, I would like to make it so that `{||...}` is always a stack closure (`fn&`).\r\n\r\nWith no other changes, this would mean that spawning a task is written `task::spawn(fn~() {...})`.  To make `fn@()` and `fn~()` a little more convenient to use, however, we could make any or all of the following changes:\r\n\r\n1. Do not require variable types (I think this would be relatively straightforward; I also think there\'s an existing bug for this but can\'t find it at the moment).\r\n2. Allow parentheses to be omitted if there are no arguments (e.g., `task::spawn(fn~ {...})`)\r\n3. Allow paren-less calls, similar to a sugared closure like `{||...}` (e.g., `task::spawn fn~ {...}` or `task::spawn fn~() {...}`)\r\n\r\nThis RFC is truly a "request for comment" because I\'m not really sure what\'s best.  Should we just leave things as they are?  If not, do we implement the proposals above to lighten the syntax a bit?  I think the first point (omitting variable types) is a clear win, but I\'m less sure about #2 and #3.  The fully explicit form is perhaps not so bad.\r\n\r\np.s. Another option might be to add some sigil to the sugared form, but `task::spawn {~|| ...}` just looks like a lot of random characters in a row to me.'
1841,'brson','Add crust functions to language docs\n'
1840,'brson',"Crust functions don't work across crates\nProbably results in segfaults. The code in trans that takes the value of crust functions doesn't know how to look up the ast::def for external functions."
1825,'brson',"FreeBSD deadlocks during compiletest\nHaven't investigated. For now I'm going to make the Makefiles export RUST_THREADS=1"
1817,'brson','range functions should iterate backwards as well\nRight now we have a bunch of `range` functions in mod `int`, etc that all iterate from low to high. It would be convenient if they would detect that the arguments were in high to low order and provide a reverse range. If not, then we need `rrange` functions.'
1815,'brson',"0 bytes definitely lost on i686\nSince I made some changes to the way C stacks work the linux2 bot periodically reports this failure\r\n\r\n```\r\n==55854== 0 bytes in 19 blocks are definitely lost in loss record 41 of 42\r\n==55854== at 0x4D70E8A: malloc (vg_replace_malloc.c:236)\r\n==55854== make: *** [check-stage2-T-i686-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-std-dummy] Error 100\r\n```\r\n\r\nI don't know why yet, but I think it might be because I'm not giving valgrind the right hints. Unfortunately, giving valgrind hints in a way that is most likely to be correct results in a big perf hit.\r\n\r\nOn my machine I also get additional valgrind errors on i686 relating to the pthread stack that don't show up on the bots."
1800,'brson',"upcall_vec_push is slow\nIt's number 3 on my profiles, after malloc and stack switching. Brian mentioned that it should run on the Rust stack, but it doesn't. Might be a candidate for moving into intrinsics."
1797,'brson','Make scheduler stacks smaller\nWe are soon going to be running native calls on their own stacks, so scheduler threads will no longer be sharing stacks with arbitrary code. We should be able to cut down the stack sizes used by our scheduler threads significantly since there is not much that scheduler threads actually do while not running on Rust stacks. Currently we use 1MB on Unix and the default on Windows.'
1788,'brson',"Redesign task API\nIt's a bit messy and uncomposable. There are various things we would like to be able to do but can't yet - set min rust stack size, set c stack size, perform operations on schedulers, specify 1:1 thread-to-task scheduling mode, add various hooks to either the spawner or spawnee.\r\n\r\nSome unimplemented ideas are in #1721.\r\n\r\nSee also #595"
1741,'nikomatsakis','Cycle collector is still turned off\n`maybe_cc` in `rust_cc.cpp` contains this:\r\n\r\n```\r\n    // FIXME: Needs a snapshot.\r\n#if 0\r\n    if (task->cc_counter++ > RUST_CC_FREQUENCY) {\r\n        task->cc_counter = 0;\r\n        do_cc(task);\r\n    }\r\n#endif\r\n```\r\n\r\nRemoving the `#if` causes the stage1 compiler to crash with the following backtrace:\r\n\r\n```\r\n\r\n#0  0x00007ffff6026d05 in *__GI_raise (sig=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64\r\n#1  0x00007ffff602aab6 in *__GI_abort () at abort.c:92\r\n#2  0x00007ffff69d7b5c in walk_vec2 (is_pod=<optimized out>, this=0x7ffff3f1b950, sp_size=<optimized out>) at ./src/rt/rust_cc.cpp:315\r\n#3  walk_vec1 (sp_size=5, is_pod=true, this=0x7ffff3f1b950) at ./src/rt/rust_shape.h:878\r\n#4  shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk_vec0 (this=0x7ffff3f1b950) at ./src/rt/rust_shape.h:440\r\n#5  0x00007ffff69d763e in walk_box_contents2 (box_dp=..., sub=..., this=<optimized out>) at ./src/rt/rust_cc.cpp:383\r\n#6  shape::data<cc::mark, shape::ptr>::walk_box_contents1 (this=<optimized out>) at ./src/rt/rust_shape.h:947\r\n#7  0x00007ffff69d77b2 in walk_box2 (this=0x7ffff3f1ba10) at ./src/rt/rust_cc.cpp:330\r\n#8  walk_iface2 (this=0x7ffff3f1ba10) at ./src/rt/rust_cc.cpp:363\r\n#9  walk_iface1 (this=0x7ffff3f1ba10) at ./src/rt/rust_shape.h:895\r\n#10 shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk (this=0x7ffff3f1ba10) at ./src/rt/rust_shape.h:381\r\n#11 0x00007ffff69d7b88 in walk_struct2 (end_sp=0x7ffff7443c5d "\\r\\016", this=0x7ffff3f1ba10) at ./src/rt/rust_cc.cpp:388\r\n#12 walk_struct1 (end_sp=0x7ffff7443c5d "\\r\\016", this=0x7ffff3f1ba10) at ./src/rt/rust_shape.h:874\r\n#13 shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk_struct0 (this=0x7ffff3f1ba10) at ./src/rt/rust_shape.h:510\r\n#14 0x00007ffff69d763e in walk_box_contents2 (box_dp=..., sub=..., this=<optimized out>) at ./src/rt/rust_cc.cpp:383\r\n#15 shape::data<cc::mark, shape::ptr>::walk_box_contents1 (this=<optimized out>) at ./src/rt/rust_shape.h:947\r\n#16 0x00007ffff69d767e in walk_box2 (this=0x7ffff3f1bad0) at ./src/rt/rust_cc.cpp:330\r\n#17 walk_box1 (this=0x7ffff3f1bad0) at ./src/rt/rust_shape.h:881\r\n#18 shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk_box0 (this=0x7ffff3f1bad0) at ./src/rt/rust_shape.h:488\r\n#19 0x00007ffff69d7b88 in walk_struct2 (end_sp=0x7ffff7443c5d "\\r\\016", this=0x7ffff3f1bad0) at ./src/rt/rust_cc.cpp:388\r\n#20 walk_struct1 (end_sp=0x7ffff7443c5d "\\r\\016", this=0x7ffff3f1bad0) at ./src/rt/rust_shape.h:874\r\n#21 shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk_struct0 (this=0x7ffff3f1bad0) at ./src/rt/rust_shape.h:510\r\n#22 0x00007ffff69d763e in walk_box_contents2 (box_dp=..., sub=..., this=<optimized out>) at ./src/rt/rust_cc.cpp:383\r\n#23 shape::data<cc::mark, shape::ptr>::walk_box_contents1 (this=<optimized out>) at ./src/rt/rust_shape.h:947\r\n#24 0x00007ffff69d767e in walk_box2 (this=0x7ffff3f1bba0) at ./src/rt/rust_cc.cpp:330\r\n#25 walk_box1 (this=0x7ffff3f1bba0) at ./src/rt/rust_shape.h:881\r\n#26 shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk_box0 (this=0x7ffff3f1bba0) at ./src/rt/rust_shape.h:488\r\n#27 0x00007ffff69d7b88 in walk_struct2 (end_sp=0x7ffff7443c6f "", this=0x7ffff3f1bba0) at ./src/rt/rust_cc.cpp:388\r\n#28 walk_struct1 (end_sp=0x7ffff7443c6f "", this=0x7ffff3f1bba0) at ./src/rt/rust_shape.h:874\r\n#29 shape::ctxt<shape::data<cc::mark, shape::ptr> >::walk_struct0 (this=0x7ffff3f1bba0) at ./src/rt/rust_shape.h:510\r\n#30 0x00007ffff69d683f in cc::mark::do_mark (task=0x626170, roots=..., marked=...) at ./src/rt/rust_cc.cpp:444\r\n#31 0x00007ffff69d6e31 in cc::do_cc (task=0x626170) at ./src/rt/rust_cc.cpp:654\r\n#32 0x00007ffff69c84b8 in upcall_s_malloc (args=0x6551d0) at ./src/rt/rust_upcall.cpp:126\r\n#33 0x00007ffff69dc139 in __morestack () from /home/marijn/src/rust/x86_64-unknown-linux-gnu/stage1/bin/../lib/librustrt.so\r\n#34 0x00007ffff69c8878 in call_shim_on_c_stack (fn_ptr=0x7ffff69c8450, args=0x6551d0, this=<optimized out>) at ./src/rt/arch/x86_64/context.h:59\r\n#35 call_upcall_on_c_stack (fn_ptr=0x7ffff69c8450, args=0x6551d0) at ./src/rt/rust_upcall.cpp:52\r\n#36 upcall_malloc (td=<optimized out>) at ./src/rt/rust_upcall.cpp:144\r\n#37 0x00007ffff71be06b in syntax::parse::parser::mk_expr::_6c35a4f2e274aebe ()\r\n   from /home/marijn/src/rust/x86_64-unknown-linux-gnu/stage1/bin/../lib/librustc-4171d83aef249987-0.1.so\r\n#38 0x00007ffff71be9d2 in syntax::parse::parser::mk_pexpr::_f82e5d709d2cbe83 ()\r\n[more]\r\n```'
1732,'brson',"Rust functions that can be called from C\nWe have a lot of scenarios now where people creating bindings want to be able to provide a callback that a C function can call. The current solution is to write a native C function that uses some unspecified internal APIs to send a message back to Rust code. Ideally it involves writing no C code.\r\n\r\nHere is a minimal solution for creating functions in Rust that can be called from C code. The gist is: 1) we have yet another kind of function declaration, 2) this function cannot be called from Rust code, 3) it's value can be taken as an opaque unsafe pointer, 4) it bakes in the stack switching magic and adapts from the C ABI to the Rust ABI.\r\n\r\nDeclarations of C-to-Rust (crust) functions:\r\n\r\n```\r\ncrust fn callback(a: *whatever) {\r\n}\r\n```\r\n\r\nGetting an unsafe pointer to a C ABI function:\r\n\r\n```\r\nlet callbackptr: *u8 = callback;\r\n```\r\n\r\nWe could also define some type specifically for this purpose.\r\n\r\n## Compiler implementation:\r\n\r\nIt's mostly straightforward, but trans gets ugly. In trans we will need to do basically the opposite of what we do for native mod functions:\r\n\r\n* Generate a C ABI function using the declared signature\r\n* Generate a shim function that takes the C arguments in a struct\r\n* The C function stuffs the arguments into a struct\r\n* The C function calls upcall_call_shim_on_rust_stack with the struct of arguments and the address of the shim function\r\n* Generate a Rust ABI function using the declared signature\r\n* The shim function pulls the arguments out of the struct and calls the Rust function\r\n\r\n## Runtime implementation:\r\n\r\nThe runtime has to change in a few ways to make this happen:\r\n\r\n* A new upcall for switching back to the Rust stack\r\n* Tasks need to maintain a stack of Rust contexts and C contexts\r\n* Needs a strategy to deal with failure after reentering the Rust stack\r\n* Needs a strategy to deal with yielding after reentering the Rust stack\r\n\r\n### Failure:\r\n\r\nWe can't simply throw an exception after reentering the Rust stack because there's no guarantee the native code can be unwound with C++ exceptions. The Go language apparently will just skip over all the native frames in this scenario, leaking everything along the way. We, instead will abort - if the user want's to avoid catastrophic failure they should use their Rust callback to dispatch a message and immediately return.\r\n\r\n### Yielding:\r\n\r\nWithout changes to the way we handle C stacks we cannot allow Rust functions to context-switch to the scheduler after reentering the Rust stack from C code. I see two solutions:\r\n\r\n1) Yielding is different after reentering the Rust stack and simply blocks. Tasks that want to do this should make sure they have their own scheduler (#1721).\r\n2) Instead of running native code using the scheduler's stack, tasks will check out C stacks from a pool located in each scheduler. Each time a task reenters the C stack it will check if it already has one and reuse it, otherwise it will request a new one from the scheduler. This would allow Rust code to always yield normally without tying up the scheduler.\r\n\r\nI prefer the second option.\r\n\r\nSee also #1508"
1725,'brson',"Remove timer code from scheduler\nThe scheduler includes periodic timer wakeups that probably don't do anything useful now (were once for preemption). Let's give them the boot."
1721,'brson',"Implement scheduler domains\nLots of bindings want to be able to block in C code. The easiest way to make this happen is to reintroduce 'thread domains'. I suggested one way in #10."
1715,'brson',"Replace str::sbuf with *ctypes::c_char\nsbuf is mostly used for C interop. Interestingly, we define sbuf as `*u8` and usually talk about strings as arrays of `u8`, but C char is a signed value. It probably doesn't make any difference."
1686,'nikomatsakis','remove the :: after type names in "as" expressions\nCurrently, you must write `foo as bar::<X>` if the type you are casting to contains a type parameter.  I find this very unintuitive.  I think the rule "type names do not require ::, explicit function type parameters do" is easy enough to explain.  But the rule "`::` are needed in expressions, but only where it might cause ambiguity" is a bit more troublesome.\r\n\r\nI realize there is a kind of ambiguity (`foo as uint < 5`) but I am ok with having to write `(foo as uint) < 5` in this case.  I think this will come up less often than casting to parameterized interfaces.'
1681,'brson',"main()'s initial stack segment should be big\nIt's just a trick, but to counter #1527 we should make the main task have a big initial segment. This way casual microbenchmarks will not hit terrible stack-growth behavior."
1663,'brson','Allow attributes on enum variants\nDoc attributes will be much nicer if attached directly to the variants.'
1657,'brson','gettimeofday example in tutorial uses wrong structure def\nThis is the gettimeofday example from the tutorial, with the addition that it prints the result\r\n\r\n```\r\nuse std;\r\ntype timeval = {mutable tv_sec: u32,\r\n                mutable tv_usec: u32};\r\n\r\n#[nolink]\r\nnative mod libc {\r\n    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\r\n}\r\n\r\nfn unix_time() -> u64 unsafe {\r\n    let x = {mutable tv_sec: 0u32, mutable tv_usec: 0u32};\r\n    libc::gettimeofday(ptr::addr_of(x), ptr::null());\r\n    ret (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\r\n}\r\n\r\nfn main() {\r\n    std::io::println(#fmt("%u", unix_time()));\r\n}\r\n```\r\n\r\nIt crashes, because timeval is defined incorrectly and gettimeofday ends up overwriting other parts of the stack. On 64-bit linux I show both fields of timeval having 8 bytes.\r\n\r\nProbably we should add time_t and suseconds_t to core::ctypes'
1649,'nikomatsakis','iteration library and lightweight bind syntax\nI am working on a nicer iteration library.  This requires a lightweight bind syntax.  I am working on that too.  You can see current status and get a flavor from the cargo package "iter", though the eventual plan is to move that into libcore (or libstd?)\r\n\r\nThe bind extension is that the `bind` keyword will no longer be required.  So one can write `foo(a, b, _)` which means precisely the same thing as `bind foo(a, b, _)` used to, *except* that I plan to infer whether to use a boxed closure, stack closure, etc.  It will also work for receivers, like `_.foo(_)`.  The plan is to have the code path in the compiler be very similar to the one used for closures (`trans_bind`, for example, should go away completely).'
1645,'brson',"enum / tag alignment is always 1 right now\nRight now, we do not compute the correct alignment for enum types.  Effectively we treat them as `[u8]` at all times.  This causes a variety of problems. Mostly it causes poor interaction with shape code and C code, which assumes that we do alignment correctly.  I think there is probably an issue for this but I haven't found one that specifically describes it.  \r\n\r\nSome symptoms:\r\n\r\n- #1535: Replacing a type like `int` with `enum foo { foo(int) }` is not equivalent.  It will cause shape code to misbehave when doing comparisons and the like because shape code will try to align to a word boundary, but the data will be stored with no alignment at all.  (For example, I tried to replace `ty::t` with such a type)\r\n\r\n- Converting tag discriminants from int to i32 does not work because the payloads are no longer properly aligned on 64-bit targets.  Basically, it works now by accident because int is 64-bits and we don't have any payloads of greater than 8-byte alignment.\r\n\r\n"
1625,'brson',"#[no_core] should be an attribute\nMaybe it shouldn't even be a command line option"
1600,'brson','Remove std::extfmt\nThis module should have died long ago.'
1592,'brson',"Linker commands don't quote paths with spaces\nBasically, our windows installation doesn't work because of quoting issues. Yikes. Thanks kib2.\r\n\r\n```\r\nC:\\Users\\kib\\Desktop\\ZZZ\\Rust_Dev>rustc hello.rs\r\nerror: linking with gcc failed with code 1\r\nnote: gcc arguments: -LC:/Program Files (x86)/Rust/bin/rustc/i686-pc-mingw32/bin\r\n -m32 -o ./hello ./hello.o -LC:/Program Files (x86)/Rust/bin/rustc/i686-pc-mingw\r\n32/bin -lcore-14bd852465126fe7-0.1 -LC:/Program Files (x86)/Rust/bin/rustc/i686-\r\npc-mingw32/bin -lstd-79ca5fac56b63fde-0.1 -lm -lrustrt -lmorestack\r\nnote: gcc: erreur: Files: No such file or directory\r\ngcc: erreur: (x86)/Rust/bin/rustc/i686-pc-mingw32/bin: No such file or directory\r\n\r\ngcc: erreur: Files: No such file or directory\r\ngcc: erreur: (x86)/Rust/bin/rustc/i686-pc-mingw32/bin: No such file or directory\r\n\r\ngcc: erreur: Files: No such file or directory\r\ngcc: erreur: (x86)/Rust/bin/rustc/i686-pc-mingw32/bin: No such file or directory\r\n\r\n\r\nerror: aborting due to previous errors\r\n```"
1590,'brson','Run language ref examples\nThe tutorial is executable now. We can do the same to the lang ref. Right now they use slightly different dialects of markdown - need to bring them into alignment.'
1578,'brson','Add .elc to .gitignore\nCompiled elisp files.'
1577,'brson',"rust-mode doesn't know 'enum'\n"
1567,'nikomatsakis',"make interface types more like closures\nInterface types are really very similar conceptually and in practice to closures.  I think we should make them resemble closures more closely both in the language and implementation as follows:\r\n\r\n- Make interface instance two words: `(vtable, data)` (analogous to a closure's (fptr, data))\r\n- Model a vtable with one entry as a single function pointer\r\n- Use type bounds after the iface name to indicate how the data is stored (& vs @ vs ~)\r\n\r\nTherefore, for an iface `X`, the type:\r\n\r\n- `X` indicates any interface instance  Such a closure cannot be copied, just as `fn` cannot be copied\r\n- `X&`indicates an interface instance whose data is located on the stack.\r\n- `X@` indicates an interface instance whose data is boxed\r\n- `X~` indicates an interface instance whose data is sendable and stored via unique ptr\r\n\r\nAdvantages:\r\n\r\n- More analogous.\r\n- `X~` instances can be sent\r\n- `X&` instances are particularly cheap to construct\r\n- Closures are a special case of an interface instance (one with a single method), in the impl at least.\r\n\r\n"
1560,'brson','Make the test runner schedule tests more efficiently\nRight now the test runner maintains a queue of futures and waits for them in order. This easily results in situations where all threads but one are stalled. Now that we have unique closures it should be easy to restructure this so it works more efficiently.'
1552,'brson','Move libcore tests into core\nThis could be tricky since injecting the test runner introduces a dependency on std.'
1545,'brson',"Clean up and document rustc::front::attr\nThis is just a grab bag of functions for manipulating attributes. It's disorganized and inconsistent."
1533,'brson','Change rustc crate crate_type to "lib". Stop passing --lib\nThe main rustc crate is always used as a library now. To do this we probably want to fix #1444 as well so we don\'t have to pass --bin when testing.'
1508,'brson',"Allow C code to call into Rust code\nThere are probably a number of things needed to make this happen:\r\n\r\nScheduler:\r\n\r\n* Instead of reusing the scheduler's stack to call C code, we'll want each scheduler thread to hold a cache of big stacks, give each task a pointer to a C stack, a stack of C contexts and a stack of Rust contexts.\r\n* When calling into C code, if the task already has a C stack it reuses it, if not it checks whether the scheduler has any C stacks and pops one, or it allocates a new one, and pushes the Rust context onto the Rust context stack.\r\n* &c.\r\n* When it pops the last Rust context it returns the C stack to the scheduler's pool.\r\n\r\nLanguage:\r\n\r\n* Would be really nice to be able to create functions with appropriate native signatures such that they could be called directly\r\n\r\nExtensions:\r\n\r\n* Any glue that might be needed could be generated via a syntax extension.\r\n"
1506,'brson','Inner attributes not supported on all item types, including fn\nWhile `mod { #[attr]; }` works, `fn { #[attr]; }` does not. This style of attribute is very desirable for rustdoc.'
1498,'pcwalton','convert shape code to be visitor glue\nI would like to do away with the shape code and instead have the compiler generator "visitor glue", which is glue code that walks the data structure and invokes methods on a visitor.  The methods would be encoded as a struct of functions.  This could replace the logging, universal equality, and other functions of glue code.  If it\'s fast enough, we may be able to replace the take, drop, and free glue with visitor glue, but if not, we could at least tie the code generation together so that they are all driven from the same codebase.'
1496,'brson','Collect benchmark numbers for 0.1\nWe need to know how our numbers now compare to those from last summer and those from gcc.'
1493,'nikomatsakis','make boxes self-describing\nToday we have a map that maps from each box allocation to a type descriptor describing its payload.  This requires hashtable lookups on malloc/free and seems inefficient.  However, to do cycle collection or any form of GC, boxes DO need to be self-describing.  Therefore, I propose we layout a box like this:\r\n\r\n    struct box {\r\n        tydesc *desc;\r\n        int refcnt;\r\n        <payload>\r\n    }\r\n\r\nThis has a few advantages:\r\n\r\n- no more map lookups on alloc, free; also memory consumption is surely lower\r\n- the desc and refcnt are always at known offsets, regardless of the alignment of payload\r\n- we can unify the paths for opaque types like closures, objects, and ifaces.  They should also begin with a type descriptor.\r\n\r\nI think it would be best if the type descriptor describes the *entire* box (including the desc and refcnt fields). The reason is that this avoids the need to consider the alignment of payload when finding the offset of the data described by the type descriptor.'
1489,'brson','Add a mechanism to set the max stack size\nRight now we can recurse until memory runs out. There should probably be a way to control the maximum stack size, with some default value'
1486,'brson','Generate rustdoc output instead of naturaldocs in build\nThis requires getting the output from rustdoc to a credible enough state that we can stand looking at its output instead of naturaldocs, rewriting the existing naturaldocs comments to rustdoc attributes, and adding some makefile logic to do the deed.'
1481,'nikomatsakis','better error message when there is a missing semicolon with an expression\nSomething like:\r\n\r\n```\r\nfn foo() {\r\n    task::spawn {|| } //! ERROR type mismatch: expected \'()\' but got \'tast\'\r\n    bar();\r\n}\r\n\r\nfn bar() {\r\n}\r\n```\r\n\r\nwill yield an error something like the one above.  It would be better if it said, "statement with non-unit return type requires a semicolon" or something like that.  This would be easy-ish to fix: the ast has a type "stmt_expr" and "stmt_semi", and "stmt_expr" must have a unit type.  '
1479,'brson','Update spawn example in language doc\nThis is wrong: https://github.com/graydon/rust/blob/master/doc/rust.texi#L1534'
1478,'brson',"Don't log in the red zone\nIt requires too much stack"
1474,'nikomatsakis','Block style autodetection should take upvars into account\nThis is a slight variation on #1467:\r\n\r\n```\r\nfn main() {\r\n    let x = 3;\r\n    fn blah(_a: fn()) {}\r\n    blah({|| log(error, x); });\r\n}\r\n```\r\n\r\nCompiling that crashes when trans tries to resolve the upvar for `x` inside the block. I guess typeck should refuse to convert something that has upvars into a bare function. (Or, if we end up dumping bare functions, this would be moot too.)'
1469,'nikomatsakis','rebind-fn.rs crashes with RUST_CC_ZEAL=1\nsrc/test/run-pass/rebind-fn.rs crashes when run with RUST_CC_ZEAL=1.'
1466,'nikomatsakis',"RUST_CC_ZEAL crash: too much recursion in walk_uniq\n    fn main() {\r\n        let _x = @{a: @10, b: ~true};\r\n    }\r\n\r\nWhen run with RUST_CC_ZEAL=1, this program crashes. The crash looks like it's due to too much recursion in\r\n\r\n     shape::data<cc::irc, shape::ptr>::walk_uniq().\r\n\r\nIt's also suspicious that the cycle collector hits a stack guard rather than growing the stack, btw."
1451,'nikomatsakis','bare fn types in record unification produces unexpected errors\nIn the following source:\r\n\r\n```\r\ntype T = { mutable f: fn@() };\r\ntype S = { f: fn@() };\r\n\r\nfn fooS(t: S) {\r\n}\r\n\r\nfn fooT(t: T) {\r\n}\r\n\r\nfn bar() {\r\n}\r\n\r\nfn main() {\r\n    let x: fn@() = bar;\r\n    fooS({f: x});\r\n    fooS({f: bar});\r\n\r\n    let x: fn@() = bar;\r\n    fooT({mutable f: x});\r\n    fooT({mutable f: bar});\r\n}\r\n```\r\n\r\nthe last call to `fooT()` results in an error:\r\n\r\n```\r\n/Users/nmatsakis/tmp/foo.rs:20:9: 20:25 error: mismatched types: expected `T` but found `{f: mutable fn()}` (types differ)\r\n/Users/nmatsakis/tmp/foo.rs:20     fooT({mutable f: bar});\r\n```\r\n\r\nI believe this is because the field `f` is immutable and hence unified as invariant.  This is kind of surprising to the user, though. The "right" fix is probably a bit involved though.  If we were to get rid of bare function types, we\'d be able to handle this, but it requires an improvement to the type checker (bounded type variables, since you don\'t know the type to assign to the bare function till later).'
1447,'brson','Reorganize the directory structure of librustc and the driver\nThe driver is now just a small stub that calls librustc, but the source still lives under comp. These two things should be separated. I suggest moving librustc to src/librustc and driver.rs to src/rustc-driver.'
1435,'brson',"Stop defining NVALGRIND when valgrind isn't found\nI forget exactly why we started defining NVALGRIND, but using it creates a situation where you can build the runtime without the needed valgrind support (if configure doesn't find valgrind); then if you later try to valgrind rust code it will report bogus errors."
1430,'pcwalton','Separate tag variants by comma\n`tag x {a; b; c}` should look like `tag {a, b, c}` to make it closer to record syntax.'
1428,'pcwalton',"Rename tag to something else. Possibly 'enum'\n"
1413,'brson','Standard Library documentation output: missing record return type\nSee http://doc.rust-lang.org/doc/core/files/str-rs.html#str.char_range_at\r\n\r\n"char_range" is of type\r\n\r\n    fn char_range_at(s: str, i: uint) -> {ch: char, next: uint}\r\n\r\nbut the output only shows\r\n\r\n    fn char_range_at(s: str, i: uint) ->'
1412,'brson','Standard Library documentation: sort function names\nI think the list of functions e.g. on http://www.rust-lang.org/doc/core/files/str-rs.html would be much easier to browse, if the function names were sorted.\r\n\r\nIs this created by rustdoc?'
1410,'brson',"Set up FreeBSD bot\nFreeBSD support is almost here (#1409). We'll need a bot."
1405,'brson',"rustc: errors should not display runtime boilerplate logging\nWhenever I have a filename typo when running rustc, I always think I'm tripping over some compiler bug before I notice the `error: error opening ...` line at the top. Could rustc catch that the file doesn't exist earlier and cleanly exit instead?\r\n\r\n    % rustc does-not-exist.rs\r\n    error: error opening does-not-exist.rs\r\n    rust: upcall fail 'explicit failure', ../src/comp/syntax/parse/parser.rs:64\r\n    rust: domain main @0x10202d200 root task failed\r\n"
1391,'brson','make rustdoc handle imports and exports\nrustdoc should copy docs from imported symbols.   this would, for example, help float get docs from f32/f64.\r\n\r\nProbably this should wait/ties in with copying default docs from interfaces when typeclasses become available.'
1364,'brson',"Make the initial obstack size very small\nThis looks to be the reason at the moment that we can't scale up past ~10,000 tasks. Right now the size of each shadow stack segment is 500K. We probably need to start this as something very small and double it each segment, like the main stack."
1359,'brson','cargo: add $HOME/.cargo/lib to rustc default search path\nIf it exists, the cargo lib dir should be added to the rustc default linking path. Figure out what counts as most-useful $HOME on windows.'
1351,'brson','change map::new_*_hash to mk_*_hash\nIt seems that the prefix `mk_` is used more often than `make_`, so we should swap the function names before 0.1.'
1343,'brson',"Building with debugging causes test failures on i686-unknown-linux-gnu\nThis command:\r\n\r\n```\r\nmake check-stage1-T-i686-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-rfail DEBUG=1\r\n```\r\n\r\nResults in tests where the instruction pointer ends up in bizarre places or the stack is misaligned. I don't know if it's related to the recent addition of debug info or not."
1333,'brson','fix setenv and getenv (especially on os x)\nI digged a bit into setenv/getenv not always working on os x and found two issues:\r\n\r\n* Sadly the man page says:\r\n\r\n        Successive calls to setenv() or putenv() assigning a differently sized\r\n        value to the same name will result in a memory leak.  The FreeBSD seman-\r\n        tics for these functions (namely, that the contents of value are copied\r\n        and that old values remain accessible indefinitely) make this bug\r\n        unavoidable.  Future versions may eliminate one or both of these semantic\r\n        guarantees in order to fix the bug.\r\n\r\n     maybe this can be patched up either by an additional unsetenv call /or/\r\n     by setting a maximum buffer value when unset/size checking after having been set from rust.\r\n    \r\n\r\n* setenv/getenv are not safe for concurrent use (acording to IEEE Std 1003.1, 2004 Edition) and thus \r\n  should be wrapped by a task that  processes set/get commands and is started on demand /or/ protected \r\n  by a lock in the runtime.  opinions on the correct approach wanted.\r\n\r\n\r\n\r\n'
1332,'brson',"Add valgrind guard bytes to the end of the stack again\nI previously removed them thinking they had no practical effect, but I was wrong since the first few words of the stack are things that shouldn't be scribbled on."
1327,'brson',"Fix failing tests on windows\nThere's at least one test that fails on windows and isn't run by check-fast"
1325,'brson',"Rewrite upcall_new_stack/del_stack to follow the standard upcall convention\nThese upcalls are used by __morestack and have a different calling convention than other upcalls, but there's no reason that has to be the case."
1322,'brson','Return address at the bottom of stack should be 0\nWe have 0xdeadbeef as our final return address. The unwinder expects to see 0 here afaict.'
1310,'brson','Add caching to tag_variant\nThis function allocates tons of memory and the results are cacheable.'
1308,'brson','OS X generates warning about compact debug info for __morestack\nThis is probably not a problem, since the unwinder falls back to dwarf for frames without compact info, but we should figure out a way to suppress it at least. Note that there are other errors in this output.\r\n\r\n```\r\n(stdcore=843d93) rustcrypto $ ls\r\nREADME.md crypto.rc hash.rs manifest.json pkey.rs symm.rs\r\n(stdcore=843d93) rustcrypto $ rustc crypto.rc\r\nerror: linking with gcc failed with code 1\r\nnote: gcc arguments: -L/opt/rust/lib/rustc/x86_64-apple-darwin/lib -m64 -o ./libcrypto-aaf71ec8e141741d-0.1.dylib crypto.o -L/opt/rust/lib/rustc/x86_64-apple-darwin/lib -lcore-14bd852465126fe7-0.1 -lcrypto -dynamiclib -Wl,-install_name,@rpath/libcrypto-aaf71ec8e141741d-0.1.dylib -lrustrt -lmorestack -Wl,-rpath,@executable_path/../../lib/rustc/x86_64-apple-darwin/lib -Wl,-rpath,/opt/rust/lib/rustc/x86_64-apple-darwin/lib\r\nnote: ld: warning: could not create compact unwind for ___morestack: register saved more than once (might be shrink wrap)\r\nUndefined symbols for architecture x86_64:\r\n  "_EVP_PKEY_get0", referenced from:\r\n      _EVP_PKEY_get0__c_stack_shim in crypto.o\r\nld: symbol(s) not found for architecture x86_64\r\ncollect2: ld returned 1 exit status\r\n\r\nerror: aborting due to previous errors\r\nrust: upcall fail \'explicit failure\', ../src/comp/driver/session.rs:74\r\nrust: domain main @0x7fa6cb81ea00 root task failed\r\n```'
1298,'nikomatsakis','Add testing supports tests those need multiple compile commands\nFor example, I need to test the re-export issue (#1115). Steps are:\r\n\r\n* compile a crate as library, which re-exports a function.\r\n* call that re-exported function from another crate.\r\n* verify compile-pass or run-pass, etc.\r\n\r\nThis requires executing rustc twice, and we don\'t have this kind of support in the test framework now.\r\n\r\nI believe there are more places where combining rustc and shell commands is needed. Like verifying metadata dumped by "rustc --ls". Check rustc generated filenames.\r\n\r\nAnd add missing tests when the infrastructure is ready.'
1290,'brson',"'make all' only builds stage 1\nIt's not obvious from the makefile why this is"
1281,'nikomatsakis',"Clarify story on native functions\nRight now, native functions have a distinct type from normal functions but there is no way to write it!  The reason that the type is distinct used to be because the ABI for native functions was different.  This caused a lot of bugs (#1059, #1058, #1174, #1179) so I implemented wrappers.  I like the wrappers, it makes for very clean trans code.  However, I also think it would be great to be able to pass around native C function pointers.  \r\n\r\nBasically I think we ought to decide between one of two options:\r\n\r\n- keep the wrappers, merge native function types with normal functions\r\n- ditch the wrappers, make it so that native functions are limited, and create a syntax for native fn types\r\n\r\nIf we do the latter, we'd have to fix the problems listed in the prior bugs.  In some cases, like bind, we can just make it illegal.  Cross-crate calls though probably ought to work (or maybe not?)."
1276,'brson','Implement crate_type attribute\nTells the compiler that the default output type is either an executable or library.'
1275,'nikomatsakis','lambdas and blocks should both have optional type decls\nRight now, lambdas must declare types for their arguments and blocks must *not*.  But both are represented in more-or-less the same way and seem to go through a similar inference path in `typeck.rs`; I think we ought to make parameter types optional in both cases.  Naturally, if the lambda/block is not used in an argument position, or at least being assigned to a variable of known type, we will not be able to infer a type for the arguments and so an error would occur.'
1264,'brson','Mark a few bytes at the end of every stack VALGRIND_MAKE_MEM_NOACCESS\n'
1260,'brson','Give std::task::task_notification a shorter name\nI hate typing it.'
1254,'brson',"Merge stdtest with std\nTests for the standard library are part of their own crate, out of a vague notion that it would improve turnaround during development. I don't think it has really turned out to be true, and putting tests next to code is really the model we're promoting, so let's just merge the two.\r\n\r\nFixing #721 would be very useful here so we don't have to worry about exporting the tests."
1244,'brson','Test run-pass/send-iloop fails occasionally\nhttp://67.23.44.229/logs/2011/11/01/2011-12-01T18:42:26Z-0ed1dd1a-6518-4768-8f7b-96b0fc803d08.html'
1230,'nikomatsakis','linux/mac bots fail on 64-bit run-pass/bind-native-printf\nhttp://67.23.44.229/logs/2011/10/30/2011-11-30T19:28:06Z-b5dfb73e-bf33-45bf-bfd2-4da8cce1d4c3.html'
1225,'brson',"Build continually runs make on LLVM\nAfter doing work on LLVM, the build dependencies get confused and everytime Rust's make is run, it also runs make on LLVM, even when there's nothing to do.\r\n\r\nThis is probably because our rules for building LLVM are not very exact - we use llvm-config as our target, which is just a script so probably doesn't always get updated when building LLVM. Running touch on llvm-config would probably fix this."
1192,'nikomatsakis','Optimize native wrappers\nAs of @b6af844, we generate Rust wrappers for native functions.  These allow for easy interop with Rust code but introduce some performance inefficiencies.  This could be improved in two ways:\r\n\r\n1. Inline the calls to the wrapper functions.  Ideally, this would be done at the LLVM level as part of a general inlining pass, so as not to complicate trans.\r\n\r\n2. Specialize to the i386 architecture (and possibly other targets as well).  In i386 in particular, we could eliminate some copies by writing the function arguments directly into memory allocated using alloc_on_c_stack(), as we used to do originally.  This was removed because it does not apply to x86_64 nor does it work well for stdcall functions (layout on stack is different), whereas the current technique lets LLVM handle details of the target calling convention.  Nonetheless, if it is deemed worthwhile, we could specialize the case of cdecl functions on i386 (and stdcall, for that matter).'
1189,'brson',"Implement the task tree and task killing using messages\nRight now killing a task means setting a flag on it in the runtime and checking that flag before and after yielding. There is at least one race condition that could result in the task not being killed and never waking up.\r\n\r\nSeems like we should be able to maintain the relationships between tasks just using Rust messages. This is desirable because every bit of synchronization we eliminate from the runtime makes it easier to understand. There are some obstacles to being able to implement this though, primarily that we need to be able to select on multiple ports. Additionally, I don't really envision how reparenting would work."
1182,'brson','Two intrinsics call C functions on the Rust stack\nrust_intrinsic_recv and rust_intrinsic_task_sleep both call functions in rustrt, which means they are calling functions on the Rust stack without doing the stack check. rust_intrinsic_recv can be rewritten as a regular builtin, and rust_intrinsic_task_sleep needs to do everything inline.'
1159,'brson',"Configure libuv in the configure script\nRight now we're carrying pre-configured makefiles for libuv for every platform/arch combination. I think we have the ability now to do this as part of configure. We'll have to include gyp in our repo (or host a git mirror)."
1155,'brson',"Basic 'Hello World' Port/Channel example causes abort/memory leak\nI tried to run the example code from the top of lib/comm.rs (here, for your convenience: http://pastebin.com/kwhhMK3Z)\r\n\r\nOutput of rustc --version: \r\nrustc prerelease (06d14f3 2011-11-07 15:46:00 -0800)\r\nhost: i686-unknown-linux-gnu\r\n\r\nOS: Ubuntu 11.10, amd64\r\n\r\nError Message: \r\nrust: fatal, 'leaked memory in rust main loop (1 objects)' failed, ./src/rt/memory_region.cpp:131 1 objects\r\nAborted\r\n\r\nFWIW, I tried taking out the argv, that was not the cause. Its my first time using rust, so its possible I did something wrong, but I figured I'd be cautious and open a bug. "
1151,'brson',"Something about make perf is broken\nrustbot isn't showing the graphs and the linux bots show some errors. Probably happened during the LLVM changes."
1126,'brson','#[test] items are not being configured out in a non-test build\nThey probably should. They could refer to things configured with #[cfg(test)], and will cause resolve errors when those are configured out.'
1094,'brson','Simplify attribute parsing\nThere may be enough lookahead in the parser to simplify attribute parsing, which is quite intricate.'
1091,'brson','Document RUST_LOG\nPut it in both the FAQ and the language documentation'
1072,'brson',"Allow items at the crate top level and in 'directory' modules\nCurrently, nothing lives in the top level of std, and directory modules like rustc::syntax can't contain code. We want especially for the standard library to define things like std::option::t as std::option.\r\n\r\nThis is one way to achieve that goal.\r\n\r\nWe add a convention that a .rs file with the same name as a directory module provides that module's implementation, and a .rs file with the same name as a crate (or the .rc file) provides the crate-level module's implementation.\r\n\r\nSo for standard we might have a directory layout like:\r\n\r\n```\r\nlib/\r\n  coll.rs - the std::coll module's implementation\r\n  coll/\r\n    list.rs - the std::coll::list module\r\n  std.rc\r\n  std.rs the std module's implementation\r\n```\r\n\r\nWe would probably want a way to explicitly override this as well."
1070,'brson','Make LLVM a git submodule\nWe may soon end up carrying an LLVM patch for an indeterminate period of time. For this and other reasons, it would be nice to automate the LLVM build process.\r\n\r\nThis will require a lot of changes to our automation.'
1022,'brson','Implement bare functions\nPer https://github.com/graydon/rust/wiki/Function-types'
1019,'brson','dyld: Library not loaded: @rpath/libstd.dylib - when doing make check\n* rust git version: aff536ec0e2f12336c86810f1558d50416d25394\r\n* llvm svn version: 141079\r\n* rust configure tags: --disable-valgrind --disable-optimizations\r\n* OS: MacOS X Lion\r\n\r\nPreviously, compilation froze. With the latest version, I have the following trace:\r\n\r\n$ make check\r\ncfg: shell host triple i686-apple-darwin\r\ncfg: llvm host triple i686-apple-darwin\r\ncfg: llvm target triples \r\ncfg: unix-y environment\r\ncfg: using gcc\r\ncfg: disabling valgrind (CFG_DISABLE_VALGRIND)\r\ncfg: including dist rules\r\ncfg: including test rules\r\ncheck: formatting\r\ncompile_and_link: stage0/lib/rustc/i686-apple-darwin/lib/libstd.dylib\r\ndyld: Library not loaded: @rpath/libstd.dylib\r\n  Referenced from: /Users/david/Documents/Code/rust/build/stage0/bin/rustc\r\n  Reason: image not found\r\nmake: *** [stage0/lib/rustc/i686-apple-darwin/lib/libstd.dylib] Trace/BPT trap: 5\r\n\r\n\r\nI have also tried with a [make clean], the result is the same.'
1016,'brson','bump LLVM on rust-mac1 when it comes back online\nrust-mac1 has been offline for weeks now. when server ops reboots it we need to catch it up to the correct llvm revision'
1011,'brson',"Figure out what we're going to do instead of rpath on windows\nWhen we install rust on windows the files are arranged in such a way that rustc can't be run because the dll's aren't found. We need to either adjust the directory structure specifically for windows, make some sort of 'rust shell' batch file that sets up the environment and runs cmd.exe, extend the system path to the appropriate directory, something."
997,'brson',"Build directory structure doesn't support target executables\nOur current layout for a stage looks like\r\n\r\n```\r\nbin - host executables\r\nlib - host libraries\r\n    rustc\r\n        ${target} - target libraries\r\n```\r\n\r\nThis works for now because we don't actually cross-compile, but it also means that building host executables (rustc, fuzzer) is done in a different way than target libraries (they build across stages, with stageN building into stageN+1).\r\n\r\nI propose that our layout should look like\r\n\r\n```\r\nbin - host executables\r\nlib - host libraries\r\n    rustc\r\n        ${target}\r\n            bin - target executables\r\n            lib - target libraries\r\n```\r\n\r\nWe always build into stageN target directories using the stageN host compiler, then promote the stageN+1 host compiler from the  appropriate stageN target directory.\r\n\r\nThis is the exact directory structure that would then be installed to /usr"
988,'brson',"Move compiletest from test/ to src/\ncompiletest is not a test, it's a test runner"
985,'brson','Implicit copy of pinned kind runs destructor twice\n```\r\nresource r(i: @mutable int) {\r\n    *i = *i + 1;\r\n}\r\n\r\nfn movearg(i: r) {\r\n    // Implicit copy to mutate reference i\r\n    let j <- i;\r\n}\r\n\r\nfn main() {\r\n    let i = @mutable 0;\r\n    {\r\n        let j <- r(i);\r\n        movearg(j);\r\n    }\r\n    log_err *i;\r\n    // nooooooo. destructor ran twice\r\n    assert *i == 2;\r\n}\r\n```'
969,'brson','invalid free with uniq-by-ref\n    fn f(&i: ~int) { i = ~2; }\r\n    fn main() { f(~1); }\r\n\r\nunique-fn-arg-mut_expr_8_12(66672,0xb060b000) malloc: *** error for object 0x1000000: pointer being freed was not allocated\r\n\r\n(Based on src/test/run-pass/unique-fn-arg-mut.rs. The important change is not assigning ~1 to a local before passing it to f.)'
968,'brson',"'Predicate type_is_unique_box(bcx, uniq_ty) failed'\n    fn main() { ~fail; }\r\n\r\nupcall fail 'Predicate type_is_unique_box(bcx, uniq_ty) failed', ../src/comp/middle/trans_uniq.rs:35"
963,'brson',"Incorrect kind checking for local initializer\n```\r\nfn f<T>(t: T) { let _t1 = t; }\r\n```\r\n\r\n_t1 is a pinned kind so can't be copied from t. As a comparison, the following generates the correct kind error:\r\n\r\n```\r\nfn f<T>(t: T) { let _t1; _t1 = t; }\r\n```"
962,'brson',"generic function mishandles unique pointer\n(Based on test/run-pass/generic-drop-glue.rs)\r\n\r\n    fn f<T>(t: T) { let _t1 = t; }\r\n    fn main() { let x = ~1; f(x); }\r\n\r\nCompiles to a program that double-frees (and leaks?):\r\n\r\n    g(10978,0xb0101000) malloc: *** error for object 0x1000000: pointer being freed was not allocated\r\n    *** set a breakpoint in malloc_error_break to debug\r\n    rt: fatal, 'live_allocs < 1' failed, ../src/rt/memory_region.cpp:43 "
961,'brson','maybe_auto_unbox hang with uniq\n    fn altsimple() { alt ~true { _ { } } }\r\n    fn main() { }\r\n\r\nHangs in the alias pass:\r\n\r\n    #0  upcall_malloc (task=0x1c00df0, nbytes=16, td=0x0) at ../src/rt/rust_upcall.cpp:57\r\n    #1  0x002c5563 in middle::mut::expr_root::maybe_auto_unbox ()\r\n    #2  0x002c8d16 in middle::mut::expr_root ()\r\n    #3  0x002e4124 in middle::alias::expr_root ()\r\n    #4  0x002db386 in middle::alias::check_alt ()\r\n    #5  0x002cf984 in middle::alias::visit_expr ()\r\n    #6  0x005e2ce3 in middle::alias::check_crate::thunk3652 ()\r\n    #7  0x002d0be0 in middle::alias::visit_block ()\r\n    #8  0x005e2a43 in middle::alias::check_crate::thunk3647 ()\r\n    #9  0x002cf38e in middle::alias::visit_fn ()\r\n    #10 0x005e2eb7 in middle::alias::check_crate::thunk3655 ()\r\n    #11 0x00391b00 in syntax::visit::visit_item ()\r\n    #12 0x00605ec2 in syntax::visit::default_visitor::thunk5307 ()\r\n    #13 0x0039160b in syntax::visit::visit_mod ()\r\n    #14 0x00605d0f in syntax::visit::default_visitor::thunk5304 ()\r\n    #15 0x00391332 in syntax::visit::visit_crate ()\r\n    #16 0x002ce21a in middle::alias::check_crate ()\r\n    #17 0x00643455 in driver::rustc::compile_input::thunk7996 ()\r\n    #18 0x0055a8a0 in driver::rustc::time ()\r\n    #19 0x00560402 in driver::rustc::compile_input ()\r\n    #20 0x005807b8 in driver::rustc::main ()\r\n    #21 0x0058230f in _rust_main ()\r\n    #22 0x0064852f in _rust_main_wrap ()\r\n    #23 0xdeadbeef in ?? ()\r\n\r\nI think the problem is that middle::mut::expr_root::maybe_auto_unbox doesn\'t update "t" in the ty::ty_uniq arm.'
952,'brson',"type_is_pod is missing an arm for ty_uniq\n    fn main() { [~100]; }\r\n\r\nupcall fail 'non-exhaustive match failure', ../src/comp/middle/ty.rs:1210"
945,'brson','double free on unwind\n    // error-pattern:non-exhaustive match failure\r\n    fn test_box() { @100; }\r\n    fn test_str() {\r\n        let res = alt false { true { "happy" } };\r\n        assert res == "happy";\r\n    }\r\n    fn main() { test_box(); test_str(); }\r\n\r\nAbout 80% of the time:\r\n\r\n    Assertion failed: (alloc->magic == MAGIC), function free, file ../src/rt/memory_region.cpp, line 41.\r\n\r\nor\r\n\r\n    malloc: ... pointer being freed was not allocated'
939,'brson',"Move-mode arguments are not unwound correctly\n```\r\nfn f(-a: @int) {\r\n    fail;\r\n}\r\n\r\nfn main() {\r\n    let a = @0;\r\n    f(a);\r\n}\r\n```\r\n\r\na is double-freed because the cleanup revocations don't take effect until after the function is called"
938,'brson','compiletest needs to check error code for compile-fail tests\nLike run-fail tests, we need to make sure the compiler not only fails, but fails correctly. Currently the following tests all fail by segfaulting:\r\n\r\n```\r\n    [compile-fail] ../src/test/compile-fail/break-outside-loop.rs\r\n    [compile-fail] ../src/test/compile-fail/dup-link-name.rs\r\n    [compile-fail] ../src/test/compile-fail/ext-nonexistent.rs\r\n    [compile-fail] ../src/test/compile-fail/extenv-no-args.rs\r\n    [compile-fail] ../src/test/compile-fail/extenv-not-string-literal.rs\r\n    [compile-fail] ../src/test/compile-fail/extenv-too-many-args.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-missing-type.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-no-args.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-non-literal.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-non-literal2.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-not-enough-args.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-too-many-args.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-unknown-type.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-unsigned-plus.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-unsigned-space.rs\r\n    [compile-fail] ../src/test/compile-fail/extfmt-unterminated-conv.rs\r\n    [compile-fail] ../src/test/compile-fail/macro-2.rs\r\n    [compile-fail] ../src/test/compile-fail/macro.rs\r\n```'
936,'brson','Compiler segfaults after printing error in some tests\nI observed this in `src/test/compile-fail/extft-non-literal.rs` and `src/test/compile-fail/extft-non-literal2.rs` , might be happening in others. This is probably an unwinding bug.\r\n\r\nWith some changes to our generated code (I was working on making calls simpler), it hangs instead of segfaulting when `extft-non-literal2.rs` fails.'
909,'brson','Make unwinding more efficient\nWe generate much more unwind code than is necessary, the full set of in-scope cleanups for every single function call. This could be more efficient by reusing landing pads and chaining scope unwind cleanup blocks together. Ideally we would have zero or one unwind block per scope.'
855,'brson','Interior strings\nWe should have interior strings so that we can send strings over channels with a minimum of fuss. Most of the infrastructure for interior vectors can be reused.'
840,'brson',"Pretty-printer can't disambiguate alts followed by ( from function calls\nFrom std::lib::task:\r\n\r\n```\r\n    alt notify {\r\n      some(c) {\r\n        (**task_ptr).notify_enabled = 1u8;\r\n        (**task_ptr).notify_chan = *c;\r\n      }\r\n      none {}\r\n    };\r\n    (*regs).esp = align_down((*regs).esp - 12u32) - 4u32;\r\n```\r\n\r\nWithout the trailing semi, the parens are interpreted as a function call. The pretty-printer can't figure out to put the semi there (it does know how to disambiguate alts followed by unops)."
836,'pcwalton','Build is broken when optimization is turned off\nWhile building stage1/lib/libstd.so:\r\n\r\n```\r\nrustc: /home/marijn/prog/llvm/include/llvm/Support/Casting.h:194: typename llvm::cast_retty<To, From>::ret_type llvm::cast(const Y&) [with X = llvm::FrameIndexSDNode, Y = llvm::SDNode*, typename llvm::cast_retty<To, From>::ret_type = llvm::FrameIndexSDNode*]: Assertion `isa<X>(Val) && "cast<Ty>() argument of incompatible type!"\' failed.\r\nStack dump:\r\n0.\tRunning pass \'Function Pass Manager\' on module \'rust_out\'.\r\n1.\tRunning pass \'X86 DAG->DAG Instruction Selection\' on function \'@_ZN3int6to_strE\'\r\nAborted\r\nmake: *** [stage1/lib/libstd.so] Error 134\r\nmake: Target `all\' not remade because of errors.\r\nmake: Leaving directory `/home/marijn/src/rust\'\r\n```\r\n'
817,'brson','Allow multiple imports and exports per statement\nFor example, allow something like "export foo, bar, baz;" and "import foo, bar, baz from quux;"\r\nI don\'t really care about the syntax.'
799,'brson',"Combine xfail-stage1/2/3 into just 'xfail'\nxfail-stage0 is no longer used, and in practice xfail-stage1, 2, and 3 are always used together"
789,'brson','Add pretty-printer tests to the test suite\n'
763,'brson','Channels leak when sent over channels\nMinimal-ish test case:\r\nhttps://gist.github.com/1110969\r\n\r\nIf I reduce it further, it seems to either not reproduce or it will deadlock or it will crash. Hopefully all the same cause!'
755,'brson','Compile tests need to capture stderr\nLLVM reports on stderr and right now those errors seem to be disappearing.'
752,'brson',"Bring the runtime tests up to date and start running them\nThe tests in src/rt/test are compiled but never run. It's almost certain that they are completely broken. Right now all they are accomplishing is making it difficult to change parts of the runtime.\r\n\r\nReplace it with a standard C++ unit testing framework and start running the tests."
741,'brson','Compile tests race on environment variables when run in parallel\nThis sucks. Running "RUST_THREADS=16 make check" will occasionally cause run-pass, etc. tests to fail because they received the wrong LD_LIBRARY_PATH variable.'
739,'brson','Automatically determine the number of CPU Cores\nInstead of getting parallelism via `RUST_THREADS`, we should, by default, find the number of CPU cores and use that. We should keep `RUST_THREADS` around though, in case we want to run sequentially in some cases.\r\n\r\nThis discussion seems to list how to do it on each of the platforms we support: http://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine'
736,'brson',"Investigate running tests under helgrind\nI don't know much about this tool, but it might be useful for exercising our task system."
735,'brson','run-pass/compile-fail, etc test runners no longer obey CFG_RUSTC_FLAGS\n'
734,'brson','Test runner should run tests in parallel\n'
732,'brson','Test suite picks up too many files.\nI had a `.#` file left over in my test directory from an old test I was working on in Emacs. When I did make check, I got an "error opening" error, instead of just ignoring this file and having the tests succeed. '
721,'brson','Test runner needs to be able to run unexported tests\nCurrently, tests have to be visible at the top level of the crate to be run, observing the normal rules for item visibility. In Rust we can have layers and layers of unexported modules - modules that still need to be tested. There are a few ways to allow these to be tested:\r\n\r\n* With reexporting we could require the user to bubble up their tests to the top level\r\n* With reexporting we could possibly have the test runner fold generate exports to do the same\r\n* We could cheat, which is what I want to do\r\n\r\nThe test runner generates a method that looks like this\r\n\r\n```\r\n__tests() -> test_desc[] {\r\n   ... build a vector of test functions ...\r\n}\r\n```\r\n\r\nI want to add a secret attribute to __tests, `#[__resolve_unexported]`, that tells the resolve pass to follow paths regardless of whether the item is exported, allowing this one function to look into the bowels of the crate.\r\n\r\nTo prevent abuse we could even give the attribute an unparsable ident, like `#[!resolve_unexported]`\r\n'
714,'brson',"Test run-pass/lib-run does not work on windows\nI'm going to disable it on win32 because it keeps burning the tinderbox. Figure out what the deal is."
712,'brson','Invalid memory access in fs::list_dir\nUnder valgrind `fs::list_dir(".")` says\r\n\r\n```\r\n==16608== Invalid read of size 4\r\n==16608==    at 0x495C205: os_fs::list_dir (in /home/banderson/Dev/rust/build/stage1/lib/libstd.so)\r\n==16608==    by 0x495F038: fs::list_dir (in /home/banderson/Dev/rust/build/stage1/lib/libstd.so)\r\n==16608==    by 0x8049503: test_list_dir (in /home/banderson/Dev/rust/build/test/run-pass/lib-fs.stage1)\r\n==16608==    by 0x80495AB: _rust_main (in /home/banderson/Dev/rust/build/test/run-pass/lib-fs.stage1)\r\n==16608==    by 0x8049ACB: _rust_main_wrap (in /home/banderson/Dev/rust/build/test/run-pass/lib-fs.stage1)\r\n==16608==    by 0xDEADBEEE: ???\r\n==16608==  Address 0x72180b0 is 0 bytes after a block of size 16 alloc\'d\r\n==16608==    at 0x48DD876: malloc (vg_replace_malloc.c:236)\r\n==16608==    by 0x48FDFDC: rust_srv::malloc(unsigned int) (rust_srv.cpp:17)\r\n==16608==    by 0x49010B9: memory_region::malloc(unsigned int) (memory_region.cpp:97)\r\n==16608==    by 0x48F6338: rust_task::malloc(unsigned int, type_desc*) (rust_task.cpp:338)\r\n==16608==    by 0x48F3221: rust_list_files_ivec (rust_builtin.cpp:612)\r\n==16608==    by 0x4923BE6: _ZN5os_fs6rustrtE73 (in /home/banderson/Dev/rust/build/stage1/lib/libstd.so)\r\n==16608==    by 0x495BBFE: os_fs::list_dir (in /home/banderson/Dev/rust/build/stage1/lib/libstd.so)\r\n==16608==    by 0x495F038: fs::list_dir (in /home/banderson/Dev/rust/build/stage1/lib/libstd.so)\r\n==16608==    by 0x8049503: test_list_dir (in /home/banderson/Dev/rust/build/test/run-pass/lib-fs.stage1)\r\n==16608==    by 0x80495AB: _rust_main (in /home/banderson/Dev/rust/build/test/run-pass/lib-fs.stage1)\r\n==16608==    by 0x8049ACB: _rust_main_wrap (in /home/banderson/Dev/rust/build/test/run-pass/lib-fs.stage1)\r\n==16608==    by 0xDEADBEEE: ???\r\n```\r\n'
698,'pcwalton','Double-free of ivecs when sending across channel\nFinally found a minimal-ish testcase! This is blocking me from getting reading working for my async-io work\r\n\r\nhttps://gist.github.com/1083866'
680,'brson',"Type of function tail expressions not inferred correctly\nThis doesn't typecheck:\r\n\r\n```\r\nfn f() -> int[] {\r\n  ~[]\r\n}\r\n```\r\n\r\nThis does:\r\n\r\n```\r\nfn f() -> int[] {\r\n  ret ~[];\r\n}\r\n```"
678,'brson','Move semantics for cross-task operations\nChannel operations (mainly sending) should have move semantics and only be allowed for unique things.\r\n\r\nThis also applies to arguments to spawned functions, and probably the spawned function itself.'
646,'brson','Race condition in port shutdown\nNow that ports have a lock, there is a race condition in the shutdown process. One task may call the port destructor while another task is still holding the lock.'
640,'pcwalton','Type-parameterized \'vec_omit\' produces incorrect result\nThe function\r\n\r\n    fn vec_omit_T[T] (&T  [] v, uint i) -> T[]   { slice(v, 0u, i) + slice(v, i+1u, len(v)) }\r\n\r\nproduces an array with bogus values in it.  In contrast, an int-specialized function produces correct results.\r\n\r\n    use std;\r\n    import std::ivec;\r\n    import std::ivec::slice;\r\n    import std::ivec::len;\r\n    import std::int;\r\n    \r\n    fn vec_omit      (&int[] v, uint i) -> int[] { slice(v, 0u, i) + slice(v, i+1u, len(v)) }\r\n    fn vec_omit_T[T] (&T  [] v, uint i) -> T[]   { slice(v, 0u, i) + slice(v, i+1u, len(v)) }\r\n    \r\n    fn vec_to_str(&int[] v) -> str {\r\n        auto i = 0u;\r\n        auto s = "[";\r\n        while (i < len(v)) {\r\n            s += int::str(v.(i));\r\n            if (i + 1u < len(v)) {\r\n                s += ", "\r\n            }\r\n            i += 1u;\r\n        }\r\n        ret s + "]";\r\n    }\r\n    \r\n    fn main() {\r\n        auto a = ~[1, 2, 3, 4, 5];\r\n        log_err vec_to_str(a);\r\n    \r\n        auto b = vec_omit(a, 2u);\r\n        log_err vec_to_str(b);\r\n    \r\n        auto c = vec_omit_T(a, 2u);\r\n        log_err vec_to_str(c);\r\n    }\r\n\r\nThe last line of output should be \'[1, 2, 4, 5]\' but is something like \'[262145, 327680, 1, 6291707]\'.'
632,'brson',"Transitive dependencies between crates don't work in the metadata reader\nReduced test case (thanks, jruderman):\r\n\r\n    use rustc;\r\n    import driver = rustc::driver:rustc;\r\n    fn main() {\r\n        driver::parse_input;\r\n    }"
621,'brson','"cannot determine a type for this expression" should be non-fatal\nGenerally, when we can\'t determine a type for an expression due to `structure_of` failing, we\'re kinda stuck when it comes to typechecking that function, but we can back out and typecheck the other functions.'
619,'pcwalton',"Passing a type parameter to a tag constructor that doesn't expect one isn't checked\nInstead, you get an index out of bounds error in typeck. This should probably be checked and properly reported. (I didn't check with non-tag-constructor functions, the same problem probably exists there)"
614,'brson',"Add warnings and errors when the crate 'link' attribute looks malformed\nThe link attribute has special meaning on crates, and certain rules should be enforced like:\r\n\r\n* Warn if there is no 'name' or 'vers' item for shared libraries\r\n* Error if there are two items with the same identifier\r\n\r\nSome of this used to exist until I lost it."
611,'brson','Support all literal types in ast::meta_item\nRight now they only hold strings, and thus attributes only support strings.'
610,'brson','Conditional compilation for native items\nPending completion of #609, native items should support conditional compilation with the #[cfg(...)] attribute.'
609,'brson','Attributes for native items\nAttributes can be applied to native modules but not the items in those modules. For completeness, this seems like it should be allowed.'
607,'nikomatsakis',"Allow crate link attributes to contain nested meta items\nIt's currently impossible to define a link attribute that has nested meta items, `#[link(foo(bar))];`, even though this is a valid way to write an attribute. There are unfinished branches in two methods, link::build_link_meta (that prevents translation), and attr::eq (that prevents the attribute from being matched in a use statement), that need to be filled in.\r\n\r\nUnfortunately it's not possible to formulate a test case for this within the current test framework, so instead of writing potentially broken code, I've just made these scenarios fail."
604,'brson',"Remove much of the crate file evaluation infrastructure\nHaving a mini scripting language inside the parser is rather undesirable, and some of it's use case will be replaced with the new conditional compilation attributes. Try to remove much of the front::eval code for parsing crate files.\r\n\r\nGraydon suggests that leaving const definitions and variable substitutions is 'probably harmless'."
585,'brson','Replace common::new_seq_hash with std::smallintmap\nThese do the same thing'
581,'pcwalton',"Current LLVM trunk incompatible with librustrt.\nOn 32-bit Linux and LLVM trunk revision 133904 (tip at the time of filing), rustc fails to build (in particular, librustrt fails to link) `rustllvm/MachOObjectFile.o`.  This appears to be due to a change in the interface of LLVM's `ObjectFile` probably introduced by revisions 133868 through 133872.\r\n\r\nLLVM revision 133867 works just fine.\r\n\r\nSome sample errors include:\r\n\r\n```\r\n/usr/local/include/llvm/Object/ObjectFile.h:131:22: error: ‘virtual llvm::error_code llvm::object::ObjectFile::getSymbolNext(llvm::object::DataRefImpl, llvm::object::SymbolRef&) const’ was hidden\r\n../src/rustllvm/MachOObjectFile.cpp:49:21: error:   by ‘virtual llvm::object::SymbolRef llvm::MachOObjectFile::getSymbolNext(llvm::object::DataRefImpl) const’\r\n```\r\n```\r\n../src/rustllvm/MachOObjectFile.cpp: In constructor ‘llvm::MachOObjectFile::MachOObjectFile(llvm::MemoryBuffer*, llvm::object::MachOObject*)’:\r\n../src/rustllvm/MachOObjectFile.cpp:37:65: error: no matching function for call to ‘llvm::object::ObjectFile::ObjectFile(llvm::MemoryBuffer*&)’\r\n/usr/local/include/llvm/Object/ObjectFile.h:116:3: note: candidates are: llvm::object::ObjectFile::ObjectFile(unsigned int, llvm::MemoryBuffer*, llvm::error_code&)\r\n/usr/local/include/llvm/Object/ObjectFile.h:113:3: note:                 llvm::object::ObjectFile::ObjectFile(const llvm::object::ObjectFile&)\r\n/usr/local/include/llvm/Object/ObjectFile.h:112:3: note:                 llvm::object::ObjectFile::ObjectFile()\r\n```\r\n\r\nand\r\n\r\n```\r\n../src/rustllvm/MachOObjectFile.cpp: In static member function ‘static llvm::object::ObjectFile* llvm::object::ObjectFile::createMachOObjectFile(llvm::MemoryBuffer*)’:\r\n../src/rustllvm/MachOObjectFile.cpp:79:46: error: cannot allocate an object of abstract type ‘llvm::MachOObjectFile’\r\n../src/rustllvm/MachOObjectFile.cpp:32:43: note:   because the following virtual functions are pure within ‘llvm::MachOObjectFile’:\r\n/usr/local/include/llvm/Object/ObjectFile.h:131:22: note: \tvirtual llvm::error_code llvm::object::ObjectFile::getSymbolNext(llvm::object::DataRefImpl, llvm::object::SymbolRef&) const\r\n```"
578,'brson','rustc happily compiles non-boolean branch expressions which assert at runtime\nauto a = 0u;\r\nif (a) {\r\n  fail\r\n}\r\n\r\nThis should be caught at compile time.'
568,'brson',"Typechecking doesn't enforce communication immutability requirements\nIt looks like we'll still attempt to compile attempts to send mutable data on channels or in spawn arguments. This should be disallowed."
565,'brson','Add ternary operator\n'
533,'pcwalton','Convert rustc over to interior vectors and remove exterior vectors\nWe should convert rustc over to interior vectors and remove exterior vectors.'
532,'brson','Assert failure with 1-argument #fmt call\n`#fmt("test")` results in "upcall fail \'Assertion start <= end failed"\r\n'
529,'brson','Make rustc installable with `make install`\nThis depends on issue #528. `make install` should do the right thing.'
528,'brson','Bake in default sysroots appropriately\nWe should bake in a default sysroot into the binary where rustc looks for all of its stuff (stdlib, glue, etc).'
526,'pcwalton',"native types should not all be the same type\nCurrently all types declared as 'native' wind up as the same type in the type checker. This is wrong. They should be considered nominal types."
519,'brson',"Tagged union typechecking regression\nCheckout 612f447e698ad127f57af1900e82923b8f5fee9b in my fork and try to build. I see the following error:\r\n../src/lib/aio.rs:50:8:50:17: error: mismatched types: expected port[iorequest] but found port[iorequest] (types differ)\r\n\r\nThis used to work a few days ago but I've lost track of which working version I was on. "
518,'brson','Change "mutable?" to something else ("const"?) and fix covariance/invariance\nAIUI the general consensus was that we should implement a mutable "slot" type. This is basically equivalent to an interior record with one mutable field. This allows us to remove the `mutable?` botch.'
513,'brson',"Typechecking if apparently doesn't require a boolean.\nI accidentally wrote `if(path_is_absolute)` instead of `if(path_is_absolute(p))` and got an LLVM assertion error instead of a rust type error. This doesn't seem right to me."
500,'brson','Binary operations are not type checked\nThis fails in trans:\r\n\r\n```\r\nfn main() {\r\n  auto x = true;\r\n  auto y = 1;\r\n  auto z = x + y;\r\n}\r\n```'
489,'brson',"More robust support for conditional compilation\nUse item attributes to support conditional compilation. Items marked with a certain attribute, e.g. ```#[cfg(test)]``` will only be translated when rustc is passed a flag for the 'test' configuration.\r\n\r\nRemove the target_os hack (as used in std.rc)"
487,'brson','Extend metadata to items, not just crates\nCrates support attributes through the ```meta``` statement. To support conditional compilation, among other things, we want to allow attributes on all items.\r\n\r\nInstead of using the meta statement, attributes will be applied using syntaxes like the following\r\n\r\n```\r\n#[foo]\r\nmod bar { }\r\n```\r\n\r\n```\r\n#[foo(10)]\r\nmod bar { }\r\n```\r\n\r\n```\r\n#[foo = "bar"]\r\nmod baz { }\r\n```\r\n\r\nMaybe even something like\r\n\r\n```\r\n#[foo = "bar", baz]\r\nmod qux { }\r\n```\r\n\r\nTo support applying attributes to crates, attributes can be applied to their containing item by following them with a semicolon:\r\n\r\n```\r\nmod foo {\r\n  #[bar];\r\n}\r\n```'
478,'brson','Make all of our GEPs InBoundsGEPs\nAll of our GEP instructions are really InBoundsGEPs. Using InBoundsGEPs makes it more likely for SROA to succeed. LLVM often mops up, but this takes some of the pressure off it.'
474,'brson',"make target-run compiled artifacts per-arch\nonce in sysroot, librustrt.so should be built as stageN/lib/$arch/librustrt.so and recompiled for every target in the targets list for the current compiler. rustc and librustllvm should probably only be compiled for every host in the host list. Or, if we're lucky, we only have one host."
466,'pcwalton','Experiment with moving the task pointer to thread local storage\nWe currently thread the task pointer through all Rust functions, which increases register pressure and makes calls slightly more expensive. It may well be cheaper to put it in thread-local storage. We should experiment with this.'
461,'nikomatsakis','Port to x64 at least, not just x86.\nHopefully we can get to a point where we only need a ucontext impl to port to a new platform. Still not quite at this stage yet.'
441,'brson',"rpath binaries so no LD_LIBRARY_PATH is needed\nuse of rpath and $ORIGIN when linking, and we won't need LD_LIBRARY_PATH settings at all. implement this."
428,'brson','unit test machinery\nWe want the language to ship with an integrated unit-testing system of sorts. Nothing too fancy, just a "no excuses" sort of entrypoint *in* the language plus some driver logic to collect tests and make a binary that shells out to a runner with a stock interface.\r\n\r\nPossibly copy D with its "test { ... }" blocks or such.'
412,'nikomatsakis',"inline keyword and llvm section for exported inline bitcode\nAdd an inline keyword for items and insert their definitions as llvm bitcode in a section of the output file -- if this is even possible; otherwise I guess pickled ASTs? -- such that the user of a crate can pull copies of the definition in entirely, not just reference via extern linkage.\r\n\r\nNaturally this will make upgrading the inlined code impossible, but that's a tradeoff we should extend the option of to users."
409,'brson',"Unique boxes\nAdd a ~ box type (steal unary-bitwise-not, it's rare enough to live in a library or use ! as a synonym or something).\r\n\r\nThis will live in the tree kind, not permit shallow copies, only deep copies and move semantics."
407,'pcwalton',"Lots of things are passing typechecking that shouldn't\nSee https://gist.github.com/992122\r\n\r\n#fmt doesn't seem to mind being passed more arguments than the format string expects (although this may be by design).\r\n\r\nI'm passing both TypeRefs and ValueRefs to ty_str, which is declared to take a TypeRef. The ValueRef cases should not be passing..."
372,'brson',"implicit block values as function bodies don't actually get returned\n    fn f() -> int { auto x = { 3 }; x }\r\n    \r\n    fn main() -> int { \r\n    \r\n      log_err f();\r\n      ret 1; \r\n    }\r\n\r\nThis prints 0, instead of 3 (though it's probably a garbage value).\r\n\r\n(the wacky definition of ```f``` is  because of a parser problem)"
236,'brson',"add fail-unwind machinery to rustc\ncode coming out of rustc can't fail-and-unwind properly. it needs to learn how to."
235,'pcwalton','implement gc in rustc\nrustc lacks a majority of the machinery required for mark/sweep gc on the kind of cyclic values. implement it.'
32,'brson',"implement stack growth check\nStack growth using segmented stacks needs implementation. There's a GSoC student working on the LLVM side of it. We need to make sure our runtime provides the necessary parts as well and get this working on our tasks. Not sure what the scope of work for us is."
19248,'aturon','DSTify Str + impl Str for &S where S: Str\nJust like we do with AsSlice\r\n\r\nThis comes in handy when dealing with iterator-centric APIs (`IntoIterator`!) and you want to receive an `Iterator<S> where S: Str` argument. Without this PR, e.g. you can\'t receive `&["a", "b"].iter()` instead you\'ll have to type `&["a", "b"].iter().map(|&x| x)` (A similar thing happens with `&[String]`).\r\n\r\nr? @aturon \r\n\r\nFull disclaimer: I haven\'t run `make`/`make check` yet (All my cores are busy)'
19236,'alexcrichton',"Implement into_iter() for BinaryHeap.\nWhilst browsing the source for BinaryHeap, I saw a FIXME for implementing into_iter.  I think, since the BinaryHeap is represented internally using just a Vec, just calling into_iter() on the BinaryHeap's data should be sufficient to do what we want here.  If this actually isn't the right approach (e.g., I should write a struct MoveItems and appropriate implementation for BinaryHeap instead), let me know and I'll happily rework this.\r\n\r\nBoth of the tests that I have added pass.  This is my first contribution to Rust, so please let me know any ways I can improve this PR!"
19232,'alexcrichton','Fix typo in Result documentation\n'
19231,'huonw','add MoveItems to RingBuf, fixes  #19085\nr? @huonw @csherratt'
19227,'huonw','Use mktemp for temporary download directory\nUsing the current directory may not always be appropriate, for example in\r\nthe case where it will unnecessarily trigger a backup to be made.\r\n\r\nThe only risk with this change is that systems might not have a mktemp.\r\nI am not aware of such a system, but have not tested on Windows. It is\r\nworking on a basic Ubuntu and OS X installation.'
19211,'aturon','libsyntax: Forbid type parameters in tuple indices\nThis breaks code like\r\n\r\n```\r\nlet t = (42i, 42i);\r\n... t.0::<int> ...;\r\n```\r\n\r\nChange this code to not contain an unused type parameter. For example:\r\n\r\n```\r\nlet t = (42i, 42i);\r\n... t.0 ...;\r\n```\r\n\r\nCloses https://github.com/rust-lang/rust/issues/19096\r\n\r\n[breaking-change]\r\n\r\nr? @aturon '
19210,'aturon','DSTify free functions in std::hash\nNow `std::hash::hash("abcd")` works.'
19205,'huonw',"args() doc: Fix a documentation line.\nCatch a missed triple-slash in the docs for `std::os::args()`. Passes `make check`. (I've also eyeballed the rest of `libstd` with the aid of some funky regexes and haven't found anything similar.)"
19184,'nikomatsakis','Fix std::fmt::Binary format char in docs\nThis small piece of documentation was missed in the format character change\r\nin 4af3494bb02e80badc978faa65e59625ade0c675.'
19176,'alexcrichton','libs: stabilize iter module\nThis is an initial pass at stabilizing the `iter` module. The module is\r\nfairly large, but is also pretty polished, so most of the stabilization\r\nleaves things as they are.\r\n\r\nSome changes:\r\n\r\n* Due to the new object safety rules, various traits needs to be split\r\n  into object-safe traits and extension traits. This includes `Iterator`\r\n  itself. While splitting up the traits adds some complexity, it will\r\n  also increase flexbility: once we have automatic impls of `Trait` for\r\n  trait objects over `Trait`, then things like the iterator adapters\r\n  will all work with trait objects.\r\n\r\n* Iterator adapters that use up the entire iterator now take it by\r\n  value, which makes the semantics more clear and helps catch bugs. Due\r\n  to the splitting of Iterator, this does not affect trait objects. If\r\n  the underlying iterator is still desired for some reason, `by_ref` can\r\n  be used. (Note: this change had no fallout in the Rust distro except\r\n  for the useless mut lint.)\r\n\r\n* In general, extension traits new and old are following an [in-progress\r\n  convention](rust-lang/rfcs#445). As such, they\r\n  are marked `unstable`.\r\n\r\n* As usual, anything involving closures is `unstable` pending unboxed\r\n  closures.\r\n\r\n* A few of the more esoteric/underdeveloped iterator forms (like\r\n  `RandomAccessIterator` and `MutableDoubleEndedIterator`, along with\r\n  various unfolds) are left experimental for now.\r\n\r\n* The `order` submodule is left `experimental` because it will hopefully\r\n  be replaced by generalized comparison traits.\r\n\r\n* "Leaf" iterators (like `Repeat` and `Counter`) are uniformly\r\n  constructed by free fns at the module level. That\'s because the types\r\n  are not otherwise of any significance (if we had `impl Trait`, you\r\n  wouldn\'t want to define a type at all).\r\n\r\nCloses #17701\r\n\r\nDue to renamings and splitting of traits, this is a:\r\n\r\n[breaking-change]'
19174,'alexcrichton','rustdoc: Support associated types\nRender associated types on traits and impls, and qualified paths in types.\r\n\r\nr? @alexcrichton '
19172,'steveklabnik','doc: adding example for implementations without traits\nAn example of how implementations work without traits would be handy'
19121,'nick29581','ICE when using a trait with an associated type as a trait object\n```\r\n#![feature(associated_types)]\r\n\r\ntrait Foo {\r\n    type A;\r\n}\r\n\r\nfn bar(x: &Foo) {}\r\n\r\npub fn main() {\r\n}\r\n```'
19065,'alexcrichton',"Add support for --bindir and remember the relative locations of bindir and libdir vs prefix (ie: sysroot)\nPotential downsides:\r\n - right now adds a build dependency on `realpath`, which I'm not sure everyone has, to determine relative directories. It's possible we could substitute something else if this matters.\r\n\r\nUpsides:\r\n - `--libdir` now avoids breaking things at runtime if it isn't in one of the expected locations\r\n - config diff between windows and everyone else is now confined to the configure script."
19043,'pnkfelix','Limit length of metadata decode debug output\nLimit the size of the raw metadata that gets printed when debug logging is enabled.'
19025,'nikomatsakis','Add Reader::skip_exact method\nThis implements the fix for #19022'
19023,'alexcrichton','implement Deref for Box.\nfixes #18624'
19021,'pcwalton','rust-mode.el: Tweak syntax table\n"_" should keep the default syntax class (symbol, not word). This\r\nallows, e.g., `forward-word\' to behave in the familiar way, jumping to\r\nunderscores within a function or variable name.'
19019,'pcwalton','creating convenience types for make_def, make_stmt, make_methods in MacResult\nI was experimenting writing a plugin and noticed that there were convenience types for a few of the methods in the `MacResult` trait but not for all of them.  So I added some for `make_stmt`, `make_methods`, and `make_def`.  For the last one, I noticed that essentially the same struct existed in macro_rules, so I removed it.'
19011,'nikomatsakis',"Search for implemented kinds recursively on Trait types. Fixes #15155 and #13155.\nIt looks like currently kinds required by traits are not propagated when they are wrapped in a TyTrait. Additionally, in SelectionContext::builtin_bound, no attempt is made to check whether the target trait or its supertraits require the kind specified.\r\n\r\nThis PR alters SelectionContext::builtin_bound to examine all supertraits in the target trait's bounds recursively for required kinds.\r\n\r\nAlternatively, the kinds could be added to the TyTrait upon creation (by just setting its builtin_bounds to the union of the bounds requested in this instance and the bounds required by the trait), this option may have less overhead during compilation but information is lost about which kinds were explicitly requested for this instance (vs those specified by traits/supertraits) would be lost.\r\n"
18983,'alexcrichton','Fixed remaining #Failure in docs to #Panics\n'
18966,'aturon','Add methods to go from a slice iterators to a slice.\nA slice iterator is isomorphic to a slice, just with a slightly\r\ndifferent form: storing start and end pointers rather than start pointer\r\nand length. This patch reflects this by making converting between them\r\nas easy as `iter.as_slice()` (or even `iter[]` if the shorter lifetime\r\nis ok). That is, `slice.iter().as_slice() == slice`.\r\n\r\nr? @aturon'
18963,'nikomatsakis','librustc: Forbid partial reinitialization of uninitialized structures or enumerations that implement the Drop trait.\nThis breaks code like:\r\n\r\n    struct Struct {\r\n        f: String,\r\n        g: String,\r\n    }\r\n\r\n    impl Drop for Struct { ... }\r\n\r\n    fn main() {\r\n        let x = Struct { ... };\r\n        drop(x);\r\n        x.f = ...;\r\n    }\r\n\r\nChange this code to not create partially-initialized structures. For\r\nexample:\r\n\r\n    struct Struct {\r\n        f: String,\r\n        g: String,\r\n    }\r\n\r\n    impl Drop for Struct { ... }\r\n\r\n    fn main() {\r\n        let x = Struct { ... };\r\n        drop(x);\r\n        x = Struct {\r\n            f: ...,\r\n            g: ...,\r\n        }\r\n    }\r\n\r\nCloses #18571.\r\n\r\n[breaking-change]\r\n\r\nI suspect I may have missed some cases that I should have checked.\r\n\r\nr? @nikomatsakis'
18958,'alexcrichton','librustc: Always parse `macro!()`/`macro![]` as expressions if not followed by a semicolon.\nThis allows code like `vec![1i, 2, 3].len();` to work.\r\n\r\nThis breaks code that uses macros as statements without putting\r\nsemicolons after them, such as:\r\n\r\n    fn main() {\r\n        ...\r\n        assert!(a == b)\r\n        assert!(c == d)\r\n        println(...);\r\n    }\r\n\r\nIt also breaks code that uses macros as items without semicolons:\r\n\r\n    fn main() {\r\n        local_data_key!(foo)\r\n\r\n        println("hello world")\r\n    }\r\n\r\nAdd semicolons to fix this code. Those two examples can be fixed as\r\nfollows:\r\n\r\n    fn main() {\r\n        ...\r\n        assert!(a == b);\r\n        assert!(c == d);\r\n        println(...);\r\n    }\r\n\r\n    fn main() {\r\n        local_data_key!(foo);\r\n\r\n        println("hello world")\r\n    }\r\n\r\nRFC #378.\r\n\r\nCloses #18635.\r\n\r\n[breaking-change]\r\n\r\nr? @alexcrichton '
18916,'steveklabnik','guide.md removed confusing semicolons\nHi everybody,\r\n\r\nI\'m completely new to Rust. In fact I\'m just in the middle reading the Rust Guide. I really like this introduction, it has a great flow. However I stumbled upon a "semicolon". It was the first time I had to switch from the guide and search for an answer and as I found out, I wasn\'t the only one http://stackoverflow.com/questions/26446587/what-difference-semicolons-make-in-early-returns.\r\n\r\n*My Problem*\r\nIt looks like these three examples all compile and work in the same way:\r\n```{rust}\r\nfn foo(x: int) -> int {\r\n    if x < 5 { return x; }\r\n\r\n    x + 1\r\n}\r\n```\r\n```{rust}\r\nfn foo(x: int) -> int {\r\n    if x < 5 { return x }\r\n\r\n    x + 1\r\n}\r\n```\r\n```{rust}\r\nfn foo(x: int) -> int {\r\n    if x < 5 { return x };\r\n\r\n    x + 1\r\n}\r\n```\r\nBecause the semicolon was just introduced before the example I expected the first example which is used currently in the guide to throw an error. (I\'d think `()` would be returned.) As it turns out in the StackOverflow answer `return` is a special case which isn\'t explained in the guide before this example.\r\n\r\n*My Proposal*\r\nRemove the semicolon and/or make a statement about the best practices of semicolons after `return` (e.g. like the "poor style" example, but as a "good style" example").'
18873,'jakub-','Matching broken with constants\n```rust\r\nconst A: &\'static [u8] = [];\r\n\r\nfn main() {\r\n    let x = [1u8];\r\n    match x.as_slice() {\r\n        A => println!("{} == {}", A, x.as_slice()),\r\n    }\r\n}\r\n```\r\n```\r\n[] == [1]\r\n```'
18783,'nikomatsakis','Two MUTABLE borrows to local var, by pushing closures into RefCell\'d Vec through a trait.\nLooks like a bug in the borrow checker:\r\n```rust\r\nuse std::cell::RefCell;\r\n\r\nfn main() {\r\n    let c = Caller::new();\r\n    let mut y = 1;  // NOT in RefCell.\r\n    c.pusher().push(|| { y = y * 2u; });\r\n    c.pusher().push(|| { y = y * 3u; });  // Second mutable borrow of y?!\r\n    c.call();\r\n    println!("{}", y); // Prints 6.\r\n}\r\n\r\n// Collects multiple closures then call all of them.\r\nstruct Caller<\'c> {\r\n    funs: RefCell<Vec<||:\'c -> ()>>,\r\n} impl<\'c> Caller<\'c> {\r\n    fn new() -> Caller<\'c> {\r\n        Caller { funs: RefCell::new(Vec::new()) }\r\n    }\r\n\r\n    fn pusher(&\'c self) -> Pusher<\'c> {\r\n        Pusher { caller: self }\r\n    }\r\n\r\n    fn call(&self) {\r\n        let ref mut funs = self.funs.borrow_mut();\r\n        loop {\r\n            match funs.pop() {\r\n                Some(f) => f(),\r\n                _ => break,\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Pushes closures into a caller.\r\ntrait Push<\'c> {\r\n    fn push<\'f: \'c>(self, push: ||:\'f -> ());\r\n}\r\n\r\nstruct Pusher<\'c> {\r\n    caller: &\'c Caller<\'c>\r\n}\r\n// /*\r\nimpl<\'c> Push<\'c> for Pusher<\'c> {\r\n    fn push<\'f: \'c>(self, fun: ||:\'f -> ()) {\r\n        self.caller.funs.borrow_mut().push(fun)\r\n    }\r\n}\r\n// Using the following impl (without trait) makes compilation fail correctly: */\r\n/*\r\nimpl<\'c> Pusher<\'c> {\r\n    fn push<\'f: \'c>(self, fun: ||:\'f -> ()) {\r\n        self.caller.funs.borrow_mut().push(fun)\r\n    }\r\n}\r\n*/\r\n```\r\n[Playpen](http://is.gd/a56cH1)\r\n\r\nThis compiles and runs fine. It also compiles when using unboxed closures instead (using type param F: FnOnce<(), ()>+\'c and F members). Using the **non-trait impl**, however, causes compilation to fail correctly:\r\n```\r\n<anon>:7:21: 7:39 error: cannot borrow `y` as mutable more than once at a time\r\n<anon>:7     c.pusher().push(|| { y = y * 3u; });  // Second mutable borrow of y?!\r\n                             ^~~~~~~~~~~~~~~~~~\r\n<anon>:7:30: 7:31 note: borrow occurs due to use of `y` in closure\r\n<anon>:7     c.pusher().push(|| { y = y * 3u; });  // Second mutable borrow of y?!\r\n                                      ^\r\n<anon>:6:21: 6:39 note: previous borrow of `y` occurs here due to use in closure; the mutable borrow prevents subsequent moves, borrows, or modification of `y` until the borrow ends\r\n<anon>:6     c.pusher().push(|| { y = y * 2u; });\r\n                             ^~~~~~~~~~~~~~~~~~\r\n<anon>:10:2: 10:2 note: previous borrow ends here\r\n<anon>:3 fn main() {\r\n...\r\n<anon>:10 }\r\n          ^\r\n<anon>:9:20: 9:21 error: cannot borrow `y` as immutable because it is also borrowed as mutable\r\n<anon>:9     println!("{}", y); // Prints 6.\r\n                            ^\r\nnote: in expansion of format_args!\r\n<std macros>:2:23: 2:77 note: expansion site\r\n<std macros>:1:1: 3:2 note: in expansion of println!\r\n<anon>:9:5: 9:23 note: expansion site\r\n<anon>:6:21: 6:39 note: previous borrow of `y` occurs here due to use in closure; the mutable borrow prevents subsequent moves, borrows, or modification of `y` until the borrow ends\r\n<anon>:6     c.pusher().push(|| { y = y * 2u; });\r\n                             ^~~~~~~~~~~~~~~~~~\r\n<anon>:10:2: 10:2 note: previous borrow ends here\r\n<anon>:3 fn main() {\r\n...\r\n<anon>:10 }\r\n          ^\r\n<anon>:9:20: 9:21 error: cannot borrow `y` as immutable because it is also borrowed as mutable\r\n<anon>:9     println!("{}", y); // Prints 6.\r\n                            ^\r\nnote: in expansion of format_args!\r\n<std macros>:2:23: 2:77 note: expansion site\r\n<std macros>:1:1: 3:2 note: in expansion of println!\r\n<anon>:9:5: 9:23 note: expansion site\r\n<anon>:7:21: 7:39 note: previous borrow of `y` occurs here due to use in closure; the mutable borrow prevents subsequent moves, borrows, or modification of `y` until the borrow ends\r\n<anon>:7     c.pusher().push(|| { y = y * 3u; });  // Second mutable borrow of y?!\r\n                             ^~~~~~~~~~~~~~~~~~\r\n<anon>:10:2: 10:2 note: previous borrow ends here\r\n<anon>:3 fn main() {\r\n...\r\n<anon>:10 }\r\n          ^\r\nerror: aborting due to 3 previous errors\r\nplaypen: application terminated with error code 101\r\nProgram ended.\r\n```'
18749,'pcwalton','Treat builtin bounds like all other kinds of trait matches.\nTreat builtin bounds like all other kinds of trait matches. Introduce a simple hashset in the fulfillment context to catch cases where we register the exact same obligation twice. This helps prevent duplicate error reports but also handles the recursive obligations created by builtin bounds.\r\n\r\nr? @pcwalton \r\ncc @FlaPer87 \r\n'
18716,'nikomatsakis','Caching and other optimizations for method call resolution\nMethod call resolution takes a long time. It should not.'
18699,'cmr','flexible target specification breaks plugins lookup\nI\'ve got two crates failing to build after flexible target specification (https://github.com/rust-lang/rust/commit/6b130e3) was merged.\r\n\r\n```\r\nrustc \\\r\n  --opt-level 2 \\\r\n  -Z no-landing-pads \\\r\n  --cfg mcu_k20 --cfg arch_cortex_m4 \\\r\n  -g \\\r\n  -C no-stack-check \\\r\n  -L /Users/farcaller/src/zinc/build \\\r\n  --out-dir /Users/farcaller/src/zinc/build \\\r\n  /Users/farcaller/src/zinc/src/macro/ioreg.rs\r\n```\r\n\r\nbuilds `libmacro_ioreg.dylib` (and a matching `libmacro_ioreg.dylib.dSYM`).\r\n\r\nThe crate that depends on it fails to build though:\r\n\r\n```\r\nrustc \\\r\n  --opt-level 2 \\\r\n  -Z no-landing-pads \\\r\n  --cfg mcu_k20 --cfg arch_cortex_m4 \\\r\n  --target thumbv7em-none-eabi -Ctarget-cpu=cortex-m4 \\\r\n  -C relocation_model=static \\\r\n  -g \\\r\n  -C no-stack-check \\\r\n  -L /Users/farcaller/src/zinc/build \\\r\n  --out-dir /Users/farcaller/src/zinc/build  /Users/farcaller/src/zinc/src/zinc/lib.rs\r\n/Users/farcaller/src/zinc/src/zinc/lib.rs:52:18: 52:43 error: can\'t find crate for `macro_ioreg`\r\n/Users/farcaller/src/zinc/src/zinc/lib.rs:52 #[phase(plugin)] extern crate macro_ioreg;\r\n                                                              ^~~~~~~~~~~~~~~~~~~~~~~~~\r\nerror: aborting due to previous error\r\n```\r\n\r\nif I remove `--target thumbv7em-none-eabi`, the macro_ioreg crate is resolved correctly.\r\n\r\ntarget spec:\r\n```json\r\n{\r\n    "data-layout": "e-m:e-p:32:32-i1:8:32-i8:8:32-i16:16:32-i64:64-v128:64:128-a:0:32-n32-S64",\r\n    "llvm-target": "thumbv7em-none-eabi",\r\n    "target-endian": "little",\r\n    "target-word-size": "32",\r\n    "arch": "arm",\r\n    "os": "none",\r\n    "morestack": false\r\n}\r\n```'
18640,'bjz','Simplify numeric traits\nTracking https://github.com/rust-lang/rfcs/pull/369'
18469,'nick29581','Implement revised coercion rules\nTracking issue for [RFC 401](https://github.com/rust-lang/rfcs/pull/401).'
18432,'nick29581',"Support the `Trait<Output=Type>` syntax\nToday when we expand associated types we always expand to a fresh type parameter. Per the RFC we should support a syntax like:\r\n\r\n    Trait<Output=Type>\r\n\r\nto permit a trait reference that specifies what to expand an associated type into. This is a subset of full `==` references.\r\n\r\nNote that cyclic equality does not have to be supported (though it'd be nice if it at least produced a nice error message, not an ICE):\r\n\r\n```rust\r\nfn foo<T:Something<Out=U::Out>, U:Something<Out=T::Out>>() { ... }\r\n```"
18261,'thestinger','support clearing TypedArena with the chunks preserved\nIt would be pretty simple to add this functionality, and it would allow catching up to the apr-based binary-trees implementation.'
18234,'nikomatsakis','Path fragments for drop obligations\nCode to fragment paths into pieces based on subparts being moved around, e.g. moving `x.1` out of a tuple `(A,B,C)` leaves behind the fragments `x.0: A` and `x.2: C`.  Further discussion in borrowck/doc.rs.\r\n\r\nIncludes differentiation between assigned_fragments and moved_fragments, support for all-but-one array fragments, and instrumentation to print out the moved/assigned/unmmoved/parents for each function, factored out into a separate submodule.\r\n\r\nThese fragments can then be used by `trans` to inject stack-local dynamic drop flags.  (They also can be hooked up with dataflow to reduce the expected number of injected flags.)'
18233,'nikomatsakis','User-defined placement-box\nAdd support for user-defined placement-box expressions (i.e. `box (<place>) <value>` for types other than `Box<T>`).\r\n\r\nThis is a prototype design that @nikomatsakis and @pnkfelix have been working on.  It works by desugaring an instance of placement-box into a protocol where we first create the intermediate storage with a pseudo-out-pointer, then initialize the storage, and then convert the out-pointer into the desired box type.\r\n\r\nThe code was originally written to handle both `box (<place>) <value>` and `box <value>` via the same uniform desugaring, and it is easy to revise support for the latter; but as is, this PR only puts `box (<place>) <value>` into the desugaring.  The reason for this is that the error messages get a lot nastier to handle from the desugared form, and pnkfelix did not want to hold this work up further trying to resolve that.\r\n\r\nThe final design for this will require an RFC; this code is entirely experimental for now.\r\n\r\nProto RFC: http://discuss.rust-lang.org/t/pre-rfc-placement-box-with-placer-trait/729/5'
18074,'aturon','Propagate recent RFC for naming conventions\nTracking issue for https://github.com/rust-lang/rfcs/pull/344'
18060,'jakub-','Wrong reordering of match arms with ranges\nAdopted and minimized from the HTTP method parsing routine of [hyperium/hyper](https://github.com/hyperium/hyper):\r\n\r\n```rust\r\nprintln!("{}", match (1u, 3u) { (0, 2...5) => 1, (1, 3) => 2, (_, 2...5) => 3, (_, _) => 4u });\r\nprintln!("{}", match (1u, 3u) {                  (1, 3) => 2, (_, 2...5) => 3, (_, _) => 4u });\r\nprintln!("{}", match (1u, 7u) { (0, 2...5) => 1, (1, 7) => 2, (_, 2...5) => 3, (_, _) => 4u });\r\n```\r\n\r\nAll three lines should print 2, but the first line prints 3 on the current nightly (`rustc 0.13.0-nightly (40b244973 2014-10-14 23:22:20 +0000)`). The `match` trans apparantly groupped the second pattern even when it may result in the wrong result.'
18027,'jakub-','ICE: task \'rustc\' failed at \'internal error: entered unreachable code\', /home/tj/rust-lang/src/librustc/middle/check_match.rs:714\n```rust\r\nfn main() {\r\n\tmatch "ab".to_string().as_bytes() {\r\n\t\tb"\\n" => (),\r\n\t\t[b1, b2] => (),\r\n\t\t_ => ()\r\n\t}\r\n}\r\n```\r\nResults in the following:\r\n\r\n```\r\n> RUST_BACKTRACE=1 rustc foo.rs\r\nerror: internal compiler error: unexpected failure\r\nnote: the compiler hit an unexpected failure path. this is a bug.\r\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\r\nnote: run with `RUST_BACKTRACE=1` for a backtrace\r\ntask \'rustc\' failed at \'internal error: entered unreachable code\', /home/tj/rust-lang/src/librustc/middle/check_match.rs:714\r\n\r\nstack backtrace:\r\n   1:     0x7f0d82c43240 - rt::backtrace::imp::write::h517d32de8f8710ddgDq\r\n   2:     0x7f0d82c463d0 - failure::on_fail::h67b81ddf88f0460eDYq\r\n   3:     0x7f0d87191190 - unwind::begin_unwind_inner::h76df22d18066ee19Gxd\r\n   4:     0x7f0d877ddf10 - unwind::begin_unwind::h14104116603448327476\r\n   5:     0x7f0d87a758a0 - middle::check_match::range_covered_by_constructor::h8fa219696c1aa6865Rn\r\n   6:     0x7f0d87a73dc0 - middle::check_match::specialize::he49722c67c62a3f4KTn\r\n   7:     0x7f0d87a72e50 - middle::check_match::is_useful_specialized::h8d2ed3b4f68da900IHn\r\n   8:     0x7f0d87a73b40 - middle::check_match::is_useful::closure.117288\r\n   9:     0x7f0d87a71ee0 - iter::Iterator::find::h3987249559819764121\r\n  10:     0x7f0d87a50730 - middle::check_match::is_useful::hfd30574cebf54b25cyn\r\n  11:     0x7f0d87a4b290 - middle::check_match::check_expr::hd4cdd89caef43d1fKWm\r\n  12:     0x7f0d87a4d7c0 - middle::check_match::check_fn::h871a1aaa1a66c0cc88n\r\n  13:     0x7f0d87a4e260 - visit::walk_item::h15341873477825387593\r\n  14:     0x7f0d87a4db10 - middle::check_match::check_crate::h38e65867c6e4bcbboWm\r\n  15:     0x7f0d877fc9e0 - util::common::time::h1991069288953859421\r\n  16:     0x7f0d880cd880 - driver::driver::phase_3_run_analysis_passes::hf687192a195df4a9Aqx\r\n  17:     0x7f0d880c7bc0 - driver::driver::compile_input::hcb2b12207a8e1dbdm7w\r\n  18:     0x7f0d88153ee0 - driver::run_compiler::hf18eb26e92099043FVA\r\n  19:     0x7f0d88153d90 - driver::run::closure.147365\r\n  20:     0x7f0d878165a0 - task::TaskBuilder<S>::try_future::closure.101542\r\n  21:     0x7f0d87816380 - task::TaskBuilder<S>::spawn_internal::closure.101513\r\n  22:     0x7f0d874de0c0 - task::spawn_opts::closure.8447\r\n  23:     0x7f0d871eca10 - rust_try_inner\r\n  24:     0x7f0d871eca00 - rust_try\r\n  25:     0x7f0d8718ea50 - unwind::try::hfee86de44e6a5329omd\r\n  26:     0x7f0d8718e8d0 - task::Task::run::h4442d464d9df41ad2Bc\r\n  27:     0x7f0d874dde00 - task::spawn_opts::closure.8387\r\n  28:     0x7f0d871901a0 - thread::thread_start::h078eb5d6b9fd3766dWc\r\n  29:     0x7f0d81fea0c0 - start_thread\r\n  30:     0x7f0d86e57f89 - __clone\r\n  31:                0x0 - <unknown>\r\n````\r\n\r\nVersion:\r\n```\r\n> rustc --version=verbose\r\nrustc 0.13.0-dev (a0ea210b3 2014-10-13 08:37:41 +0000)\r\nbinary: rustc\r\ncommit-hash: a0ea210b394aa1b61d341593a3f9098fe5bf7806\r\ncommit-date: 2014-10-13 08:37:41 +0000\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 0.13.0-dev\r\n```'
18004,'thestinger','provide a new efficient implementation of thread-local storage\nIt should be a thin layer on top of `#[thread_local]` where supported. It can provide an `unsafe` low-level API and then implement `Cell` and `RefCell` semantics on top of that for the safe API.'
18003,'thestinger','implement new low-level and high-level mutexes and condition variables\nThis should be a pair of types built directly on the platform primitives. On Windows, it should directly wrap `CRITICAL_SECTION` and `CONDITION_VARIABLE` while on *nix it would wrap `pthread_mutex_t` and `pthread_cond_t`. It can then be wrapped into a new high-level safe API.\r\n\r\nC++11 also exposes a portable recursive mutex, which would be an easy addition. It could allow expose adaptive mutexes (faster, at the expense of fairness) when available since falling back to normal mutexes is a portable implementation.'
17931,'thestinger','improve chunk allocation scheme used by Arena / TypedArena\nIt should attempt in-place growth before falling back to allocating a new chunk. The initial size and growth should be chosen to map well onto jemalloc. Rather than an intrusive linked list of chunks, it should probably just keep the metadata out of band for simplicity and to avoid bumping the allocations into a higher size class.'
17907,'nikomatsakis','Unboxed closures: Type inferencer failed to detect closure argument types\n```rust\r\n#![feature(unboxed_closures)]\r\n#![feature(overloaded_calls)]\r\n\r\nfn action<T: Send, F: FnOnce(Sender<T>) -> ()>(sender: Sender<T>, cb: F) {\r\n  cb(sender);\r\n}\r\n\r\npub fn main() {\r\n  let (tx, rx) = channel();\r\n\r\n  // Must be uncommented to work    vvv\r\n  action(tx, move |:tx /* :Sender<&\'static str> */| {\r\n      tx.send("zomg")\r\n  });\r\n\r\n  println!("recv: {}", rx.recv());\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nrustc fnonce.rs\r\nfnonce.rs:13:7: 13:22 error: the type of this value must be known in this context\r\nfnonce.rs:13       tx.send("zomg")\r\n                   ^~~~~~~~~~~~~~~\r\nfnonce.rs:12:3: 12:9 error: type mismatch: the type `closure` implements the trait `core::ops::FnOnce<([type error]),[type error]>`, but the trait `core::ops::FnOnce<(sync::comm::Sender<<generic #9>>),()>` is required (expected struct sync::comm::Sender, found type error)\r\nfnonce.rs:12   action(tx, move |:tx /* :Sender<&\'static str> */| {\r\n               ^~~~~~\r\nfnonce.rs:12:3: 12:9 note: the trait `core::ops::FnOnce` must be implemented because it is required by `action`\r\nfnonce.rs:12   action(tx, move |:tx /* :Sender<&\'static str> */| {\r\n               ^~~~~~\r\nerror: aborting due to 2 previous errors'
17864,'nikomatsakis','librustc: Make `Copy` opt-in.\nThis change makes the compiler no longer infer whether types (structures\r\nand enumerations) implement the `Copy` trait (and thus are implicitly\r\ncopyable). Rather, you must implement `Copy` yourself via `impl Copy for\r\nMyType {}`.\r\n\r\nThis breaks code like:\r\n\r\n    #[deriving(Show)]\r\n    struct Point2D {\r\n        x: int,\r\n        y: int,\r\n    }\r\n\r\n    fn main() {\r\n        let mypoint = Point2D {\r\n            x: 1,\r\n            y: 1,\r\n        };\r\n        let otherpoint = mypoint;\r\n        println!("{}{}", mypoint, otherpoint);\r\n    }\r\n\r\nChange this code to:\r\n\r\n    #[deriving(Show)]\r\n    struct Point2D {\r\n        x: int,\r\n        y: int,\r\n    }\r\n\r\n    impl Copy for Point2D {}\r\n\r\n    fn main() {\r\n        let mypoint = Point2D {\r\n            x: 1,\r\n            y: 1,\r\n        };\r\n        let otherpoint = mypoint;\r\n        println!("{}{}", mypoint, otherpoint);\r\n    }\r\n\r\nThis is the backwards-incompatible part of #13231.\r\n\r\nPart of [RFC #3](https://github.com/rust-lang/rfcs/pull/127).\r\n\r\n[breaking-change]\r\n\r\nr? @nikomatsakis'
17828,'aturon','identify traits in libstd that should use associated lifetimes\nas a subtask of #17307, once the associated lifetimes part of associated items is implemented, we will want to update libstd to use it.\r\n\r\nMy google doc from #17826 includes a column for associated lifetimes; I copied the link again below.\r\n\r\nMost/all of the cases are related to slice traits, and its possible that they will just go away with other design changes.  I am not sure.\r\n\r\nhttps://docs.google.com/spreadsheets/d/1Y_NAgzEK3FWcG0LjcykyKJEAibSFI3w-v-ekZ4GU8n4/edit?usp=sharing'
17826,'aturon','identify traits in libstd that should use associated types (as output parameters)\nas a subtask of #17307, once associated types are implemented, we will want to update libstd to use them, rather than continuing to use type parameters to traits as a way to encode so-called "output types" associated with an impl.\r\n\r\nI ran the following ack invocation: `ack --rust \'pub.*trait.*<\'` and then manually surveyed the results to determine the set of traits we might need to update.  (I haven\'t finished the survey yet.)\r\n\r\nHere is a google doc with partial results.  There are at most 65 cases that I identified via this method, mostly in `collections`, `core::iter`, `core::ops`, and `core::slice`.\r\n\r\nhttps://docs.google.com/spreadsheets/d/1Y_NAgzEK3FWcG0LjcykyKJEAibSFI3w-v-ekZ4GU8n4/edit?usp=sharing\r\n'
17701,'aturon','Split up the Iterator trait\nWhen #17670 lands, we will no longer be able to make Iterator trait objects. The only method on Iterator which is object safe is `next`, I assume we should therefore pull that out to its own trait and Iterator should extend that, but that means all implementers of Iterator will have to change. So, perhaps there is a better way.\r\n\r\ncc @aturon '
17632,'jakub-','`pub type Foo = foo::Foo` causes bad dead_code warnings on enum variants\nThe following code triggers `dead_code` warnings on each enum variant:\r\n\r\n```rust\r\npub type Foo = foo::Foo;\r\npub mod foo {\r\n    pub enum Foo {\r\n        One,\r\n        Two\r\n    }\r\n}\r\n```\r\n\r\nThis happens even though the enum is fully public. Commenting put the `pub type` line gets rid of the warnings.'
17631,'jakub-',"ICE with byte char literal in match\nUsing a `b'x'` literal in a `match` in one arm when another arm uses an integral literal causes an ICE.\r\n\r\nCode:\r\n\r\n```rust\r\npub fn main() {\r\n    let (a, b) = (1u8, 2u8);\r\n\r\n    let _x = match (a, b) {\r\n        (0x1b, b'\\\\') => 1u,\r\n        (_, 0x05) => 2u,\r\n        _ => 5u\r\n    };\r\n}\r\n```\r\n\r\nResults:\r\n\r\n```\r\nerror: internal compiler error: unexpected failure\r\nnote: the compiler hit an unexpected failure path. this is a bug.\r\nnote: we would appreciate a bug report: http://doc.rust-lang.org/complement-bugreport.html\r\nnote: run with `RUST_BACKTRACE=1` for a backtrace\r\ntask 'rustc' failed at 'compare_list_exprs: type mismatch', /Volumes/Himling/Users/kevin/Dev/rust/rust/src/librustc/middle/trans/_match.rs:236\r\n\r\nstack backtrace:\r\n   1:        0x10b611c19 - rt::backtrace::imp::write::h49e167be6c35c7a6I3q\r\n   2:        0x10b614f71 - failure::on_fail::h2de262f0fa07a6d1mkr\r\n   3:        0x10b89c025 - unwind::begin_unwind_inner::h9dd2b45e3189ab76PQd\r\n   4:        0x10825d84c - unwind::begin_unwind::h17200107724015028583\r\n   5:        0x1086bb033 - middle::trans::_match::Opt<'a>::eq::ha0347177cb74f650KDg\r\n   6:        0x1086c7908 - middle::trans::_match::compile_submatch_continue::h2c95eff2a4dfe45ejHh\r\n   7:        0x1086c42f0 - middle::trans::_match::compile_submatch::he72af60857c57ca2yBh\r\n   8:        0x1086c729f - middle::trans::_match::compile_submatch_continue::h2c95eff2a4dfe45ejHh\r\n   9:        0x1086c42f0 - middle::trans::_match::compile_submatch::he72af60857c57ca2yBh\r\n  10:        0x10864fb8b - middle::trans::_match::trans_match::h01258bca90f67af8E0h\r\n  11:        0x10863cc1c - middle::trans::expr::trans_rvalue_dps_unadjusted::h27302feaf01beb5aZ03\r\n  12:        0x1085fe8ed - middle::trans::expr::trans_into::h148e25892fc50848QC2\r\n  13:        0x1086d76fe - middle::trans::_match::store_local::closure.127410\r\n  14:        0x1086d7565 - middle::trans::_match::mk_binding_alloca::h10952157501536158966\r\n  15:        0x1086a375d - middle::trans::_match::store_local::h4bc417dc83908137Xdi\r\n  16:        0x1085fde6a - middle::trans::base::init_local::hc06087db4c732c66eYd\r\n  17:        0x1085fd331 - middle::trans::controlflow::trans_stmt::h4fb6e8ab2ae05364OEY\r\n  18:        0x1085feb98 - middle::trans::controlflow::trans_block::h4903f12a15b4b417UJY\r\n  19:        0x1086ac572 - middle::trans::base::trans_closure::hcc72f0bf6b75cf89EPe\r\n  20:        0x1085f17f8 - middle::trans::base::trans_fn::h50dd8cb21b7d227f20e\r\n  21:        0x1085eec9a - middle::trans::base::trans_item::h2481520530d8b2c5lkf\r\n  22:        0x1086b5d78 - middle::trans::base::trans_crate::h2d09203b93180fb4Bkg\r\n  23:        0x108abc895 - driver::driver::phase_4_translate_to_llvm::h480b949b4d48af47pJw\r\n  24:        0x108ab5613 - driver::driver::compile_input::h7ecbeb2017ef3606rgw\r\n  25:        0x108b33b34 - driver::run_compiler::ha722889403f0b6bdn6z\r\n  26:        0x108b31d26 - driver::main_args::closure.146118\r\n  27:        0x1082949ab - task::TaskBuilder<S>::try_future::closure.101380\r\n  28:        0x1082948a3 - task::TaskBuilder<S>::spawn_internal::closure.101351\r\n  29:        0x10b4e44bd - task::spawn_opts::closure.8577\r\n  30:        0x10b903ecc - rust_try_inner\r\n  31:        0x10b903eb6 - rust_try\r\n  32:        0x10b899437 - unwind::try::h493476c01d8d39d6xFd\r\n  33:        0x10b8992ac - task::Task::run::hd474352d5be20d9fMVc\r\n  34:        0x10b4e4312 - task::spawn_opts::closure.8516\r\n  35:        0x10b89af6a - thread::thread_start::hf69b37c15c1d48651fd\r\n  36:     0x7fff8d29d2fc - _pthread_body\r\n  37:     0x7fff8d29d279 - _pthread_body\r\n```\r\n\r\n```\r\nrustc 0.12.0-pre (496b68d48 2014-09-29 01:03:06 +0000)\r\n```"
17569,'thestinger',"add a new implementation of thread-local storage\nIt should map directly to `#[thread_local]` on most platforms. Android *may* need a special slow path since it doesn't have a full implementation of TLS. There are various other bugs blocking an implementation that's as efficient and flexible as C++'s `thread_local`.\r\n\r\n* #17572: implement destructor support for thread-local variables -> must do memory allocation and register a dynamic TLS entry with the destructor"
17344,'brson',"32-bit nightlies are not being tested\nThe OSX and Linux nightly builders are not testing the 32-bit nightlies because they're only testing the 64-bit nightlies.\r\n\r\nThe most recent 32-bit cargo builds instantly segfault, which leads me to believe that there may be codegen bugs?"
17307,'pnkfelix',"Implement associated items\nTracking issue for https://github.com/rust-lang/rfcs/pull/195\r\n\r\nNominating as this will have large repercussions on library design which I believe need to be done for 1.0\r\n\r\nTask List\r\n * [x] Implement associated output types (see PR #16377),\r\n * [ ] Implement defaults for associated types,\r\n * [ ] Update library code for associated output types (see Issue #17826),\r\n * [x] Implement multi-dispatch (see PR #17669),\r\n * [ ] Update library code for multi-dispatch (see Issue #17827),\r\n * [ ] Implement associated lifetimes (see Issue #17842),\r\n * [ ] Update library code for associated lifetimes (see Issue #17828),\r\n * [ ] Implement associated constants (see Issue #17841),\r\n * [ ] Update library code for associated constants (see Issue #17825).\r\n* [x] ICE: Unbound path #17388 \r\n\r\nICEs (need to be triaged):\r\n\r\n* [ ] ICE: Didn't find associated type (#17359)\r\n* [ ] ICE: When implementing trait with a generic parameter and an associated output type (#19129)\r\n\r\nBugs needing fixing before un-feature-gating:\r\n\r\n* [x] Associated types should permit builtin bounds (#17921)\r\n* [ ] Implement `Trait<Out=Type>` syntax (#18432)\r\n* [ ] Support `T::Type` syntax (#18433)\r\n* [ ] Associated types are used as inputs for multidispatch (#18437)\r\n* [ ] Traits with associated types appearing on structs, enums, or other traits (#18768)\r\n  * [ ] ICE: find_associated_type_in_generics(): didn't find associated type anywhere in the generics list (#17732)\r\n* [ ] Qualified paths don't check type arguments in the trait reference (#18865)\r\n* [ ]  rustdoc panics when dealing with associated types (#18594)\r\n\r\nBugs that would be great for 1.0 but not strictly required by the libraries:\r\n\r\n* [ ] Associated types  should permit arbitrary bounds (#18178)\r\n* [ ] Associated types need to do transitive bound expansion (#18434)\r\n* [ ] Permit unqualified references to associated types of the trait within the trait definition (#18764)\r\n\r\nBugs needing fixing possibly after un-feature-gating:\r\n\r\n* [ ] Traits with where clauses that themselves reference traits with assoc types (#18436)"
16745,'jakub-',"Can't mix generic and specific literals in match arms\nFor example\r\n```rust\r\nn is_whitespace(b: u8) -> bool {\r\n    match b {\r\n        b' '  => true,\r\n        b'\\t' => true,\r\n        b'\\n' => true,\r\n        0x0B  => true,\r\n        0x0C  => true,\r\n        b'\\r' => true,\r\n        _     => false,\r\n    }\r\n}\r\n```\r\n```\r\nmod.rs:166:9: 166:13 error: mismatched types between arms\r\nmod.rs:166         b' '  => true,\r\n                   ^~~~\r\nmod.rs:167:9: 167:14 error: mismatched types between arms\r\nmod.rs:167         b'\\t' => true,\r\n                   ^~~~~\r\nmod.rs:168:9: 168:14 error: mismatched types between arms\r\nmod.rs:168         b'\\n' => true,\r\n                   ^~~~~\r\nmod.rs:166:9: 166:13 error: mismatched types between arms\r\nmod.rs:166         b' '  => true,\r\n                   ^~~~\r\nmod.rs:167:9: 167:14 error: mismatched types between arms\r\nmod.rs:167         b'\\t' => true,\r\n                   ^~~~~\r\nmod.rs:168:9: 168:14 error: mismatched types between arms\r\nmod.rs:168         b'\\n' => true,\r\n                   ^~~~~\r\nmod.rs:169:9: 169:13 error: mismatched types between arms\r\nmod.rs:169         0x0B  => true,\r\n                   ^~~~\r\nmod.rs:170:9: 170:13 error: mismatched types between arms\r\nmod.rs:170         0x0C  => true,\r\n```"
16679,'brson',"Develop standard training material\nFor spreading the gospel it would be nice to have a standard set of training material so that everybody who wants to teach Rust doesn't need to start from scratch. It should be based on the guide."
16678,'brson',"Add the ability to completely disable experimental features in release channels\nIn the stable release channel we're probably going to completely disable the ability to use experimental features and libraries. Add this capability to the build.\r\n\r\ncc https://github.com/rust-lang/rust/issues/16677"
16677,'brson',"Add release channel automation\nBefore 1.0 we want to change the release process to have multiple parallel release channels ('nightly', 'beta', 'stable', probably). This will require a bunch of new automation."
16676,'aturon',"Audit reference manual before 1.0\nShortly before 1.0 we should give some attention to the manual and make sure it's not too inaccurate nor incomplete."
16593,'thestinger',"use high entropy ASLR on 64-bit Windows\nMinGW-w64 doesn't expose the necessary flag yet, so I'll look into adding it to their linker. It should be as easy as adding support for an extra flag there and then passing the switch from the Rust compiler."
16581,'thestinger',"MinGW's linker does not create a reloc section for DYNAMICBASE executables\nThis issue exists to track the necessity of a workaround for this bug in the compiler."
16577,'aturon','various `eof` type signatures are not consistent\n```\r\n$ git grep "fn eof"\r\nsrc/libnative/io/util.rs:pub fn eof() -> IoError {\r\nsrc/libserialize/json.rs:    fn eof(&self) -> bool { self.ch.is_none() }\r\nsrc/libstd/io/fs.rs:    pub fn eof(&self) -> bool {\r\nsrc/libstd/io/mem.rs:    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\r\nsrc/libstd/io/mem.rs:    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\r\nsrc/libsyntax/print/pp.rs:pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_...\r\n```\r\n\r\nOne `IoError`, four `bool`s, and one `IoResult`.\r\n\r\ncc @aturon '
16516,'thestinger',"add a lint for preventing all known sources of address leaks\nRust now uses full ASLR by default, but it's possible to expose the randomized base in *safe code* by leaking a single address. An optional lint could check for conversions from raw pointers to integers. An attribute for marking functions like the `to_uint` method on raw pointers would also be necessary. Some of these functions could also be removed to discourage patterns prone to leaking addresses.\r\n\r\nOne common usage of addresses is for unique identifiers, but this is possible *without* converting raw pointers to integers. An identifier can be stored as `*const ()` and then compared with other pointers."
16514,'thestinger','use ASLR on Windows\nThis should be as simple as passing `--dynamicbase` to the linker for both libraries and executables. However, the necessary relocations are never generated by MinGW or MinGW-w64 for executables so nothing is actually randomized without also passing `--export-all-symbols`. The `-pie` switch is also broken and results in a messed up entry point, but it may not actually be required.'
16459,'brson',"Windows metabug\nThese are some of the major outstanding Windows bugs, ordered roughly by priority. [Prior discussion](http://discuss.rust-lang.org/t/prioritizing-windows-issues/319)\r\n\r\nMajor tasks:\r\n\r\n* [x] #16312 64-bit automation\r\n* [x] #16823 Installer naming\r\n* [x] #11782 stop requiring mingw install\r\n* [ ] #16456 cargo installation\r\n* [x] #13259 TCB-slot usage                                                                  \r\n* [x] https://github.com/rust-lang/cargo/issues/326 native dlls\r\n* [x] #16457 run full test suite on bots\r\n* [ ] #13810 make install problems\r\n* [x] #17202 debuginfo\r\n\r\nCompiler fixes:\r\n\r\n* [ ] #13256 debugging problems\r\n* [ ] #15644 'benign' segfaults\r\n* [ ] #15420 static libgcc\r\n* [ ] #13794 inconsistent output naming\r\n* [x] #13793 0-length static array\r\n* [ ] #13429 float casts\r\n* [x] #11261 which system ABI on win64\r\n\r\nLibrary fixes:\r\n\r\n* [x] #16070 MemoryMap::new()\r\n* [ ] #15836 fs::rename\r\n* [ ] #15522 plugin_registrar ICE\r\n* [ ] #5286 x-crate tests\r\n* [x] #13725 regex tests\r\n* [ ] #12795 lstat\r\n* [x] #10102 UDP tests\r\n* [ ] #8818 dynamic lib tests\r\n* [ ] #8755 math test failures\r\n* [ ] #16937 process::Command::env\r\n\r\nMysterious crashes:\r\n\r\n* [ ] #14403\r\n* [ ] #15813\r\n* [ ] #16324\r\n\r\nOther:\r\n\r\n* [ ] #16654 - docs\r\n* [ ] #15717 - triples\r\n* [x] #17260 - broken installer link\r\n* [ ] #17251 - incompatibility with system mingw"
16456,'brson','Figure out combined Rust+Cargo installation\nOn Unix, the rustup.sh script will install both Rust+Cargo (though that may not end up the official installation mechanism). On Windows, acquiring Cargo is not so convenient.\r\n\r\nThe obvious thing to do on Windows is to put them both in the same installer, but since Cargo and Rust live in different repos (and should continue to do so for the foreseeable future imo) creating that installer will require some work.\r\n\r\nNominating.'
16293,'nick29581','Implement UFCS (Tracking RFC 132)\nhttps://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md\r\n\r\n'
16035,'aturon','Consider returning &c_char from CString::as_ptr\nThis should make it a lot harder to run into the bug mentioned in its documentation (`let p = foo.to_c_str().as_ptr();`).'
15883,'cmr',"Model lexer is still wrong\nTracking issue for all known problems with the lexer.\r\n\r\nTodo:\r\n\r\n- [ ] https://github.com/rust-lang/rust/issues/15679 antlr's lack of unicode is disturbing\r\n- [ ] https://github.com/rust-lang/rust/issues/15877 Model lexer doesn't handle range correctly\r\n- [ ] https://github.com/rust-lang/rust/issues/15878 Weirdness with shebang between model and rustc\r\n- [ ] https://github.com/rust-lang/rust/issues/15879 Model lexer doesn't handle question marks\r\n- [ ] https://github.com/rust-lang/rust/issues/15881 Model lexer doesn't handle ... something?\r\n- [ ] https://github.com/rust-lang/rust/issues/15882 Model lexer doesn't handle CRLF correctly\r\n- [ ] Remove any remaining `ignore-lexer-test`s."
15880,'brson',"Move checking of tests with little x-platform risk to supplemental auto bot, turn on lexer tests\nWe have tests in tree that the lexer conforms to an official grammar, but the bots are not running them yet. These tests take a long time to run, as will the impending tests of the parser. We need to do a few things to turn them on:\r\n\r\n* Add ANTLR to at least the linux EC2 images\r\n* Add 'check-primary' and 'check-secondary' build targets\r\n* Change the current integration builders to use 'check-primary'. Add a new one that only does 'check-secondary'.\r\n\r\nPut the lexer tests and the pretty-printing tests under 'check-secondary'.\r\n\r\ncc @cmr @alexcrichton "
15287,'zwarich','Implement Pattern Guards with Bind-By-Move\nTracking issue for https://github.com/rust-lang/rfcs/pull/107'
15278,'jakub-','Unused mut lint doesn\'t warn on declare first - initialize later pattern\nScript to reproduce:\r\n\r\n``` rust\r\nfn main() {\r\n    // `a` doesn\'t need to be mutable\r\n    let mut a: int;\r\n    a = 42;\r\n    println!("{}", a);\r\n}\r\n```\r\n\r\nNo warnings on the output.\r\n\r\n``` bash\r\n$ rustc --version\r\nrustc 0.11.0-pre (287dcb77b34b421256c1d9cf26f3101276d2f486 2014-06-30 10:26:28 +0000)\r\n```'
14560,'thestinger',"use gold instead of bfd on Linux if it's available\nThis is what `clang` does on Linux, by detecting the existence of `/usr/bin/ld.gold` and then using it. This can be done with `gcc` by passing `-fuse-ld=gold`. It's a much faster linker and doesn't consume as much memory, so it will reduce the compiler's peak memory consumption."
14466,'brson',"Short doc url don't mention Rust version at all\nE.g. http://doc.rust-lang.org/std/index.html\r\n\r\nPossible solutions:\r\n- not have the short forms\r\n- have the version on each page\r\n- redirect to the .../master/... or .../1.0/... (or whatever) version as appropriate"
14007,'jakub-','Type errors of the form "expected... but found..." should indicate the source of their expectation\nThe program\r\n\r\n```rust\r\nextern crate collections;\r\nuse collections::treemap::TreeMap;\r\n\r\nfn main() {\r\n    let mut a = TreeMap::new();\r\n    a.insert(0, 1);\r\n    a.insert(0, "foo");\r\n}\r\n```\r\ngives the type error\r\n\r\n```\r\ntreemap-test.rs:7:17: 7:22 error: mismatched types: expected `<generic integer #1>` but found `&\'static str` (expected integral variable but found &-ptr)\r\ntreemap-test.rs:7     a.insert(0, "foo");\r\n                                   ^~~~~\r\n```\r\nThis error should indicate the source of the expectation that the type parameter is integral.'
13551,'jakub-',"Implementation cannot be defined for 'type' alias\nCode example:\r\n\r\nSave this in `main.rs` and try to compile.\r\n\r\n```\r\nenum T {}\r\ntype New = T;\r\n\r\nimpl New {}\r\n\r\nfn main() {}\r\n```\r\n\r\nTrying to compile, it shows this error:\r\n\r\nimpl.rs:4:1: 4:12 error: cannot associate methods with a type outside the crate the type is defined in; define and implement a trait or new type instead\r\nimpl.rs:4 impl New {}\r\n          ^~~~~~~~~~~\r\nerror: aborting due to previous error\r\n\r\nUsing git master HEAD: 6fcf43e50e9dd8ad8dc83d550e25f738f821f1ce\r\n"
13407,'jakub-','error: internal compiler error: node_id_to_type: no type for node `expr A::C (id=61)`\nHost OS: Linux Mint 15 x86_64\r\nrustc version: rustc 0.10-pre (6f1c06d 2014-04-03 03:42:02 -0700)\r\n\r\nTest case:\r\n\r\n```rust\r\nuse A::B;\r\npub mod A {\r\n  pub trait B {\r\n    fn new() -> Self;\r\n  }\r\n  pub struct C;\r\n  impl B for C {\r\n    fn new() -> C { C }\r\n  }\r\n}\r\n\r\npub fn test(param: ~A::B) {}\r\n\r\nfn main() {\r\n  test(A::C = B::new());\r\n}\r\n```'
13231,'nikomatsakis','opt-in built-in bounds traits RFC tracker\nThis is a tracking issue for the approved RFC [0003-opt-in-builtin-traits](https://github.com/rust-lang/rfcs/blob/master/active/0003-opt-in-builtin-traits.md)\r\n\r\nNominating'
13217,'brson',"Run valgrind on a bot\nWe are not running valgrind anywhere right now, even though the linux dist builder says it's enabling valgrind, valgrind is not installed on that machine.\r\n\r\nThe makefiles probably should not silently disable valgrind like they appear to be doing."
13159,'aturon',"unwrap/get/get_ref/take etc. conventions\nI'm sure there are other issues about this, which naturally I can't *find*. We need to make sure the conventions for these accessors are consistent for 1.0. Nominating."
12938,'nick29581',"Implement DST\nTracking bug for implementing DST (I'll file issues for the intermediate steps).\r\n\r\n@nick29581 to implement, @nikomatsakis to write an RFC for the RFC repo.\r\n\r\nNominating 1.0 (I think its already been discussed and agree that this blocks 1.0, if someone could tag this, it would be great).\r\n\r\nSub-bugs:\r\n========\r\n\r\n- [x] #12969: Add the unsized keyword \r\n- [x] #13120: Remove the `Sized` kind\r\n- [x] #13121: Allow the last field of a struct to be a DST \r\n- [x] #13367: Remove hack around requiring `Sized` bound in collect.rs\r\n- [x] #13376: Prevent storing and passing DST values\r\n- [x] #13554: Refactor ty_vec, avoiding vstore\r\n- [x] #13716: Implement coercion rules from `&[T, ..n]` to `&[T]`, etc.\r\n- [x] #13819: Refactor ty_str, avoiding vstore (follow up (#13834) - remove size field from ty_str)\r\n- [x] #12755: Coerce return values (needed for DST `&[T]` literals)\r\n- [x] #14869: Refactor ty_trait, avoiding tstore\r\n- [x] #15521 Implement syntax for unsized types. Currently `Sized?` looks like the favourite\r\n- [x] #16805 fat raw pointers\r\n- [ ] #17178 unify [T] with U in type inference (needs refactoring a lot of the libs, and/or trait reform, see #16918) - turns out we *really* need this. Doing anything non-trivial with DST requires it. I had hoped we could get away without for a while but that does not seem to be the case.\r\n- [ ] #19187 DST: trait objects should automatically implement the trait\r\n\r\nTasks which don't yet have issues\r\n===========================\r\n\r\n- [x] Add fat pointers to trans\r\n- [x] Indexing into fat pointer types in trans\r\n- [x] remove all the hackey support for old behaviour (where we treat `&[T]` differently from `&([T])`)\r\n- [x] structs\r\n- [ ] recursive coercions (pointers in structs) - needs some design work\r\n- [x] strings (but can only be instantiated using transmute)\r\n- [x] traits\r\n- [ ] use DST coercions for receiver when doing trait/method search (leaving this till post- NIko's cleanup of everything trait related, if we want to do it at all).\r\n- [ ] properly deal with type aliases which are traits (i.e., accept them everywhere a trait is accepted)\r\n"
12836,'jakub-','Lint for functions that don\'t return but aren\'t written as "-> !"\nI think this should warn: f never returns, but it claims to return int.\r\n\r\n    fn f() -> int {\r\n      fail!("f")\r\n    }\r\n\r\n    fn main() {\r\n      f();\r\n    }'
12604,'brson',"Put the doc language in the doc url\nAs suggested in http://ericholscher.com/blog/2014/feb/27/how-i-judge-documentation-quality/, our doc URLs should be future-proofed for translation by putting 'en' somewhere in them. Nominating."
12517,'alexcrichton','use correct naming for the comparison traits and add trait inheritance\n# Updated description\r\n\r\nThe target end point: https://gist.github.com/alexcrichton/10945968\r\n\r\n# Original issue\r\n\r\n* [x] rename `Ord` -> `PartialOrd`\r\n* [x] rename `TotalOrd` -> `Ord`\r\n* [x] rename `Eq` -> `PartialEq`\r\n* [x] rename `TotalEq` -> `Eq`\r\n* [x] `PartialOrd` inherits from `PartialEq`\r\n* [x] `Ord` inherits from `Eq`\r\n* [x] `Ord` inherits from `PartialOrd`\r\n* [x] `Eq` inherits from `PartialEq`\r\n* [x] remove `equals` method (`TotalEq` deriving needs to be redone)\r\n* [ ] deriving `Ord` also derives `PartialOrd`\r\n* [ ] deriving `Eq` also derives `PartialEq`\r\n\r\nAn implementation of `Eq` will simply mean that the `PartialEq` implementation provides equivalence rather than partial equivalence. An `Ord` implementation will add a single `cmp` method and the guarantee of the `PartialOrd` implementation providing a total order.\r\n\r\nThis allows code generic over `Float` to use the operators, since it will inherit from `PartialEq` and `PartialOrd`. Code generic over `Eq` and `Ord` will also be able to use the operators, despite not being designed to handle a partial order.'
12466,'brson','Fix googleability of docs\nGoogling for Rust documentation gives very inconsistent results, often to very old docs. Newbies often are led astray.\r\n\r\nOld description:\r\n\r\nThis is a topic I haven\'t paid much attention to, but it\'s important, and I know our googlability has traditionally been very bad. I don\'t know at all what needs to be done off hand but it\'s something we should dedicate some effort to.\r\n\r\nNominating.\r\n\r\nTasks:\r\n\r\n* [x] description and keyword meta for home page\r\n* [ ] description and keyword meta for standalone docs (needs #16178)\r\n* [x] description and keyword meta for crate docs\r\n* [x] descriptive titles for standalone docs\r\n* [ ] teach rustdoc to meta (https://github.com/rust-lang/rust/issues/16178)\r\n* [ ] add `<link rel="canonical">` to docs (needs #16178)\r\n'
12363,'brson','`make install` starts rebuilding stage0 after a just completed `make`\n```sh\r\njurily ~/p/e/rust $ rm -rf build\r\njurily ~/p/e/rust $ mkdir build; and cd build\r\njurily ~/p/e/r/build $ ../configure --enable-fast-make --prefix=~/sys/\r\nconfigure: looking for configure programs\r\n<snip>\r\njurily ~/p/e/r/build $ smake\r\ncfg: build triple x86_64-unknown-linux-gnu\r\ncfg: host triples x86_64-unknown-linux-gnu\r\n<snip>\r\noxidize: x86_64-unknown-linux-gnu/stage2/lib/rustlib/x86_64-unknown-linux-gnu/lib/librustdoc\r\n67m 11s jurily ~/p/e/r/build $ make install\r\ncfg: build triple x86_64-unknown-linux-gnu\r\ncfg: host triples x86_64-unknown-linux-gnu\r\ncfg: target triples x86_64-unknown-linux-gnu\r\ncfg: enabling more debugging (CFG_ENABLE_DEBUG)\r\ncfg: host for x86_64-unknown-linux-gnu is x86_64\r\ncfg: os for x86_64-unknown-linux-gnu is unknown-linux-gnu\r\ncfg: using gcc\r\ncfg: no node found, omitting docs\r\ncfg: including prepare rules\r\ncfg: including install rules\r\noxidize: x86_64-unknown-linux-gnu/stage0/lib/rustlib/x86_64-unknown-linux-gnu/lib/libstd\r\n```'
11053,'alexcrichton',"LocalIo is unsafe and should not be.\nThe current implementation of `LocalIo` involves unsafe borrowing which doesn't transfer ownership of the `IoFactory`. This unsafe code allows for mutably aliasing the `IoFactory` multiple times on the stack (leading to memory unsafety).\r\n\r\nFixing this would involve dancing around transferring ownership of the `IoFactory` between the calls that it makes. My initial idea was for `LocalIo` to take ownership and give out `&mut` loans to it, but this is insufficient because when a green task context switches the scheduler must again have ownership of the `IoFactory`.\r\n\r\nMy best idea for doing this right now is to change all methods on `IoFactory` to take `~self` and then right before the M:N methods block they would transfer ownership back to the scheduler. All the 1:1 methods would basically immediately return ownership of the factory back to the local `Task`."
11043,'alexcrichton',"Investigate whether dumb_println can be removed\nIn #10965, I have made the runtime's dumb_println function much less useful. Try to delete it (after the PR lands)"
10337,'nikomatsakis',"Clarify and document operator overloading trait matching rules etc\nOur current trait matching rules for operator overloading are somewhat ad-hoc. I've got a branch which implements a more straightforward set of rules, which I think is what we want for 1.0 going forward. Part of completing this bug will be updating the docs.\r\n\r\nThe rules I've in mind can be summarized as:\r\n\r\nGiven an expression `l op r` where `op` is a binary operator and `l : L` and `r : R`:\r\n- We search for a trait `impl Op<R,T> for L`. Note that there is no attempt to autoderef `l` and so forth.\r\n- At runtime we'll pass in `&l` and `&r` to the trait method (as is reflected in the `&self` type etc).\r\n- The type of `l op r` is `T`."
9456,'alexcrichton','format! should support multiple formats for one argument\nTake something like the following format string:\r\n\r\n```rust\r\nformat!("{a:?} is {a}", a = "foo\\u2014bar")\r\n```\r\n\r\nI *expect* this to produce the string `"foo\\u2014bar" is foo—bar`.\r\n\r\nHowever, what it actually produces is `"foo\\u2014bar" is "foo\\u2014bar"`; the behaviour of the second placeholder has changed from using `Default` to using `Poly`.\r\n\r\nIf I make the type difference explicit with the format string `"{a:?} is {a:s}"`, then I get a compilation error, which, although not what I wanted, at least *tells* me I can\'t do what I\'m trying to do:\r\n\r\n```\r\n0.rs:2:50: 2:64 error: argument redeclared with type `s` when it was previously `?`\r\n0.rs:2     println!("a is {a:?} (literally, {a:s})", a = "foo\\u2014bar");\r\n                                                         ^~~~~~~~~~~~~~\r\nerror: aborting due to previous error\r\n```\r\n\r\nMy problem is with the implicit change of behaviour for named arguments from using `Default` to using what was done last. This distinctly confused me when I came across it. If using an argument with different formatting constraints is not possible (I don\'t see why this constraint is there, truth to tell) then I believe the unspecified format should still be interpreted as `Default` rather than what-was-done-last, and an error raised rather than this surprising behaviour.'
8861,'nikomatsakis','New destructor semantics\nWe agreed in a meeting to replace the unsafe destructor code with the rule that a value with a destructor must only contain values of lifetime *strictly greater* than the value to be destructed. The idea is to prevent values from referencing one another. Permitting borrowed values in destructors enables a number of RAII causes and helps to eliminate the need for once fns. This also relies on the change to prevent `&` pointers from being placed within managed boxes (which I think has already been made).\r\n\r\nI have to figure out precisely how to formalize this rule still. =)\r\n\r\nNominating for backwards compat.'
7211,'nikomatsakis',"incorrect borrow conflict with temporary borrow\n```rust\r\n    pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\r\n        /*!\r\n         * Determines whether two free regions have a subregion relationship\r\n         * by walking the graph encoded in `free_region_map`.  Note that\r\n         * it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\r\n         * (that is, the user can give two different names to the same lifetime).\r\n         */\r\n\r\n        if sub == sup {\r\n            return true;\r\n        }\r\n\r\n        // Do a little breadth-first-search here.  The `queue` list\r\n        // doubles as a way to detect if we've seen a particular FR\r\n        // before.  Note that we expect this graph to be an *extremely\r\n        // shallow* tree.\r\n        let mut queue = ~[sub];\r\n        let mut i = 0;\r\n        while i < queue.len() {\r\n            match self.free_region_map.find(&queue[i]) {\r\n                Some(parents) => {\r\n                    for parents.each |parent| {\r\n                        if *parent == sup {\r\n                            return true;\r\n                        }\r\n\r\n                        if !queue.iter().contains_(&parent) {\r\n                            queue.push(*parent);\r\n                        }\r\n                    }\r\n                }\r\n                None => {}\r\n            }\r\n            i += 1;\r\n        }\r\n        return false;\r\n    }\r\n\r\n```\r\n\r\n```\r\n/home/strcat/projects/rust/src/librustc/middle/region.rs:206:28: 206:33 error: cannot borrow `queue` as mutable because it is also borrowed as immutable\r\n/home/strcat/projects/rust/src/librustc/middle/region.rs:206                             queue.push(*parent);\r\n                                                                                         ^~~~~\r\n/home/strcat/projects/rust/src/librustc/middle/region.rs:205:28: 205:33 note: second borrow of `queue` occurs here\r\n/home/strcat/projects/rust/src/librustc/middle/region.rs:205                         if !queue.iter().contains_(&parent) {\r\n                                                                                         ^~~~~\r\n\r\n```\r\n\r\nThis happens with the expression done in a block by itself with the `bool` result stored in a variable too. It's not related to it being in the `if` statement's conditional.\r\n\r\nI'm finding it hard to reproduce a simple example, I'll get one here when I have time."
6393,'zwarich','borrow scopes should not always be lexical\nIf you borrow immutably in an `if` test, the borrow lasts for the whole `if` expression. This means that mutable borrows in the clauses will cause the borrow checker to fail.\r\n\r\nThis can also happen when borrowing in the match expression, and needing a mutable borrow in one of the arms.\r\n\r\nSee here for an example where the if borrows boxes, which causes the nearest upwards `@mut` to freeze. Then `remove_child()` which needs to borrow mutably conflicts.\r\n\r\nhttps://github.com/mozilla/servo/blob/master/src/servo/layout/box_builder.rs#L387-L411\r\n\r\n'
5244,'nikomatsakis',"should be possible to do [CopyableVariant, ..n] for a non-copyable type\nThis should be fixable by special casing this (the type isn't copyable, but for this specific case the variant is).\r\n\r\nThis problem only exists with fixed-size vectors since `vec::from_fn(10, |_| None)` works with non-copyable types.\r\n\r\n@nikomatsakis thinks this should be fixable"
5016,'pnkfelix','remove the necessity of "zeroing out" from codegen\nThe current liveness check has a concept of "alive" and "maybe dead", so I\'ll just describe this in terms of a hypothetical "move optimization pass" (although liveness can probably be extended with "surely dead").\r\n\r\n### Hypothetical move optimization pass:\r\n\r\nIn each scope where they exist, all variables are given an associated boolean representing whether they were *certainly* moved from. Moving from a variable in a scope marks it as such for that scope. This can be bubbled up if and only if the variable is also moved from in every other branch.\r\n\r\nIf the compiler can bubble this up to the scope where the variable is declared, the drop glue can be omitted and all moves from that variable do not need to zero it.\r\n\r\nThis can probably be extended to fields too, but I\'m not sure on what the semantics would be.\r\n\r\n@nikomatsakis: does this look like something that would be reasonable to implement (probably as part of liveness)? It doesn\'t actually need to bubble it up to be useful - even if it only worked in a local scope, it would allow the destructor of the `save` variable in the TreeMap `split` and `skew` functions to be omitted (since it\'s moved from in the same scope where it\'s declared) and that would be a big performance win.'
4704,'nikomatsakis','Possibly change the ordering of integer-literal inference and method selection.\n```\r\nfn sub(i: int) { for i.times {} }\r\nfn main() {}\r\n```\r\n\r\n```\r\ntest.rs:1:17: 1:31 error: type `int` does not implement any method in scope named `times`\r\ntest.rs:1 fn sub(i: int) { for i.times {} }\r\n                           ^~~~~~~~~~~~~~\r\nerror: aborting due to previous error\r\n```\r\n\r\nThis works in master(2372d2c) but is broken in incoming(42b462e).'
4639,'jakub-','Lint warning for pattern bindings with the same name as a variant\nRelated to #4612 and #3070, it would be good to have a lint rule like: If there is ever a variable binding "foo" whose type is an enum E that includes a variant named "foo", report a warning.  This should probably be done in the exhaustiveness or type checker so that the warning is reported early in compilation.\r\n\r\nI\'m tossing on the 1.0 list as another of those "very nice to have when you are dotting your i\'s and crossing your t\'s" sort of things.'
3478,'nikomatsakis',"tests for cleanup in guards\nI realized I forgot to ensure that there are tests for cleanup of by-value bindings in match guards.  For example, if the guard should fail, or be false, we have to be sure we don't leak.  Similarly, just testing that if the guard is taken, cleanup occurs---there may not be good dedicated tests for that either."
3417,'nikomatsakis',"better mismatched types error message\nThese are great error messages but most of the time they're quite hard to read because they are so long. They would be much more readable if they were six lines instead of one line.\n\nSo instead of\n```\nsrc/configuration.rs:179:54: 179:70 error: mismatched types: expected `@std::map::chained::hashmap_<@~str,mustache::mustache::Data>` but found `@std::map::chained::hashmap_<~str,mustache::mustache::Data>` (expected @-ptr but found ~str)\n```\n\nsomething like\n```\nsrc/configuration.rs:179:54: 179:70 error: mismatched types\nexpected:\n    `@std::map::chained::hashmap_<@~str,mustache::mustache::Data>` \nbut found: \n    `@std::map::chained::hashmap_<~str,mustache::mustache::Data>` \nexpected @-ptr but found ~str\n```"
2262,'nikomatsakis',"freeze type vars after structure is extracted\nI'm pretty sure that it is possible for the following things to happen today:\r\n\r\n1. We infer a type with bounds X <: T <: top\r\n2. We resolve T structurally based on X\r\n3. T acquires an upper bound and perhaps migrates away\r\n\r\nI don't have a specific bad example, but I think it could lead to inconsistencies, perhaps with impl dispatch, perhaps elsewhere.  This issue is kind of a note to myself to come up with some examples and make some tests and be sure we're ok.  I think what it amounts to is that whenever we do a type-dependent operation, we should go back and assert this type as the upper-bound, so that the type inferencer doesn't come away with a more liberal upper-bound. \r\n\r\nOur quite limited subtyping might also make this less relevant."
2190,'nikomatsakis','Closure inference is based on expected type\n**UPDATE:** I updated the title to reflect the root problem. "Closure inference" refers to detailing the specifics of a closure type, such as its bounds and so forth. Ideally, only the argument types would derive from the expected type (with a fallback to fresh type variables).\r\n\r\noriginal issue report follows:\r\n\r\n```\r\ntype t = {\r\n    f: fn~()\r\n};\r\n\r\nfn main() {\r\n    let _t: t = { f: {||()} };\r\n}\r\n```\r\n\r\n```\r\n../src/test/run-pass/test.rs:6:16: 6:29 error: mismatched types: expected `t` but found `{f: fn@()}` (in field `f`, closure protocol mismatch (fn~ vs fn@))\r\n../src/test/run-pass/test.rs:6     let _t: t = { f: {||()} };\r\n```'
2092,'brson','FAQ links in error messages\nOn IRC we were discussing how, for complex errors, we ought to put a link to a FAQ in the error message.  Perhaps we could even embed the rust manual and print the relevant paragraph if you use `rustc --explain` or something.  \r\n\r\nSome examples of errors that could benefit:\r\n\r\n- `ret` disallowed from within sugared closure `{|| ... }`\r\n- `;` required after a statement with non-unit type\r\n- etc.\r\n\r\nThis of course would also entail *making* such a FAQ. :)'
1920,'nikomatsakis','absolute path names are not correct for crates not in root namespace\nRight now, if you get the absolute path of an item using the `ty::item_path()` function, and that item is an external crate `x`, you always get a path like `x::foo::bar` where `foo::bar` is the path to the item within the crate `x`.  This is usually right but not always, because it is possible that the crate `x` is not linked into the root namespace.\r\n\r\nFor example, you might have:\r\n\r\n```\r\nmod local_mod {\r\n    use x;\r\n    ...\r\n}\r\n```\r\n\r\nin which case the right path would be `local_mod::x::foo::bar`.  \r\n\r\nTo fix this, we ought to store some valid path to the crate along with the crate metadata (preferably a shortest path [there could be more than one shortest path]).  We can then prepend this path.  The function `csearch.rs:get_item_path()` would be the primary one to change.\r\n\r\n'
