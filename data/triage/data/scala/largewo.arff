@relation large.json
@attribute id integer
@attribute owner string
@attribute content string
@data
4124,'gkossakowski',"SI-7521 Fix erasure of parametric value classes.\n`Erasure.boxingErasure` exists to ensure that we use boxed primitives\nto represent the value, if the value class has type parameters\nreferred to by its element type.\n\nHowever, this is implenented with a type map that runs deeply\nacross the type. In the enclosed test case, we have\n`Repr=Array[Int]`, which should be erased to `Array[Int]`, _not_\nto `Array[Integer]`.\n\nThis commit ensures that the `boxingErasure` map only applies\nboxing at the top level, and not within array arguments. (Other\ntype arguments will be erased, so we don't have to deal with them.)\n\nReview by @gkossakowski"
4121,'gkossakowski',"SI-5938 Test for a FSC bug with mixin, duplicate static forwarders\nUnder resident compilation, we were getting multiple copies of static\nforwarders created for mixed in methods. It seems like the bug was\nfixed as a by-product of #4040.\n\nThis commit adds a test to show this. I've confirmed that the test\nfails appropriately with 2.11.4.\n\nFor future reference, before I figured out how to write the test\nfor this one (test/resident doesn't seem to let you run the code\nafter compiling it), I was using bash to test as follows:\n\n    (export V=2.11.x; (scalac-hash $V sandbox/t5938_1.scala; (for i in 1 2; do echo sandbox/t5938.scala; done; printf '\\n') | scalac-hash $V  -Xresident); stty echo; scala-hash $V X ; echo ':javap -public X' | scala-hash $V);\n\nReview by @gkossakowski"
4118,'adriaanm','SI-5639 Fix spurious discarding of implicit import\nIn Scala fa0cdc7b (just before 2.9.0), a regression in implicit search,\nSI-2866, was discovered by Lift and fixed. The nature of the regression was\nthat an in-scope, non-implicit symbol failed to shadow an eponymous\nimplicit import.\n\nThe fix for this introduced `isQualifyingImplicit` which discards in-scope\nimplicits when the current `Context`\'s scope contains a name-clashing\nentry.\n\nIncidentally, this proved to be a shallow solution, and we later improved\nshadowing detection in SI-4270 / 9129cfe9. That picked up cases where a\nlocally defined symbol in an intervening scope shadowed an implicit.\n\nThis commit includes the test case from the comments of SI-2866. Part of it\nis tested as a neg test (to test reporting of ambiguities), and the rest is\ntested in a run test (to test which implicits are picked.)\n\nHowever, in the test case of SI-5639, we see that the scope lookup\nperformend by `isQualifyingImplicit` is fooled by a "ghost" module symbol.\nThe apparition I\'m referring to is entered when\n`initializeFromClassPath` / `enterClassAndModule` encounters a class file\nnamed \'Baz.class\', and speculatively enters _both_ a class and module\nsymbol. AFAIK, this is done to defer parsing the class file to determine\nwhat inside. If it happens to be a Java compiled class, the module symbol\nis needed to house the static members.\n\nThis commit adds a condition that `Symbol#exists` which shines a torch\n(forces the info) in the direction of the ghost module symbol. In our test,\nthis causes it to vanish, as we only need a class symbol for the Scala\ndefined `class Baz`.\n\nThe existing `pos` test for this actually did not exercise the bug,\nseparate compilation is required. It was originally checked in to\n`pending` with this error, and then later moved to `pos` when someone\nnoticed it was not failing.\n\nTo be conservative, I\'ve predicated this fix in `-Xsource:2.12`. This is\ndone in separate commit to show that the previous fix passes the test\nsuite, rather than just tests with `-Xsource:2.12`.\n\nReview by @adriaanm'
4117,'adriaanm','SI-8449 Fix spurious error with Java raw type over a Scala class\nWhen the Scala typechecker typechecks signatures in Java sources,\nit must enable use of a type constructor without applied type\narguments (a raw type).\n\nHowever, the check in `adaptType::properTypeRequired` was too\nrestricive: it only allows raw types given a) we are typechecking a\nJava source file and b) the type constructor itself is Java defined.\n\nThe second check does not make sense; it is perfectly legal to define\na Java raw type for over a Scala defined type constructor. This commit\nremoves it.\n\nThe bug was noticed in the Scaladoc context, as it explores the\nsignatures of all Java sources so it can document them. But the\nenclosed test demonstrates the underlying bug under normal\ncompilation.\n\nReview by @adriaanm'
4116,'lrytz','SI-5413 Test for fixed owner-corruption bug with names/defaults\nFixed in SI-8111 / 2.10.4.\n\nReview by @lrytz'
4115,'adriaanm','SI-8597 Improved pattern unchecked warnings\nThe spec says that `case _: List[Int]` should be always issue\nan unchecked warning:\n\n> Types which are not of one of the forms described above are\n> also accepted as type patterns. However, such type patterns\n> will be translated to their erasure (§3.7). The Scala compiler\n> will issue an “unchecked” warning for these patterns to flag\n> the possible loss of type-safety.\n\nBut the implementation goes a little further to omit warnings\nbased on the static type of the scrutinee. As a trivial example:\n\n   def foo(s: Seq[Int]) = s match { case _: List[Int] => }\n\nneed not issue this warning.\n\nThese discriminating unchecked warnings are domain of\n`CheckabilityChecker`.\n\nLet\'s deconstruct the reported bug:\n\n  def nowarn[T] = (null: Any) match { case _: Some[T] => }\n\nWe used to determine that if the first case matched, the scrutinee\ntype would be `Some[Any]` (`Some` is covariant). If this statically\nmatches `Some[T]` in a pattern context, we don\'t need to issue an\nunchecked warning. But, our blanket use of `existentialAbstraction`\nin `matchesPattern` loosened the pattern type to `Some[Any]`, and\nthe scrutinee type was deemed compatible.\n\nI\'ve added a new method, `scrutConformsToPatternType` which replaces\npattern type variables by wildcards, but leaves other abstract\ntypes intact in the pattern type. We have to use this inside\n`CheckabilityChecker` only. If we were to make `matchesPattern`\nstricter in the same way, tests like `pos/t2486.scala` would fail.\n\nI have introduced a new symbol test to (try to) identify pattern\ntype variables introduced by `typedBind`. Its not pretty, and it\nmight be cleaner to reserve a new flag for these.\n\nI\'ve also included a test variation exercising with nested matches.\nThe pattern type of the inner case can\'t, syntactically, refer to the\npattern type variable of the enclosing case. If it could, we would\nhave to be more selective in our wildcarding in `ptMatchesPatternType`\nby restricting ourselves to type variables associated with the closest\nenclosing `CaseDef`.\n\nAs some further validation of the correctness of this patch,\nfour stray warnings have been teased out of\nneg/unchecked-abstract.scala\n\nI also had to changes `typeArgsInTopLevelType` to extract the type\narguments of `Array[T]` if `T` is an abstract type. This avoids the\n"Checkability checker says \'Uncheckable\', but uncheckable type\ncannot be found" warning and consequent overly lenient analysis.\nWithout this change, the warning was suppressed for:\n\n    def warnArray[T] = (null: Any) match { case _: Array[T] => }'
4114,'adriaanm','SI-8534 Avoid crash in erroneous SelectFromTypeTree\nPR #2374 changed the behaviour of `typedSingletonTypeTree` in the\npresence of an error typed reference tree. It incorrectly\nreturns the reference tree in case on an error. However, this is\na term tree, which is an inconsistent result with the input type\ntree. Consequently, a `typedSelectInternal` later fails when\nusing this as the qualifier of a `SelectFromTypeTree`.\n\nBoth test cases enclosed show this symptom.\n\nThis commit:\n\n  - Returns `tree` rather than `refTyped` when `refTyped` is\n    error typed or when it isn\'t suitable as a stable prefix.\n  - Avoids issuing a cascading "not a stable prefix" error if the\n    `refTyped` is error typed.\n  - Adds an extra layer of defense in `typedSelectFromTypeTree`\n    to bail out quickly if the qualifier is error typed.\n\nThe last measure is not necessary to fix this bug.\n\nReview by @adriaanm'
4113,'adriaanm','SI-8967 Only add JARs and dirs from $SCALA_HOME/lib to classpath\nThat\'s all we ship in that directory, but it seems that some\r\nJVMs freak out with a core dump if something else ends up\r\nin that directory and we add it to the boot classpath.\r\n\r\nTesting on unix:\r\n\r\n```\r\n    % rm ./build/pack/bin.complete; ant\r\n    % touch /Users/jason/code/scala/build/pack/lib/foo.txt\r\n    % mkdir /Users/jason/code/scala/build/pack/lib/dir\r\n  \xa0 % bash -x ./build/pack/bin/scala -version\r\n    ...\r\n    /Library/Java/JavaVirtualMachines/jdk1.8.0_20.jdk/Contents/Home/bin/java -Xmx256M -Xms32M -Xbootclasspath/a:/Users/jason/code/scala/build/pack/lib/dir:/Users/jason/code/scala/build/pack/lib/jline.jar:/Users/jason/code/scala/build/pack/lib/scala-actors.jar:/Users/jason/code/scala/build/pack/lib/scala-compiler.jar:/Users/jason/code/scala/build/pack/lib/scala-continuations-library_2.11-1.0.2.jar:/Users/jason/code/scala/build/pack/lib/scala-continuations-plugin_2.11.2-1.0.2.jar:/Users/jason/code/scala/build/pack/lib/scala-library.jar:/Users/jason/code/scala/build/pack/lib/scala-parser-combinators_2.11-1.0.2.jar:/Users/jason/code/scala/build/pack/lib/scala-partest-extras.jar:/Users/jason/code/scala/build/pack/lib/scala-partest-javaagent.jar:/Users/jason/code/scala/build/pack/lib/scala-reflect.jar:/Users/jason/code/scala/build/pack/lib/scala-swing_2.11-1.0.1.jar:/Users/jason/code/scala/build/pack/lib/scala-xml_2.11-1.0.2.jar:/Users/jason/code/scala/build/pack/lib/scalap.jar -classpath \'""\' -Dscala.home=/Users/jason/code/scala/build/pack -Dscala.usejavacp=true -Denv.emacs= scala.tools.nsc.MainGenericRunner -version\r\n```\r\n\r\nThe boot classpath contains `build/pack/lib/dir` but not `foo.txt`.\r\n\r\nI will seek a Windows test of the same during PR review.\r\n\r\nReview by @gourlaysama'
4103,'gkossakowski',"SI-5938 Test for a FSC bug with mixin, duplicate static forwarders\nUnder resident compilation, we were getting multiple copies of static\r\nforwarders created for mixed in methods. It seems like the bug was\r\nfixed as a by-product of #4040.\r\n\r\nThis commit adds a test to show this. I've confirmed that the test\r\nfails appropriately with 2.11.4.\r\n\r\nFor future reference, before I figured out how to write the test\r\nfor this one (test/resident doesn't seem to let you run the code\r\nafter compiling it), I was using bash to test as follows:\r\n\r\n    (export V=2.11.x; (scalac-hash $V sandbox/t5938_1.scala; (for i in 1 2; do echo sandbox/t5938.scala; done; printf '\\n') | scalac-hash $V  -Xresident); stty echo; scala-hash $V X ; echo ':javap -public X' | scala-hash $V);\r\n\r\nReview by @gkossakowski"
4102,'adriaanm','SI-8965 Account for corner case in "unrelated types" warning\nIt\'s okay for the two types to LUB to something above `Object`\nif they both individially were its supertype.'
4099,'gkossakowski','SI-7596 Curtail overloaded symbols during unpickling\nIn code like:\n\n    object O { val x = A; def x(a: Any) = ... }\n    object P extends O.x.A\n\nThe unpickler was using an overloaded symbol for `x` in the\nparent type of `P`. This led to compilation failures under\nseparate compilation.\n\nThe code that leads to this is in `Unpicklers`:\n\n    def fromName(name: Name) = name.toTermName match {\n      case nme.ROOT     => loadingMirror.RootClass\n      case nme.ROOTPKG  => loadingMirror.RootPackage\n      case _            => adjust(owner.info.decl(name))\n    }\n\nThis commit filters the overloaded symbol based its stability\nunpickling a singleton type. That seemed a slightly safer place\nthan in `fromName`.\n\nResubmission of #2664 incorporating review from @gkossakowski.\n\nReview by @gkossakowski :)'
4097,'adriaanm','SI-7602 Avoid crash in LUBs with erroneous code\nIf a class contains a double defintion of a method that overrides\nan interface method, LUBs could run into a spot where filtering\noverloaded alternatives to those that match the interface method\nfails to resolve to a single overload, which crashes the compiler.\n\nThis commit uses `filter` rather than `suchThat` to avoid the crash.'
4095,'lrytz','Fix problems in Symbol Literal static caching\nDetails in the commit messages.\n\nReview by @soc / @lrytz'
4088,'lrytz','GenBCode: cleanup optimizations\nMethod-level cleanup optimizations.\r\n\r\nSee individual commit messages.'
4084,'Ichoran','Correct collections variable definitions to avoid many scaladoc warnings.\nRunning \'ant docs.lib\' produces such a long warning list that nobody seems to care. Consequently the documentation for stdlib contains many errorneous signatures.\r\n\r\nThis PR addresses most of the "Unresolved $Coll when documenting XXX" warnings and reduces scaladoc output from 1600 to 400 lines. Since this is a pure documentation change, it is safe to merge in 2.11.x'
4083,'xeno-by','SI-8947 Avoid cross talk between tag materializers and reify\nAfter a macro has been expanded, the expandee are expansion are\nbidirectionally linked with tree attachments. Reify uses the back\nreference to replace the expansion with the expandee in the reified\ntree. It also has some special cases to replace calls to macros\ndefined in scala-compiler.jar with `Predef.implicitly[XxxTag[T]]`.\nThis logic lives in `Reshape`.\n\nHowever, the expansion of a macro may be `EmptyTree`. This is the case\nwhen a tag materializer macro fails. User defined macros could do the\nalso expand to `EmptyTree`. In the enclosed test case, the error\nmessage that the tag materializer issued ("cannot materialize\nclass tag for unsplicable type") is not displayed as the typechecker\nfinds another means of making the surrounding expression typecheck.\n\nHowever, the macro engine attaches a backreference to the materializer\nmacro on `EmpytyTree`!\n\nLater, when `reify` reshapes a tree, every occurance of `EmptyTree`\nwill be replaced by a call to `implicitly`.\n\nThis commit expands the domain of `CannotHaveAttrs`, which is mixed\nin to `EmptyTree`. It silently ignores all attempts to mutate\nattachments.\n\nUnlike similar code that discards mutations of its type and position,\nI have refrained from issuing a developer warning in this case, as\nto silence this I would need to go and add a special case at any\nplaces adding attachments.\n\nReview by @xeno-by @densh'
4079,'lrytz',"SI-8941 Idempotent presentation compilation of implicit classes\nWhen we name an implicit class, `enterImplicitWrapper` is called,\r\nwhich enters the symbol for the factory method into the\r\nowning scope. The tree defining this factory method is stowed into\r\n`unit.synthetics`, from whence it will be retrieved and incorporated\r\ninto the enclosing tree during typechecking (`addDerivedTrees`).\r\nThe entry in `unit.synthetics` is removed at that point.\r\n\r\nHowever, in the presentation compiler, we can typecheck a unit\r\nmore than once in a single run. For example, if, as happens\r\nin the enclosed test, a call to ask for a type at a given\r\nposition interrupts type checking of the entire unit, we\r\ncan get into a situation whereby the first type checking\r\ninvocation has consumed the entry from `unit.synthetics`,\r\nand the second will crash when it can't find an entry.\r\n\r\nSimilar problems have been solved in the past in\r\n`enterExistingSym` in the presentation compiler. This method\r\nis called when the namer encounters a tree that already has\r\na symbol attached. See 0b78a0196 / 148736c3df.\r\n\r\nThis commit takes a two pronged approach.\r\n\r\nFirst, `enterExistingSym` is extended to handle implicit classes.\r\nAny previous factory method in the owning scope is removed, and\r\n`enterImplicitWrapper` is called to place a new tree for the factory\r\ninto `unit.synthetics` and to enter its symbol into the owning scope.\r\n\r\nSecond, the assertions that could be tripped in `addDerivedTrees`\r\nand in `ImplicitClassWrapper#derivedSym` have been converted to\r\npositioned errors.\r\n\r\nThe first change is sufficient to fix this bug, but the second\r\nis also enough to make the enclosed test pass, and has been retained\r\nas an extra layer of defence.\r\n\r\nReview by @lrytz / @dragos"
4068,'gkossakowski',"SI-8925, SI-7407 test cases, fixed in new backend\nGiven that the issue exists is old (2.10) and we move to the new\r\nbackend in 2.12, I don't plan to fix it in GenASM.\r\n\r\nThe test case for 7407 existed already, this commit just adds\r\n`-Yopt:l:none` to the flags to make no dead code is eliminated."
4065,'Ichoran',"Propsing a simple addition to collections API\nI often find myself in need of a method like `groupWhile` (it similar in essence to `takeWhile`, and hence the name). so far I've written similar solutions using `foldLeft` or `span`, but it is less convinient to use."
4055,'lrytz',"Update copyright notices in source code to 2014\nI used this command:\n\n    % git grep -l --null Copyright | xargs -0 -n 1 perl -p -i -e 's/(Copyright\\s+(20..-|))(20(09|10|11|12|13))(\\b.*(LAMP|Typesafe).*)/${1}2014$5/g'"
4045,'retronym','SI-8875 showCode should print all class constructor modifiers.\nshowCode used to print nothing when the only modifier was a change in\r\nvisibility scope (i.e. no flags but privateWithin is set).'
4043,'lrytz',"SI-3439 Fix use of implicit constructor params in super call\nWhen typechecking the primary constructor body, the symbols of\nconstructor parameters of a class are owned by the class's owner.\nThis is done make scoping work; you shouldn't be able to refer to\nclass members in that position.\n\nHowever, other parts of the compiler weren't so happy about\nthis arrangement. The enclosed test case shows that our\nchecks for invalid, top-level implicits was spuriously triggered,\nand implicit search itself would fail.\n\nFurthermore, we had to hack `Run#compiles` to special case\ntop-level early-initialized symbols. See SI-7264 / 86e6e9290.\n\nThis commit:\n\n  - introduces an intermediate local dummy term symbol which\n    will act as the owner for constructor parameters and early\n    initialized members\n  - adds this to the `Run#symSource` map if it is top level\n  - simplifies `Run#compiles` accordingly\n  - tests this all in a top-level class, and one nested in\n    another class.\n\nReview by @lrytz.\n\nUp for discussion: this might need to target `-Xsource:2.12`\nas it could introduce a new candidate implicit in the super call."
4042,'adriaanm',"SIP-14 improvements\n Add missing canonical combinators:\r\n\r\n  - `def transform[S](f: Try[T] => Try[S])(implicit executor: ExecutionContext): Future[S]`\r\n  - `def transformWith[S](f: Try[T] => Future[S])(implicit executor: ExecutionContext): Future[S]`\r\n  - `def flatten[S](implicit ev: T <:< Future[S]): Future[S]`\r\n  - `def zipWith[U, R](that: Future[U])(f: (T, U) => R)(implicit executor: ExecutionContext): Future[R]`\r\n\r\nAdd missing utilities:\r\n  -  `val unit: Future[Unit]` in `object Future`\r\n  -  `val never: Future[Nothing]` in `object Future`\r\n  -  `def defaultBlockContext: BlockContext` in `object BlockContext`\r\n\r\nRefactors:\r\n  - the `scala.concurrent.Future` trait to not explicit create any `Promises`,\r\n    so that implementations can control implementation type,\r\n    this is mainly facilitated through adding of the `transform` and `transformWith` methods.\r\n  - the implementation of `ExecutionContextImpl` has been cleaned up\r\n\r\nSecuring:\r\n  - Add a self-check in `completeWith` and `tryCompleteWith` to avoid cycles in trait Promise\r\n  - Capping the maximum number of threads for the global `ExecutionContext` to the max parallelism\r\n  - Implementing (almost) all `Future` combinators on `transformWith` and `transform` means\r\n     that `DefaultPromise` linking works on both `(flat)map` and `recover(With)`\r\n  - Nested `blocking {}` should not spawn extra threads beyond the first.\r\n\r\nRemoves:\r\n  - the private `internalExecutor` method in favor of an import in trait `Future`\r\n  - the private `internalExecutor` method in favor of an import in trait `Promise`\r\n  - the `AtomicReferenceFieldUpdater` in `AbstractPromise` since we're using `Unsafe`\r\n  - `scala.concurrent.impl.Future` is no longer needed\r\n\r\nDeprecates:\r\n  - `Future.onSuccess` - discourage the use of callbacks\r\n                         (and is also redundant considering `foreach` and `onComplete`)\r\n  - `Future.onFailure` - discourage the use of callbacks\r\n                       (and is also redundant considering `onComplete` and `failed.foreach`)\r\n  - `ExecutionContext.prepare` - it was ill specced and it is too easy to forget to call it\r\n                     (or even know when to call it or call it more times than needed)\r\n\r\nReimplements:\r\n  - `failed` - in terms of `transform`\r\n  - `map` - in terms of `transform`\r\n  - `flatMap` - in terms of `transformWith`\r\n  - `recover` - in terms of `transform`\r\n  - `recoverWith` - in terms of `transformWith`\r\n  - `zip` - in terms of `flatMap` + `map`\r\n  - `fallbackTo` - in terms of `recoverWith` + `recoverWith`\r\n  - `andThen` - in terms of `transform`\r\n\r\nMiscellaneous:\r\n  - Giving the threads of `ExecutionContext.global` sensible names\r\n\r\nDocumentation:\r\n  - Almost all methods on `Future` and `Promise` have been revisited and had their ScalaDoc updated\r\n\r\nTests:\r\n  - Yes"
4040,'lrytz',"FSC / REPL Bug Bonanza\nThe big contribution here is to change `adaptInfos` to\nstart with a clean slate (a one element type history)\non subsequent runs. I did the same a while back for package\nclasses, this is an generalization of that idea. This ensures\nthat all info transformers are run, importantly the side-effecty\nones.\n\nThis fixes a regression in specialization in the REPL, which\nwas a latent bug uncovered by our recent fix to `perRunCaches`.\n\nThe other changes are similarly themed, being more disciplined\nwhen reading or mutating the type history.\n\nSubmitting for a test run and initial review by @lrytz. The commit\nmessages might need some fleshing out as I've been a little bit\nhand wavy in a few of my explanations where I wasn't able to\nprecisely explain *why* the fix works."
4036,'retronym',"SI-8893 Restore linear perf in TailCalls with nested matches\nDetails in the individual commits. The one with SI-8893 in the commit\r\ntitle offers the biggest win.\r\n\r\nI'd ask for some help from the kindly reviewer to understand why\r\nthat fixed exponential performance, rather than just giving\r\na constant factor speedup.\r\n\r\nReview by @adriaanm"
4028,'lrytz',"Avoid ClassfileAnnotation warning for @SerialVersionUID\n@SerialVersionUID is special-cased, the warning doesn't apply.\r\n\r\nRelated to SI-7041."
4024,'adriaanm',"SI-8217 allow abstract type members in objects\nPreviously, abstract type members were allowed in objects only when inherited,\nbut not when declared directly. This inconsistency was not intended. In dotty,\nabstract type members are allowed in values and represent existentials; so upon\ndiscussion, it was decided to fix things to conform to dotty and allow such type\nmembers. Adriaan also asked to keep rejecting abstract type members in methods\neven though they would conceivably make sense.\n\nDiscussions happened on #3407, scala/scala-dist#127.\nThis code is improved from #3442, keeps closer to the current logic, and passes tests.\n\nExisting tests that have been converted to `pos` tests show that\nthis works, and a new test has been added to show that local\naliases (ie term-owned) without a RHS are still rejected.\n\nI've just added the new test to @Blaisorblade's PR, #3978.\n\nReview by @adriaanm\n\nI tend to think this one is okay for 2.11.x, as it only loosens\na restriction. That said, it would be no great loss to wait until\n2.12."
4023,'gkossakowski','Increase REPL startup timeout to avoid test failures\nUnder load on Jenkins, we\'ve been seeing:\n\n```\n% diff /localhome/jenkins/a/workspace/scala-nightly-auxjvm-2.12.x/jdk/jdk7/label/auxjvm/test/files/run/t4542-run.log /localhome/jenkins/a/workspace/scala-nightly-auxjvm-2.12.x/jdk/jdk7/label/auxjvm/test/files/run/t4542.check\n@@ -2,75 +2,14 @@ Type in expressions to have them evaluated.\n Type :help for more information.\n\n scala> @deprecated("foooo", "ReplTest version 1.0-FINAL") class Foo() {\n java.util.concurrent.TimeoutException: Futures timed out after [60 seconds]\n \tat scala.concurrent.impl.Promise$DefaultPromise.ready(Promise.scala:219)\n \tat scala.concurrent.impl.Promise$DefaultPromise.ready(Promise.scala:153)\n \tat scala.concurrent.Await$$anonfun$ready$1.apply(package.scala:95)\n \tat scala.concurrent.Await$$anonfun$ready$1.apply(package.scala:95)\n \tat scala.concurrent.BlockContext$DefaultBlockContext$.blockOn(BlockContext.scala:53)\n \tat scala.concurrent.Await$.ready(package.scala:95)\n \tat scala.tools.nsc.interpreter.ILoop.processLine(ILoop.scala:431)\n \tat scala.tools.nsc.interpreter.ILoop.loop(ILoop.scala:457)\n \tat scala.tools.nsc.interpreter.ILoop$$anonfun$process$1.apply$mcZ$sp(ILoop.scala:875)\n```\n\nThis commit bumps the timeout up be a factor of ten to try to\nrestore that comforting green glow to https://scala-webapps.epfl.ch/jenkins/view/2.N.x\n\nReview by @gkossakowski'
4021,'adriaanm',"SI-8869 Prevent ill-kindedness in type lambdas\nWhen type checking an type application, the arguments are allowed\nto be of kinds other than *. This leniency is controlled by the\n`ContextMode` bit `TypeConstructorAllowed`.\n\n(More fine grained checking of matching arity a bounds of type\nconstructors is deferred until the refchecks phase to avoid\ncycles during typechecking.)\n\nHowever, this bit is propagated to child contexts, which means\nthat we fail to report this error in the lexical context marked\nhere:\n\n    T[({type x = Option}#x)]\n        `-------------'\n\nThis commit resets this bit to false in any child context\nrelates to a different tree from its parent.\n\nReview by @adriaanm"
4017,'retronym','SI-6541 valid wildcard existentials for case-module-unapply\nInstead of letting the compiler infer the return type of case module\r\nunapply methods, provide them explicitly.'
4016,'gkossakowski','SI-8731 warning if @switch is ignored\nFor matches with two or fewer cases, @switch is ignored. This should\r\nnot happen silently.'
4010,'retronym','SI-8087 keep annotations on mixed-in private[this] fields\nRelated to SI-2511 / eea7956, which fixed the same issue for non\r\n`private[this]` fields.\r\n\r\nIf you have\r\n\r\n    trait T { private[this] val f = 0 }\r\n    class C extends T\r\n\r\nMixin geneartes an accessor method `T.f` with owner `T`. When\r\ngenerating the field in `C`, the Mixin.mixinTraitMembers calls\r\n`fAccessor.accessed`. The implementation of `accessed` does a lookup\r\nfor a member named `"f "` (note the space). The bug is that\r\n`private[this]` fields are not renamed to have space\r\n(`LOCAL_SUFFIX_STRING`) in their name, so the accessed was not found,\r\nand no annotations were copied from it.'
4004,'retronym','SI-8861 Handle alias when probing for Any\nIf args to a method are alias types, dealias to see if they\r\ncontain Any before warning about inferring it. Similarly for\r\nreturn and expected types.'
4001,'adriaanm','SI-8862 Fix treatment of inherited implicits in package objects\nTwo spots in implicit search fell prey to a trap with package\r\nobjects. Members of a package object are entered into the scope\r\nof the enclosing package, but that doesn\'t form a suitable prefix\r\nfor determing the member type.\r\n\r\nA REPL transcript paints a picture that speaks a 1000 words:\r\n\r\n```\r\nscala> :paste -raw\r\n// Entering paste mode (ctrl-D to finish)\r\n\r\npackage p { class C[A] { def foo: A = ??? }; object `package` extends C[String] }\r\n\r\n// Exiting paste mode, now interpreting.\r\n\r\nscala> val p = rootMirror.getPackageIfDefined("p")\r\nwarning: there was one deprecation warning; re-run with -deprecation for details\r\np: $r.intp.global.Symbol = package p\r\n\r\nscala> p.info.decls\r\nres0: $r.intp.global.Scope = Scopes(class C, package object p, method foo)\r\n\r\nscala> val foo = p.info.decl(TermName("foo"))\r\nfoo: $r.intp.global.Symbol = method foo\r\n\r\nscala> p.typeOfThis memberType foo\r\nres1: $r.intp.global.Type = => A\r\n\r\nscala> val fooOwner = foo.owner\r\nfooOwner: $r.intp.global.Symbol = class C\r\n\r\nscala> p.info.decl(nme.PACKAGE).typeOfThis memberType foo\r\nres3: $r.intp.global.Type = => String\r\n```\r\n\r\nThis commit detects if we find an implicit in a package module,\r\nand then uses the self type of the corresponding package object\r\nas the prefix for the `ImplicitInfo`. This is done in both\r\n`Context.implicitss` (which collects in-scope implicits), and\r\nin `companionImplicitMap` (which harvests them from the implicit\r\nscope.) In addition, it was necessary / possible to remove a special\r\ncase that excluded package object implicits, the referenced tests for\r\nSI-3999 now pass without this.'
3989,'gkossakowski','SI-8852 Support joint compilation of Java interfaces w. statics\nWe had to change the java parser to accomodate this language\nchange in Java 8.\n\nThe enclosed test does not require JDK8 to run, it only tests\nJavaParsers.\n\nHere is a transcript of my manual testing using Java 8.\n\n```\n% tail test/files/run/8852b/{Interface.java,client.scala}\n==> test/files/run/8852b/Interface.java <==\npublic interface Interface {\n  public static int staticMethod() {\n  \treturn 42;\n  }\n}\n\n==> test/files/run/8852b/client.scala <==\nobject Test extends App {\n  assert(Interface.staticMethod() == 42)\n}\n\n// Under separate compilation, statics in interfaces were already working\n% rm /tmp/*.class 2> /dev/null; javac -d /tmp test/files/run/8852b/Interface.java && scalac-hash v2.11.2 -classpath /tmp -d /tmp test/files/run/8852b/client.scala && scala-hash v2.11.2 -classpath /tmp -nc Test\n\n// Under joint compilation, statics in interfaces now work.\n% rm /tmp/*.class 2> /dev/null; qscalac -d /tmp test/files/run/8852b/{client.scala,Interface.java} && javac -d /tmp test/files/run/8852b/Interface.java && qscala -classpath /tmp -nc Test\n```\n\nReview by @gkossakowski'
3986,'gkossakowski',' SI-6502 Repl reset/replay take settings args\nThe reset and replay commands take arbitrary command line args.\r\nWhen settings args are supplied, the compiler is recreated.\r\n\r\nFor uniformity, the settings command performs only the usual\r\narg parsing: use `-flag:true` or `-flag` instead of `+flag`, and clearing a\r\nsetting is promoted to the command line, so that -Xlint: is not\r\nan error but clears the flags.\r\n\r\n```\r\nscala> maqicode.Test main null\r\n<console>:8: error: not found: value maqicode\r\n              maqicode.Test main null\r\n              ^\r\n\r\nscala> :reset -classpath/a target/scala-2.11/sample_2.11-1.0.jar\r\nResetting interpreter state.\r\nForgetting all expression results and named terms: $intp\r\n\r\nscala> maqicode.Test main null\r\nHello, world.\r\n\r\nscala> val i = 42\r\ni: Int = 42\r\n\r\nscala> s"$i is the loneliest numbah."\r\nres1: String = 42 is the loneliest numbah.\r\n\r\nscala> :replay -classpath ""\r\nReplaying: maqicode.Test main null\r\nHello, world.\r\n\r\nReplaying: val i = 42\r\ni: Int = 42\r\n\r\nReplaying: s"$i is the loneliest numbah."\r\nres1: String = 42 is the loneliest numbah.\r\n\r\nscala> :replay -classpath/a ""\r\nReplaying: maqicode.Test main null\r\n<console>:8: error: not found: value maqicode\r\n              maqicode.Test main null\r\n              ^\r\n\r\nReplaying: val i = 42\r\ni: Int = 42\r\n\r\nReplaying: s"$i is the loneliest numbah."\r\nres1: String = 42 is the loneliest numbah.\r\n```\r\n\r\nClearing a clearable setting:\r\n```\r\nscala> :reset -Xlint:missing-interpolator\r\nResetting interpreter state.\r\n\r\nscala> { val i = 42 ; "$i is the loneliest numbah." }\r\n<console>:8: warning: possible missing interpolator: detected interpolated identifier `$i`\r\n              { val i = 42 ; "$i is the loneliest numbah." }\r\n                             ^\r\nres0: String = $i is the loneliest numbah.\r\n\r\nscala> :reset -Xlint:\r\nResetting interpreter state.\r\nForgetting this session history:\r\n\r\n{ val i = 42 ; "$i is the loneliest numbah." }\r\n\r\nscala> { val i = 42 ; "$i is the loneliest numbah." }\r\nres0: String = $i is the loneliest numbah.\r\n\r\nscala> :replay -Xlint:missing-interpolator\r\nReplaying: { val i = 42 ; "$i is the loneliest numbah." }\r\n<console>:8: warning: possible missing interpolator: detected interpolated identifier `$i`\r\n              { val i = 42 ; "$i is the loneliest numbah." }\r\n                             ^\r\nres0: String = $i is the loneliest numbah.\r\n```\r\nReview by @gkossakowski '
3984,'retronym','General formatting improvements in the spec\nThe spec always needs some love, so here I go:\r\n\r\n**This is only about formatting, it does not change content or even wording.**\r\n\r\n * syntax highlighting for scala code, using highlight.js: \r\n    * this is done in a way that *interacts nicely with MathJax*: one can use latex inside code blocks without problem (and still get syntax highlighting),\r\n    * uses the latest highlight.js 8.2, with the Scala support freshly revamped by @non,\r\n * individual HTML pages now have titles,\r\n * no more broken links,\r\n * fix or work around some latex problems with MathJax,\r\n * mass-removal of trailing whitespace, while I was at it...\r\n\r\nI uploaded a preview of the result [here](http://static.antoine.gourlay.fr/temp/spec/) to make reviewing easier.'
3981,'lrytz','SI-8575 Fix subtyping transitivity with aliases, compound types\nThanks to @b-studios and @Blaisorblade for investigation into this\nbug.\n\n`RefinedType#normalize` is responsible for flattening nested\ncompound types to a flat representation.\n\nTypes are normalized during `=:=` in search of a successful\nresult.\n\nThis means that `((A with B) with C) =:= (A with B with C)`.\n\nHowever, if we introduce a type alias for `A with B` on the LHS,\nthe attempt at flattening is thwarted.\n\nThis commit dealiases parents of refined types during normalization.\n\nTwo tests are included. The first demonstrates a symptom of this\nproblem: failure to install a bridge method resulted in a linkage\nerror.\n\nThe second test uses the reflection API to directly show transitivity\nof subtyping now holds.\n\nTargetting at 2.12, as bug fixes in subtyping usually can be shown\nto lead to binary incompatibilities between code using the old and\nnew compilers.'
3980,'lrytz','SI-8844 Fix regression with existentials + type aliases\nRegressed in 2a1b15e / SI-8283. Another specimen of an archetypal\nbug: unwanted dealising by using `typeSymbol`, rather than\n`typeSymbolDirect`.\n\nReview by @lrytz'
3969,'gkossakowski',"Interactive / ScalaDoc housekeeping\nThis is a re-issue of https://github.com/scala/scala/pull/3903 (closed during my leave)\r\n\r\nThose are the leftovers of what should have been a larger bugfix PR, but that's finally not meant to be.\r\nNo issue, since the changes are straightforward & compiler warnings-driven, but I'd be happy to create one.\r\nShould probably be merged into 2.12.\r\n\r\n[reviewed & LGTM'ed](https://github.com/scala/scala/pull/3903#issuecomment-50616549) by @dragos \r\nAdaptation PR for refactoring is [open](https://github.com/scala-ide/scala-refactoring/pull/60)\r\n\r\nEdit : non-trivial changes in the last commit post-review (but going in the direction of simplicity)"
3965,'lrytz','Prefer scala.Serializable to j.io.Serializable\nThe former extends the latter, and exists as a platorm agnostic\nserialization marker trait. It is of less value now that we\nhave jettisoned the MSIL backend, but while it still exists\nwe ought ought to use it.\n\nI achieved this by replacing wildcard import of `java.io._`\nwith selective imports, leaving `Serializable` to bind to\n`scala.Serializable`.'
3964,'lrytz',"SI-8788 Add generic signature to Parcelable static field special case.\nAndroid's AIDL generates Java code that assumes the presence of generic\r\nannotations for Parcelable classes, which previously were not being\r\ngenerated. This patch adds a generic signature to the generated CREATOR\r\nfield, resolving the issue.\r\n\r\nSame as https://github.com/scala/scala/pull/3922 except into 2.11.x instead of 2.12.x."
3955,'gkossakowski','SI-8410 Don\'t warn fatally on disabled flag\nSince boolean settings can now be set false by user,\r\nsummary warnings should not be issued when the flag\r\nis explicitly off (as opposed to unset, default).\r\n\r\nIn particular, `-Xfatal-warnings` should not fail\r\nif there were no warnings otherwise.\r\n\r\n```\r\n$ ~/scala-2.11.2/bin/scalac -d /tmp -deprecation:false test/files/pos/t8410.scala\r\n$ ~/scala-2.11.2/bin/scalac -d /tmp -deprecation:false -Xfatal-warnings test/files/pos/t8410.scala\r\nwarning: there were three deprecation warnings; re-run with -deprecation for details\r\nerror: No warnings can be incurred under -Xfatal-warnings.\r\none warning found\r\none error found\r\n\r\n```\r\nAfter this commit:\r\n```\r\n$ skalac -d /tmp -Xfatal-warnings test/files/pos/t8410.scala\r\nwarning: there were three deprecation warnings; re-run with -deprecation for details\r\nerror: No warnings can be incurred under -Xfatal-warnings.\r\none warning found\r\none error found\r\n$ skalac -d /tmp -deprecation:false -Xfatal-warnings test/files/pos/t8410.scala\r\n```\r\nSimilarly for other collecting flags:\r\n```\r\n$ skalac -d /tmp -optimise -Yinline-warnings -deprecation:false -Xfatal-warnings test/files/pos/t8410.scala\r\ntest/files/pos/t8410.scala:14: warning: Could not inline required method dropWhile because access level required by callee not matched by caller.\r\n  def k = List(0).dropWhile(_ < 1)   // inlining warns doubly\r\n                           ^\r\ntest/files/pos/t8410.scala:14: warning: At the end of the day, could not inline @inline-marked method dropWhile\r\n  def k = List(0).dropWhile(_ < 1)   // inlining warns doubly\r\n                           ^\r\nerror: No warnings can be incurred under -Xfatal-warnings.\r\ntwo warnings found\r\none error found\r\n$ skalac -d /tmp -optimise -Yinline-warnings:false -deprecation:false -Xfatal-warnings test/files/pos/t8410.scala\r\n\r\n```\r\nFootnote: handling of deprecated locals also changed in 2014:\r\n```\r\n$ ~/scala-2.11.0-M7/bin/scalac -d /tmp -deprecation -Xfatal-warnings test/files/pos/t8410.scala\r\ntest/files/pos/t8410.scala:8: warning: method f in object Test is deprecated:\r\n  Console println f  // warns\r\n                  ^\r\nerror: No warnings can be incurred under -Xfatal-warnings.\r\none warning found\r\none error found\r\n$ ~/scala-2.11.0-M8/bin/scalac -d /tmp -deprecation -Xfatal-warnings test/files/pos/t8410.scala\r\ntest/files/pos/t8410.scala:5: warning: method _f is deprecated:\r\n  def g = { @deprecated("","") def _f = f ; _f }                   // warns in 2.11.0-M8\r\n                                            ^\r\ntest/files/pos/t8410.scala:6: warning: class X is deprecated:\r\n  def x = { @deprecated("","") class X { def x = f } ; new X().x } // warns in 2.11.0-M8\r\n                                                           ^\r\ntest/files/pos/t8410.scala:8: warning: method f in object Test is deprecated:\r\n  Console println f  // warns\r\n                  ^\r\nerror: No warnings can be incurred under -Xfatal-warnings.\r\nthree warnings found\r\none error found\r\n\r\n```'
3954,'adriaanm','SI-7746 fix unspecifc non-exhaustiveness warnings and non-determinism in pattern matcher (2.11)\nThis pull request should resolve all remaining non-determinisms regarding exhaustiveness warnings in the pattern matcher. It was buried deep in the machinery and thus not easy to find. The non-determinism is also the reason behind SI-7746.\r\n\r\nReview by @adriaanm or @retronym\r\n\r\n1) The implementation of the DPLL algorithm was flawed and did not return all solutions. Depending on the ordering of the symbols, more or less solutions were found.\r\nYou can find a test project that compares the results of the implementation with Sat4j here:\r\nhttps://github.com/gbasler/dpll\r\n2) The formulas that were passed to the solver resulted in counter examples that were invalid and removed in a following filtering step. That led to the weird situation where the fixed algorithm returned less counter examples than the buggy one. The recursion goes now deeper than before and also this led to less counter examples reported, since it was stopped too early before.\r\n3) I also cleaned up the `LinkedHashSet` workarounds. They should not be needed anymore. I\'ve repeated Jason\'s checks (see below) and could not find any problems.\r\n\r\nIf the search for exhaustivity stops at the max recursion depth, all bets are off since we might not find all possible counter examples. Thus I added a switch `-Ypatmat-exhaust-depth <n> | <off>` that lets the user set the max recursion depth. This is necessary in order to keep the regression tests stable.\r\n\r\nI\'m working on another PR that will get rid of the "analysis budget" error but this one is a prerequisite to make it work.\r\n\r\nCheck 1:\r\n\r\n```\r\n  ~/Documents/scala-fix-nondet-patmat:ticket/7746$ (f=test/files/neg/t8430.scala; (for i in {1..20}; do echo $f; done; printf "\\n") | qbin/scalac -Xresident) 2>&1 | grep "fail" | sort | uniq | wc -l\r\n      1\r\n```\r\nCheck 2:\r\n\r\n```\r\n for i in {1..100}; do cp test/files/neg/t7020.scala test/files/neg/t7020-$i.scala; cp test/files/neg/t7020.flags test/files/neg/t7020-$i.flags; cat test/files/neg/t7020.check | sed "s/t7020/t7020-$i/" > test/files/neg/t7020-$i.check; done\r\n\r\n~/Documents/scala-fix-nondet-patmat:ticket/7746$ test/partest --terse --srcpath disabled test/files/neg/t7020*.scala\r\n\r\nSelected 101 tests drawn from specified tests\r\n\r\n\r\n# starting 101 tests in neg\r\n\r\n........................................................................\r\n\r\n.............................\r\n\r\n\r\n101/101 passed (elapsed time: 00:00:32)\r\n\r\nTest Run PASSED\r\n```'
3948,'retronym','SI-8823 Exclude specialized methods from extension method rewrite\nIf a value class extends a specialized class, it can sprout\nspecialized members after the specialization info transformer has run.\nHowever, we only install extension methods for class members we know\nabout at the extmethods phase.\n\nThis commit simply disables rewiring calls to these methods in\nerasure to an extention method. This follows the approach taken\nfrom super accessors.\n\nNote: value class type parameters themselves currently are not\nallowed to be specialized.\n\nReview by @gkossakowski'
3946,'gkossakowski','SI-5254 running an empty scala script should succeed\nThe script runner made the assumption that "compilation succeeded"\r\nimplies "there is a Main class to run", but this can be wrong if the\r\nscript is empty (or only contains imports/comments).\r\n\r\nThe ScriptRunner now uses the ClassPath utility to check if there really\r\nis a main class. If not, it doesn\'t try to run it and returns\r\npeacefully. This also makes `scala -e \'\'` succeed.'
3945,'lrytz',"Ystats\nReduce book-keeping Lukas's cleanup by using an Enumeration and a ValueSet or two.\r\n\r\nEnumeration rocks!\r\n\r\nSee if this passes tests this morning.\r\n\r\nI wanted to PR against lrytz, but the UI doesn't show me how. :(\r\n"
3941,'lrytz',"SI-8815  mutable.LongMap makes different choices for splitAt vs etc.\nIt turns out that take/drop/splitAt/takeWhile/dropWhile inherit a smattering of foreach vs. iterator-based implementations.  These aren't consistent unless they iterate in the same order.  This probably reflects an undesirable underlying weakness, but in this particular case it was easy to make LongMap's foreach order agree with iterator.\r\n\r\nMade traversal order of other foreach-like methods match also.\r\n\r\nAlso fixed a bug where Long.MinValue wasn't iterated."
3940,'lrytz','SI-7128  copyToArray(xs, 0, 0) should not fail\nFixed all copyToArray methods to do exactly what the docs say they do, with the least-suprise behavior of not throwing an exception if you ask to copy nothing (but would have copied out of range).\r\n\r\nIterator had an undocumented requirement for the target index to be in range regardless if anything happened; this has been removed.'
3938,'retronym',"SI-8764 fix return type of case class productElement under Xexperimental\nUnder `-Xexperimental`, `productElement` now returns the lub instead\r\nof the weak lub of case class parameter types (numeric widening\r\nshouldn't magically happen *inside* `productElement`)."
3937,'lrytz','[backport] SI-8787 Backport Regex doc\nBackport the doc with two material changes:\r\n\r\n1. need to use Groups to extract from Match,\r\nso say that in lieu of the 2.11 advice that\r\nthe Regex instance can be used without\r\nrecomputing the match;\r\n\r\n2. and relatedly, in 2.10 there is no secondary\r\nconstructor, so the doc for group names is\r\nmoved back up to the class doc.\r\n\r\nOriginal doc update on PR #3923 was:\r\n\r\n0e26910\r\n\r\nf98c53c\r\n\r\nReview by @lrytz \r\n'
3936,'retronym','SI-8806 Add lower bound check to Any lint\nWe already exclude the lint check for infer-any if\r\nAny is somewhere explicit.\r\n\r\nThis commit adds lower bounds of type params to\r\nthe somewheres.\r\n\r\nApologies for the "royal we" in the commit message.\r\n\r\nReview by @retronym '
3935,'retronym',"SI-8803 generate super accessor for super[A], if A is outer superclass\n    class C extends A with T {\r\n      class I {\r\n        C.super[T]\r\n        C.super[A]\r\n      }\r\n    }\r\n\r\nA super call in a nested class of the form super[T] where T is a\r\nparent trait of the outer class doesn't need an accessor: mixin can\r\ndirectly re-route the call to the correct implementation class - it's\r\nstatically known to be T$class.\r\n\r\nHowever, if a nested class accesses super[A] and A is the superclass\r\nof the outer class (not a trait), then we need a super accessor in the\r\nouter class.\r\n\r\nWe need to add the mixin name to the super accessor name, otherwise\r\nit clashes with non-qualified super accessors."
3932,'retronym','SI-8498 @compileTimeOnly should be aware of bridge methods.\nValues classes, for example, will create bridges to a `@compileTimeOnly`\r\nmethod (the bridge is also marked `@compileTimeOnly`), which should not\r\nthrow an error. Calling the bridge or the method will anyway.'
3931,'gkossakowski','GenBCode refactoring (remove Tracked) and fix InnerClass / EnclosingMethod attributes\nThe largest commit, "Remove Tracked, ...", was already reviewed in #3855. It is a squashed version of the commits labelled `[squash-after-review]` in that PR.\r\n\r\nThe subsequent commits address the review comments. They should be reviewed.\r\n\r\nThe commit "Fix InnerClass / EnclosingMethod attributes" is new and should be reviewed.\r\n\r\n[`-Ybackend:GenBCode` build OK](https://scala-webapps.epfl.ch/jenkins/job/scala-checkin-manual/1330/consoleFull)'
3929,'lrytz',"SI-8793 Fix patmat regression with extractors, existentials\nIn the same vein as SI-8128 / 3e9e2c65a, revert to the 2.10.x style\nof determining the types of the product elements of an extractor\nwhen using `TupleN`.\n\nI believe we can discard the special casing for Option/Tuple/Seq\naltogether with judicious application of `repackExistential` in\n`unapplyMethodTypes`. That ought to also fix fix SI-8149. But I'll\ntarget that work at 2.12.x."
3928,'lrytz','Scaladoc: the value of an id attribute must be unique within a document\nThe value of an id attribute must be unique, according to HTML spec.'
3922,'lrytz',"SI-8788 Add generic signature to Parcelable static field special case.\nAndroid's AIDL generates Java code that assumes the presence of generic\r\nannotations for Parcelable classes, which previously were not being\r\ngenerated. This patch adds a generic signature to the generated CREATOR\r\nfield, resolving the issue."
3920,'gkossakowski','SI-7350 Prevent resource leaks in PipedProcesses.runAndExitValue()\nThis patch fixes some problems in `PipedProcesses` as listed bellow:\r\n\r\n- `source` and `sink` leak when b.run() fails at [ProcessImpl.scala#L132](https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L132). ([SI-7350](https://issues.scala-lang.org/browse/SI-7350))\r\n\r\n- `source`, `sink` and `second` leak when a.run() fails at [ProcessImpl.scala#L133](https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L133). ([SI-7350](https://issues.scala-lang.org/browse/SI-7350))\r\n\r\n- `source` and `sink` leak when `Process.exitValue()` interrupted in [ProcessImpl.scala#L135](https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L135). ([SI-7350](https://issues.scala-lang.org/browse/SI-7350))\r\n\r\n- `first` do not properly connected with `second` when `None` putted to `currentSink` before `sink` receive `Some(InputStream)` at [ProcessImpl.scala#L138](https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/ProcessImpl.scala#L138). ([SI-8768](https://issues.scala-lang.org/browse/SI-8768))\r\n\r\nand, a broblem in [BasicIO.scala#L222](https://github.com/scala/scala/blob/538aa22ec8144430e778a34bc749eccb6f5dbf4c/src/library/scala/sys/process/BasicIO.scala#L222) that \r\n\r\n- `InputStream` and `OutputStream` never throw `InterruptedException`, but `BasicIO.transferFully` trying to catch it at [package.scala#L238](https://github.com/scala/scala/blob/159baa268e5cc14b50bf29a40fff922e36dd7bc9/src/library/scala/sys/process/package.scala#L238). \r\n\r\nI guess this originally intented to catch `InterruptedIOException`.\r\n'
3917,'Ichoran','Possible fix for SI-8782\nModified Range.Double to use NumericRange of Double instead of using BigDecimal internally and then converting it to Double.\r\n\r\nSame change can be made on the other branches 2.9.x, 2.10.x and 2.11.x'
3905,'lrytz',"SI-5691 lint warning when a type parameter shadows an existing type.\nThis adds a new lint warning for when a class/method/type-member's\r\ntype parameter shadows an existing type: `-Xlint:type-parameter-shadow`.\r\n\r\nIt excludes type parameters of synthetic methods (the user can't\r\nrename or remove those anyway), otherwise, for example, every case class\r\ntriggers the warning.\r\n\r\nAlso fixes a test that contained wrong java sources (that didn't even\r\ncompile...), discovered thanks to the warning.\r\n\r\n---\r\nThis kind of errors shows up every now and then on the mailing-list, on\r\nstackoverflow, etc. so maybe a warning would be useful.\r\nI was afraid this would yield too many warnings for libraries that are\r\nheavy on type parameters, but no: running this on scalaz and shapeless\r\nHEAD (`v7.1.0-RC1-41-g1cc0a96` and `v2.0.0-M1-225-g78426a0` respectively)\r\nyields 44 warnings. None of them are false positives; they usually come\r\nfrom:\r\n - scalaz loving using `A` as type parameter, even several levels deep\r\n   of parametrized classes/methods\r\n - or calling a type parameter that will hold a map `Map`, or similar,\r\n   thus shadowing an existing type"
3886,'retronym','part 2 of the big error reporting refactoring\nThe big refactoring, pt 2. review by @retronym when the 2.11.2 dust has settled'
3879,'gkossakowski',"SI-8715 Include versions.properties in scala-compiler.jar.\nSo that it can be consumed in builds that cannot use scala-library-all's pom.\r\n\r\nReview by @dragos, cc @skyluc"
3868,'adriaanm','Restore reporter forwarders in CompilationUnit\n'
3860,'lrytz','[backport] SI-7710 fix memory performance of RegexParsers in jdk7u6+\nBackport of scala/scala-parser-combinators@91584dc.\r\n\r\nSee scala/scala-parser-combinators#17.\r\n\r\n---\r\n\r\nStarting with 1.7.0_06 [1], String.substring no longer reuses the internal\r\nchar array of the String but make a copy instead. Since we call\r\nsubSequence twice for *every* input character, this results in horrible\r\nparse performance and GC.\r\n\r\nWith the benchmark from the (duplicate) ticket SI-8542, I get:\r\n\r\nBEFORE:\r\n    parseAll(new StringReader(String))\r\n    For 100 items: 49 ms\r\n    For 500 items: 97 ms\r\n    For 1000 items: 155 ms\r\n    For 5000 items: 113 ms\r\n    For 10000 items: 188 ms\r\n    For 50000 items: 1437 ms\r\n    ===\r\n    parseAll(String)\r\n    For 100 items: 4 ms\r\n    For 500 items: 67 ms\r\n    For 1000 items: 372 ms\r\n    For 5000 items: 5693 ms\r\n    For 10000 items: 23126 ms\r\n    For 50000 items: 657665 ms\r\n\r\nAFTER:\r\n    parseAll(new StringReader(String))\r\n    For 100 items: 43 ms\r\n    For 500 items: 118 ms\r\n    For 1000 items: 217 ms\r\n    For 5000 items: 192 ms\r\n    For 10000 items: 196 ms\r\n    For 50000 items: 1424 ms\r\n    ===\r\n    parseAll(String)\r\n    For 100 items: 2 ms\r\n    For 500 items: 8 ms\r\n    For 1000 items: 16 ms\r\n    For 5000 items: 79 ms\r\n    For 10000 items: 161 ms\r\n    For 50000 items: 636 ms\r\n\r\n[1] http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6924259'
3859,'adriaanm',"[backport] SI-7470 implements fundep materialization\nBackports 21a8c6c from the 2.11.x branch under -Xfundep-materialization\r\nas per Miles Sabin's request. Thanks Miles!"
3858,'xeno-by','SI-8703 add support for blocks with just a single expression to quasiquotes\nPreviously it was impossible to match a block that was constructed as\r\n\r\n    Block(Nil, term)\r\n\r\nDue to the fact that quasiquotes always flatten those into just `term`. This is\r\na correct behavior for construction (for sake of consistency with parser) but\r\ndoing it in deconstruction mode make it impossible to match such blocks which\r\ncould have been constructed manually somewhere.\r\n\r\nTo fix this we just disable block flattening in deconstruction mode.\r\nInterestingly enough this doesn\'t break existing code due to the fact that\r\nquasiquote\'s block matcher also matches expressions as single-element blocks.\r\n\r\nThis allows to match single-element blocks with patterns like `q"{ $foo }"`.\r\n\r\nreview @retronym @xeno-by'
3855,'gkossakowski','Refactorings in GenBCode, remove Tracked\nNote 1: the first bunch of commits in this PR (the ones from June 22) is being reviewed in a separate PR (#3826), ignore them here.\r\n\r\nNote 2: the commits marked [squash-after-review] don\'t build (except for the last). They exist to make reviewing easier, I\'ll squash them into one before merging.\r\n\r\nFor the big commit ("Remove Tracked, ..."), I\'ll add some comments to the diff on GitHub.\r\n\r\nReview by @gkossakowski\r\n\r\n[`-Ybackend:GenBCode` build succeeded](https://scala-webapps.epfl.ch/jenkins/job/scala-checkin-manual/1255/)'
3852,'adriaanm','Document SuperAccessors\nAdded comment giving an up-to-date overview of SuperAccessors\r\nand how we might want to change it. '
3850,'retronym','add distinctBy method and implement distinct in terms of distinctBy\nadd distinctBy method to Seq (move it from scala-reflect) and implement distinct in terms of distinctBy\r\n\r\nreview by @Ichoran '
3848,'lrytz','SI-8680  Stream.addString is too eager\nUsed the standard method of sending out two iterators, one twice as fast as the others, to avoid hanging on .force, .hasDefiniteSize, and .addString.\r\n\r\n.addString appends a "..." as the last element if it detects a cycle.  It knows how to print the cycle length, but there\'s no good way to specify what you want right now, so it\'s not used.\r\n\r\nAdded tests in t8680 that verify that cyclic streams give the expected results.'
3846,'gkossakowski','moves the impl of quasiquotes to scala.reflect\nThis brings consistency with scala.reflect.reify and scala.reflect.macros\r\nalready existing in scala-compiler. To the contrast, scala.tools.reflect,\r\nthe previous home of quasiquotes, is a grab bag of various stuff without\r\nany central theme.'
3845,'retronym','relaxes attachment-matching rules\nIt came as a surprise recently, but attachments.contains/get/update/remove\r\nrequire the class of the payload to match the provided tag exactly, not\r\ntaking subclassing into account. This commit fixes the oversight.'
3844,'retronym','prevents c.internal.subpatterns from destroying rangeposes\nreview @retronym @densh'
3842,'adriaanm','SI-8335  List.++ avoidably burns memory\nChanged to check the identity of the CanBuildFrom instead of the identity of the generated builder to shortcut building.  Should reduce memory churn on ++ a little.'
3840,'adriaanm','SI-8638  Empty UnrolledBuffer hangs on prepend.\nTracked down bug to incorrect recursion in insertAll.  Fixed by adding a missing case (which incidentally will provide better performance when adding to the end of a block).\r\n\r\nNo specific tests, as this is caught by quasi-complete collections tests.'
3837,'Ichoran','SI-8686: scala.io.Source now implements java.io.Closeable\nallows users to write a single function for dealing with Input/Output\r\nstreams and Sources. It also allows Source to be used in\r\n"try-with-resources" statements in Java > 7.\r\n\r\nNo tests since this is a binary and source compatible change.'
3828,'adriaanm',"SI-8675 Avoid unreported error after second try using implicit view\nThis is specific to situations in which we first typecheck an\napplication `qual.m(arg)` against the method `m` directly provided\nby `qual`, and then fall back to `implicitView(qual).m(arg)`.\n\nRegressed in SI-3971 / 7fa77af, in which error reports were moved\nto the innermost `Apply`, and the check for `errorInResult` was\naccordingly changed to recurse through `Apply` trees.\n\nBefore that change, we did not fall back to using a view. After the\nchange, we do try a view. We retypecheck the arguments under the\n`retyping` mode (see `tryTypedArgs`), but this doesn't seem to\nbe enough to avoid leaking the error typed nested trees from the\nfirst try.\n\nHere's an example from the enclosed test case:\n\n    a.update(0, x[A]({new isString(true)}))\n                                   `-- error typed\n\n    refArrayOps(a).update(0, x[A]({new isString(true)}))\n                             `                  `-- error type persists\n                              `-- this tree is retypecked by tryTypedArgs\n\nThis commit changes `onError` to only proceed with the second\ntry if the retyped argument trees are error free."
3827,'adriaanm','WIP: investigating SI-8069\n'
3826,'gkossakowski','Assortiment of cleanups and comments around the backend\n'
3822,'Ichoran',"Mlbileschi update partial function documentation\nTo include the fact that the caller is responsible for checking 'isDefinedAt', except when using partial functions defined using {} and case statements."
3821,'adriaanm','Merge 2.11.x to 2.12.x\n'
3820,'gkossakowski','refactor error/warning reporting\nRefactor error/warning reporting to prepare making it configurable.\r\n\r\nreview by @gkossakowski (on hangout?)'
3817,'gkossakowski','SI-5919 TypeTags and Exprs should be serializable\n- Make TypeCreator and TreeCreator extend Serializable.\r\n- When replacing a SerializedTypeTag with a TypeTag or WeakTypeTag,\r\n  do not use scala.reflect.runtime.universe.rootMirror, since\r\n  it is unlikely to find user classes; instead, create a runtime\r\n  mirror using the context ClassLoader of the current thread.\r\n  Use the same logic for SerializedExpr.\r\n- Remove writeObject/readObject methods from SerializedTypeTag\r\n  and SerializedExpr since they are unused.\r\n- Add @throws annotation on writeReplace and readResolve methods.\r\n- Handle SecurityException if the current thread cannot access the\r\n  context ClassLoader.\r\n- To make type tags of primitive value classes serializable, make\r\n  PredefTypeCreator a top-level class. Otherwise, it would\r\n  retain a reference to the enclosing Universe,\r\n  rendering the TypeCreator non-serializable.'
3815,'lrytz',"Java 8 agnostism for our test suite\nContinuing on from @gkossakowski's work in #3404."
3807,'phaller','SI-8554 Two-arg remove throws exception on large count\nSI-8554  Two-arg remove throws exception on large count\r\n\r\nMade ArrayBuffer and BufferLike have same behavior, which is also consistent with single-arg remove.'
3806,'adriaanm','SI-6967 Fix ClassTag unapply for primitives\nThis pull request should make the unapply method on ClassTag work much better for primitives; It makes reflect.ClassTag.Int unapply (2: Any) work.'
3805,'adriaanm','SI-6409  Stream flatMap leaks memory if mapper returns many empties \nSI-6409  Stream flatMap leaks memory if mapper returns many empties          \r\n\r\nAdded Scaladoc explaining that this is necessary behavior, but closed ticket as'
3801,'gkossakowski','SI-8474  Inconsistent behavior of patch method\n SI-8474 Inconsistent behavior of patch method\r\n\r\nChanged Iterator to be consistent with other collections.\r\n\r\nAlso fixed SeqViewLike to validate/constrain inputs.\r\n\r\nNo specific tests; quasi-comprehensive collection tests will cover this later.'
3797,'retronym','SI-8631 Treat `A with Sealed` as enumerable for pattern matching\nEnumerate the subtypes of sealed parent types of refinement\ntypes, and filter those that conform to the refinement type.\n\nSuch types can crop up easily when LUB-bing case classes which\nadd `Product with Serializable` to the mix.'
3792,'adriaanm','SI-8525 -Xlint:nowarn-missing-interpolator\nTurn warn-missing-interpolator into an -Xlint choice. Allow choice negation with prefix "no".  Refactor choice logic from MultiString to MultiChoice. Update set of choices all together.\r\n\r\nThe mechanism between MutableSettings and concrete settings could be further over-engineered. Rube Goldberg is occupied on another project at the moment.  For instance, no easy way to override `def wildcards = choices // filter (!_.isSetByUser)`.\r\n\r\nDepends on #3776\r\n\r\nReview by @retronym as follow-up to #3776 '
3788,'retronym','SI-8494 Restore filtering javap output\nRegressed in support for new delayedEndPoint, where it must\r\npick what to filter for.\r\n\r\n`s/claas/klass/` and similar.\r\n\r\nReview by @retronym who had to manually snip some output, to my chagrin'
3781,'adriaanm',"SI-8611 Avoid accidental patmat unification with refinement types\nIn the enclosed test, t8611a.scala, the patterns `O.{A, B}` were\r\nincorrect treated as equivelent by the combination of\r\n`uniqueTpForTree` and `Const.uniqueTpForTree`.\r\n\r\n`uniqueTpForTree` used `Type#narrow` to try to create a distinct\r\ntype for each new pattern tree it encountered. However, narrowing a\r\n`RefinedType` does not create a distinct type as we are used to\r\nwhen narrowing, e.g. a class type.\r\n\r\n    // Type\r\n    def narrow: Type =\r\n      if (phase.erasedTypes) this\r\n      else {\r\n        val cowner = commonOwner(this)\r\n        refinedType(this :: Nil, cowner, EmptyScope, cowner.pos).narrow\r\n      }\r\n\r\n    // CompoundType\r\n    override def narrow: Type = typeSymbol.thisType\r\n\r\nThis commit first tries to use `narrow`, and then detects if the\r\nresult shares a type symbol with the input. If so, it compensates\r\nby creating another refinement type over the result and narrows that.\r\n\r\nI've included a unit test to show the subtleties of narrowing refinements.\r\n\r\nReview by @adriaanm. I'm hoping you can find a less ugly way to do this!"
3780,'retronym',"macro args now correctly preserve range positions\nSomewhen in the 2.11.0 development cycle we started duplicating macro arguments\r\nfor increased robustness. What wasn't taken into account though is that\r\nTree.duplicate destroys range positions. This commit fixes the problem.\r\n\r\n2.10.x is unaffected by this bug, because it doesn't duplicate the args yet."
3778,'retronym','adds MacroPlugin.pluginsIsBlackbox\nThis is an important omission in the current macro plugin API, which was\r\ndesigned before the blackbox vs whitebox separation was implemented.\r\n\r\nEven if one overrides pluginsTypedMacroBody and pluginsMacroExpand,\r\nthat would still be not enough to write a custom macro expander, because\r\ntypedImplicit1 uses isBlackbox, which is tightly coupled with the standard\r\nway of reading/writing macro signatures.'
3777,'retronym','SI-5905 Clarify test case\nThe language feature options are discovered reflectively, but it\r\nis nice to enforce that expected options are supplied.\r\n\r\nShort of that, the code string includes a rowdy postfix operator.\r\n\r\nIt still does enforce that at least one option was discovered.\r\n\r\n(Resubmittal.)\r\n\r\nReview by @retronym since this is in response to previous minor feedback from him.'
3776,'adriaanm','SI-8610 -Xlint is multichoice option\nMake -Xlint a "multichoice" option for purposes of option parsing.\r\n\r\nThis allows turning on "lint with these warnings" instead of only\r\n"turn off these warnings but enable other lint warnings".\r\n\r\n```\r\n$ scalac -Xlint:warn-adapted-args linty.scala  # lint plus a warning\r\n$ scalac -Xlint warn-adapted-args linty.scala  # same\r\n$ scalac -Xlint linty.scala                    # same as now\r\n$ scalac -Xlint -- linty.scala                 # ok, not necessary\r\n$ scalac -Xlint _ -- linty.scala               # another funky underscore\r\n```\r\n\r\nThis would also enable Xlint options that are not standalone options,\r\nalthough that is not implemented in this commit.  For example,\r\n`-Xlint:no-missing-interpolator` could be used to disable that\r\nwarning. (There is no `-Xoption:flavor=off` syntax.) (`no-` switches\r\nwould not be enabled by `_`.)\r\n\r\nReview by @retronym who has expressed opinions about the warning group conundrum\r\n'
3772,'retronym','SI-8609 Fix flattening of definitions and imports in quasiquotes \nQuasiquotes allow to unquote trees with ..$ with block flattening\r\nsemantics to simplify composition:\r\n```\r\n  val onetwo = q"1; 2"\r\n  val onetwothree = q"..$onetwo; 3" // same as q"1; 2; 3"\r\n```\r\nIf there is no block it will be equivalent to $ unquoting:\r\n```\r\n  val one = q"1"\r\n  val onetwo = q"..$one; 2" // same as q"1; 2"\r\n```\r\nBut the inconsistency here is that currently only terms support\r\nthis single-element semantics. This commit extends this functionality\r\nto also support definitions and imports. So that following code works:\r\n```\r\n  val q1 = q"val x = 1"\r\n  val q2 = q"..$q1; val y = 2" // same as q"val x = 1; val y = 2"\r\n```\r\nreview @retronym @xeno-by'
3769,'xeno-by','SI-8608 f interpolator emits plain old strings\nWhen invoking `format` is obviated by a lack of\r\nformatting fields, then just degenerate to an\r\nunenhanced string.\r\n\r\nThis means it doesn\'t cost anything to use\r\nf"$$ordinary" in place of "$ordinary", which\r\nmay cause warnings under -Xlint.\r\n\r\nNote that certain format literals, in particular\r\nfor line separator %n, are not actually literals and\r\ncan\'t be replaced at compile time.\r\n\r\nReview by @xeno-by for macro expertise'
3768,'densh',' SI-6476 Improve error on escapement\nBehavior of escape processing under string interpolation can\r\nbe confusing.  This PR improves the exception message so\r\nyou know at least what sort of escapes are handled.\r\n```\r\nscala> s"\\d".r\r\nscala.StringContext$InvalidEscapeException: invalid escape \'\\d\' not one of [\\b, \\t, \\n, \\f, \\r, \\\\, \\", \\\'] at index 0 in "\\d". Use \\\\ for literal \\.\r\n\r\nscala> s"a\\"\r\nscala.StringContext$InvalidEscapeException: invalid escape at terminal index 1 in "a\\". Use \\\\ for literal \\.\r\n\r\nt6476-bad-esc-d.scala:3: error: \';\' expected but string literal found. (A trailing \'\\\' escapes nothing. Use \\\\, $$ or $" for literal \\, $ or ".)\r\n  def f = s"\\"abcdef\\""\r\n                     ^\r\n```\r\nAlso enable $" under -Xfuture. This is the same as retronym\'s tweak,\r\nbut puts it under `-Xfuture` until the ecosystem catches up.\r\n\r\nAlso give the parser enough knowledge of `s` and `f`\r\nto emit an error on the puzzling badly escaped\r\nquote.  The error is emitted as supplemental\r\nadvice when a subsequent syntax error is encountered,\r\nsuch as an unclosed literal.\r\n\r\nThe mechanism is non-ideal but serves to mitigate the pain of\r\nmany users from us hoi polloi all the way up to paulp.  Hoi paulpoi.\r\n\r\nThese are the remaining commits from #3695.\r\n\r\nReview by @retronym'
3764,'adriaanm',"SI-8597 Issue an elusive unchecked warning\nFor:\r\n\r\n```scala\r\ndef nowarn[T] = (null: Any) match { case _: Some[T] => }\r\n```\r\n\r\nReview by @adriaanm. I'll be out your way on Wedsneday, let's\r\nrun through this together then.\r\n\r\nSee also a followup issue that I lodged as SI-8604."
3759,'retronym','SI-8599 Improve type variable inference in nested matches\nRefine the upper and lower bounds independentally, rather than\nbailing out if `!(lo1 <:< hi1)`.\n\nBefore, the enclosed test case traced out as follows:\n\n```\ninferTypedPattern\n-----------------------------------\npattpt   = RefinementTest.Child[c]\npt       = RefinementTest.Parent[a]\nptparams = [type a]\nptvars   = [=?(?c, ?c)]\nptvars foreach instantiateTypeVar\n\n  instantiateTypeVar\n  -----------------------------------\n  tvar  = =?(?c, ?c)\n  tb0   =  >: A <: A\n  instBounds(tvar)\n\n    instBounds\n    -----------------------------------\n    loBounds   = [(c, c)]\n    hiBounds   = [(c, c)]\n    tparam     = type a\n    val TypeBounds(lo, hi) = tparam.info.bounds\n    lo         = A\n    hi         = A\n    lub(A :: (c, c) :: Nil) = Any\n    glb(A :: (c, c) :: Nil) = A with (c, c)\n    result = >: Any <: A with (c, c)\n\n  lo1   = Any\n  hi1   = A with (c, c)\n  if (! (lo1 <:< hi1) )\n   log(s"inconsistent bounds: discarding TypeBounds($lo1, $hi1)")\n```\n\nSo because we haven\'t yet refined the info of `a`, it still appears\ndistinct from `(c, c)`, and the LUB is `Any`. Based on this, we\ndon\'t proceed to refine the type.\n\nThis commit changes the process to individually retain or discard\nthe low and high bounds, which is enough to tie the knot here.'
3758,'Ichoran','SI-7372 fix wrong insertion point for binary & linear search.\nIt should return the position the value would have if it was a part of\r\nthe sequence. Somehow even the test was wrong.'
3757,'retronym','List extends scala.Serializable\nList should extend scala.Serializable, not java.io.Serializable. Because of `import java.io._` java.io.Serializable has higher priority than scala.Serializable which is not good (Personally I found this problem not being able to pass List as an argument of type scala.Serializable). \r\n\r\nThis is clearly a bug.'
3753,'retronym',"SI-5920 enables default and named args in macros\nHopefully third time's a charm. review @retronym"
3752,'Ichoran','SI-8589 Performance improvement for ArrayCharSequence.toString\nWhile using a csv parser to process large char arrays i ran into the problem that the toString method of ArrayCharSequence was very slow on large buffers (and, as it appears, also on small buffers)\r\nThe problematic method:\r\noverride def toString = xs drop start take length mkString ""\r\n\r\nI created a faster version which is already almost 50% faster on an empty charsequence and only becomes relatively faster when the array gets bigger.\r\n\r\nSee https://issues.scala-lang.org/browse/SI-8589'
3749,'retronym','SI-8185 Correct grammar for single-warning compilation run\nThis is a re-issue of #3419\r\n\r\n50-odd updated tests (!)\r\nreview by @retronym\r\n'
3741,'retronym','SI-6778 scala.math.random should have parenthesis\nAdded parenthesis to scala.math.random because it has side-effects on\r\nthe seed.'
3738,'adriaanm','SI-8574 Copy @SerialVersionUID, etc, to specialized subclasses\nThe test case demonstrates that this is important for serialization\nand for strictfp. (Although the latter is still pretty broken,\nsee SI-7954.)'
3736,'xeno-by','SI-8447 fix TypeTree printing (2.11.x)\nAdded TypeTree printing based on tpe to CodePrinter (if original is not available) - [SI-8447](https://issues.scala-lang.org/browse/SI-8447)\r\n\r\nPrevious [version](https://github.com/scala/scala/pull/3710) of this pull request'
3727,'adriaanm','SI-8531 Better space efficiency for patmat analysis\nBy adding logging to `clause`, I found that the majority of\ncalls provide 0 or 1 elements. In SI-7020 / 69557da55, we changed this\nmethod to use a `LinkedHashSet` to have deterministic results\nfor clauses with more elements. But I suspect that this\ncontributes to higher memory usage from the pattern matcher.\n\nThe enclosed test case, carefully whittled down by @oxbowlakes,\nused to consume an inordinate amount of memory and time.\nAfter this patch, it is back to 2.10.4 performance.\n\nI have run `neg/t7020.scala` in a loop and it still is deterministic.\n\nReview by @adriaanm\n\nResubmission of #3696 that included a test and uses `toSet` as\nsuggested.'
3719,'adriaanm','SI-8546 Pattern matcher analysis foiled by over-widening\nIn the enclosed test, the prefix checkable type\n`ModuleTypeRef(F2.this, C)` was being inadvertently widened to\n`ModuleTypeRef(F2[?], C)`. This started after some misguided\nfuture-proofing in SI-6771 / 3009916.\n\nThis commit changes the `dealiasWiden` to a `delias`.'
3682,'gkossakowski','SI-8497 Fix regression in pickling of AnnotatedTypes\nFixes an inconsistency introduced in these two spots:\r\n\r\n  https://github.com/scala/scala/pull/3033/files#diff-6ce1a17ebee31068f41c36a8a2b3bc9aR79\r\n  https://github.com/scala/scala/pull/3033/files#diff-c455cb229f5227b1bcaa1544478fe3acR452\r\n\r\nThe bug shows up when pickling then unpickling an AnnotatedType\r\nthat has only non-static annotations. It manifests as a crash in unpickling.'
3670,'adriaanm','SI-8463 Avoid unpositioned errors from search for views\nIdeally, I\'d like to fix this using `saveErrors = false` here to\nfirewall the enclosing context from the ambiguiouty error encountered\nduring implicit search.\n\nI originally proposed that patch as a fix for SI-8419 in\nhttps://github.com/scala/scala/pull/3460 but withdrew from\nthat approach as I uncovered a deeper bug that meant that\nwe actually shouldn\'t have even been looking for views in\nthat case.\n\nBut, this runs into SI-8230 and these failures:\n\n\ttest/partest --update-check \\\n\t  /Users/jason/code/scala/test/files/pos/t2504.scala \\\n\t  /Users/jason/code/scala/test/files/pos/t4457_1.scala \\\n\t  /Users/jason/code/scala/test/files/neg/t4457_2.scala\n\nTurns out that typechecking the ostensible straight forward\napplication, `Array("abc")`, hinges on us leaking an ambiguity\nerror from `viewExists` to find a path through overload resolution!\n\nThis commit takes a tiny step forward by using `context.tree`\nrather than `EmptyTree` as the argument to `inferImplicit`.\nThis avoids unpositioned type errors.\n\nReview by @adriaanm'
3659,'retronym','SI-8451 makes uncurry more forgiving\nApparently even though the rhs of a secondary constructor looks like an expr,\r\nit always gets wrapped in a block by the parser. This works just fine with\r\nthe typer, but crashes in uncurry. This commit brings quasiquotes in line with the parser.'
3657,'retronym',"SI-8388 consistently match type trees by originals\nDue to the fact that all TypTrees are transformed into TypeTrees\r\nduring typechecking one couldn't treat typed type trees in the same\r\nway as they treat untyped type trees.\r\n\r\nThis change implements support for pattern matching of TypeTrees as their\r\ncorresponding TypTree equivalent using tree preserved in the original.\r\n\r\nThe implementation itself is a trivial wrapping of regular TypTree\r\nextractors into MaybeTypeTreeOriginal."
3656,'xeno-by','SI-8350 SI-8387 tweak handling of new trees\nAdds two tweaks to the handling of `q"new ..."` trees:\r\n\r\n1. Makes `q"$f(...$argss)"` not match `q"new Foo(x)"` as function with arguments \r\n2. Makes `q"new Foo"` and `q"new Foo()"` match one another\r\n\r\nreview @xeno-by @retronym'
3653,'xeno-by','SI-8200 provide an identity liftable for trees\nThis liftable hasn\'t been originally included in the set of standard\r\nliftables due to following contradiction:\r\n\r\n1. On one hand we can have identity lifting that seems to be quite\r\n   consistent with regular unquoting and splicing:\r\n   ```scala\r\n    q"..${List(1,2)}"        <==> q"1; 2"\r\n    q"${List(1,2)}"          <==> q"s.c.i.List(1, 2)"\r\n    q"..${List(q"a", q"b")}” <==> q"a; b"\r\n    q"${List(q"a", q"b")}"   <==> q"s.c.i.List(a, b)" // introduced by this pr, currently fails\r\n   ```\r\n   This is also consistent with how lisp unquoting works although they\r\n   get lifting for free thanks to homoiconicity:\r\n   ```scala\r\n    // scala\r\n    scala> val x = List(q"a", q"b"); q"f($x)"\r\n    q"f(s.c.i.List(a, b))"\r\n   ```\r\n   ```scheme\r\n    ;; scheme\r\n    > (let [(x (list a b))] `(f ,x))\r\n    \'(f (list a b))\r\n   ```\r\n\r\n2. On the other hand lifting is an operation that converts a value into\r\n   a code that when evaluated turns into the same value. In this sense\r\n   `Liftable[Tree]` means reification of a tree into a tree that\r\n   represents it, i.e.:\r\n   ```scala\r\n    q"${List(q"a", q"b")}"\r\n    <==>\r\n    q"""s.c.i.List(Ident(TermName("a")), Ident(TermName("b")))"""\r\n   ```\r\n   But I belive that such lifting will be very confusing for everyone\r\n   other than a few very advanced users.\r\n\r\nThis commit introduces the first option as a default Liftable for trees.\r\n\r\nreview @xeno-by @retronym'
3652,'retronym',"SI-8388 consistently match type trees by originals\nDue to the fact that all TypTrees are transformed into TypeTrees\r\nduring typechecking one couldn't treat typed type trees in the same\r\nway as they treat untyped type trees.\r\n\r\nThis change implements support for pattern matching of TypeTrees as their\r\ncorresponding TypTree equivalent using tree preserved in the original.\r\n\r\nThe implementation itself is a trivial wrapping of regular TypTree\r\nextrarctors into MaybeTypeTreeOriginal.\r\n\r\nreview @retronym"
3651,'retronym',"SI-8437 macro runtime now also picks inherited macro implementations\nPreviously it didn't matter much that we used Class.getDeclaredMethods\r\ninstead of just getMethods, but with the introduction of macro bundles\r\nit can make a difference which is fixed in this commit.\r\n\r\nI'd also like to note that the fact that getMethods only returns public\r\nmethods and getDeclaredMethods also sees private methods, doesn't make\r\na difference, because macro implementations must be public."
3647,'xeno-by','SI-8411 match desugared partial functions\nreview @xeno-by /cc @vladimirnik'
3641,'adriaanm','SI-8341 minor fixup for comments in test\n'
3638,'retronym',"SI-8425 don't create double-dollar names in c.freshName\nIf we append a dollar to a user-provided prefix that ends in a dollar,\r\nwe create a potential for confusion for backend phases. That's why\r\nthis commit prevents such situations from happening."
3637,'retronym',"SI-8420 don't crash on unquoting of non-liftable native type\nPreviously quasiquote's type-based dispatch failed to handle situation\r\nwhere unquotee's type is native but non-liftable and was used to splice\r\nwith non-zero cardinality.\r\n\r\nreview @retronym"
3636,'retronym',"introduces Mirror.typeOf\nI just realized that our tag-based shortcuts were incomplete, because\r\nthey only work with root mirrors (doing just u.typeTag[T].tpe means that\r\nthe type is going to be resolved in u.rootMirror because that's the default).\r\n\r\nThis commit fixes this oversight. I'm hoping for 2.11.0-RC3, but also feel\r\nfree to reschedule to 2.12.0-M1 if it becomes clear that RC3 isn't happening."
3635,'adriaanm',"SI-8329 Better hygiene for patmat partial functions\nDon't enter synthetic parameters of `applyOrElse` et al into\r\nscope when typechecking the user-code; instead reference those\r\nsymbolically.\r\n\r\nReview by @adriaanm. For 2.11.1"
3629,'retronym','SI-8086 follow-up that fixes the problem with `setter`\nThis is a super-low risk follow-up for 47dba05 that fixes the same\r\nproblem with a neighboring method.'
3627,'gkossakowski','SI-8407 "symbol not found" in Scaladoc use cases: warning only\nThe refactoring in aedec1980 mistakenly used the non-silent\ntyper to typecheck the use cases. It temptingly had the desired\ntype (`ScalaDocAnalyzer`), but sadly the wrong properties (it will\nreport errors, rather than buffer.)\n\nThis meant that "symbol not found" errors in use cases would prevent\nScaladoc generation.\n\nThis commit introduces a little downcast on the silent typer.\nA more principled approach would be to go through the rigmarole\nof the virtual class pattern for `Analzyer.Typer`, but that will\nhave to remain work for another day.\n\nReview by @gkossakowski'
3626,'adriaanm','SI-2458 Explicit import should shadow def in other comp. unit\nFixes the implementation of point 4. from SLS chapter 2:\n\n> Definitions made available by a package clause not in the\n> compilation unit where the definition occurs have lowest precedence.\n\nWe had code to deal with this:\n\n    if (defSym.exists && impSym.exists) {\n      if (isPackageOwnedInDifferentUnit(defSym))\n        defSym = NoSymbol\n\nBut, in the `pos/t2458a`, no `impSym` was around, due to filtering\nin `depthOk`. The depth of the imported symbol was the same as the\ndepth of the defined symbol, which didn\'t pass:\n\n    imp.depth > symbolDepth\n\n`depthOk` already had special handling for Java sources: if the\nimport is non-wildcard and depths are equal, retain the import.\n\nThis commit does the same thing for Scala sources, using the\n`isPackageOwnedInDifferentUnit` as the criteria. It also makes\nthe check for the "imported ... is permanently hidden" warning\nto avoid this spurious warning:\n\n    test/files/pos/t2458a/A.scala:3: warning: imported `BitSet\' is permanently hidden by definition of class BitSet in package p\n    import scala.collection.BitSet\n                        ^\n\nI have retained compatibiltiy with the bug under -Xsource:2.10\n\nReview by @adriaanm. I\'l trigger a dbuild of this one to check for fallout.'
3611,'retronym','SI-8385 make sure $quasiquote$tuple gets reified properly \nPreviously due to greediness of SyntacticApplied there was a chance that\r\nquasiquote tuple placeholder got reified as its representation rather\r\nthan its meaning.\r\n\r\nreview @retronym'
3610,'retronym','SI-8369 resetAttrs now correctly accounts for skolems\nresetAttrs (née resetLocalAttrs) has been oblivious to existence of skolems.\r\nNot anymore, which prevents us from reverting to the untyper nightmare.'
3609,'adriaanm',"SI-8370 fixes an infinite loop in repl init\nUnder a weird coincidence of circumstances provided by `sbt console-quick`,\r\nnew XML parsing logic in compiler plugin initialization could lead to stack\r\noverflow errors.\r\n\r\nHere's the abridged sequence events that led to this unfortunate problem\r\n(full description can be found on the JIRA issue page):\r\n\r\n1) Initialization of the compiler underlying the REPL would kick off\r\nplugin initialization.\r\n\r\n2) PluginDescription.fromXML would call into DocumentBuilderFactory, i.e.\r\nDocumentBuilderFactory.newInstance.newDocumentBuilder.parse(xml).\r\n\r\n3) That thing would call into javax.xml.parsers.SecuritySupport.getResourceAsStream,\r\nrequesting META-INF/services/javax.xml.parsers.DocumentBuilderFactory.\r\n\r\n4) That request would get serviced by TranslatingClassLoader provided\r\nby the REPL to expose dynamically compiled code.\r\n\r\n5) TranslatingClassLoader would call translatePath that would call into\r\nIMain.symbolOfIdent trying to map the requested resource onto one of the\r\nclasses defined by the REPL (which don't exist yet, because REPL hasn't\r\nyet finished initializing).\r\n\r\n6) IMain.symbolOfIdent would request IMain.global, which is exactly the\r\ninstance of the compiler that underlies the REPL, and that's currently\r\nbeing initialized.\r\n\r\n7..inf) Repeat until a StackOverflowError."
3607,'retronym',"SI-8367 revert SI-8192's change to primaryConstructor when isJavaDefined\nthis is some weird stuff"
3606,'retronym',"SI-8375 saner binary incompat errors for macros\nInspired by Brian McKenna's RC1 migration experience, this commit improves\r\nmacro impl binding validation in order to provide more helpful diagnostic\r\nfor this quite frequent class of errors."
3602,'retronym',"[backport] no longer warns on calls to vampire macros\nAs eloquently elaborated and cleverly named by Travis Brown, macros\r\ndefined in structural types are useful:\r\nhttp://meta.plasm.us/posts/2013/07/12/vampire-methods-for-structural-types/.\r\n\r\nHowever, since such macros are on the intersection of a number of language\r\nfeatures, as usual, there are bugs.\r\n\r\nThis commit fixes an unwanted interaction of macros defined in structural\r\ntypes with the scala.language.reflectiveCalls guard. Since macro calls\r\naren't going to be carried to runtime, there's no need to warn about them."
3596,'retronym',"SI-8333 can't use modifiers if class is in a block\nWas caused by the ordering of parser cases. Need to check for definition\r\nfirst due to the fact that modifiers unquote looks like identifier from\r\nparser point of view.\r\n\r\nreview @retronym"
3594,'retronym',"SI-8331 make sure type select & applied type doesn't match terms\nDue to tree re-use it used to be the fact that type quasiquotes could\r\nmatch term trees. This commit makes sure selections and applied type and\r\ntype applied are all non-overlapping between `q` and `tq`.\r\n\r\nreview @retronym"
3593,'retronym',"SI-8285 use correct kind of map for quasiquote positions\nPreviously mutable.ListMap was used with assumption that it preserved\r\norder of inserted elements (but it doesn't). Surprisingly logic that\r\nassumed ordered elements worked mosly fine on unordered ones. I guess\r\ntwo bugs can cancel each other out.\r\n\r\nreview @retronym"
3592,'retronym','SI-8281 check for unbound placeholder parameters in quasiquote parser\nreview @retronym'
3591,'xeno-by','SI-8275 allow to directly extract block contents of the case def\nDue to the fact that blocks in cases are implicit one might expect to be\r\nable to extract its contents with `..$`.\r\n\r\nreview @xeno-by '
3589,'adriaanm','test case that verifies SI-8352\nreview @re^W @adriaanm'
3579,'xeno-by','Add ScalaDoc to Quasiquotes and Liftables parts of api\nreview @xeno-by @heathermiller'
3571,'retronym',"SI-8321 bundles can't be whitebox\nreview @retronym"
3569,'retronym',"SI-8316 SI-8318 SI-8248 reintroduces resetAllAttrs\nUnfortunately, due to the aforementioned bugs we have to delay our triumph\r\nover resetAllAttrs.\r\n\r\nTherefore, I'm rolling back the internal changes to scalac introduced in\r\nhttps://github.com/scala/scala/pull/3485. Our public reflection API interface\r\nin Scala 2.11 is still going to contain only resetLocalAttrs, but both\r\nthe reifier and the label typechecker are too heavily addicted to resetAllAttrs\r\nto do away with it right now."
3568,'xeno-by',"Fix quasiquote terminology to be consistent with Scheme \n1. Fix terminology not to contradict Scheme's one\r\n2. Tweak signature of quasiquote's apply to help IDEs\r\n\r\nreview @xeno-by"
3566,'gkossakowski','SI-6455 no longer rewrite .withFilter to .filter\nThis has been deprecated for two major releases now,\r\nand during that time caused plenty of harm (see also SI-7239).\r\n\r\nTime to retire, rewrite.\r\n\r\nWhat say ye, @gkossakowski, @Ichoran & @retronym?'
3565,'gkossakowski','SI-6217 deprecate `_root_` as part of package name\nreview by @gkossakowski'
3564,'retronym',"SI-6675 deprecation warning for auto-tupling in patterns\nNOTE: when the deprecation warning becomes an error,\r\nSI-6111 must become a `won't fix`\r\n\r\nreview by @retronym"
3563,'gkossakowski',"SI-5479 deprecate DelayedInit outside of App\nDelayedInit's semantics are way too surprising.\r\n\r\nFor example, it delays initialization of fields,\r\nso that fields on objects that extend `App`\r\n(which `extends DelayedInit`) are not initialized\r\nuntil the `main` method is called.\r\n\r\nFor more details and a proposed alternative,\r\nsee https://issues.scala-lang.org/browse/SI-4330?jql=labels%20%3D%20delayedinit%20AND%20resolution%20%3D%20unresolved.\r\n\r\nSupport for `App` will continue -- we'll special case it.\r\n\r\nreview by @gkossakowski"
3562,'retronym',"SI-8197 Overload resolution should not consider default arguments\nThe spec says\r\n\r\n> Let B be the set of alternatives in A that are applicable (§6.6)\r\n> [...] It is an error if none of the members in B is applicable. If\r\n> there is one single applicable alternative, that alternative is\r\n> chosen. Otherwise, let C be the set of applicable alternatives which\r\n> don’t employ any default argument in the application to e1, ..., em.\r\n> It is again an error if C is empty. Otherwise, one chooses the most\r\n> specific alternative among the alternatives in C [...].\r\n\r\nThere are many ways to interpret this, but none of them involves\r\nexcluding default getters, which is what the old code was doing.\r\nWe now exclude all alternatives that define any default arguments.\r\n\r\nNOTE: according to SI-4728, this should fail to compile with an\r\nambiguity error. The compiler has been accepting this program\r\nfor all of 2.10.x, as far as I can tell, so let's not change that\r\nfor 2.11.0-RC1..."
3559,'gkossakowski',"SI-1503 don't assume unsound type for ident/literal patterns\nThe fix only kicks in under -Xfuture. We also warn under -Xlint.\r\n\r\nWhat type should a variable bound to the value matched by a pattern have?\r\nTo avoid CCEs, it should be a type that's implied by the matching\r\nsemantics of the pattern.\r\n\r\nUsually, the type implied by a pattern matching a certain value\r\nis the pattern's type, because pattern matching implies instance-of checks.\r\n\r\nHowever, Stable Identifier and Literal patterns are matched using `==`,\r\nwhich does not imply a type for the binder that binds the matched value.\r\n\r\nThe change in type checking due to this fix is that programs that used to crash with a CCE\r\n(because we blindly cast to the type of the pattern, which a `==` check does not imply)\r\nnow get a weaker type instead (and no cast). They may still type check, or they may not.\r\n\r\nTo compensate for this fix, change `case x@Foo => x` to `case x: Foo.type => x`,\r\nif it's important that `x` have type `Foo.type`.\r\n\r\nSee also:\r\n- SI-4577: matching of singleton type patterns uses `eq`,\r\n  not `==` (so that the types are not a lie).\r\n- SI-5024: patmat strips unused bindings, but affects semantics"
3558,'retronym',"SI-4577 singleton type pattern test should use `eq`, not `==`\nI find it hard to imagine anyone is relying on `case x: foo.type =>`\r\nerroneously being compiled to `foo == x` instead of the spec'ed `foo eq x`,\r\nso let's finally fix this.\r\n\r\nMaybe my imagination is lacking, so feel free to veto this, @retronym and @gkossakowski."
3557,'retronym',"SI-8224 Fix regression in f-bound aware LUBs\nDisable the heuristic approach to recursive bounds unless\r\nthe compiler is running under `-Dscalac.experimental.lub`.\r\n[NOTE: the above part of the patch was authored by @adriaanm,\r\n the rest is by the commit's original author.]\r\n\r\nIn db46c71e88, steps were taken to avoid blowing up in the\r\npathological LUB calculation needed for:\r\n\r\n    def trav = List(List(), Stream())\r\n\r\nThis skipped a level in the base class sequence when f-bounds\r\nwere detected at the current level.\r\n\r\nIn that example, when `lublist` was about to:\r\n\r\n    mergePrefixAndArgs(\r\n      typeOf[LinearSeqOptimized[A, List[A]]],\r\n      typeOf[LinearSeqOptimized[A, Stream[A]]],\r\n    )\r\n\r\nIf it proceeded (as in 2.10.3), the LUB is invalid:\r\n\r\n    error: type arguments [B[_ >: D with C <: B[_ >: D with C <: A]],s.c.immutable.LinearSeq[B[_ >: D with C <: A]] with s.c.AbstractSeq[B[_ >: D with C <: A]] with s.c.LinearSeqOptimized[B[_ >: D with C <: A],s.c.immutable.LinearSeq[A] with s.c.AbstractSeq[A] with s.c.LinearSeqOptimized[A,Immutable with Equals with java.io.Serializable] with java.io.Serializable] with java.io.Serializable] do not conform to trait LinearSeqOptimized's type parameter bounds [+A,+Repr <: s.c.LinearSeqOptimized[A,Repr]]\r\n\r\nTo avoid this, the added code would skip to the first non-F-bounded\r\nbase type of the same arity of each element in the list. This would\r\nget to:\r\n\r\n    LinearSeqLike[D, Stream[D]]\r\n    LinearSeqLike[C, List[C]]\r\n\r\nwhich are lubbable without violating the type constraints.\r\n\r\nI don't think this was the right remedy. For starters, as seen in\r\nthis bug report, SI-8224, if the list of types are identical we\r\nhave let a perfectly good lub slip through our fingers, and end up\r\ncalculating too general a type.\r\n\r\nMore generally, if the type arguments in f-bounded positions coincide,\r\nwe don't risk calculating a ill-bounded LUB.\r\n\r\nFurthermore, the code was widening each of the types separately;\r\nthis isn't something we want to do within `if (isUniformFrontier)`.\r\nAFAICT this was just wasteful and as all `ts0` start with the same\r\ntype symbol, so `typeConstructorList` should be uniform.\r\n\r\nThis commit restricts this base-class skipping to situations where\r\nthe argument inferred for an type argument that is used as an f-bound\r\nis not:\r\n\r\n    a) an existential (as created by `mergePrefixAndArgs` in invariant\r\n      positions.), or\r\n    b) equivalent to one of the corresponding input type arguments\r\n       (this is the case that fixes the regression in pos/8224.scala)"
3556,'gkossakowski','SI-3235 math.round() returns wrong results for Int and Long\nNear-minimal fix for math.round() issue.  (Based on a more extensive fix proposed by soc.)\r\n\r\nRichLong intercepts calls to the four floating-point-only methods of .math: round, rint, ceil, and floor.\r\n\r\nAlso catches round on Int/Long in scala.math.'
3555,'retronym',"Small Predef cleanup\nRebased and improved #3553's fix for SI-8229.\r\nAlso rename Predef.conforms to Predef.$conforms so it can't accidentally be shadowed."
3551,'retronym','[nomaster] backports 609047ba37\nreview @retronym @gkossakowski'
3546,'retronym','CodePrinter added to Printers 2.11.0\n1. Typed trees printer is added to internal.Printers (as a part of CodePrinter). \r\nCodePrinter generates the code for passed attributed/unattributed trees.\r\n2. Attributed val/var processing for syntactics is added (SI-8180).\r\n3. Tests for CodePrinter are added.\r\n4. Code cleanup for EOL-printing #3377\r\n\r\nPrevious version (with comments): #3481'
3543,'retronym',"SI-5920 enables default and named args in macros\nFixes a tiny vararg mistake introduced in https://github.com/scala/scala/pull/3397, covers vararg expansion extensively, and additionally makes sure that new code paths are only taken by the code that didn't previously compile (named/default macro applications)."
3541,'retronym',"SI-5920 hardens macro engine against invalid inputs\nDue to an unexpected combination of c.abort's in Slick codebase (something\r\nthat I've yet to minimize), it was possible for a Block of erroneous macro\r\napplications to enter macro engine, wreaking havoc in undoNamesDefaults.\r\nThis commit prevents this from ever happening again."
3539,'retronym',"Avoid storing source file contents twice\nBatchSourceFile instances contain two almost identical character arrays,\r\ncontent0 and content. What's worse, content0 is even public. Instead,\r\ncontent0 should just be a constructor parameter. This seems the residual\r\nof an incomplete refactoring.\r\n\r\nI observed this waste of memory during debugging; after applying this\r\npatch, I've verified by hand that the second field indeed disappears.\r\n\r\nI don't expect a measurable difference, but this patch is not premature\r\noptimization because it makes code more logical.\r\n\r\nReview by @retronym ."
3536,'xeno-by','TypedTreePrinter added to Printers\nSupersedes https://github.com/scala/scala/pull/3481'
3534,'adriaanm','Add an extremely well-commented test\nThis commit includes a test for some simple existential subtyping\r\nchecks. It is exceptionally well-commented and may be helpful to\r\nsomeone trying to figure out what the rules are (supposed to be)\r\nin the future.\r\n\r\nReview by @retronym'
3533,'retronym','SI-8283 mutation-free bound inference for existentials\nA safer version of the fix for SI-6169 (#3471)\r\n\r\nreview by @retronym'
3532,'adriaanm','SI-7711 Do not emit extra argv in script body\nTake away `argv` and make `args` the standard parameter name.\r\n\r\nThis is a quick fix to avoid "unused local" lint error.  All\r\nthe examples use `args`; in particular, "Step 4. Write some\r\nScala scripts" in "Programming in Scala" uses `args`.\r\n\r\nI see the footnote there is also where Odersky concatenation is\r\nspecified, `"Hello, "+ args(0) +"!"` with no space next to the\r\nliterals.'
3529,'adriaanm',"SI-8072 rationalize public implicits in scala parallel collections\nPretty much everything seems like it's intended for internal use, so I wrapped it in a (deprecated) object.\r\n\r\nSplit toParArray out and put it in an implicit class."
3528,'adriaanm',"SI-6908 FlatHashTable and things that depend on it can't store nulls\nFixed ParFlatHashTable to use entryToElem which correctly converts sentinels to nulls."
3527,'adriaanm',"SI-8264 scala.collection.immutable.HashSet#- returns broken Set\nWas an error in HashSet's handling of removal of an element when a HashTrieSet should turn into a HashSet1.\r\n\r\nAlso slightly modified HashMap's filter0 to more closely match HashSet (by adding the same comment)."
3526,'gkossakowski',"SI-8276 Test for cyclic error caused by (reverted) SI-1786 fix\nWe reverted SI-1786 recently on the grounds that its means of\navoiding cycles (not sharpening bounds of T[_] when T is\nuninitialized) caused unacceptable non-determinism (well:\ncompilation order dependency) to type inference.\n\nNary a day later, @gkossakowski hit a regression in scala-io.\nBisection revealed that it stopped working in 2dbd17a2 and\nstarted working agiain after the revert. How's that for\nprescience!\n\nI've distilled the cyclic error in scala-io in this test\ncase.\n\nI'm yet to pinpoint this, followon error, which didn't survive\nthe shrink ray, and only appeared in the original code:\n\n    error: java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOptimized$class.apply(LinearSeqOptimized.scala:51)\n\tat scala.collection.immutable.List.apply(List.scala:83)\n\tat scala.reflect.internal.tpe.TypeMaps$AsSeenFromMap.correspondingTypeArgument(TypeMaps.scala:5\n\nReview by @gkossakowski.\n\n/cc @adriaanm (it will make a good test case for the alternative\napproach you're trying.)"
3525,'adriaanm','SI-8177 specializeSym must use memberInfo on high side\nWhen determining whether member `symLo` of `tpLo`\r\nhas a stronger type than member `symHi` of `tpHi`,\r\nshould we use memberType or memberInfo?\r\n\r\nWell, memberType transforms (using `asSeenFrom`) `sym.tpe`,\r\nwhereas memberInfo performs the same transform on `sym.info`.\r\nFor term symbols, this ends up being the same thing (`sym.tpe == sym.info`).\r\nFor type symbols, however, the `.info` of an abstract type member\r\nis defined by its bounds, whereas its `.tpe` is a `TypeRef` to that type symbol,\r\nso that `sym.tpe <:< sym.info`, but not the other way around.\r\n\r\nThus, for the strongest (correct) result,\r\nwe should use `memberType` on the low side.\r\n\r\nOn the high side, we should use the result appropriate\r\nfor the right side of the `<:<` above (`memberInfo`).'
3524,'adriaanm',"SI-8280 regression in implicit selection.\nIn 2fa2db7840 I fixed a bug where applicable implicit conversions\r\nwould not be found for numeric types if one introduced any aliasing\r\nor singleton types, for the usual reasons involving the absence of\r\nuniform type normalization. See pos/t7228 for examples - that test\r\ncase has 20 errors in 2.10.3 but compiles in master.\r\n\r\nAn unintended side effect was making implicit search less oblivious.\r\nIt turns out that in so doing I had created ambiguity where there was\r\nnone before. Not because it was any more ambiguous, but because the\r\ncompiler now had the wits to notice the ambiguity at an earlier time.\r\n\r\nThe fix for this is not intuitive. The way the internal logic is,\r\nwe need to keep the wool over implicit search's eyes, which leads\r\nto those unrecognized types being passed to adapt, where they are\r\nrecognized and weak subtyping suffices to be more specific. It is\r\nsufficient for SI-7228 that weak subtyping be done correctly - the\r\nother change, which is reverted here, was exposing the type arguments\r\nof Function1 when a view exists as a subtype of Function1.\r\n\r\nIt is also possible this could be remedied by calling weak_<:<\r\nsomewhere which is presently <:<, but I don't know where and it\r\nhas a far greater chance of affecting something else than does\r\nthis, which is a straight reversion of a post-2.10.3 change."
3523,'adriaanm','SI-5900 Fix pattern inference regression\nRebase #3514'
3522,'adriaanm',"SI-6493 more robust symbol handling in existentialTransform\nTo illustrate the problem, let's compute the result type for\r\n\r\n```\r\ndef foo = { class Foo { class Bar { val b = 2 }}; val f = new Foo; new f.Bar }\r\n```\r\n\r\nNote the inconsistent symbol ids in:\r\n\r\nrawSyms     = List(value f#49740, class Foo#49739, class Bar#49742)\r\nquantifiers + their infos =\r\n  type f.type#49774 <: AnyRef{type Bar#49762 <: AnyRef{val b#49764: Int}} with Singleton,\r\n  type Foo#49775    <: AnyRef{type Bar#49770 <: AnyRef{val b#49772: Int}},\r\n                              type Bar#49773 <: AnyRef{val b#49758: Int}\r\n\r\nIt makes sense to subst the symbols in tp, but the modifyInfo will have\r\nlittle effect on quantifiers. Luckily, coevolveSym will fix up some of\r\nthe inconsistencies, so that we get `f.type#49774.Bar#49762`, which is\r\nextrapolated to `AnyRef{type Bar#49868 <: AnyRef{val b: Int}}#Bar#49868`.\r\n\r\nThe intermediate type `f.type#49774.Bar#49762` motivates the need for\r\nthe `.substSym` above, as `.subst` does not touch the `Bar#49742` in\r\nthe `f#49740.Bar#49742` that we start out with.\r\n\r\nThe remaining problem is that ExistentialExtrapolation will not consider\r\ntype Bar#49868 as existentially bound. Instead, it's looking for the\r\nstale version in quantifiers, Bar#49773. If it was looking for Bar#49868,\r\nthe result type would simply be `AnyRef{val b: Int}`\r\n\r\nTODO: figure out how to compute the full set of quantifiers for extrapolation\r\n      the `doSubst(tp)` will clone more symbols, so we'll probably need to\r\n      traverse its result and somehow correlate the contained symbols to\r\n      those in `quantifiers`..."
3521,'retronym',"SI-8270 unconfuses bundles and vanilla macros\nThis fixes a mistake in macro impl ref typechecking that used to have\r\nan heuristic to figure out whether it looks at a bundle method ref or at\r\na vanilla object method ref. Under some circumstances the heuristic could\r\nfail, and then the macro engine would reject perfectly good macro impls.\r\n\r\nNow every macro impl ref is typechecked twice - once as a bundle method ref\r\nand once as a vanilla object method ref. Results are then analyzed,\r\nchecked against ambiguities (which are now correctly reported instead\r\nof incorrectly prioritizing towards bundles) and delivered to the macro\r\nengine.\r\n\r\nThe only heuristic left in place is the one that's used to report errors.\r\nIf both bundle and vanilla typechecks fail, then if a bundle candidate\r\nlooks sufficiently similar to a bundle, a bundle typecheck error is reported\r\nproviding some common bundle definition hints."
3520,'retronym',"SI-8269 tolerates CaseDefs with empty bodies\nThis commit proposes to make `CaseDef(_, _, EmptyTree)` behave the\r\nsame as `CaseDef(_, _, Literal(Constant(())))` with respect to typechecking.\r\n\r\nIt's not like we absolutely have to have that, but it would be definitely\r\nuseful for people who don't remember default values of tree parts by heart."
3517,'retronym',"SI-8271 ignore free term values if we can't see them\nMigration of reification from resetAllAttrs to resetLocalAttrs uncovered\r\na serious bug with reifications of free terms that could emit references\r\nto symbols that don't belong to current lexical scopes. Such symbols can\r\narise when recursively reifying owners of existentials that can come from\r\narbitrary places in the program.\r\n\r\nThis commit ignores values of such free terms (reifying them as ???)\r\nin order to plug an issue that would otherwise be a non-workaroundable\r\nregression in 2.11.0-RC1.\r\n\r\nI don't have a very good understanding of this thing, but intuitively\r\nwe shouldn't even think of reifying existentials that originate elsewhere.\r\nFrom what I can see from my brief excursion into typer, a typical approach\r\nof dealing with this is skolemizing existentials that come from elsewhere\r\nand then packing them up by calling existentialAbstraction on created skolems.\r\nTheoretically we could apply the same approach to reified types, but\r\nthat will have to remain future work, as that would be too risky for RC1."
3516,'retronym'," SI-8177 co-evolve more than just RefinedTypes \n[Rebase and improvement of #3482]\r\n\r\n`asSeenFrom` produced a typeref of the shape `T'#A` where `A` referred to a symbol\r\ndefined in a `T` of times past.\r\n\r\nMore precisely, the `TypeRef` case of `TypeMap`'s `mapOver` correctly modified a prefix\r\nfrom having an underlying type of `{ type A = AIn }` to `{ type A = Int }`,\r\nwith a new symbol for `A` (now with info `Int`), but the symbol in the outer\r\n`TypeRef` wasn't co-evolved (so it still referred to the `A` in `{ type A = AIn }`\r\nunderlying the old prefix).\r\n\r\n`coEvolveSym` used to only look at prefixes that were directly `RefinedType`s,\r\nbut this bug shows they could also be `SingleType`/`ThisType`s with an underlying `RefinedType`,\r\nso we look for a prefix's for a refinement class for a type symbol instead.\r\n\r\nReview by @retronym  "
3515,'gkossakowski','A test case for a name binding progression\nI noticed the change when adapting Slick to work with\nScala 2.11 in `AbstractSourceCodeGenerator.scala`.\nThe behaviour changed in a70c8219.\n\nThis commit locks down the new, correct behaviour with a test.\n\nReview by @gkossakowski\n\n/cc @szeiger, @cvogt'
3514,'adriaanm',"SI-5900 Fix pattern inference regression\nDeets in the commits, review by @adriaanm\n\n/cc @paulp (we'll take another swing at SI-7886 in 2.12)"
3513,'retronym','typecheck(q"class C") no longer crashes\nMemberDefs alone can\'t be typechecked as is, because namer only names\r\ncontents of PackageDefs, Templates and Blocks. And, if not named, a tree\r\ncan\'t be typed.\r\n\r\nThis commit solves this problem by wrapping typecheckees in a trivial block\r\nand then unwrapping the result when it returns back from the typechecker.'
3511,'densh','SI-8266 Deprecate octal escapes in f-interpolator\nAlso turns the f-interpolator into a migration\r\nassistant by suggesting alternatives for the\r\nstandard escapes.\r\n\r\nJust a little brown-bagged exercise, in case it is useful.\r\n\r\nIt would have been more fun if it could have recommended replacing `\\042` with \'$"`.\r\n'
3504,'gkossakowski','SI-8167 readLine shold flush output before reading input\n(patch by @retronym from #3393, I just rebased it)\r\n\r\nAs reported on scala-user:\r\n\r\n> Using `scala.Predef.readLine(text: String, args: Any*)`\r\n> on Windows causes strange behavior. If I am leaving some\r\n> part of `text` unforced to be flushed (say, "---\\nEnter new\r\n>  expression >") then "Enter new expression >" flushed only\r\n> after Enter press. Still, it works fine on Ubuntu and (seems like)\r\n> on MacOS.\r\n>\r\n> My workaround is to force `java.lang.System.out` (that readLine\r\n> depends on to write welcome string) to flush output like\r\n> "---\\nEnter new expression >\\n".'
3503,'adriaanm',"SI-7475 Private members aren't inheritable, findMember overhaul\nRebase of #3440"
3499,'xeno-by','Make handling of tuples more consistent in quasi-quotes\nOn one hand we know that `q"($expr)"` is the same as `q"$expr"`. On the other if we wrap it into a list and splice as `q"(..$expr)"` we get a `Tuple1` which is inconsistent.\r\n\r\nThis pull request fixes this inconsistency by making `q"(..$expr)"` being equivalent `q"(${expr.head})"` for single-element list.\r\n\r\nWe also add support for matching of expressions as single-element tuples (similarly to blocks) and remove liftables and unliftables for `Tuple1` (which aren\'t clearly defined any longer due to `q"(foo)" == q"foo"` invariant).\r\n\r\nreview @xeno-by'
3498,'gkossakowski','SI-8240 Consider rolling back optimizations for List\nSome compiler-specific optimizations turn out to be very helpful for Lists in general.\r\n\r\n  * List map can be a lot faster (up to 5x!)\r\n  * List collect can be considerably faster (up to 2.5x)\r\n  * List flatMap can be a bit faster (1.5x)\r\n  * List take can be slightly faster (1.1x) and have better structural sharing\r\n\r\nThese appear to be unqualified wins (tested), even in a scenario with mixed collections.  This is expected: detecting the builder is faster than the otherwise mandatory object creation, and multiple dispatch is mostly a wash since it was already multiple dispatch in getting to the builder.'
3497,'adriaanm','SI-8129 Make Object#== override Any#==\n[This is a rebase of #3464]\r\n\r\nAnd the same for !=\r\n\r\nIf we tried to declare these signatures in non-fictional classes,\r\nwe would be chastised about collapsing into the "same signature after\r\nerasure".\r\n\r\nThis will have an influence of typing, as the typechecking of\r\narguments is sensitive to overloading: if multiple variants are\r\nfeasible, the argument will be typechecked with a wildcard expected\r\ntype. So people inspecting the types of the arguments to `==` before\r\nthis change might have seen an interesting type for\r\n`if (true) x else y`, but now the `If` will have type `Any`, as we\r\ndon\'t need to calculate the LUB.\r\n\r\nI\'ve left a TODO to note that we should really make `Any#{==, !=}`\r\nnon-final and include a final override in `AnyVal`. But I don\'t think\r\nthat is particularly urgent.'
3495,'retronym','changes the order of whitebox typechecks. yes, again.\nMy first attempt at SI-6992 was about having whitebox expansions first\r\ntypecheck against outerPt and only then verify that the result is compatible\r\nwith innerPt.\r\n\r\nThat was a nice try, but soon after it went live in 2.11.0-M8, we\'ve got\r\nmultiple reports with problems - both shapeless and then in a week specs2\r\nstarted having issues with their whitebox macros.\r\n\r\nIn shapeless, typecheck against outerPt screwed up type inference, which\r\nwas more or less fixable by explicit type annotations, so I decided to\r\nwait a bit before jumping to conclusions.\r\n\r\nHowever, in specs2 the problem was more insidious. After being typechecked\r\nagainst outerPt, expansions were being implicitly converted to a type\r\nthat became incompatible with innerPt. This revealed a fatal flaw of the\r\nimplemented approach - if allowed to typecheck against outerPt first,\r\nwhitebox macros could never be robust.\r\n\r\nNow realizing that "outerPt > innerPt" doesn\'t work, I nevertheless wasn\'t\r\nlooking forward to rolling that back to "innerPt > outerPt", because that\r\nwould revive SI-6992 and SI-8048 that are highly unintuitive, especially\r\nthe latter one.\r\n\r\nTherefore, this commit combines the permissiveness of "... > innerPt"\r\napproaches with the robustness of "innerPt > outerPt", introducing\r\n"WildcardType > innerPt > outerPt".'
3494,'gkossakowski',"Optimization: use AnyRef map for Namer -> Typer tree handoff\nAnd uses a map per-compilation unit, rather than one per Typer.\n\nNo need to cleanup in `reset()`, this way.\n\nReview by @gkossakowski\n\nIn my topic/opt2 branch, I used tree attachments as an alternative\nto using a map at all. But when I submitted a PR with that change,\nthe test suite picked up a subtle change in behaviour that I didn't\nhave time to investigate. Switching to `AnyRefMap` is a lower-risk\npatch, but still worthwhile for performance."
3493,'gkossakowski','SI-3452 Correct Java generic signatures for mixins, static forwarders\n[Parts of this patch and some of the commentary are from @paulp]\r\n\r\nThis took me so long to figure out I can\'t even tell you. Partly because\r\nthere were two different bugs, one which only arose for trait forwarders\r\nand one for mirror class forwarders, and every time I\'d make one set\r\nof tests work another set would start failing. The runtime failures\r\nassociated with these bugs were fairly well hidden because you usually\r\nhave to go through java to encounter them: scala doesn\'t pay that much\r\nattention to generic signatures, so they can be wrong and scala might still\r\ngenerate correct code. But java is not so lucky.\r\n\r\n## Bug in mixin forwarders\r\n\r\nDuring mixin composition, classes which extend traits receive forwarders\r\nto the implementations. An attempt was made to give these the correct\r\ninfo (in method "cloneBeforeErasure") but it was prone to giving\r\nthe wrong answer, because: the key attribute which the forwarder\r\nmust capture is what the underlying method will erase to *where the\r\nimplementation is*, not how it appears to the class which contains it.\r\nThat means the signature of the forwarder must be no more precise than\r\nthe signature of the inherited implementation unless additional measures\r\nwill be taken.\r\n\r\nThis subtle difference will put on an unsubtle show for you in test\r\nrun/t3452.scala.\r\n\r\n    trait C[T]\r\n    trait Search[M] { def search(input: M): C[Int] = null }\r\n    object StringSearch extends Search[String] { }\r\n    StringSearch.search("test");  // java\r\n    // java.lang.NoSuchMethodError: StringSearch.search(Ljava/lang/String;)LC;\r\n\r\nThe principled thing to do here would be to create a pair of\r\nmethods in the host class: a mixin forwarder with the erased\r\nsignature `(String)C[Int]`, and a bridge method with the same\r\nerased signature as the trait interface facet.\r\n\r\nBut, this turns out to be pretty hard to retrofit onto the\r\ncurrent setup of Mixin and Erasure, mostly due to the fact\r\nthat mixin happens after erasure which has already taken\r\ncare of bridging.\r\n\r\nFor a future, release, we should try to move all bridging\r\nafter mixin, and pursue this approach. But for now, what can\r\nwe do about `LinkageError`s for Java clients?\r\n\r\nThis commit simply checks if the pre-erasure method signature\r\nthat we generate for the trait forward erases identically to\r\nthat of the interface method. If so, we can be precise. If not,\r\nwe emit the erased signature as the generic signature.\r\n\r\n## Bug in static forwarders\r\n\r\nThe same principle is at work, at a different location.\r\nDuring genjvm, objects without declared companion classes\r\nare given static forwarders in the corresponding class, e.g.\r\n\r\n    object Foo { def bar = 5 }\r\n\r\nwhich creates these classes (taking minor liberties):\r\n\r\n    class Foo$ { static val MODULE$ = new Foo$ ; def bar = 5 }\r\n    class Foo  { static def bar = Foo$.MODULE$.bar }\r\n\r\nIn generating these, genjvm circumvented the usual process whereby one\r\ncreates a symbol and gives it an info, preferring to target the bytecode\r\ndirectly. However generic signatures are calculated from symbol info\r\n(in this case reusing the info from the module class.) Lacking even the\r\nattempt which was being made in mixin to "clone before erasure", we\r\nwould have runtime failures of this kind:\r\n\r\n    abstract class Foo {\r\n      type T\r\n      def f(x: T): List[T] = List()\r\n    }\r\n    object Bar extends Foo { type T = String }\r\n    Bar.f("");    // java\r\n    // java.lang.NoSuchMethodError: Bar.f(Ljava/lang/String;)Lscala/collection/immutable/List;\r\n\r\nBefore/after this commit:\r\n\r\n    <   signature                                     f  (Ljava/lang/String;)Lscala/collection/immutable/List<Ljava/lang/String;>;\r\n    ---\r\n    >   signature                                     f  (Ljava/lang/Object;)Lscala/collection/immutable/List<Ljava/lang/Object;>;\r\n\r\nThis takes the warning count for compiling collections under\r\n`-Ycheck:jvm` from 1521 to 26.\r\n'
3492,'retronym',"prevents using reify and quasiquotes in the compiler\nKind of prevents us from using quasiquoting facilities in scalac,\r\nbecause those depend on internal APIs that can easily diverge from starr,\r\ncreating problems similar to https://groups.google.com/forum/#!topic/scala-internals/K4EoU6q0dek.\r\n\r\nThis hack doesn't strictly prohibit those facilities from being used,\r\nsince I have no good idea about how to do that reliably, but rather\r\nmakes reification/quasiquoting print swaths of debug output that are\r\ngoing to catch someone's eye."
3489,'Ichoran','This fixes SI-8251: `ListBuffer.readOnly` destroys List immutability\nMethod `BufferLike.readOnly` now returns a view over changing state of the buffer.\r\n\r\nDiscussion:\r\nhttps://groups.google.com/d/msg/scala-internals/g_-gIWgB8Os/kWazrALbLKEJ\r\n'
3487,'gkossakowski','fix typo\n'
3486,'adriaanm',"SI-7553 Propagate type of unstable args through dependent methods\nAfter a soundness fix in , instantiation of dependent\r\nmethod type results behaved differently for if the argument\r\nfrom which we were propagating information had a stable type\r\nor not. This is particular to substutition into singleton types\r\nover the parameter in question.\r\n\r\nIf the argument was stable, it was substituted into singleton\r\ntypes, such as the one below in the prefix in `a.type#B`\r\n(which is the longhand version of `a.B`)\r\n\r\n\tscala> class A { type B >: Null <: AnyRef }\r\n\tdefined class A\r\n\r\n\tscala> object AA extends A { type B = String }\r\n\tdefined object AA\r\n\r\n\tscala> def foo(a: A): a.B = null\r\n\tfoo: (a: A)a.B\r\n\r\n\tscala> foo(AA)\r\n\tres0: AA.B = null\r\n\r\nBut what if it isn't stable?\r\n\r\n\tscala> foo({def a = AA; a: A { type B <: String}})\r\n\tres3: a.B = null\r\n\r\nThis commit changes that to:\r\n\r\n\tscala> foo({def a = AA; a: A { type B <: String}})\r\n\tres1: a.type with A{type B <: String}#B = null\r\n\r\nThat oddly printed type is missing parens: it should be:\r\n\r\n    (a.type with A{type B <: String})#B\r\n\r\nIt is is a projection from refinement that combines:\r\n  a) the singleton type on the parameter\r\n  b) the type of the argument\r\n\r\nReview by @adriaanm"
3485,'retronym','kills resetAllAttrs\nreview @retronym'
3483,'adriaanm',"SI-8244 Fix raw type regression under separate compilation\nIn #1901, handling of raw types encountered in signatures during class\nfile parsing was changed to work in the same manner as\n`classExistentialType`, by using\n`existentialAbstraction(cls.tparms, cls.tpe_*)`\n\nBut this never creates fresh existential symbols, and just sticks\nthe class type parameters it `quantified`:\n\n\tscala> trait T[A <: String]\n\tdefined trait T\n\n\tscala> val cls = typeOf[T[_]].typeSymbol\n\tcls = trait T#101864\n\n\tscala> cls.typeParams\n\tres0 = List(type A#101865)\n\n\tscala> cls.tpe_*\n\tres1 = T#101864[A#101865]\n\n\tscala> classExistentialType(cls)\n\tres3 = T#101864[_ <: String#7209]\n\n\tscala> val ExistentialType(quantified, result) = res3\n\tList(type A#101865)\n\nIn the enclosed test case, this class type parameter was substituted\nduring `typeOf[X] memberType sym`, which led us unsoundly thinking\nthat `Raw[_]` was `Raw[X]`.\n\nI've added a TODO comment to review the other usages of\n`classExistentialType`.\n\nTest variations include joint and separate compilation, and the\ncorresponding Scala-only code. All fail with type errors now,\nas we expect.\n\nReview by @adriaanm. /cc @paulp"
3482,'retronym',"SI-8177 co-evolve more than just RefinedTypes\n`asSeenFrom` produced a typeref of the shape `T'#A` where `A` referred to a symbol\r\ndefined in a `T` of times past.\r\n\r\nMore precisely, the `TypeRef` case of `TypeMap`'s `mapOver` correctly modified a prefix\r\nfrom having an underlying type of `{ type A = AIn }` to `{ type A = Int }`,\r\nwith a new symbol for `A` (now with info `Int`), but the symbol in the outer\r\n`TypeRef` wasn't co-evolved (so it still referred to the `A` in `{ type A = AIn }`\r\nunderlying the old prefix).\r\n\r\n`coEvolveSym` used to only look at prefixes that were directly `RefinedType`s,\r\nbut this bug shows they could also be `SingleType`s with an underlying `RefinedType`.\r\n\r\nReview by @paulp "
3481,'xeno-by','TypedTreePrinter added to Printers\n1. TypedTreePrinter is added to internal.Printers. TypedTreePrinter generates the code for passed attributed trees.\r\n2. Attributed val/var processing for syntactics added ([SI-8180] (https://issues.scala-lang.org/browse/SI-8180)).\r\n3. Tree-based printer selection for showCode added.\r\n4. Tests for TypedTreePrinter are added.\r\n5. Code cleanup for EOL-printing https://github.com/scala/scala/pull/3377'
3480,'Ichoran',"SI-6948 Make the Abstract* classes public.\nSeveral weaknesses in the implementation converge and force multiply.\r\n\r\n1) Type constructor inference is not persistent. During implicit search\r\nit will give up after the first seen parent even if some deeper base type\r\n(even another direct parent) would satisfy the search.\r\n\r\n2) Type inference is not aware of access restrictions. Inferred types are\r\ncalculated with disregard for whether the inferred type is visible at\r\nthe point of inference. That means that package-private types - which may be\r\nprivate for any number of good reasons, such as not wanting them to appear in\r\nbytecode thus creating binary compatibility obligations - are not private.\r\nThere is no such thing as a qualified private type.\r\n```\r\n  package p {\r\n    trait PublicInterface[T] { def foo(): Int }\r\n    private[p] trait ImplementationOnly[T] extends PublicInterface[T] { def foo(): Int = 1 }\r\n    class PublicClass extends ImplementationOnly[PublicClass]\r\n  }\r\n  package q {\r\n    object Test {\r\n      def f[A, CC[X]](xs: CC[A]): CC[A] = xs\r\n      def g = f(new p.PublicClass) // inferred type: p.ImplementationOnly[p.PublicClass]\r\n      def h = g.foo()\r\n      // Bytecode contains:\r\n      // public p.ImplementationOnly<p.PublicClass> g();\r\n      // public int h();\r\n      //    0: aload_0\r\n      //    1: invokevirtual #30                 // Method g:()Lp/ImplementationOnly;\r\n      //    4: invokeinterface #33,  1           // InterfaceMethod p/ImplementationOnly.foo:()I\r\n      //    9: ireturn\r\n    }\r\n  }\r\n```\r\n3) The trait encoding leads to a proliferation of forwarder methods, so much so that\r\n1.5 Mb of bytecode was taken off of the standard library size by creating abstract classes\r\nwhich act as central mixin points so that leaf classes can inherit some methods the\r\nold fashioned way rather than each receiving their own copy of every trait defined method.\r\nThis was done for 2.10 through the creation of the Abstract* classes, all of which were\r\ngiven reduced visibility to keep them out of the API.\r\n```\r\n  private[scala] class AbstractSeq extends ...\r\n```\r\nThis achieved its intended goal very nicely, but also some unintended ones.\r\n\r\nIn combination with 1) above:\r\n```\r\n  scala> val rand = new scala.util.Random()\r\n  rand: scala.util.Random = scala.util.Random@7f85a53b\r\n\r\n  // this works\r\n  scala> rand.shuffle(0 to 5)\r\n  res1: scala.collection.immutable.IndexedSeq[Int] = Vector(4, 0, 1, 2, 5, 3)\r\n\r\n  // and this doesn't! good luck reasoning that one out\r\n  scala> rand.shuffle(0 until 5)\r\n  <console>:9: error: Cannot construct a collection of type scala.collection.AbstractSeq[Int]\r\n    with elements of type Int based on a collection of type scala.collection.AbstractSeq[Int].\r\n                rand.shuffle(0 until 5)\r\n                            ^\r\n\r\n  // Somewhat comically, in scala 2.9 it was flipped: to failed (differently), until worked.\r\n  scala> scala.util.Random.shuffle(0 to 5)\r\n  <console>:8: error: type mismatch;\r\n   found   : scala.collection.immutable.Range.Inclusive\r\n   required: ?CC[?T]\r\n\r\n  scala> scala.util.Random.shuffle(0 until 5)\r\n  res2: scala.collection.immutable.IndexedSeq[Int] = Vector(4, 3, 1, 2, 0)\r\n```\r\nIn combination with 2) above:\r\n```\r\n  scala> def f[A, CC[X]](xs: CC[A]): CC[A] = xs\r\n  f: [A, CC[X]](xs: CC[A])CC[A]\r\n\r\n  scala> var x = f(1 until 10)\r\n  x: scala.collection.AbstractSeq[Int] = Range(1, 2, 3, 4, 5, 6, 7, 8, 9)\r\n\r\n  // It has inferred a type for our value which it will not allow us to use or even to reference.\r\n  scala> var y: scala.collection.AbstractSeq[Int] = x\r\n  <console>:10: error: class AbstractSeq in package collection cannot be accessed in package collection\r\n         var y: scala.collection.AbstractSeq[Int] = x\r\n                                 ^\r\n  // This one is a straight regression - in scala 2.9,\r\n  scala> var x = f(1 until 10)\r\n  x: scala.collection.immutable.IndexedSeq[Int] = Range(1, 2, 3, 4, 5, 6, 7, 8, 9)\r\n```\r\nSince 1) and 2) are essentially unfixable - at least by me - I propose\r\nto ameliorate these regressions by attacking the symptoms at the leaves.\r\nThat means making all the Abstract* classes public - keeping in mind that\r\nthey must already be assumed to be in the binary compatibility footprint,\r\nsince they have been leaking throughout their existence. This only impacts\r\nthe inference of inaccessible collections types - it doesn't help with the\r\nmore serious issue with type inference."
3476,'adriaanm',"SI-8207 Allow import qualified by self reference\nThis regressed in SI-6815 / #2374. We check if the result of\r\n`typedQualifier(Ident(selfReference))` is a stable identifier\r\npattern. But we actually see the expansion to `C.this`, which\r\ndoesn't qualify.\r\n\r\nThis commit adds a special cases to `importSig` to compensate.\r\nThis is safe enough, because the syntax prevents the following:\r\n\r\n\tscala> class C { import C.this.toString }\r\n\t<console>:1: error: '.' expected but '}' found.\r\n\t       class C { import C.this.toString }\r\n\t                                        ^\r\nSo loosening the check here doesn't admit invalid programs.\r\nI've backed this up with a `neg` test.\r\n\r\nThe enclosed test also checks that we can use the self\r\nreference in a singleton type. (That wasn't broken.)\r\n\r\nMaybe it would be more principled to avoid expanding the self\r\nreference in `typedIdent`. I can imagine that the current situation\r\nis a pain for refactoring tools that try to implement a rename\r\nrefactoring, for example.\r\n\r\nSeems a bit risky at the minute, but I've noted the idea\r\nin a comment.\r\n\r\nReview by @adriaanm. \r\n\r\n/cc @misto for discussion about the expansion of the `Ident` to a `This` in the IDE context."
3472,'gkossakowski',"Fix compilation errors\nThis fixes compilation errors about adapted argument lists and\r\na type error between CharSequence and String\r\n\r\n---\r\n\r\nI have no idea how the type error between CharSequence and String happened. Compiling it in the IDE doesn't work whereas on the command line everything is ok."
3470,'adriaanm',"SI-8215: Correcting typo and splitting a long sentence in MatchIterator doc\nFollow-up to 9c0ca62. The typo comes from the fact that I didn't take into account the full rendering of exception names:\r\n\r\n![image](https://f.cloud.github.com/assets/223702/2091023/ed0ff260-8e9b-11e3-88f3-b6a1465e096c.png)\r\n\r\nAlso taken the opportunity to split a sentence that seems a bit long into two.\r\n\r\nReview by @adriaanm @heathermiller\r\n\r\nSorry that we need this fixup!"
3468,'xeno-by',"Add support for a more straightforward alternative to import selectors\nWhile writing new revised version of documentation for quasiquotes I've noticed that quasiquotes still required usage of ugly non-tree ImportSelector api that didn't compose very well. This pull request adds a much nicer syntactic construction/deconstruction alternative.\r\n\r\nreview @xeno-by"
3464,'adriaanm',"SI-8219 Coherency for `{Any, Object}#==`; typer.context / infer.context\n- Make our ficticious == and != methods line up for overriding checks\r\n  - Eliminate a major source of puzzling behaviour by ensuring Inferencer\r\n    and Typer agree on what the current Context is.\r\n\r\nReview by @adriaanm, @xeno-by @lrytz (or any number of people that have been puzzled about what a strange Context was doing in their inferencer over the years...)\r\n\r\nThese changes are independent, I can break them up if desired. The `==` parts are probably a touch riskier as I don't know the history of the divergent signatures."
3463,'densh',"SI-7937 No nested if after val def in for\nDeprecate nested if after a value definition in\r\na for comprehension. (That is per spec.)\r\n\r\nThe difference is between\r\n```\r\nfor (i <- is if i > 0)\r\n```\r\nand\r\n```\r\nfor (i <- is ; j = 2 * i if i > 0)\r\n```\r\nwhere, in the second form, the guard seems to\r\ncontrol perlesquely the val def. That is confusing\r\nto the human eye.\r\n\r\nThe first form, where the guard directly follows\r\na generator, is OK because a generator doesn't\r\nlook like an expression that would be guarded\r\nby the if condition.\r\n\r\nReview by @densh"
3459,'gkossakowski','SI-4788 Respect RetentionPolicy of Java annotations\nAlso closes SI-5420 and SI-5948.'
3458,'xeno-by','SI-8173 add support for patterns like init :+ last to quasiquotes\nAdds support for patterns like:\r\n```scala\r\n  val q"{ ..$init; $last }" = q"{ a; b; c }"\r\n  // init == List(q"a", q"b")\r\n  // last == q"c"\r\n```\r\nWhich under the hood get compiled as `:+` patterns:\r\n```scala\r\n  SyntacticBlock(init :+ last)\r\n```'
3457,'adriaanm',"SI-8228 Avoid infinite loop with erroneous code, overloading\nSI-8228 Avoid infinite loop with erroneous code, overloading …\r\n`isApplicableBasedOnArity` couldn't get of the ferris wheel after\r\nas `followApply` kept insisting on another spin.\r\n\r\n    scala> ErrorType nonPrivateMember nme.apply\r\n    res0: $r.intp.global.Symbol = value apply\r\n\r\n    scala> res0.info\r\n    res1: $r.intp.global.Type = <error>\r\n\r\nThis commit makes `followApply` consider that an `ErrorType`\r\ndoes not contain an `apply` member.\r\n\r\nI also considered whether to do a deep check on the type\r\n(`isErroneous`), but I can't motivate this with a test.\r\nI tend to think we *shouldn't* do that: `List[${ErrorType}]`\r\nstill has an `apply` member that we should follow, right?\r\n\r\nReview by @adriaanm "
3456,'gkossakowski','SI-8226 Deduplicate JavaTokens/ScalaTokens\n'
3455,'xeno-by','Fix SI-8202 and improve support for splicing patterns into vals\nFixes:\r\n- SI-8202 makes quasiquote parse q"val (x: Int) = 1" the same as q"val x: Int = 1" \r\n- Splicing of patterns into vals which was quite broken previously\r\n\r\nreview @xeno-by @retronym'
3454,'retronym',"SI-5994 battling implicits for String.lines\nDeprecated ProcessBuilder's lines method and renamed it streaming.\r\n\r\nstream was another possibility, but that seemed more likely to cause conflicts.\r\n\r\nAlso updated tutorial in ProcessBuilder.\r\n\r\nI am sure this will break some tests, but because of the name conflict it's hard to be sure where they are.  So Jenkins gets to find the problems for me."
3452,'retronym','SI-8063 and its seventy friends\nThis is a preview version of the pull request that addresses https://issues.scala-lang.org/browse/SI-8063 in parallel with cleaning up reflection API for 2.11 and fixing a bunch of low-hanging bugs.\r\n\r\n**Much needed day-to-day APIs**\r\n\r\nThis pull request brings a number of methods that have been frequently requested by you guys (thanks a lot for your relentless feedback!), including `Type.typeArgs`, `Flag.PARAMACCESSOR` and `Type.companionType`. It also adds new conveniences like `ClassSymbol.isPrimaryConstructor`, `symbolOf[T]` and `typecheck(tree, TYPEmode)` that simplify typical reflection tasks both at compile time and at runtime.\r\n\r\n**First-class support for complex macros**\r\n\r\nOver the course of Scala 2.10, it\'s become clear that high-level reflection APIs are insufficient for complex macros (async, sbt, etc) and that those low-level APIs that we put in place anticipating the difficulties aren\'t enough either. As a result, macro programmers are often forced to perform casts to compiler internals, which not only requires close knowledge of compiler internals, but also makes such macros hard to maintain, as compiler internals can change without notice at any time.\r\n\r\nThese problems with complex macros are caused by internal implementation details of the macro engine that we\'ve already been trying to address for some time (https://groups.google.com/forum/#!topic/scala-internals/TtCTPlj_qcQ), but we\'re still not done with the fixes. Hopefully, we\'ll be able to merge some progress over the course of 2.11.x lifecycle, and by the 2.12.0-final release we\'ll have this handled, but no promises yet.\r\n\r\nIn the meanwhile, thanks to precious feedback from Jason Zaugg, we have been able to identify the low-level APIs that should be sufficient to work around the existing problems while we\'re looking for a definitive fix. We have exposed these APIs under `import c.internal._`, so that there\'s no longer need to cast to address typical issues arising in complex macros.\r\n\r\nDocumentation of these techniques is still scarce, but in mid-May @densh and I are going to run the ["Macrology 201" workshop](http://2014.flatmap.no/speakers/burmako.html) at flatMap, so stay tuned if you\'re interested in that kind of stuff.\r\n\r\n**Towards perfect reflection API**\r\n\r\nWhile reflection API has definitely become easier to use during the Scala 2.11 development cycle (quasiquotes, bunch of deprecations of confusing APIs, isolation of low-level APIs in `internal`, thread safety), there\'s still much work to do.\r\n\r\nAmong the most pressing issues I would highlight the following five bugs that we\'re going to take a very good look at for Scala 2.12: [Typechecking is not idempotent](https://issues.scala-lang.org/browse/SI-5464), [Hygiene for tree manipulation](https://issues.scala-lang.org/browse/SI-7823), [Get rid of pervasive casts in the reflection API](https://issues.scala-lang.org/browse/SI-8220), [Better usability for reflective invocations](https://issues.scala-lang.org/browse/SI-8221) and [Toolbox doesn\'t respect relative imports](https://issues.scala-lang.org/browse/SI-6393).\r\n'
3451,'adriaanm','SI-8214 AnyRefMap should not be final\nAnyRefMap is now not final; instead, the interrelated core methods for retrieval/removal are marked final.\r\n\r\nAdditionally, the defaultEntry field has been removed, and the overriding method for specifying a default has been restored.\r\n\r\nThe same changes have been made to LongMap also (as that has the same design).\r\n\r\nTests have been modified appropriately.'
3450,'gkossakowski',"SI-7266 Stream leaks memory\nChanged tail-generation function to mutable and clear it after it's used to allow any captured memory to be freed once the tail has been generated.\r\n\r\n(This is a case where a by-name parameter was used when a lazy val parameter was wanted instead.  If we ever get lazy val parameters, we should switch to that.)"
3449,'gkossakowski','Another grab bag of compiler optimizations\nReview by @gkossakowski'
3448,'gkossakowski','Optimizations in tail calls\nReview by @gkossakowski'
3445,'gkossakowski',"Grab bag of compiler optimizations\n@gkossakowski This work comes from my branch that we\nwent through in Lausaunne a few months back.\n\nSorry I was so slow to submit this as PRs. I had hoped\nto find more time to robustly benchmark, but you know\nhow it goes...\n\nWhen I tried, your benchmark tool showed the usual\nproblems of saying anything conclusive about individual\ncommits, but the trend over the entire series unambigious.\nThe entire series showed ~30% delta for FSC-style compilation,\n~20% for SBT-style (new Global instance each compilation batch.)\n\nI'm trying to submit what I consider to be uncontroversial\nchanges in groups. If a particular change requires deeper\nreview, I'll submit it individually.\n\n/cc @ichoran"
3444,'gkossakowski','Avoid generic collections operations hot paths\n- Use a specialized version of List#{map, collectFirst}\n   These special case mapping over an empty list and avoid\n   allocating.\n - Avoid nonEmpty in favor of `ne Nil`\n\nI see in the order of 2% speedup.\n\nPerhaps more useful is that\nthese methods no longer dominate the YourKit profiles, even though\nprofiler bias due to safepoints at allocation of the ListBuffer\nmight have been overstating their significance.\n\nReview by @gkossakowski / @ichoran'
3443,'adriaanm','add -Xsource:version to scalac man page\nThe flag was added in d43618a (PR #3340) by @huitseeker.'
3442,'adriaanm',"Fix SI-8217\nRealign the compiler with the proposed spec update: scala/scala-dist#127\r\n\r\nI know I'll need to rewrite the commit message.\r\n\r\nReview by @retronym."
3440,'adriaanm',"SI-7475 Private members aren't inheritable, findMember overhaul\nReview by @adriaanm @odersky @xeno-by\n\nDetails in the commit messages. The last one poses a few questions\nfor which I need input."
3439,'heathermiller','SI-8215: Document IllegalStateExceptions thrown by uninitialized MatchIterator from Regex (review by @heathermiller)\nAlso cleans up a misaligned ASCII art class diagram which is duplicated by the Content Hierarchy anyway.\r\n\r\nSee https://groups.google.com/forum/#!topic/scala-language/2T2wKVQiyVg'
3438,'heathermiller','SI-4014 Scaladoc omits @author\nreview by @VladUreche'
3437,'adriaanm','SI-6736 Range.contains is wrong\nRemoved once-used private method that was calculating ranges in error and corrected the contains method (plus improved performance).'
3435,'Ichoran','SI-3235 Add round/ceil/floor to integral number types\nThis is a stopgap measure to prevent implicit conversions to\r\nfloating point numbers which cause issues like\r\n\r\n  123456789.round == 123456792'
3433,'adriaanm','SI-7933 REPL javax.script eval is cached result\n'
3432,'adriaanm',"Improve ExecutionContext implicitNotFound and docs\nIt is not good practice to import a specific ExecutionContext all over the place; we shouldn't recommend that. People should allow callers to specify the context in most cases and only import the context in some central location in their code."
3428,'gkossakowski',"SI-6260 Avoid double-def error with lambdas over value classes\nPost-erasure of value classs in method signatures to the underlying\ntype wreaks havoc when the erased signature overlaps with the\ngeneric signature from an overriden method. There just isn't room\nfor both. But we *really* need both; callers to the interface method\nwill be passing boxed values that the bridge needs to unbox and\npass to the specific method that accepts unboxed values.\n\nThis most commonly turns up with value classes that erase to\nObject that are used as the parameter or the return type of\nan anonymous function.\n\nThis was thought to have been intractable, unless we chose\na different name for the unboxed, specific method in the\nsubclass. But that sounds like a big task that would require\ncall-site rewriting, ala specialization.\n\nBut there is an important special case in which we don't need\nto rewrite call sites. If the class defining the method is\nanonymous, there is actually no need for the unboxed method;\nit will *only* ever be called via the generic method.\n\nI came to this realisation when looking at how Java 8 lambdas\nare handled. I was expecting bridge methods, but found none.\nThe lambda body is placed directly in a method exactly matching\nthe generic signature.\n\nThis commit detects the clash between bridge and target,\nand recovers for anonymous classes by mangling the name\nof the target method's symbol. This is used as the bytecode\nname. The generic bridge forward to that, as before, with\nthe requisite box/unbox operations.\n\nReview by @gkossakowski"
3424,'adriaanm','SI-7322 Interpolator idents must be encoded\nOtherwise, they are not found.\r\n\r\nThis matters for term names with a differential encoding.'
3423,'retronym',"SI-1503 don't assume unsound type for ident/literal patterns\nWhat type should a variable bound to the value matched by a pattern have?\r\nTo avoid CCEs, it should be a type that's implied by the matching\r\nsemantics of the pattern.\r\n\r\nUsually, the type implied by a pattern matching a certain value\r\nis the pattern's type, because pattern matching implies instance-of checks.\r\n\r\nHowever, Stable Identifier and Literal patterns are matched using `==`,\r\nwhich does not imply a type for the binder that binds the matched value.\r\n\r\nThe change in type checking due to this fix is that programs that used to crash with a CCE\r\n(because we blindly cast to the type of the pattern, which a `==` check does not imply)\r\nnow get a weaker type instead (and no cast). They may still type check, or they may not.\r\n\r\nTo compensate for this fix, change `case x@Foo => x` to `case x: Foo.type => x`,\r\nif it's important that `x` have type `Foo.type`.\r\n\r\nNOTE: once  is fixed, matching of singleton type patterns will use `eq`,\r\nnot `==` (so that the types are not a lie).\r\n\r\nSee also: \r\n\r\nReview by @retronym"
3422,'adriaanm','update mailmap\nreview by @som-snytt, @vladimirnik'
3420,'densh',"SI-8092 More verify for f-interpolator\nAttempt to verify the nooks and crannies of the format string.\r\n\r\nAllows all syntax in the javadoc, including arg indexes. If the\r\nspecifier after an arg has an index that doesn't refer to the arg,\r\na warning is issued and the missing `%s` is prepended (just as\r\nfor a part with a leading `%n`).\r\n\r\nOther enhancements include detecting that a `Formattable` wasn't\r\nsupplied to `%#s`.\r\n\r\nError messages attempt to be pithy but descriptive."
3419,'adriaanm',"SI-8185 Correct grammar for single-warning compilation run\n50-odd updated tests (!)\r\n\r\nreview by @dragos or @adriaanm or anybody who isn't too busy (this is an easy one)"
3415,'retronym','[nomaster] corrects an error in reify’s documentation\nreview @retronym'
3414,'retronym','corrects an error in reify’s documentation\n'
3409,'retronym','SI-6411 SI-7328 value class fixes for runtime reflection\n'
3406,'retronym','SI-7570 top-level codegen for toolboxes\nProvides a way to inject top-level classes, traits and modules into\r\ntoolbox universes.\r\n\r\nPreviously that was impossible, because compile and eval both wrap their\r\narguments into an enclosing method of a synthetic module, which makes it\r\nimpossible to later on refer to any definitions from the outside.'
3405,'gkossakowski','SI-3600 Allow annotations on package objects\nThis will desugar annotations on package objects to the object `package` which is generated. Further, it will add the annotations to the package symbol.'
3402,'xeno-by','SI-7275 allow flattening of blocks with ..$ \nThis commit extends current splicing rules to allow flattening of\r\ntrees into other trees.\r\n\r\nWithout such support it is impossible to correctly use vals with\r\npatterns and use it in other location as they could expand into\r\nmultiple-statement blocks:\r\n```scala\r\n    scala> q"val (a, b) = (1, 2)"\r\n    res0: reflect.runtime.universe.Tree =\r\n    {\r\n      <synthetic> <artifact> private[this] val x$1 = scala.Tuple2(1, 2):\r\n    @scala.unchecked match {\r\n        case scala.Tuple2((a @ _), (b @ _)) => scala.Tuple2(a, b)\r\n      };\r\n      val a = x$1._1;\r\n      val b = x$1._2;\r\n      ()\r\n    }\r\n\r\n    scala> q"..$res0; println(a + b)"\r\n    res1: reflect.runtime.universe.Tree =\r\n    {\r\n      <synthetic> <artifact> private[this] val x$1 = scala.Tuple2(1, 2):\r\n    @scala.unchecked match {\r\n        case scala.Tuple2((a @ _), (b @ _)) => scala.Tuple2(a, b)\r\n      };\r\n      val a = x$1._1;\r\n      val b = x$1._2;\r\n      println(a.$plus(b))\r\n    }\r\n```\r\nreview by @xeno-by'
3401,'retronym','SI-6879 improves Context.freshName\nInstead of per-compilation unit unique counters, the freshName API now\r\nuses a per-Global counter. Fresh names now also contain dollars to exclude\r\nclashes with supported user-defined names (the ones without dollar signs).\r\n\r\nThis doesn’t fix the bug, because per-Global counters get created anew\r\nevery time a new Global is instantiated, and that provides some potential\r\nfor name clashes even for def macros, but at least it completely excludes\r\nclashes in typical situations.'
3400,'adriaanm',"SI-8170 Fix regression in TypeRef#transform w. PolyTypes\nRegressed in SI-8046 / edc9edb7, by my hand.\n\nAt the time, I noticed the problem: transform wasn't accounting\nfor the potential Poly-Type-ness of its argument, and this would\nlead to under-substituted types. The commit comment of edc9edb7\nshows an example.\n\nBut the remedy wasn't the right one. The root problem is\nthat a TypeMap over a PolyType can return one with cloned\ntype parameter symbols, which means we've lose the ability\nto substitute the type arguments into the result.\n\nThis commit detects up front whether the type-under-transform\nis a PolyType with the current TypeRef's type parameters, and\njust runs the `asSeenFrom` over its result type.\n\nReview by @adriaanm"
3399,'retronym','an optimization for c.eval\nPeople are very frequently using c.eval in order to obtain underlying\r\nvalues of literals. Spinning up a new compiler for that modest purpose\r\nis a gross waste of fossil fuels.'
3397,'retronym','SI-5920 enables default and named args in macros\nWhen producing an initial spec for macros two years ago, we sort of glossed\r\nover named/default arguments in macro applications, leaving them for future work.\r\n\r\nOnce the aforementioned future has come, I’ve made several attempts at\r\nmaking things operational (e.g. last summer), but it’s always been unclear\r\nhow to marry the quite complex desugaring that tryNamesDefaults performs\r\nwith the expectations of macro programmers to see unsugared trees\r\nin macro impl parameters.\r\n\r\nHere’s the list of problems that arise when trying to encode named/default\r\narguments of macro applications:\r\n1) When inside macro impls we don’t really care about synthetic vals\r\nthat are typically introduced to preserve evaluation order in non-positional\r\nmethod applications. When we inline those synthetics, we lose information\r\nabout evaluation order, which is something that we wouldn’t like to lose\r\nin the general case.\r\n2) More importantly, it’s also not very exciting to see invocations of\r\ndefault getters that stand for unspecified default arguments. Ideally,\r\nwe would like to provide macro programmers with right-hand sides of those\r\ndefault getters, but that is: a) impossible in the current implementation\r\nof default parameters, b) would anyway bring scoping problems that we’re\r\nnot ready to deal with just yet.\r\n\r\nBeing constantly unhappy with potential solutions to the aforementioned\r\nproblems, I’ve been unable to nail this down until the last weekend,\r\nwhen I realized that: 1) even though we can’t express potential twists in\r\nevaluation order within linearly ordered macro impl params, we can use\r\nc.macroApplication to store all the named arguments we want, 2) even though\r\nwe can’t get exactly what we want for default arguments, we can represent\r\nthem with EmptyTree’s, which is not ideal, but pretty workable. That’s\r\nwhat has been put into life in this commit.\r\n\r\nAs a pleasant side-effect, now the macro engine doesn’t have to reinvent\r\nthe wheel wrt reporting errors about insufficient arg or arglist count.\r\nSince this logic is intertwined with the tryNamesDefaults desugaring,\r\nwe previously couldn’t make use of it and had to roll our own logic\r\nthat checked that the number of arguments and parameters of macro applications\r\ncorrespond to each other. Now it’s all deduplicated and consistent.'
3396,'retronym','SI-5940 enables default and named args in macros\nWhen producing an initial spec for macros two years ago, we sort of glossed\r\nover named/default arguments in macro applications, leaving them for future work.\r\n\r\nOnce the aforementioned future has come, I’ve made several attempts at\r\nmaking things operational (e.g. last summer), but it’s always been unclear\r\nhow to marry the quite complex desugaring that tryNamesDefaults performs\r\nwith the expectations of macro programmers to see unsugared trees\r\nin macro impl parameters.\r\n\r\nHere’s the list of problems that arise when trying to encode named/default\r\narguments of macro applications:\r\n1) When inside macro impls we don’t really care about synthetic vals\r\nthat are typically introduced to preserve evaluation order in non-positional\r\nmethod applications. When we inline those synthetics, we lose information\r\nabout evaluation order, which is something that we wouldn’t like to lose\r\nin the general case.\r\n2) More importantly, it’s also not very exciting to see invocations of\r\ndefault getters that stand for unspecified default arguments. Ideally,\r\nwe would like to provide macro programmers with right-hand sides of those\r\ndefault getters, but that is: a) impossible in the current implementation\r\nof default parameters, b) would anyway bring scoping problems that we’re\r\nnot ready to deal with just yet.\r\n\r\nBeing constantly unhappy with potential solutions to the aforementioned\r\nproblems, I’ve been unable to nail this down until the last weekend,\r\nwhen I realized that: 1) even though we can’t express potential twists in\r\nevaluation order within linearly ordered macro impl params, we can use\r\nc.macroApplication to store all the named arguments we want, 2) even though\r\nwe can’t get exactly what we want for default arguments, we can represent\r\nthem with EmptyTree’s, which is not ideal, but pretty workable. That’s\r\nwhat has been put into life in this commit.\r\n\r\nAs a pleasant side-effect, now the macro engine doesn’t have to reinvent\r\nthe wheel wrt reporting errors about insufficient arg or arglist count.\r\nSince this logic is intertwined with the tryNamesDefaults desugaring,\r\nwe previously couldn’t make use of it and had to roll our own logic\r\nthat checked that the number of arguments and parameters of macro applications\r\ncorrespond to each other. Now it’s all deduplicated and consistent.'
3395,'jsuereth',"Dist cleanup\n1. Figured out why we were packaging extraneous jars.\r\n2. Removed <distributionManagement> from POMs. I could close the staged repo without the distributionManagement tag, and all the docs I've seen indicate it's a maven-publishing-client kind of thing (not necessary for publishing to maven central).\r\n\r\nReview by @jsuereth (not urgent)"
3393,'Ichoran','SI-8167 readLine shold flush output before reading input\nAs reported on scala-user:\n\n> Using `scala.Predef.readLine(text: String, args: Any*)`\n> on Windows causes strange behavior. If I am leaving some\n> part of `text` unforced to be flushed (say, "---\\nEnter new\n>  expression >") then "Enter new expression >" flushed only\n> after Enter press. Still, it works fine on Ubuntu and (seems like)\n> on MacOS.\n>\n> My workaround is to force `java.lang.System.out` (that readLine\n> depends on to write welcome string) to flush output like\n> "---\\nEnter new expression >\\n".\n\nReview by @ichoran'
3392,'retronym','deprecates resetAllAttrs and resetLocalAttrs in favor of the new API\nreview @retronym'
3391,'retronym',"SI-8131 fixes residual race condition in runtime reflection\nreview @retronym\r\n\r\nThis is the version of yesterday's pull request with `gitSynchronizedIfNotThreadsafe` optimization disabled. Let's get this in first and experiment with optimizations later."
3389,'lrytz','SI-8134 SI-5954 Fix companions in package object under separate comp.\nReview by @odersky'
3387,'retronym','SI-8131 fixes residual race condition in runtime reflection\nreview @retronym'
3386,'retronym','SI-8131 fixes residual race condition in runtime reflection\nreview @retronym'
3385,'retronym','fixes some typos and types\nreview @retronym /cc @densh'
3384,'retronym','Merge 2.10.x\nforgot one PR from the 2.10.4-RC2 queue\r\n\r\nclean merge, luckily -- review by @retronym'
3383,'retronym','Merge 2.10.x\nreview by @retronym\r\n\r\n```\r\n$ g co 2.10.x && g pull scala 2.10.x && g co master && g pull scala master\r\n$ export MB=`git merge-base 2.10.x master` # 9cdbe28c00b39c51ae9afe3066c8b44a6e5f6f96\r\n$ git log --graph --oneline $MB...2.10.x\r\n\r\n*   b3ad7534fb (scala/2.10.x, 2.10.x) Merge pull request #3364 from retronym/ticket/8152\r\n|\\  \r\n| * 9df2dcc584 (scala/pr/3364) [nomaster] SI-8152 Backport variance validator performance fix\r\n* |   d5801b9eee Merge pull request #3328 from retronym/ticket/8111\r\n|\\ \\  \r\n| |/  \r\n|/|   \r\n| * c91d373a78 (scala/pr/3328) SI-8111 Expand the comment with a more detailed TODO\r\n| * 2c770ae31a (scala/pr/3327) SI-8111 Repair symbol owners after abandoned named-/default-args\r\n* |   a8122413c0 Merge pull request #3345 from retronym/ticket/8114\r\n|\\ \\  \r\n| * | 5876e8c621 (scala/pr/3345) [nomaster] SI-8114 Binary compat. workaround for erasure bug SI-7120\r\n* | |   aefe3fb844 Merge pull request #3344 from jamesward/fix/ec-implicit-error\r\n|\\ \\ \\  \r\n| |/ /  \r\n|/| |   \r\n| * | bd4adf5c97 (scala/pr/3344) More clear implicitNotFound error for ExecutionContext\r\n|/ /  \r\n* |   1f2cd7e512 (origin/2.10.x) Merge pull request #3329 from retronym/ticket/6563\r\n|\\ \\  \r\n| |/  \r\n|/|   \r\n| * 255c51b3dd (scala/pr/3329) SI-6563 Test case for already-fixed crasher\r\n|/  \r\n*   370d6d6188 Merge pull request #3312 from xeno-by/topic/fine-points-of-whiteboxity-210x\r\n|\\  \r\n| * c0cb1d891a (scala/pr/3312) [nomaster] codifies the state of the art wrt SI-8104\r\n|/  \r\n*   97b9b2c06a Merge pull request #3282 from retronym/ticket/8085\r\n|\\  \r\n| * 7e85b59550 (scala/pr/3282) SI-8085 Fix BrowserTraverser for package objects\r\n| * a12dd9c3b6 Test demonstrating SI-8085\r\n|/  \r\n*   5cbb5a7f62 (tag: v2.10.4-RC1) Merge pull request #3268 from adriaanm/support-3021\r\n|\\  \r\n| * 3fa2c97853 (scala/pr/3268, adriaanm/support-3021) Report error on code size overflow, log method name.\r\n|/  \r\n* 2aa9da578e Partially revert f8d8f7d08d.\r\n*   ba7bf5e229 Merge pull request #3261 from adriaanm/ticket-6426\r\n|\\  \r\n| * 47562e7adb (scala/pr/3261, adriaanm/ticket-6426, ticket-6426) Revert "SI-6426, importable _."\r\n* da919ec24c Merge pull request #3253 from retronym/ticket/8062\r\n* f0d913b51d (scala/pr/3253) SI-8062 Fix inliner cycle with recursion, separate compilation\r\n\r\n$ g log --oneline --no-merges $MB..97b9b2c06a\r\n7e85b59550 (scala/pr/3282) SI-8085 Fix BrowserTraverser for package objects\r\na12dd9c3b6 Test demonstrating SI-8085\r\n3fa2c97853 (scala/pr/3268, adriaanm/support-3021) Report error on code size overflow, log method name.\r\n2aa9da578e Partially revert f8d8f7d08d.\r\n47562e7adb (scala/pr/3261, adriaanm/ticket-6426, ticket-6426) Revert "SI-6426, importable _."\r\nf0d913b51d (scala/pr/3253) SI-8062 Fix inliner cycle with recursion, separate compilation\r\n\r\n$ g log --oneline --no-merges 97b9b2c06a..370d6d6188\r\nc0cb1d891a (scala/pr/3312) [nomaster] codifies the state of the art wrt SI-8104\r\n\r\n$ g log --oneline --no-merges 370d6d6188..aefe3fb844\r\nbd4adf5c97 (scala/pr/3344) More clear implicitNotFound error for ExecutionContext\r\n255c51b3dd (scala/pr/3329) SI-6563 Test case for already-fixed crasher\r\n\r\n$ g log --oneline --no-merges aefe3fb844..a8122413c0\r\n5876e8c621 (scala/pr/3345) [nomaster] SI-8114 Binary compat. workaround for erasure bug SI-7120\r\n\r\n$ g log --oneline --no-merges a8122413c0..d5801b9eee\r\nc91d373a78 (scala/pr/3328) SI-8111 Expand the comment with a more detailed TODO\r\n2c770ae31a (scala/pr/3327) SI-8111 Repair symbol owners after abandoned named-/default-args\r\n\r\n$ g log --oneline --no-merges d5801b9eee..2.10.x\r\n9df2dcc584 (scala/pr/3364) [nomaster] SI-8152 Backport variance validator performance fix\r\n\r\n$ g merge 97b9b2c06a\r\n$ g merge -s ours 370d6d6188\r\n$ g merge aefe3fb844\r\n$ g merge -s ours a8122413c0\r\n$ g merge d5801b9eee\r\n$ g merge -s ours 2.10.x\r\n\r\n```'
3376,'adriaanm',"SI-8153 Mutation is hard, let's go shopping with an empty list\nChanged the implementation of iterator to be more robust to mutation of the underlying ListBuffer.\r\n\r\nTest added to verify the fix."
3371,'gkossakowski','SI-8154 AnyRefMap iterates its way to ((null, null))\nChanged logic to prevent mutation between hasNext and next from delivering invalid results.'
3365,'adriaanm','SI-8133 Fix regression with package objects, overloading\nReview by @adriaanm.\n\n/cc @paulp on the off chance you haven\'t scrubbed the part of\nyour memory that could confirm or disconfirm the "ostensibly"\npart.'
3363,'adriaanm','SI-8146 Fix non-deterministic <:< for deeply nested types\nDetails in the commit messages.\r\n\r\nReview by @adriaanm, @odersky /cc @szeiger'
3361,'adriaanm','SI-6615 junit test\nTest for #3303'
3357,'adriaanm',"SI-8143 Regressions with override checks, private members\nThese regressed in e609f1f20b, which excluded all private methods from\r\noverriding checks. We should only exclude private[this] members on the\r\nlow end of a pair, as was done before that commit, and, we must also\r\nexclude private members on the high side.\r\n\r\nWhy? Warning: reverse engineered intuition follows.\r\n\r\nWe need to report an error when if a private method in a subclass\r\nhas matches a less-private method in the super class and report an\r\nerror, lest the user be fooled into thinking it might be invoked\r\nvirtually. On the other hand, adding a private method to a super\r\nclass shouldn't invalidate the choice names of public members in\r\nits superclasses.\r\n\r\nI've removed the test case added by that commit and will lodge a\r\nreworked version of it that Paul provided as a new issue. That shows\r\na bug with qualified private + inheritance.\r\n\r\nIn addition, the expectation of `neg/accesses.check` is reverted\r\nto its 2.10.3 version, which I believe is correct. When it was\r\nchanged in e609f1f20b it sprouted a variation, `neg/accesses-2`,\r\nwhich has now changed behaviour. The intent of that test will\r\nbe captured in the aforementioned issue covering qualified private\r\ninheritance.\r\n\r\nReview by @adriaanm.\r\n"
3355,'retronym','reshuffles names for blackbox/whitebox contexts, changes bundle notation\nreview @retronym'
3354,'retronym','deprecates c.enclosingTree-style APIs\nExisting enclosing tree macro APIs face both technical and philosophical problems.\r\n\r\nOn the one hand, it’s close to impossible to provide their robust\r\nimplementation within the current typer infrastructure. From the very\r\nbeginning, these APIs have been very experimental, and I was very much\r\nhoping to tackle the underlying technical problems, but after a year and\r\na half I can say that it’s still outside our reach.\r\n\r\nOn the other hand, we’re gravitating towards increasingly more local macro\r\nexpansion, which is in direct contradiction with the existence of\r\nc.enclosingTree APIs. Therefore, in order to be able to further evolve\r\nmacros, we need need additional freedom to reshape the enclosing tree APIs.\r\n\r\nTherefore I suggest we deprecate the aforementioned APIs and start\r\npreparing ourselves to removing them for good in 2.12.0.\r\n\r\nI hope that existing macros that use these APIs can be reformulated in\r\nterms of completely local expansion or be built on top of orthogonal\r\nlanguage features (existing ones or new ones, e.g. something like\r\nhttps://groups.google.com/forum/#!topic/scala-debate/f4CLmYShX6Q).\r\nPlease share your use cases, and I will be glad to help!\r\n\r\nWe have at least the entire 2.12 development cycle ahead of us, so I’m\r\nsure we’ll figure this out. Let’s shape robust and scalable reflection\r\nAPI together!'
3351,'retronym','fixes run/macroPlugins-namerHooks.scala\nMakes run/macroPlugins-namerHooks.scala work equally well on both\r\nUnix and Windows machines.'
3348,'retronym','deprecates resetAllAttrs and resetLocalAttrs in favor of the new API\nWe now have c.untypecheck, which is supposed to be a counterpart of c.typecheck\r\nin the sense that it goes back from typed trees to untyped ones:\r\nhttp://stackoverflow.com/questions/20936509/scala-macros-what-is-the-difference-between-typed-aka-typechecked-an-untyped.\r\n\r\nLet’s hope that c.untypecheck will soon be able to solve our problems\r\nwith partially/incorrectly attributed trees emitted by macros:\r\nhttps://groups.google.com/forum/#!topic/scala-internals/TtCTPlj_qcQ.'
3346,'gkossakowski','SI-8129 Plug a leak in perRunCaches\nI guess we\'ve never leaned to heavily on these, because the\r\nregistry of caches was forgetting about most of them\r\nimmediately if they compared == at the point of creation.\r\n\r\nConsequently, maps like `treatedInfos` in Mixin were holding\r\nonto old types and symbols and leaking memory.\r\n\r\nYou can reproduce the leak with:\r\n\r\n\t(for i in {1..200}; do echo src/library/scala/collection/*.scala; done; printf "\\n") | scalac-hash v2.11.0-M7 -J-Xmx256M -Xresident\r\n\r\n\tnsc> warning: there were 6 deprecation warning(s); re-run with -deprecation for details\r\n\r\n\t(... 15 times)\r\n\r\n\tnsc> java.lang.OutOfMemoryError: GC overhead limit exceeded\r\n\tDumping heap to java_pid90362.hprof ...\r\n\tHeap dump file created [340635728 bytes in 7.993 secs]\r\n\t^CException in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded\r\n\r\nReview by @gkossakowski'
3345,'adriaanm',"[nomaster] SI-8114 Binary compat. workaround for erasure bug SI-7120\nWe can't backport SI-7120 to 2.10.x as it changes erased signatures,\nwhich can lead to interop problems between 2.10.3 and 2.10.4.\n\nBut, we can detect one of the nasty symptoms -- a bridge method\nwith the same signature as its target -- and treat that.\n\nThis commit detects duplicate bridges in the ASM (only) backend\nand removes them.\n\nReview by @adriaanm @magarcia"
3342,'retronym','Presentation compiler friendliness for macros\n   - Retain macro expansion in the tree in the presentation compiler\r\n     under a new setting -Ymacro-expand:discard.\r\n   - Deprecate -Ymacro-no-expand, in favour of -Ymacro-expand:none\r\n   - Prevent range position validation errors in macro expansions (even\r\n     though the preceding change means they no longer impact the IDE.)\r\n\r\nI trialled the "discard-the-macro-expansion" approach recently in\r\nscala-async (it can actually all be driven from a suitably ambitious\r\nmacro), and the results in the IDE were pleasing: hyperlinking works\r\nas expected.\r\n\r\nFuture work: Add `-Ymacro-expand:discard-whitebox-only` to avoid expanding\r\nblackbox macros altogether. This would be handy when troubleshooting\r\nperformance problems in the IDE.'
3340,'adriaanm','SI-8126 add -Xsource option to let (parts of) the compiler run on older code\nThis adds a `-source` flag and puts various 2.10 source-level\r\ncompatibility-breaking fixes under it (so that the fixed codepath\r\ndoesn\'t run with -source:2.10). \r\n\r\nThe last commit adds another (early) setting (`-Yrelax-variance-checks`)\r\nfor the specific checks brought by SI-6566, fixed in a419799f87. This\r\nis needed to bypass the stricter (and correct) variance checks done in\r\n`reflect/internal/Variances`. `-Y-relax-variance-checks`, contrarily to\r\n`-source`, doesn\'t depend on the `nsc.settings.ScalaVersion` class. This\r\noption is turned on by `-source:2.10`\r\n\r\nThis has been tested by compiling the 2.10 scala library (using the\r\ncompiler in this PR , with "`-source:2.10 -Ystop-after:typer`") using\r\nthis project: https://github.com/huitseeker/scala-library\r\n\r\nreview by @dragos or @retronym.'
3338,'retronym','SI-7491 fix typo in scala.App documentation\nThis is a really cheap PR, but hey, there was a ticket for it!'
3337,'retronym','SI-8125 SI-8130 position fixes for presentation compiler\nreview by @retronym\r\n\r\n@danchia This PR should make you happy ;-)'
3336,'retronym','Fix typo in documentation\n'
3335,'Ichoran','Fixes #3330 with Scaladoc changes only\nImproves the Scaladocs for sequence operations apply(), +:, :+, ++, /:, :\\ and addString.'
3334,'adriaanm','SI-4841 CLI help update for -Xplugin\nThe argument to `-Xplugin` is now a comma-separated list of paths.\r\nThis commit updates the option descriptor and a code comment.'
3333,'adriaanm','Update man pages for scala and scalac.\nThey had fallen quite a bit behind the output of\r\n"scalac -X" and "scalac -Xshow-phases".\r\n\r\n----\r\nI always have to remember to query scalac directly instead of using the man page; well, not anymore :-)\r\n\r\nHere is the resulting html man page : https://dl.dropboxusercontent.com/u/46938538/static/man/html/scalac.html\r\nAnd the old one for comparison: http://www.scala-lang.org/files/archive/nightly/docs/manual/html/scalac.html'
3332,'retronym','ExistentialTypeTree.whereClauses are now MemberDefs\nToday’s flight back to Lausanne wasn’t as productive as the recent flight\r\nto Minsk (https://github.com/scala/scala/pull/3305), but I noticed\r\none minor thingie: ExistentialTypeTree had an imprecise type specified\r\nfor its whereClauses. This is now fixed.\r\n\r\nI didn’t increment PickleFormat.*Version numbers, because this change\r\nintroduces only a miniscule incompatibility with what would have been\r\na meaningless and most likely crash-inducing pickle anyway.'
3326,'retronym','SI-8032 Provides an implicit macro for materialization of Liftable for case classes\nNow case classes can be used in quasiquotes.\r\n\r\n```scala\r\nWelcome to Scala version 2.11.0-20140105-195053-c1b3d94af9 (OpenJDK 64-Bit Server VM, Java 1.7.0_45).\r\nType in expressions to have them evaluated.\r\nType :help for more information.\r\n\r\nscala> import scala.reflect.runtime.{universe => u}\r\nimport scala.reflect.runtime.{universe=>u}\r\n\r\nscala> import u._\r\nimport u._\r\n\r\nscala> case class Test(str: String, i: Int, lst: List[Double])\r\ndefined class Test\r\n\r\nscala> val test = Test("test", 1, List(2.0, 3.5))\r\ntest: Test = Test(test,1,List(2.0, 3.5))\r\n\r\nscala> showRaw(q"$test")\r\nres0: String = Apply(Select(Select(Select(Select(Select(Ident($line8.$read), TermName("$iw")), TermName("$iw")), TermName("$iw")), TermName("$iw")), TermName("Test")), List(Literal(Constant("test")), Literal(Constant(1)), Apply(Select(Select(Select(Ident(scala), TermName("collection")), TermName("immutable")), TermName("List")), List(Literal(Constant(2.0)), Literal(Constant(3.5))))))\r\n\r\nscala> val cm = runtimeMirror(getClass.getClassLoader)\r\ncm: reflect.runtime.universe.Mirror = JavaMirror with scala.tools.nsc.interpreter.IMain$TranslatingClassLoader@74a2ccbd of type class scala.tools.nsc.interpreter.IMain$TranslatingClassLoader with classpath [(memory)] and parent being scala.reflect.internal.util.ScalaClassLoader$URLClassLoader@6c2fc81d of type class scala.reflect.internal.util.ScalaClassLoader$URLClassLoader with classpath [file:/usr/lib/jvm/java-7-openjdk/jre/lib/resources.jar,file:/usr/lib/jvm/java-7-openjdk/jre/lib/rt.jar,file:/usr/lib/jvm/java-7-openjdk/jre/lib/jsse.jar,file:/usr/lib/jvm/java-7-openjdk/jre/lib/jce.jar,file:/usr/lib/jvm/java-7-openjdk/jre/lib/charsets.jar,file:/usr/lib/jvm/java-7-openjdk/jre/lib/rhino.jar,file:/home/folone/workspace/scala/build/quick/classes/library/,file:/home/folone/workspace/scala/...\r\nscala> import scala.tools.reflect.ToolBox\r\nimport scala.tools.reflect.ToolBox\r\n\r\nscala> val tb = cm.mkToolBox()\r\ntb: scala.tools.reflect.ToolBox[reflect.runtime.universe.type] = scala.tools.reflect.ToolBoxFactory$ToolBoxImpl@e01afa1\r\n\r\nscala> tb.eval(q"$test")\r\nres1: Any = Test(test,1,List(2.0, 3.5))\r\n\r\nscala> .asInstanceOf[Test]\r\nres2: Test = Test(test,1,List(2.0, 3.5))\r\n```\r\n\r\nReview by @xeno-by, @densh, and @retronym please.'
3324,'retronym','remove symbol-based factories for MemberDef AST nodes\nAs recent discussion shows, methods like ValDef(sym) or DefDef(sym, rhs)\r\nare not just useless (i.e. not achieving the goal that users expect them\r\nto achieve), but they are also misleading (i.e. actively confusing users\r\nfrom utilizing the reflection API the right way):\r\nhttp://stackoverflow.com/questions/20908036/how-do-i-splice-symbols-of-various-types-in-a-quasiquote.\r\n\r\nTherefore this PR removes these factories from the public API in 2.11.0.\r\nEven though we don’t have a formal right to do that, as the factories\r\nweren’t deprecated before 2.10.1, I strongly propose to go for it, because:\r\n1) these APIs are actively harmful, 2) reflection is an experimental API,\r\nso we’re not bound as tightly as usual.'
3323,'Ichoran','Removes TODO comments that are no longer applicable\n- we do not want to use mutable updates because that would mean making vals\r\nvars, losing various guarantees for final fields of the java memory model\r\n\r\n- we do not want to add more subcasses of HashSet, because that would make\r\ncallsites megamorphic. If anything, we should try to reduce the number of\r\nsubclasses\r\n\r\n- checking for monomorphic call site is not worth it for a single virtual\r\nmethod call.\r\n\r\nReview by @Ichoran'
3322,'Ichoran','SI-6253 HashSet should implement union\nImplements of HashSet.union that reuses the two trees as much as\r\npossible when calculating the union of two sets. This leads to significant\r\nperformance improvements as well as to much better structural sharing.\r\n\r\nThere is a comprehensive correctness test for union since there was not a single test\r\nfor HashSet.union before. In addition, there are some tests of the desirable\r\nproperties of the new implementation (structural sharing and efficiency\r\nregarding calls of key.hashCode.\r\n\r\nThe other operations diff and intersect, which are conceptually very\r\nsimilar to union, are also implemented along with comprehensive test cases\r\nfor both correctness and structural sharing.\r\n\r\nNote that while it appears that there is some code duplication between the\r\nthree methods, they are sufficiently different that it is not possible\r\nto merge them into one without sacrificing performance.\r\n\r\nReview by @Ichoran, @axel22'
3321,'retronym','Add tree-based code generation\nNew printer (ParsedTreePrinter) is intended for unattributed trees and generates the code based on the passed AST.\r\nResult code can be later compiled by scalac retaining the same meaning.\r\nParsedTreePrinter is based on [Sprinter project](http://vladimirnik.github.io/sprinter/).'
3320,'gkossakowski','SI-8081 unzip/unzip3 return wrong static type when applied to Arrays\nAdded unzip and unzip3 methods to ArrayOps so that we get proper return\r\nvalues.  (No tests due to unfavorable effort/reward ratio for an ongoing\r\ntest of something so simple.)'
3319,'retronym','SI-4370 Range bug: Wrong result for Long.MinValue to Long.MaxValue by In...\n...t.MaxValue\r\n\r\nFixed by rewriting the entire logic for the count method.  This is necessary because the old code was making all kinds of assumptions about what numbers were, but the interface is completely generic.\r\n\r\nThose assumptions still made have been explicitly specified.  Note that you have to make some or you end up doing a binary search, which is not exactly fast.\r\n\r\nThe existing routine is 10-20% slower than the old (broken) one in the worst cases.  This seems close enough to me to not bother special-casing Long and BigInt, though I note that this could be done for improved performance.\r\n\r\nNote that ranges that end up in Int ranges defer to Range for count.\r\n\r\nA new JUnit test has been added to verify that the test works.  It secretly contains an alternate BigInt implementation, but that is a lot slower (>5x) than Long.'
3318,'Ichoran','SI-6196 - Set should implement filter\nImplements a version of filter and filterNot that reuses as much as\r\npossible from the existing tree instead of building an entirely new one\r\nlike the builder-based filter does. This results in significant performance\r\nimprovements on average.\r\n\r\nAdds a test of basic correctness of filter and filterNot as well as of the\r\ndesirable properties of the new filter implementation.\r\n\r\nThis is a collaboration between me and @Ichoran\r\n\r\nReview by @Ichoran, @soc'
3317,'Ichoran','SI-8107: Add Regex.quote\nhttps://issues.scala-lang.org/browse/SI-8107'
3316,'adriaanm',"Quasi-comprehensive BigDecimal soundness/correctness fix.\nThis fixes issues SI-6153, SI-6173, SI-6456, SI-6699, and SI-8116, along with a number of other similar possible issues.\r\n\r\nRelevant changes include\r\n  * Changes to avoid heap explosion when working with BigInt\r\n    - to isWhole\r\n    - to hashCode\r\n    - to equals\r\n    - to BigInt's equals\r\n  * Changes to enable equality matching hashCode\r\n    - Only for sufficiently small BigInt\r\n    - For identical values with different precision\r\n  * Changes to isValidDouble\r\n    - Takes precision into account now\r\n    - New methods added to test whether even if the Double is not represented exactly, it's a representation of a certain type\r\n    - New companion methods added to allow intended expansion of Double (binary/decimal difference)\r\n  * Changes to constructor\r\n    - Null arguments are not allowed (these can throw NPEs later at awkward/unexpected times)\r\n  * New JUnit test to test all these things\r\n  * Fixed existing tests to expect new behavior\r\n  * Modified scaladocs to explain the issues\r\n  * Deprecated problematic methods\r\n  * Made application of MathContext more consistent (it is where you expect it and not where you don't)\r\n\r\nThese changes are coordinated, for the most part, hence the monolithic commit."
3315,'Ichoran','Implements specialized subsetOf for HashSet\nFixes SI-7326. This also adds a basic test for subsetOf that was missing before.\r\n\r\nReview by @Ichoran, @soc\r\n\r\n@Ichoran: feel free to integrate the subsetOf test into your collection comparison test suite and remove the testCorrectness part of t7326.scala'
3314,'retronym','makes well-known packages and package classes consistent with each other\nAs discovered in https://groups.google.com/forum/#!topic/scala-user/RckXE90LoXo,\r\nRootClass.sourceModule and EmptyPackageClass.sourceModule used to incorrectly\r\nreturn NoSymbol instead of RootModule and EmptyPackage. This is now fixed.'
3312,'retronym','(2.10.x) codifies the state of the art wrt SI-8104\nAs it was discovered in SI-8104, whiteboxity doesn’t apply equally to\r\ntype parameters and type members of materialized type classes.\r\n\r\nDuring implicit search and subsequent type inference, whitebox type parameters\r\nare consistently erased to wildcards, whereas whitebox type members sometimes\r\nremain as is and get in the way of signature conformance checks.\r\n\r\nUnfortunately, 2.10.x can’t make use of type parameter whiteboxity, because\r\nit requires fundep materializers that were only merged into 2.11:\r\nhttps://github.com/scala/scala/pull/2499, and therefore Si-8104 seems to be\r\na hard blocker for 2.10.x at the moment. Stay tuned for updates.'
3311,'retronym','(master) codifies the state of the art wrt SI-8104\nAs it was discovered in SI-8104, whiteboxity doesn’t apply equally to\r\ntype parameters and type members of materialized type classes.\r\n\r\nDuring implicit search and subsequent type inference, whitebox type parameters\r\nare consistently erased to wildcards, whereas whitebox type members sometimes\r\nremain as is and get in the way of signature conformance checks.'
3310,'retronym','SI-6355 SI-7059 it is possible to overload applyDynamic\nAs our discussion at https://issues.scala-lang.org/browse/SI-6355 shows,\r\nit looks like it is possible to overload applyDynamic, even though a\r\nstraightforward way is closed. This commit codifies the pattern proposed\r\nby @paulp and makes sure that it doesn’t break in the future.'
3309,'retronym','SI-7777 SI-8006 assorted fixes for dynamics\n'
3305,'retronym','awakens default getter synthesis from the untyper nightmare\nOur happy little macro paradise is regularly invaded by resetAllAttrs,\r\nthe bane of all macros and typers. It’s so ruthless and devastating that\r\nwe’ve been long scheming to hack something really cool and to one day\r\ndefeat it.\r\n\r\nToday we make the first step towards the happy future. Today we overthrow\r\nthe UnTyper, resetAllAttrs’s elder brother that rules in the kingdoms of\r\nGetterLand and CaseClassia, and banish him from the land of getters.\r\nIn the name of what’s good and meta, let’s band together and completely\r\ndrive him away in a subsequent pull request! (upd. Done - see the second commit).'
3304,'retronym','SI-8100 - prevent possible SOE during Stream#flatten.\nThis commit changes stream flatten to avoid allocating a\r\nstack frame for every stream item. Previously, flattening\r\na stream whose elements are mostly empty would result in\r\na StackOverflowException.\r\n\r\nThis commit also adds a test demonstrating the problem.'
3303,'adriaanm','Fixes SI-6615, NPE on slice of PagedSeq.\nMade sure to addMore when roving forward on a slice into unpaged territory.'
3302,'adriaanm','Resolves SI-6364, O(n) performance of wrapped set contains.\nAdded overrides for contains and isEmpty to SetWrapper.  Note that sets are\r\ninvariant in Scala, while the Java signature is for any Object, so we trap\r\na ClassCastException if one occurs.  (Is this everything that could possibly\r\ngo wrong?  I think so, but am not as confident as I would like.)'
3295,'gkossakowski','SI-1448 Deprecate conversion of numeric values types by casts\n**Attention**: This is an alternative PR to #3294. Do **NOT** merge both.\r\n\r\nCasts of AnyVals had inconsitent behavior depending on whether they were boxed:\r\n\r\n    1L.asInstanceOf[Int]        // -> 1\r\n    (1L: Any).asInstanceOf[Int] // -> ClassCastException\r\n\r\nThis PR fixes this by deprecating casts for conversion. I.e. in future scala versions, both calls will fail (although the first at compile time).\r\n\r\nPR #3294 contains some discussion why this version might be desirable above the other.\r\n\r\nAfter checkfile update to accomodate deprecation warnings, all partests succeed. However, run/t7868 does now emit a deprecation warning due to the code generated by the pattern matcher (no difference in matching behaviour is observed). If we proceed with this option, this warning will have to be fixed in the pattern matcher.\r\n\r\n**UPDATE** This does not deprecate casts from `null` to a value type.'
3294,'gkossakowski','SI-1448 Unify casting behavior for AnyVals\n**Attention**: This is an alternative PR to #3295. Do **NOT** merge both.\r\n\r\nCasts of AnyVals had inconsitent behavior depending on whether they were boxed:\r\n\r\n    1L.asInstanceOf[Int]        // -> 1\r\n    (1L: Any).asInstanceOf[Int] // -> ClassCastException\r\n\r\nThis PR fixes this by adapting the unboxing helpers in `BoxesRunTime`. A couple of caveats:\r\n\r\n- Unboxing requires an additional instanceof check. (Reason: Casting of Character, which is not subtype of Number).\r\n- A wrong ClassCastException is raised on a failed cast to a primitive numeric value. It says "cannot cast to Number" instead of Integer etc.\r\n\r\nWhere the latter issue can easily be fixed by adding another `instanceof` check, the former is inherent to the fact that `java.lang.Character` does not extend `java.lang.Number` but conversion must be performed. It can only be fixed by integrating (part) of this behaviour in the compiler.\r\n\r\nMaybe we should reconsider changing the behaviour the other way around. It is easy to emit a deprecation warning in 2.11 for casts that convert (implemented in PR #3295) and put the behaviour behind a flag in 2.12.\r\n\r\nAll partests ~~except for the instrumentation tests~~ succeed on this PR.'
3293,'xeno-by','SI-7469 Remove misc. @deprecated elements\n'
3292,'retronym','duplicates arguments to macro typer APIs\nThis commit continues the tendency set by the parent commit to duplicate\r\nas much as possible in order to avoid potential confusion that users\r\nmight run into when compiler internals start leaking.\r\n\r\nHere we plumb another way that by-reference sharing of trees might bite\r\nunsuspecting macro writers. Previously we have duplicated macro expansions,\r\nmacro arguments, c.macroApplication, and now it’s arguments to typeCheck\r\nand resetAttrs.\r\n\r\nThere is still an unlikely situation when someone gets to c.enclosingXXX\r\nand then starts typechecking around, but that’s left for future work,\r\nas it’s yet unclear what to do with c.enclosingXXX APIs.'
3290,'adriaanm','SI-7680 Update the ScalaDoc entry page of the Scala library\n'
3288,'retronym','makes boxity of fast track macros configurable\nPreviously, all built-in macros were assumed to be whitebox, but that’s\r\nactually not the case. Just quasiquote macros have to be whitebox, while\r\nthe rest can be blackbox.\r\n\r\nThis also fixes SI-8091, because blackbox macros are typechecked differently\r\nand therefore the necessary implicit conversion kicks in. If f”...” were\r\nto remain a whitebox macro, then due to the changes introduced in commit\r\nhttps://github.com/scala/scala/commit/a3b33419b02cafb7e2c6fed6dd96151859fc7d77\r\nwe would have to explicitly ascribe its expansion as String to achieve the same effect.'
3287,'xeno-by','Presentation compiler friendliness for macros\n   - Retain macro expansion in the tree in the presentation compiler\r\n     under a new setting -Ymacro-expand:discard.\r\n   - Deprecate -Ymacro-no-expand, in favour of -Ymacro-expand:none\r\n   - Prevent range position validation errors in macro expansions (even\r\n     though the preceding change means they no longer impact the IDE.)\r\n\r\nI trialled the "discard-the-macro-expansion" approach recently in\r\nscala-async (it can actually all be driven from a suitably ambitious\r\nmacro), and the results in the IDE were pleasing: hyperlinking works\r\nas expected.\r\n\r\nFuture work: Add `-Ymacro-expand:discard-whitebox-only` to avoid expanding\r\nblackbox macros altogether. This would be handy when troubleshooting\r\nperformance problems in the IDE.'
3285,'adriaanm','SI-8015 Count lines by EOLs\nSource lines were counted by "line break chars", including FF.\r\nClients of `pos.line` seem to all expect the ordinary line num,\r\nso that is what they get.\r\n\r\nUnicode processing now precedes line ending processing.\r\n\r\nReview by @adriaanm who is going to come across it anyway in the final hours of clean-up before cutting a milestone\r\n'
3283,'adriaanm',"Dotless type application for infix operators.\nWhen you have an aesthetic expresion like\r\n```\r\n  def f(xs: Iterator[Int]) = (\r\n    xs takeWhile (_ < 1000)\r\n             map (_ * -1)\r\n          filter (_ % 2 == 0)\r\n         flatMap (x => List(x, x))\r\n    reduceOption (_ + _)\r\n           maxBy (_.toString)\r\n  )\r\n```\r\nAnd then for whatever reason you have to perform explicit\r\ntype application in the midst of that expression, it's\r\naggravating in the extreme that it has (had) to be rewritten\r\nin its entirety to accommodate that change.\r\n\r\nSo now you can perform type application in the middle of it.\r\n\r\nFor reasons not entirely clear to me postfix operators are\r\nexcluded. The discussion as well as the approval for the infix\r\nvariation of it can be found at:\r\n  https://groups.google.com/forum/#!msg/scala-language/eJl1wnkEz9M/hR984-lqC5EJ"
3281,'retronym','(2.10.4) backports https://github.com/scala/scala/pull/3236\nEven though whitebox macros are supposed to be used to produce expansions\r\nthat refine advertised return types of their macro definitions, sometimes\r\nthose more precise types aren’t picked up by the typechecker.\r\n\r\nIt all started with Travis generating structural types with macros\r\nand noticing that typer needs an extra nudge in order to make generated\r\nmembers accessible to the outside world. I didn’t understand the mechanism\r\nof the phenomenon back then, and after some time I just gave up.\r\n\r\nAfterwards, when this issue had been brought up again in a different\r\nStackOverflow question, we discussed it at reflection meeting, figured out\r\nthat typedBlock provides some special treatment to anonymous classes,\r\nand it became clear that the first macro typecheck (the one that types\r\nthe expansion against the return type of the corresponding macro def)\r\nis at fault here.\r\n\r\nThe thing is that if we have a block that stands for a desugard anonymous\r\nclass instantiation, and we typecheck it with expected type different from\r\nWildcardType, then typer isn’t going to include decls of the anonymous class\r\nin the resulting structural type: https://github.com/scala/scala/blob/master/src/compiler/scala/tools/nsc/typechecker/Typers.scala#L2350.\r\nI tried to figure it out at https://groups.google.com/forum/#!topic/scala-internals/eXQt-BPm4i8,\r\nbut couldn’t dispel the mystery, so again I just gave up.\r\n\r\nBut today I had a profound WAT experience that finally tipped the scales.\r\nIt turns out that if we typecheck an if, providing a suitable pt, then\r\nthe resulting type of an if is going to be that pt, even though the lub\r\nof the branch types might be more precise. I’m sure that reasons for this\r\nbehavior are also beyond my understanding, so I decided to sidestep this problem.\r\n\r\nupd. Here’s Jason’s clarification: Doing thing differently would require\r\nus to believe that "\'Tis better to have lubbed and lost than never to have\r\nlubbed at all." But the desire for efficiency trumps such sentimentality.\r\n\r\nNow expansions of whitebox macros are first typechecked against pt,\r\nthe expected type that comes from the enclosing context, before being\r\ntypechecked against expectedTpe, the expected type that comes from the return\r\ntype of the macro def. This means that now pt provides the correct\r\nexpected type for the initial, most important typecheck, which makes\r\ntypes more precise.'
3280,'retronym','[nomaster] backports https://github.com/scala/scala/pull/3236\nEven though whitebox macros are supposed to be used to produce expansions\r\nthat refine advertised return types of their macro definitions, sometimes\r\nthose more precise types aren’t picked up by the typechecker.\r\n\r\nIt all started with Travis generating structural types with macros\r\nand noticing that typer needs an extra nudge in order to make generated\r\nmembers accessible to the outside world. I didn’t understand the mechanism\r\nof the phenomenon back then, and after some time I just gave up.\r\n\r\nAfterwards, when this issue had been brought up again in a different\r\nStackOverflow question, we discussed it at reflection meeting, figured out\r\nthat typedBlock provides some special treatment to anonymous classes,\r\nand it became clear that the first macro typecheck (the one that types\r\nthe expansion against the return type of the corresponding macro def)\r\nis at fault here.\r\n\r\nThe thing is that if we have a block that stands for a desugard anonymous\r\nclass instantiation, and we typecheck it with expected type different from\r\nWildcardType, then typer isn’t going to include decls of the anonymous class\r\nin the resulting structural type: https://github.com/scala/scala/blob/master/src/compiler/scala/tools/nsc/typechecker/Typers.scala#L2350.\r\nI tried to figure it out at https://groups.google.com/forum/#!topic/scala-internals/eXQt-BPm4i8,\r\nbut couldn’t dispel the mystery, so again I just gave up.\r\n\r\nBut today I had a profound WAT experience that finally tipped the scales.\r\nIt turns out that if we typecheck an if, providing a suitable pt, then\r\nthe resulting type of an if is going to be that pt, even though the lub\r\nof the branch types might be more precise. I’m sure that reasons for this\r\nbehavior are also beyond my understanding, so I decided to sidestep this problem.\r\n\r\nupd. Here’s Jason’s clarification: Doing thing differently would require\r\nus to believe that "\'Tis better to have lubbed and lost than never to have\r\nlubbed at all." But the desire for efficiency trumps such sentimentality.\r\n\r\nNow expansions of whitebox macros are first typechecked against pt,\r\nthe expected type that comes from the enclosing context, before being\r\ntypechecked against expectedTpe, the expected type that comes from the return\r\ntype of the macro def. This means that now pt provides the correct\r\nexpected type for the initial, most important typecheck, which makes\r\ntypes more precise.'
3278,'gkossakowski','improvements to GenBCode\n- catching up with GenASM\r\n- two fixes (overly restrictive asserts) \r\n- readability\r\n\r\nReview by @gkossakowski'
3277,'gkossakowski','Scala dist maven\nreview by @gkossakowski\r\n\r\nThe idea is that a Scala distribution is a simple repackaging of artifacts already available on maven.\r\n\r\nWe already publish the following to maven: typical jars for the artifacts (classes, sources, scaladoc).\r\nThis PR adds: the bin/, doc/, and man/ directories, packaged up in scala-dist.\r\n\r\nTo simplify this, move the contents that should end up in the distribution\r\nfrom docs/ to doc/, create the man/ directory with the manpages,\r\nand include the scripts in bin/.\r\n\r\nThese directories are packaged in the scala-dist jar and published to maven,\r\nwith a dependency on scala-library-all and scala-compiler,\r\nfor the jars that should end up in the distribution.\r\n\r\nThis way, a scala dist can be built by resolving scala-dist,\r\nand moving all the class-file jars of its depencies to lib/\r\n(use api/ for scaladoc jars, and src/ for the source jars).'
3275,'adriaanm','Improves name-based patmat.\nSome internal documentation and logic separation, and fixing the\r\nspecific-to-name-based-patmat bugs I know about.\r\n\r\nOver to you, @adriaanm.'
3274,'gkossakowski','SI-8017 Value class awareness for -Ydelamdafy:method\nThe delambdafy creates a bridge method which requires adaptation\nof the result type to the generic `Object`, which is the erased\nreturn type of FunctionN.\n\nThis bridge building reused some code from erasure, now refactored\ninto TypeAdaptingTransformer.\n\nBut, it was running into problems with:\n\n    class C(a: Int) extends AnyVal\n    (x: Any) => new C(0)\n\nIt created (forgive the pseudo quasiquote syntax):\n\n    class anonfun$ extends Function1[Any, C] {\n       def apply#1(a: Object): Int = 0\n       <bridge> def apply#2(a: Object): Object = {\n         val result: Int = apply#1(a)\n         ${adapt(Ident("result"), ObjectType)}\n       }\n    }\n\nThis resulted in primitive boxing, rather than value class boxing.\n\nInstead, we need the call to the main apply method to be typed\nas `ErasedValueClass(C, Int)`, which `adapt` takes as a trigger\nto perform value class boxing.\n\nFinally, we have to run the post-erasure transformer over the adapted\ntree to eliminate remnants of `ErasedValueClass` from the types of\ntrees.\n\nReview by @gkossakowski / @adriaanm'
3269,'retronym','Issue/si 4287\nThis is a rework of https://github.com/scala/scala/pull/3210\r\n\r\nreview by @retronym, @densh'
3266,'adriaanm','SI-7546 Use likely monotonic clock source for durations\nSystem.currentTimeMillis is affected by wall-clock time, which means\r\nthings can appear to jump back in time.\r\nUse System.nanoTime which is more likely¹ to be monotonic instead.\r\n\r\n¹ See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6458294\r\n  "nanoTime affected by system clock change on Linux (RH9) or in\r\n   general lacks monotonicity".'
3265,'adriaanm','Merge 2.10.x to master\nReview by @adriaanm \r\n\r\nThe conflict resolution in dist.doc is the main spot to check.\r\n\r\n```\r\nexport MB=`git merge-base origin/2.10.x origin/master`\r\nmerge/2.10.x-to-master ~/code/scala4 git --no-pager  log $MB...origin/2.10.x --oneline --graph\r\n* 9cdbe28 Fixup #3248 missed a spot in pack.xml\r\n*   4aaee3b Merge pull request #3249 from retronym/ticket/7912\r\n|\\\r\n| * 006e2f2  Be defensive calling `toString` in `MatchError#getMessage`\r\n* |   0b77398 Merge pull request #3251 from retronym/ticket/8060\r\n|\\ \\\r\n| * | bb427a3  Avoid infinite loop with higher kinded type alias\r\n| |/\r\n* |   f405417 Merge pull request #3248 from adriaanm/dist-cleanup-licenses\r\n|\\ \\\r\n| |/\r\n|/|\r\n| * 27a3860 Update README, include doc/licenses in distro\r\n| * 139ba9d Add attribution for Typesafe.\r\n| * e555106 Remove docs/examples; they reside at scala/scala-dist\r\n| * dc6dd58 Remove unused android test and corresponding license.\r\n| * f8d8f7d Do not distribute partest and its dependencies.\r\n* |   0c92704 Merge pull request #3222 from skyluc/issue/completion-import-vals-210-7995\r\n|\\ \\\r\n| * | 5ed834e  completion imported vars and vals\r\n* | |   a444ed7 Merge pull request #3244 from rtyley/si-8019-swing-publisher-check-pf-defined\r\n|\\ \\ \\\r\n| |_|/\r\n|/| |\r\n| * | c955cf4  Make Publisher check PartialFunction is defined for Event\r\n|/ /\r\n* |   db19ddf Merge pull request #3229 from retronym/ticket/8029\r\n|\\ \\\r\n| * | fdcc262  Avoid multi-run cyclic error with companions, package object\r\n| |/\r\n* |   4d439dd Merge pull request #3230 from retronym/backport/7439\r\n|\\ \\\r\n| * | 8d74fa0 [backport]  Avoid NPE in `isMonomorphicType` with stub symbols.\r\n* | |   a774157 Merge pull request #3223 from retronym/ticket/8010-2.10.x\r\n|\\ \\ \\\r\n| * | | 9036f77  Fix regression in erasure double definition checks\r\n| | |/\r\n| |/|\r\n* | |   f6c6846 Merge pull request #3232 from xeno-by/topic/macro-error-messages-210x\r\n|\\ \\ \\\r\n| |_|/\r\n|/| |\r\n| * | 3faa2ee [nomaster] better error messages for various macro definition errors\r\n|/ /\r\n* | 7e996c1 Merge pull request #3209 from dotta/-on-2.10.x\r\n* |   7d74884 Merge pull request #3181 from heathermiller/issue/6913\r\n|\\ \\\r\n| |/\r\n|/|\r\n| * 7063439  Fixing semantics of Future fallbackTo to be according to docs\r\n|/\r\n* 7c1d114 Merge pull request #3208 from dotta/si-7548-on-2.10\r\n* 02308c9  Pres. compiler must not observe trees in silent mode\r\n* 652b3b4  Test to demonstrate residual exploratory typing bug\r\n* b7509c9  askTypeAt returns the same type whether the source was fully or targeted type-checked\r\n```'
3263,'adriaanm','SI-6780 Better handling of cycles in in-scope implicit search\nImplicit searches in the body of implicit members with inferred\ntypes were leading to cycles. Before we used to resolve that\nby saying there were no implicits in scope at all; now we just\nskip the current context and still include the enclosing implicits.\nCare is taken not to cache results under these circumstances.'
3260,'retronym','SI-8035 Deprecate automatic () insertion in argument lists\nThis promotes the () insertion warning from -Ywarn-adapted-args to a\r\ndeprecation warning. -Xfuture tunrs it into a compiler error.\r\n\r\nAuto tupling remains unchanged for now.\r\n\r\nThe tests have been fixed the following way:\r\n- Warnings caused by general sloppiness (Try(), Future(), ...) have been\r\n  fixed.\r\n- Warnings which raise interesting questions (x == (), ...) received an\r\n  updated checkfile for now.'
3259,'retronym','(2.10.4) duplicates macro arguments before expansion\nAs discussed with Jason, this is an important dimension of defenses that\r\nwe can build to ensure robustness of the macro engine.\r\n\r\nThis commit is important in the context of the upcoming patch to the\r\npresentation compiler that will throw away expansions and keep original\r\nmacro applications (only when run in presentation compiler mode) so that\r\nhyperlinking in macro arguments starts working in the IDE.\r\n\r\nDuplication of macro arguments will make sure that macro arguments, which\r\nare going to become exposed to the IDE, can’t become corrupted by possibly\r\nmisbehaving or misguided macros.'
3257,'retronym','(2.11.0-M8) duplicates macro arguments before expansion\nAs discussed with Jason, this is an important dimension of defenses that\r\nwe can build to ensure robustness of the macro engine.\r\n\r\nThis commit is important in the context of the upcoming patch to the\r\npresentation compiler that will throw away expansions and keep original\r\nmacro applications (only when run in presentation compiler mode) so that\r\nhyperlinking in macro arguments starts working in the IDE.\r\n\r\nDuplication of macro arguments will make sure that macro arguments, which\r\nare going to become exposed to the IDE, can’t become corrupted by possibly\r\nmisbehaving or misguided macros.'
3256,'retronym','(2.10.4) whitebox macros are now first typechecked against outerPt\nEven though whitebox macros are supposed to be used to produce expansions\r\nthat refine advertised return types of their macro definitions, sometimes\r\nthose more precise types aren’t picked up by the typechecker.\r\n\r\nIt all started with Travis generating structural types with macros\r\nand noticing that typer needs an extra nudge in order to make generated\r\nmembers accessible to the outside world. I didn’t understand the mechanism\r\nof the phenomenon back then, and after some time I just gave up.\r\n\r\nAfterwards, when this issue had been brought up again in a different\r\nStackOverflow question, we discussed it at reflection meeting, figured out\r\nthat typedBlock provides some special treatment to anonymous classes,\r\nand it became clear that the first macro typecheck (the one that types\r\nthe expansion against the return type of the corresponding macro def)\r\nis at fault here.\r\n\r\nThe thing is that if we have a block that stands for a desugard anonymous\r\nclass instantiation, and we typecheck it with expected type different from\r\nWildcardType, then typer isn’t going to include decls of the anonymous class\r\nin the resulting structural type: https://github.com/scala/scala/blob/master/src/compiler/scala/tools/nsc/typechecker/Typers.scala#L2350.\r\nI tried to figure it out at https://groups.google.com/forum/#!topic/scala-internals/eXQt-BPm4i8,\r\nbut couldn’t dispel the mystery, so again I just gave up.\r\n\r\nBut today I had a profound WAT experience that finally tipped the scales.\r\nIt turns out that if we typecheck an if, providing a suitable pt, then\r\nthe resulting type of an if is going to be that pt, even though the lub\r\nof the branch types might be more precise. I’m sure that reasons for this\r\nbehavior are also beyond my understanding, so I decided to sidestep this problem.\r\n\r\nupd. Here’s Jason’s clarification: Doing thing differently would require\r\nus to believe that "\'Tis better to have lubbed and lost than never to have\r\nlubbed at all." But the desire for efficiency trumps such sentimentality.\r\n\r\nNow expansions of whitebox macros are first typechecked against pt,\r\nthe expected type that comes from the enclosing context, before being\r\ntypechecked against expectedTpe, the expected type that comes from the return\r\ntype of the macro def. This means that now pt provides the correct\r\nexpected type for the initial, most important typecheck, which makes\r\ntypes more precise.'
3254,'retronym','typeCheck => typecheck\nThis method has always been slightly bothering me, so I was really glad\r\nwhen Denys asked me to rename it. Let’s see how it pans out.'
3252,'retronym',"SI-8061 Do not mutate List in Types.scala\n  In src/reflect/scala/reflect/internal/Types.scala, change the\r\n  findMember method's algorithm to use the public List API.\r\n  Prior to this change, the method built a list of matching members\r\n  by appending matching symbols and mutating the tail.\r\n  This change builds up the maching list by prepending instead,\r\n  and reverses the result at the end."
3247,'adriaanm','SI-8058 Better support for enum trees\nReplace the approach of “detect some magic combination of flags to\r\ntrigger some action” by introducing an enum flag which makes the\r\nsemantics and the intentions of the code using it more explicit.\r\n\r\nThis basically involves wiring up the existing ACC_ENUM bit to a new\r\nmodifier flag and making sure it is set correctly when encountering\r\nenums.\r\n\r\nThe existing enum tests files/pos/t5165 and files/pos/t2764 keep\r\nworking, showing that this hasn\'t introduced any obvious regressions.\r\n\r\nTests for the changes in Namer which prevent scalac from messing with\r\nenum trees can\'t be added yet, because one currently can\'t define an\r\nenum in Scala without the help of the macro paradise.\r\nThe intention is to add the @enum macro as a full test suite as soon\r\nas one can depend on macro annotations.\r\n\r\nOne might wonder why we don\'t check for\r\n    clazz.superClass == JavaEnumClass (where clazz is the owning class)\r\nin isEnumConstant.\r\n\r\nThe reason is that this causes illegal cyclic reference error.\r\n\r\nExplanation by Eugene why this happens:\r\n\r\n(23:17:52) xeno_by: so here\'s what happens as far as I can understand at 11pm :)\r\n(23:18:09) xeno_by: scalac tries to complete the signature of the newly expanded class\r\n(23:18:11) xeno_by: to do that\r\n(23:18:40) xeno_by: to do that it needs three things\r\n(23:18:51) xeno_by: because the signature of a class is ClassInfoType which consists of three things\r\n(23:19:05) xeno_by: parents\r\n(23:19:08) xeno_by: decls\r\n(23:19:09) xeno_by: and symbol\r\n(23:19:20) xeno_by: symbol is easy - it\'s already there\r\n(23:19:30) xeno_by: parents are also easy\r\n(23:19:39) xeno_by: you just typecheck the things that come after "extends"\r\n(23:19:42) xeno_by: but decls are tricky\r\n(23:19:51) xeno_by: scalac goes through all the members of the class\r\n(23:20:03) xeno_by: and doesn\'t typecheck them... no, it doesn\'t\r\n(23:20:07) xeno_by: it just enters them\r\n(23:20:32) xeno_by: i.e. creates symbols for them and assigns lazy completers to those symbols so that if someone wants to know their signatures, they will go through the completers\r\n(23:20:34) xeno_by: and then\r\n(23:20:38) xeno_by: wait\r\n(23:20:40) xeno_by: there\'s one but\r\n(23:20:42) xeno_by: BUT\r\n(23:20:47) xeno_by: while we enter those symbols\r\n(23:20:53) xeno_by: our ClassInfoType is not ready yet\r\n(23:21:09) xeno_by: the class we\'re completing is still considered to be in the middle of being completing\r\n(23:21:12) xeno_by: so\r\n(23:21:24) xeno_by: when inside enterSym you try to ask that class for its super class\r\n(23:21:35) xeno_by: what happens is that check asks the class for its type signature\r\n(23:21:45) xeno_by: the ClassInfoType that consists of parents and decls\r\n(23:21:54) xeno_by: even though the parents are already calculated\r\n(23:22:01) xeno_by: the ClassInfoType as a whole is not\r\n(23:22:16) xeno_by: so scalac says that you\'re trying to complete something that\'s currently being completed\r\n(23:22:20) xeno_by: cyclic reference error\r\n(23:22:59) xeno_by: "cyclic" in English looks an awful lot like "суслик" in Russian (which means "gopher")'
3246,'retronym','streamlines refchecking undesired symbol properties\nUnifies `checkDeprecated`, `checkMigration` and `checkCompileTimeOnly`\r\ninto a single centralized point of reference that is now consistently\r\ncalled from `checkTypeRef`, `transformIdent` and `transformSelect`.'
3245,'retronym','SI-8047 change fresh name encoding in quasiquotes to avoid symbol owner corruption\nPreviously a following encoding was used to represent fresh names that should be created at runtime of the quasiquote:\r\n\r\n```\r\nbuild.withFreshTermName(prefix1) { name$1 =>\r\n  ...\r\n    build.withFreshTermName(prefixN) { name$N =>\r\n      tree\r\n    }\r\n  ...\r\n}\r\n```\r\n\r\nIt turned out that this encoding causes symbol corruption when tree defines symbols of its own. After being spliced into anonymous functions, the owner chain of those symbols will become corrupted.\r\n\r\nNow a simpler and probably better performing alternative is used instead:\r\n\r\n```\r\n{\r\n  val name$1 = build.freshTermName(prefix1)\r\n  ...\r\n  val name$N = build.freshTermName(prefixN)\r\n  tree\r\n}\r\n```\r\n\r\nHere owner stays the same and doesn’t need any adjustment.'
3242,'adriaanm','SI-8046 BaseTypeSeq fixes with aliases\nPreview/Feedback by @adriaanm and build kitteh'
3240,'adriaanm','SI-7618 Remove octal number literals\nThis also fixes a spurious detection of octal literals in floating\r\npoint literals: Literals like 01.23 are neither deprecated nor planned\r\nfor removal.'
3239,'xeno-by',"SI-8052 Disallow `macro` as an identifier\nNote that the change could look a lot cleaner, at the cost of returning\r\nmore generic error messages. I decided that at least for 2.11 I'll keep\r\nscalac remembering that macro was a standard identifier name once, so\r\nthat we can point out more precisely what's wrong with users' code."
3237,'retronym','deprecates macro def return type inference\nWith the new focus on quasiquotes in macro implementations, we now have\r\nto change the way how inference of macro def return types works.\r\n\r\nPreviously, if the return type of a macro def wasn’t specified, we looked into\r\nthe signature of its macro impl, took its return type (which could only\r\nbe c.Expr[T]) and then assigned T to be the return type of the macro def.\r\n\r\nWe also had a convenient special case which inferred Any in case when\r\nthe body of the macro impl wasn’t an expr. That avoided reporting spurious\r\nerrors if the macro impl had its body typed incorrectly (because in that\r\ncase we would report a def/impl signature mismatch anyway) and also provided\r\na convenience by letting macro impls end with `???`.\r\n\r\nHowever now we also allow macro impls to return c.Tree, which means that\r\nwe are no longer able to do any meaningful type inference, because c.Tree\r\ncould correspond to tree of any type.\r\n\r\nUnfortunately, when coupled with the type inference special case described\r\nabove, this means that the users who migrate from exprs to quasiquotes\r\nare going to face an unpleasant surprise. If they haven’t provided\r\nexplicit return types for their macro defs, those types are going to be\r\nsilently inferred as `Any`!\r\n\r\nThis commit plugs this loophole by prohibiting type inference from\r\nnon-expr return types of macro impls (not counting Nothing). Moreover,\r\nit also deprecates c.Expr[T] => T inference in order to avoid confusion\r\nwhen switching between exprs and quasiquotes.'
3236,'retronym','(2.11.0-M8) whitebox macros are now first typechecked against outerPt \nEven though whitebox macros are supposed to be used to produce expansions\r\nthat refine advertised return types of their macro definitions, sometimes\r\nthose more precise types aren’t picked up by the typechecker.\r\n\r\nIt all started with Travis generating structural types with macros\r\nand noticing that typer needs an extra nudge in order to make generated\r\nmembers accessible to the outside world. I didn’t understand the mechanism\r\nof the phenomenon back then, and after some time I just gave up.\r\n\r\nAfterwards, when this issue had been brought up again in a different\r\nStackOverflow question, we discussed it at reflection meeting, figured out\r\nthat typedBlock provides some special treatment to anonymous classes,\r\nand it became clear that the first macro typecheck (the one that types\r\nthe expansion against the return type of the corresponding macro def)\r\nis at fault here.\r\n\r\nThe thing is that if we have a block that stands for a desugard anonymous\r\nclass instantiation, and we typecheck it with expected type different from\r\nWildcardType, then typer isn’t going to include decls of the anonymous class\r\nin the resulting structural type: https://github.com/scala/scala/blob/master/src/compiler/scala/tools/nsc/typechecker/Typers.scala#L2350.\r\nI tried to figure it out at https://groups.google.com/forum/#!topic/scala-internals/eXQt-BPm4i8,\r\nbut couldn’t dispel the mystery, so again I just gave up.\r\n\r\nBut today I had a profound WAT experience that finally tipped the scales.\r\nIt turns out that if we typecheck an if, providing a suitable pt, then\r\nthe resulting type of an if is going to be that pt, even though the lub\r\nof the branch types might be more precise. I’m sure that reasons for this\r\nbehavior are also beyond my understanding, so I decided to sidestep this problem.\r\n\r\nupd. Here’s Jason’s clarification: Doing thing differently would require\r\nus to believe that "\'Tis better to have lubbed and lost than never to have\r\nlubbed at all." But the desire for efficiency trumps such sentimentality.\r\n\r\nNow expansions of whitebox macros are first typechecked against outerPt,\r\nthe expected type that comes from the enclosing context, before being\r\ntypechecked against innerPt, the expected type that comes from the return\r\ntype of the macro def. This means that now outerPt provides the correct\r\nexpected type for the initial, most important typecheck, which makes\r\ntypes more precise.'
3235,'retronym','new hooks in AnalyzerPlugins to enable macro experimentation\nThis pull requests introduces several new hooks in AnalyzerPlugins that would greatly assist me in experimenting with macros without hijacking namers and typers:\r\n1) `pluginsEnterSym`, `pluginsEnsureCompanionObject` and `pluginsEnterStats` are all that it takes to support macro annotations.\r\n2) `pluginsTypedMacroBody` and `pluginsMacroExpand` should be enough to play with Palladium without touching trunk.\r\n\r\nI already have [a macro paradise branch](https://github.com/scalamacros/paradise/commit/4bb01031bb3c2d17d689d0ddf0a9c7ac71d87e2b#diff-0) that is based on this pull request, and one can observe that it brings significant code shrinkage as well as reduces the amount of hackery down to zero, ensuring full compatibility with 2.11 and lack of unexpected side-effects in projects that use paradise.\r\n\r\nreview @retronym'
3234,'gkossakowski',"SI-5508 Fix crasher with private[this] in nested traits\nCurrently, this is done late in the game as the Mixin tree transformer\r\ntreats the trait.\r\n\r\n    // Mixin#addLateInterfaceMembers\r\n    val getter = member.getter(clazz)\r\n    if (getter == NoSymbol) addMember(clazz, newGetter(member))\r\n\r\n`addMember` mutates the type of the interface to add the getter.\r\n\r\nHowever, if an inner class or anonymous function of the trait\r\nhas been flattened to a spot where it precedes the trait in the\r\nenclosing packages info, this code hasn't had a chance to run,\r\nand the lookup of the getter crashes as mixins postTransform\r\nruns over a selection of the not-yet-materialized getter.\r\n\r\n    // Mixin#postTransform\r\n\tcase Select(qual, name) if sym.owner.isImplClass && !isStaticOnly(sym) =>\r\n\t  val iface  = toInterface(sym.owner.tpe).typeSymbol\r\n\t  val ifaceGetter = sym getter iface\r\n\r\nThis commit ensures that Flatten lifts inner classes to\r\na position *after* the enclosing class in the stats of the\r\nenclosing package.\r\n\r\nBonus fix: SI-7012 (the followup ticket to SI-6231 / SI-2897)"
3232,'retronym','[nomaster] better error messages for various macro definition errors\nbackport of 1d3ec4e708154ec05554f540d7d68ed55dc12426'
3231,'retronym','undeprecates c.parse\nWe never thought that c.parse is going to be completely subsumed by\r\nquasiquotes, but hoped that the use cases that are going to be lost\r\naren’t going to be noticed by anyone.\r\n\r\nUnfortunately, this isn’t the case, so I’m undeprecating c.parse until\r\nwe get a better story for those for whom quasiquotes are not enough.'
3229,'adriaanm',"SI-8029 Avoid multi-run cyclic error with companions, package object\nThe bug report suggests this problem only became visible in the\nIDE *after* 2.10.3, but I tested an IDE with exactly 2.10.3 and\nsaw the same problem.\n\nIn fact, my test case fails as far back as 2.10.0. I suspect the\nproblem showed up after 816cecf9a9, which checks that pairs of\ncompanion symbols are codefined eagerly in Namers.\n\nThis commit modifies the check of `rawInfo ne NoType`\nin `isCoDefinedWith` to avoid triggering adaptation of types from\nthe previous run. I'm not sure of the precise intent of that check.\nI looked at c9861cd198 (genesis of isCoDefinedWith). Before that we\nget back to 3761cb4b3a1 (the dawn of Subversion.)\n\nReview by @adriaanm"
3224,'adriaanm','SI-7971 Handle static field initializers correctly\nBefore this fix, static fields where erroneuosly treated like instance\r\nfields and the initialization was moved into the constructor.\r\n\r\nWith this fix, the static initializer statements go into the static\r\ninitializer of the class (called “<STATIC> def init” in Scala,\r\n<clinit> in Java). The statements are added to an existing\r\nstatic initializer method or, if no such method exists, a new static\r\ninitializer method is created and added to the class.'
3223,'xeno-by','SI-8010 Fix regression in erasure double definition checks\nCalls to `Symbol#info` during scope iteration considered harmful.\r\n\r\nLooks like calling `info` during this Scope iteration is triggering\r\nthe ExplicitOuter info transformer, which "makes all super accessors\r\nand modules in traits non-private, mangling their names.". This name\r\nchange necessitates a rehashing of the owning scope, which I suspect\r\nis enough to corrupt the ScopeEntry-s being traversed in\r\n`checkNoDeclaredDoubleDefs`.\r\n\r\nThe upshot was that we encountered the same symbol twice, which was\r\nreported as being a double-definition.\r\n\r\nThis problem only showed up after 086702d8a74, which did nothing\r\nworse then change the order in which `{e, e1}.sym.info` were\r\nforced.\r\n\r\nI inspected SymbolPairs/OverridingPairs which *appear* to be immune\r\nas they only test flags during scope iteration; infos are not used\r\nuntil later, at which point we\'re iterating a temporary scope that\r\nisn\'t part of the type of the owner of the symbols.\r\n\r\nReview by @xeno-by\r\n'
3222,'JamesIry',"SI-7995 completion imported vars and vals\nImported member vals and vars were always marked inaccessible, even\r\nif referencing them at the location of the completion is valid in code.\r\nThe accessible flag is now set accordingly to the accessibility of the getter.\r\n\r\nI am working on an equivalent PR for 2.11. The changes are fairly different, as the code has been modularized, and the format of the oracle is different. I'll submit it after this PR is merged."
3221,'adriaanm',"Final library modularization for 2.11\nThe continuations plugin and library moved to https://github.com/scala/scala-continuations.\r\nThe Scala Swing library moved to https://github.com/scala/scala-swing.\r\n\r\nThey will still ship with 2.11 (albeit unsupported), but may disappear in 2.12.\r\n\r\nTODO: add deprecation to CPS plugin over at https://github.com/scala/scala-continuations.\r\n\r\nreview by @gkossakowski\r\n\r\nNOTE: I've moved the java7 patches over to scala/scala-swing as well, which means we're one step closer to building master on java 6 and 7 without modification. I noticed I missed a couple of changes to partest javaagent in the java7 branch. It would be good to port those over, and to see if we can get rid of the java7 branch all together in scala/scala."
3220,'JamesIry','Handle static fields correctly in Constructors\n'
3217,'adriaanm','SI-7788 Predef.conforms can circumvent implicit shadowing\n... together with small improvements to shadowing detection\nin implicit typechecking.\n\nReview by @adriaanm'
3216,'retronym','better error messages for various macro definition errors\n'
3214,'adriaanm','SI-8024 Fix inaccurate message on overloaded ambiguous ident\nMore details in the commit messages.\n\nReview by @adriaanm'
3209,'retronym',"SI-7982 make askLoadedType unload arguments out of the PC by default,\nRe-opened https://github.com/scala/scala/pull/3158 to target 2.10.x\r\n\r\nreview by @adriaanm\r\n\r\nAs point out by @huitseeker in https://github.com/scala/scala/pull/3158#issuecomment-28900230, scala-refactoring failure is expected until https://github.com/scala-ide/scala-refactoring/pull/37 is merged. I'm not sure what's the best course of action here, but merging this PR will require some coordination with @misto, because the scala-refactoring PR should be merged at the same time.\r\n"
3206,'adriaanm','SI-7281 Add @scala.runtime.ValueType to value type classes\nInstead of preserving AnyVal as a superclass, which seems to be out of\r\nreach for the time being, add a marker annotation which gives runtimes\r\nan cheap and easy way to check whether a certain class is a value type\r\nwithout depending on a language-specific library.'
3204,'xeno-by','Test case for recently improved unchecked warning\nPrior to https://github.com/scala/scala/pull/2848, the enclosed\ntest compiled without warning and printed:\n\n    true\n    false\n\nFeatures interacting:\n  - implicit class tags to enable type patterns on abstract types\n  - type tests on compound types.\n\nI think the unchecked warning is acceptable for now.'
3185,'adriaanm','Update Eclipse classpath files\nReview by @adriaanm'
3184,'adriaanm',"SI-2066 Plug a soundness hole higher order type params, overriding\nPolyType-s parameterized by higher order type parameters (HOTPs)\nshould only be relatable with <:< or =:= if the variances of their\ntype parameters line up. This is only enforced for HOTPs defined in\nmethod type arguments.\n\nReview by @adriaanm. I'm not sure if this is the right place to\nmake the fix, nor if the scope is quite right."
3183,'retronym','SI-8001 spurious "pure expression does nothing" warning\n`isPureExprForWarningPurposes` doesn’t warn on `()`, but `(): Unit`\r\nleaves it confused. This patch fixes the problem.\r\n\r\nThe fix is important in the context of the recent split between blackbox\r\nand whitebox macros. Macro engines wrap expansions of blackbox macros\r\nin type ascriptions, so a macro that expands into `()` would actually\r\nproduce `(): Unit`, which would trigger a spurious warning. Thanks\r\n@milessabin for spotting this problem!'
3180,'retronym','teaches toolbox about -Yrangepos\nreview @retronym'
3179,'gkossakowski','Merge ChangeOwner{AndModuleClass}Traversers\nI found while implementing scala-async that I needed the\nequivalent functionality of `ChangeOwnerAndModuleClassTraverser`,\nwhich I found squirrelled away in part of the lazy vals\nimplementation.\n\nThis functionality was at briefly (starting in 981424b376)\nin the regular `ChangeOwnerTraverser` but was moved to a subclass\nin a15969a6963 in response to code review [1].\n\nBut that review was actually about exposing a boolean\nparameter "followModuleClass", rather than a criticism of\ncentralizing this pattern.\n\nThis commit speculates that "followModuleClass = true" is\n*always* what you want.\n\nReview by @gkossakowski\n\n[1] https://github.com/scala/scala/pull/1406#discussion_r1703370'
3178,'adriaanm','SI-7872 Plug a variance exploit in refinement types\nRefinement types are collapsed to a TypeTree with an original\nduring type checking; this was enough to evade variance validation\nin refchecks.\n\nThis commit:\n\n  - validates the original of `TypeTree`s in refchecks\n  - changes VarianceValidator to recurse into:\n    - the originals of `TypeTree`s\n    - `TypTree` (to cover, e.g. `CompoundTypeTree` / `SelectFromTypeTree`)'
3165,'JamesIry','Unifying -Ydelambdafy:{inline, method}\nAvoid code duplication and use a common approach for\r\nsymbol substituion.\r\n\r\nI asked Martin "why did the apply method just reuse the parameter symbols\r\nof the lambda verbatim", to which he suggested at the time substitution\r\nwasn\'t up to scratch to risk anything more principled.\r\n\r\nTurns out it still isn\'t, but I\'ve taken steps to remedy that\r\nin this incarnation of the pull request.'
3160,'adriaanm','Fix implicit divergence regression\nWith a sprinkling of additional cleanup.\n\nReview by @adriaanm\n\n/cc @szeiger'
3157,'JamesIry','Backport of SI-7915\n(cherry picked from commit 3009a525b58a4c7865ff524899b85518884ee5f7)'
3156,'adriaanm','Remove deprecated constructor from the migration annotation\nThe migration annotation had a deprecated 2 arg constructor that was\r\ndeprecated in 2.10.0. This commit removes that constructor. Because\r\nmigration is private to the scala package this change shouldn’t affect\r\nthe rest of the community.'
3153,'JamesIry','Fix a typo in the `scala` man page\n'
3150,'JamesIry','WIP: rebase of #3117\nWIP: rebase of #3117'
3149,'retronym',"SI-7974 Fix broken 'Symbol-handling code in CleanUp\nThe transformation did never happen because the pattern\r\nfailed to match. Why did the pattern fail to match? Because\r\nSymbol_apply turned into an overloaded Symbol after erasure."
3147,'gkossakowski','SI-7969 REPL -C columnar output\nLet `ConsoleReaderHelper.printColumns` print in a vertical\r\norientation (similar to `ls -C`) instead of horizontally (`ls -x`).\r\n\r\nTo support the old behavior, add a property `-Dscala.repl.format=across`\r\nwhere "across" is the presumptive mnemonic for `-x`.\r\n\r\nExtend column formatting to make columns only as wide as\r\ntheir widest element. \r\n\r\nExample that really benefits, witness the skinny columns:\r\n\r\n```\r\nscala> math.\r\n\r\nBigDecimal                     PartiallyOrdered             cosh      rint\r\nBigInt                         Pi                           exp       round\r\nE                              ScalaNumber                  expm1     signum\r\nEquiv                          ScalaNumericAnyConversions   floor     sin\r\nFractional                     ScalaNumericConversions      hypot     sinh\r\nIEEEremainder                  abs                          log       sqrt\r\nIntegral                       acos                         log10     tan\r\nLowPriorityEquiv               asin                         log1p     tanh\r\nLowPriorityOrderingImplicits   atan                         max       toDegrees\r\nNumeric                        atan2                        min       toRadians\r\nOrdered                        cbrt                         package   ulp\r\nOrdering                       ceil                         pow\r\nPartialOrdering                cos                          random\r\n\r\n```'
3144,'JamesIry','fix IntMap#foreachValue and LongMap#foreachValue scaladoc\n'
3140,'retronym','SI-7280 Scope completion not returning members provided by imports\nScope completion was not returning members provided by import declared in the same block as the given position, if the position was inside an expression which could not be typed successfully, or outside any expression (2 normal use cases when triggering completion in an IDE).\r\n\r\nThe first commit is a port of retronym/scala@e7ebf3825b4bc63e60ea1e7fcb8c74d509f5a0c6 on the 2.11 code base, to add support to test scope completion in parttest. The second one contains some basic tests for code completion (inheritance, multilevel definition, ...). And the last commit contains the actual fix, with the associated test.\r\n\r\nreview by @retronym, @odersky'
3138,'retronym','Refactor out fresh name prefix extraction logic\nAs discussed in https://github.com/densh/scala/commit/0bcb907a25fd0688653c497e2d83a7c2c05e8f8e#diff-9b7190b44c5da63343ed67c2bfa6d043R194\r\n\r\n1. refactor out FreshNameExtractor out of Quasiquotes cake into SymbolTable (can’t put it outside due to the fact that names are path-dependent)\r\n\r\n2. add optional parameter to the fresh name creator to cover additional qq$ prefix needed for quasiquotes\r\n\r\n3. add unit tests\r\n\r\nreview by @retronym'
3137,'retronym','correctly fails implicit search for invalid implicit macros\nThere was a rare corner case when implicit search wouldn’t discard\r\nan invalid implicit macro (e.g. the one with mismatching macro impl or\r\nthe one with macro impl defined in the same compilation run) during\r\ntypechecking the corresponding candidate in typedImplicit1. This is now fixed.'
3136,'retronym',"SI-7915 Corrected range positions created during default args expansion\nThe tree created during expansion of default arguments contained trees with the\r\nwrong type of positions. In particular:\r\n\r\n* The synthetic $qual should have a transparent position.\r\n* The new Select tree should always have a range position, because `selected`\r\n  (i.e., the called method) is always visible in the source.\r\n* The Block that contains the expanded default arguments is transparent.\r\n\r\nThe only tricky part of the fix is the position assigned to the new Select\r\ntree, which needs to respect the range position's invariants. In the specific\r\ncase, we ought to make sure that range positions don't overlap. Therefore, the\r\nposition assigned to the new Select tree is computed by intersecting the\r\noriginal Select position (i.e., `baseFun`'s position) and the original\r\nqualifier's position (i.e., `qual`'s position). Furthermore, calling\r\n`withStart` would turn any position in a range position, which isn't\r\ndesiderable in general (and, even worse, this could lead to generation of\r\ninvalid - bad offsets - positions). Hence, the computation is only performed\r\nwhen both `baseFun` and `qual` positions are range positions. I expect this to\r\nbe always the case if the compiler is started with -Yrangepos. In fact, I\r\nwonder if I should add an assertion that validates this assumption."
3135,'JamesIry',"Revived tests that once depended on xml\nI was a bit overzealous in moving stuff over to scala-xml in 9c50dd5274\r\nThese were all compiler tests that accidentally touched on xml.\r\nI've tried to delicately decouple them so they can roam the\r\nscalac pastures as intended.\r\n\r\nI'm not sure the operation was completely successful, but close enough, I'd say.\r\n\r\nreview by @jamesiry"
3134,'retronym','more precise isMacroApplication check\nReplaces the `symbol.isMacro` check with `symbol.isTermMacro`.\r\nDoesn’t make any difference to trunk but helps a lot with macro annotations.'
3130,'adriaanm','SI-7967 Account for type aliases in self-type checks\nThese eluded the check for "illegal inheritance; self-type does not\r\nconform" as AliasTypeRef doesn\'t forward `typeOfThis`.\r\n\r\nThis commit dealiases before calling `typeOfThis`. That seems to be\r\nthe most localised change.\r\n\r\nWithout the dealias, we had:\r\n\r\n    parent.tpe            = TypeRef(pre, sym = AliasTypeSymbol("CC"), Nil)\r\n    parent.tpe.typeOfThis = parent.tpe.transform(sym.typeOfThis) = CC\r\n\r\nAfter:\r\n\r\n    parent.tpe.dealias            = TypeRef(pre, sym = ClassSymbol("C"), Nil)\r\n    parent.tpe.dealias.typeOfThis = C with B\r\n\r\nReview by @adriaanm'
3128,'JamesIry',"Upgrade pax-url-aether to 1.6.0.\nSince our jenkins uses mirrors with passwords,\r\nwe needed a fix for https://ops4j1.jira.com/browse/PAXURL-217\r\nin order to run osgi.test on jenkins, now that we use maven more.\r\nWe didn't hit this bug before because we were using a standard\r\nlocation for the maven local repository, but that causes problems\r\nwith concurrent jenkins jobs accessing it."
3127,'JamesIry','SI-7968 Use an intrinsic for the next power of two calculation.\nFixes issues raised in #3126.\r\nThe nextPowerOfTwo function is replaced by nextPositivePowerOfTwo which provides the following improvements:\r\n\r\n1) Uses the Integer.numberOfLeadingZeros intrinsic for the actual implementation.\r\n2) If the input is already a power of two it just returns the number instead of returning the next power of two.\r\n3) Works for negative numbers and zero as input. The output is 1 in both cases.'
3125,'JamesIry',"Better support for enum trees\nReplace the approach of “detect some magic combination of flags to\r\ntrigger some action” by introducing an enum flag which makes the\r\nsemantics and the intentions of the code using it more explicit.\r\n\r\nThis basically involves wiring up the existing ACC_ENUM bit to a new\r\nmodifier flag and making sure it is set correctly when encountering\r\nenums.\r\n\r\nThe existing enum tests files/pos/t5165 and files/pos/t2764 keep\r\nworking, showing that this hasn't introduced any obvious regressions.\r\n\r\nTests for the changes in Namer which prevent scalac from messing with\r\nenum trees can't be added yet, because one currently can't define an\r\nenum in Scala without the help of the macro paradise.\r\nThe intention is to add the @enum macro as a full test suite as soon\r\nas one can depend on macro annotations."
3124,'adriaanm'," Fix SI-7443 Range.sum ignoring Numeric argument and always assuming default 'plus' implementation\nhttps://issues.scala-lang.org/browse/SI-7443\r\nReview: @axel22"
3119,'JamesIry',"New mutable hash map with Long keys: partially solves SI-5263 and is relevant to SI-6825.\n\r\nThis implements a new hash map, mutable.LongMap, based on an open addressing scheme that provides\r\ndramatically faster (mostly due to specialization) get and contains\r\noperations than either the standard Java HashMap or any of the existing\r\nScala hash maps.  It doesn't work well above 500,000,000 elements as\r\nthe arrays cannot scale past 2^30 elements.  Maps are not faster in\r\ngeneral due to the lack of specialization of Function1[Long, V]."
3117,'JamesIry','WIP uncurry tiding\n/cc @JamesIry'
3116,'paulp','Add buildcharacter.properties to .gitignore.\n(cherry picked from commit 693e55e1cb75055bb243ffca2e18b8e44e80bb8c)\n\nReview by @paulp'
3113,'adriaanm','Make parameters to implicit value classes private\nRebase of #3046, first bumping starr to M6\r\n(Left other versions as-is, as something seems wrong with partest.\r\nLooking into that now.)\r\n\r\nOld description:\r\nSo that they aren\'t offered as an autocomplete suggestion:\r\n\r\n    implicit class Shouty(string: String) extends AnyVal {\r\n     def SHOUT_! = string.toUpperCase + "!"\r\n    }\r\n    "". // autocompletion offers `.string` here.\r\n\r\nThe original incarnation of value classes didn\'t allow this sort of\r\nencapsulation, so we either invented goofy names like\r\n`__thingToAdd` or just picked `x` or `self`. But  has delivered us the\r\nfreedom to keep the accessor private.\r\n\r\nShould we keep any of these accessors around in a deprecated form?\r\n\r\nThe implicit classes in Predef were added in 2.11.0-M2\r\n(c26a8db067e4f), so they are okay.\r\n\r\nI think we can make reason that these APIs were both accidental and unlikely\r\nto be interpreted as public, so we can break them immediately.\r\n\r\n    scala> Left(1).x\r\n    res0: scala.util.Either[Int,Int] = Left(1)\r\n    \r\n    scala> import concurrent.duration._\r\n    import concurrent.duration._\r\n    \r\n    scala> 1.n\r\n    res1: Int = 1'
3111,'JamesIry','SI-7958 Deprecate methods `future` and `promise` in the `scala.concurren...\n...t` package object\r\n\r\nThe corresponding `apply` methods in the `Future` and `Promise` objects\r\nshould be used instead.'
3110,'retronym','[backport] SI-7776 post-erasure signature clashes are now macro-aware\n"double definition: macro this and method that have same type after erasure"\r\nThis error doesn\'t make sense when macros are involved, because macros\r\nexpand at compile-time, where we\'re not affected by erasure. Moreover,\r\nmacros produce no bytecode, which means that we\'re safe from VerifyErrors.'
3109,'JamesIry',"Faster build 2.10\nBackport of #3108 -- provide hooks for jenkins jobs to specify which repository to publish to.\r\nAlso, publish only what's needed during PR validation to save time.\r\nFinally, we're standardizing on putting all our java properties in versions.properties and passing that around between the jenkins pr validation jobs, having them consumed by the scripts and dbuild. This way we can keep all module versions in synch and don't need to change infrastructure (much) when new properties are needed."
3108,'JamesIry',"Faster PR validation\nThis reworks the build so we can speed up PR validation, publishing Scala to maven once, and consuming that downstream in the other jobs (by maven/sbt/dbuild)\r\n\r\nWe're standardizing on putting all our java properties in versions.properties and passing that around between the jenkins pr validation jobs, having them consumed by the scripts and dbuild. This way we can keep all module versions in synch and don't need to change infrastructure (much) when new properties are needed."
3105,'scala-jenkins','Fix completion after application with implicit arguments\n`List(1, 2, 3).map(f).<ctrl-space>` now works; before\nthe tree had the type `(bf: CanBuildFrom[...]):...` and\ndid not contribute completions from the result type.\n\nThis commit checks if the tree has an implicit method\ntype, and typechecks it as a qualifier. That is enough\nto get to `adaptToImplicitMethod` in the type checker,\ninfer the implicit arguments, and compute the final result\ntype accordingly.'
3104,'adriaanm','Update eclipse setup instructions\nThanks to @gkossakowski for helping on setting up my Eclipse environment for Scala development.\r\n\r\nreview by @gkossakowski\r\n\r\nLet me know if you guys want me to squash any of the below commits.'
3102,'JamesIry','SI-4012 Mixin and specialization work well\nThe bug was fixed along with SI-7638 in 504b5f3.\r\n\r\nReview by @axel22.'
3101,'retronym','SI-7776 post-erasure signature clashes are now macro-aware\n"double definition: macro this and method that have same type after erasure"\r\nThis error doesn\'t make sense when macros are involved, because macros\r\nexpand at compile-time, where we\'re not affected by erasure. Moreover,\r\nmacros produce no bytecode, which means that we\'re safe from VerifyErrors.'
3100,'retronym','Paulper stack reduction\nRewrites the parser stack reduction logic, rebased.\r\n\r\nReview by @densh or @retronym \r\n'
3097,'JamesIry',"SI-6546 InnerClasses attribute refers to absent class\nAt issue is that the optimizer would eliminate closure classes\r\ncompletely, then neglect to eliminate those classes from the\r\ncontainer's InnerClasses attribute. This breaks tooling which\r\nexpects those entries to correspond to real classes.\r\n\r\nThe code change is essentially mgarcia's - I minimized it and\r\nput the caches in perRunCaches, and added the test case which\r\nverifies that after being compiled under -optimise, there are\r\nno inner classes. Before/after:\r\n```diff\r\n  7,8d6\r\n  <   InnerClasses:\r\n  <        public final #22; //class A_1$$anonfun$f$1\r\n  37,45c35,40\r\n  <   #21 = Utf8               A_1$$anonfun$f$1\r\n  <   #22 = Class              #21            //  A_1$$anonfun$f$1\r\n  <   #23 = Utf8               Code\r\n  ---\r\n  >   #21 = Utf8               Code\r\n```"
3095,'gkossakowski','Don\'t use runtime reflection from the batch compiler.\nNot only does this save a big chunk of time on startup by avoiding\nclassloading and symbol table population, but it also seems to\nimprove steady state performance of the compiler.\n\nTheory: JIT can optimize more aggressively without the\nSynchronizedXxx decorators and the like being in the classloader.\nSee "Class Heirarchy Analyis" in [1]\n\nThis commit does this by:\n\n  - Avoiding use of FromString in pattern matcher, instead\n    using an established mechanism to parse system properties.\n  - Changes FromString back to use OptManifest. AFAICT, this\n    is now only a dependency of scala.tools.cmd.gen.Codegen,\n    so this is just a defensive measure.\n\nThe REPL still uses runtime reflection, so will pay a little\nperformance tax.\n\nBenchmark:\n\n    avg shortest 10 times 744ms  # before\n    avg shortest 10 times 675ms  # after\n\n[1] https://wikis.oracle.com/display/HotSpotInternals/PerformanceTechniques'
3094,'adriaanm','Avoid needless TypeRef allocation during erasure.\nAvoid needless TypeRef allocation during erasure.\r\n\r\n  - ThisType(some.package) need not be erased, we can let\r\n    that prefix through unchanged and avoid churning through\r\n    allocations.\r\n  - Sharpen the condition in `rebindInnerClass`. The answer\r\n    to the deleted comment in the code, is "anonymous and\r\n    local classes", which are specifically excluded in the\r\n    new formulation.\r\n  - Finally, detect if erasure of the TypeRef is an identity and reuse\r\n    the original.\r\n\r\nWaste not, want not.\r\n\r\nTo expand on the first point, here is what used to happen during\r\nerasure:\r\n\r\n    scala> val scalaPack = typeOf[Predef.type].prefix\r\n    scalaPack: $r.intp.global.Type = scala.type\r\n\r\n    scala> typeDeconstruct.show(scalaPack)\r\n    res19: String = ThisType(package scala)\r\n\r\n    scala> typeDeconstruct.show(erasure.scalaErasure(scalaPack))\r\n    res20: String = TypeRef(TypeSymbol(final class scala extends ))\r\n\r\nShowing one step of the erasure type map:\r\n\r\n    scala> typeDeconstruct.show(scalaPack.asInstanceOf[SubType].underlying.typeOfThis)\r\n    res21: String = SingleType(pre = ThisType(package <root>), package scala)\r\n'
3092,'gkossakowski','Small implicit optimizations, and SI-7678 RunDefinitions\nThe first two commits should be pretty uncontroversial. They speed up\r\nimplicit search a little.\r\n\r\nI then tried to cache per-run some member symbols that were being\r\nlooked up and stuffed into a map per-implicit search. This led to the \r\nintroduction of RunDefinitions, which in turn let me address SI-7678,\r\nin which the presentation compiler shows up places where we incorrectly\r\nwere caching member symbols per-global, rather than per-run.\r\n\r\n'
3090,'retronym','Add support for For loops to quasiquotes \nreview by @retronym @xeno-by'
3088,'adriaanm',"SI-7944 FOUND: stray undetermined type params in vicinity of implicits\nImplicit search created a nested Context into which the results of\nits typechecking, namely, errors and undetermined type parameters\n(roughly: those inferred as Nothing) are stashed.\n\nThe code the drives the process was checking for errors, but\ndiscarded those undetermined type parameters.\n\nThis commit copies them from the child context to the parent,\nwhich lets `Typer#adapt` to get to:\n\n    else if (hasUndetsInMonoMode) { // (9)\n      assert(!context.inTypeConstructorAllowed, context) //@M\n      instantiatePossiblyExpectingUnit(tree, mode, pt)\n    }\n\nOur lost TypeVar has found its way home! The reward for which\nis being instantiated, based on another type inference session\nadapting the expression's type to the expected type."
3084,'gkossakowski','Microoptimization in implicit search\nAvoid creating a throwaway list of parameter types.\r\n\r\nReview by @gkossakowski '
3082,'gkossakowski','SI-6385 Avoid bridges to identical signatures over value classes\nAs Paul noted in the comments to SI-6260 (from which I mined some\ntest cases) "there is no possible basis for conflict here":\n\n    scala> class C[A](val a: Any) extends AnyVal\n    defined class C\n\n    scala> class B { def x[A](ca: C[A]) = () }\n    defined class B\n\n    scala> class D extends B { override def x[A](ca: C[A]) = () }\n    <console>:8: error: bridge generated for member method x: [A](ca: C[A])Unit in class D\n    which overrides method x: [A](ca: C[A])Unit in class B\n    clashes with definition of the member itself;\n    both have erased type (ca: Object)Unit\n           class D extends B { override def x[A](ca: C[A]) = () }\n                                            ^\nWhat was happening?\n\nBridge computation compares `B#x` and `D#x` exitingErasure, which\nresults in comparing:\n\n    ErasedValueType(C[A(in B#x)]) =:= ErasedValueType(C[A(in D#x)])\n\nThese types were considered distinct (on the grounds of the unique\ntype hash consing), even though they have the same erasure and\ninvolve the same value class.\n\nThat triggered creation of an bridge. After post-erasure eliminates\nthe `ErasedValuedType`s, we find that this marvel of enginineering is\nbridges `(Object)Unit` right back onto itself. The previous\nresolution of SI-6385 (d435f72e5fb7fe) was a test case that confirmed\nthat we detected the zero-length bridge and reported it nicely, which\nhappened after related work in SI-6260. But we can simply avoid\ncreating in it in the first place.\n\nThat\'s what this commit does. It does so by reducing the amount\nof information carried in `ErasedValueType` to the bare minimum needed\nduring the erasure -> posterasure transition.\n\nWe need to know:\n\n  1. which value class wraps the value, so we can box and unbox\n     as needed\n  2. the erasure of the underlying value, which will replace this\n     type in post-erasure.\n\nThis construction means that the bridge above computation now\ncompares:\n\n   ErasedValueType(C, Any) =:= ErasedValueType(C, Any])\n\nI have included a test to show that:\n\n  - we don\'t incur any linkage or other runtime errors in the\n    reported case (run/t6385.scala)\n  - a similar case compiles when the signatures align\n    (pos/t6260a.scala), but does *not* compile when the just\n    erasures align (neg/t6260c.scala)\n  - polymorphic value classes continue to erase to the instantiated\n    type of the unbox: (run/t6260b.scala)\n  - other cases in SI-6260 remains unsolved and indeed unsolvable\n    without an overhaul of value classes: (neg/t6260b.scala)\n\nIn my travels I spotted a bug in corner case of null, asInstanceOf\nand value classes, which I have described in a pending test.'
3081,'adriaanm','Delay delambdafication and put the lambda\'s body into the containing class\nThis is an experimental work in progress PR to bring us closer to using method handles. It will be entirely protected by a flag until it is as solid as the current mechanism.\r\n\r\nWith the flag enabled the compiler will defer final translation from lambda to class until very late in the pipeline, and it will put the body of the lambda in a method in the original class.\r\n\r\nThis PR leaves two key things undone\r\n\r\n1) Specialization still needs to be handled.\r\n2) Logic that partially prevents the use of \'this\' in a super constructor call is bypassed. That logic needs to be redone in order to have fewer holes and be less brittle.\r\n\r\nTo enable on a one off basis use -Ydelambdafy:method. For extensive testing modify ScalaSettings to make "method" the default and recompile.\r\n\r\nResubmission of #2887'
3080,'JamesIry','Check file maintainence\nRemoving the empty and orphaned.'
3078,'gkossakowski','SI-7598 Make erasure of isInstanceOf[X.type] $outer-aware\nType tests against Singleton-, This- and, Super- types are translated\r\ninto reference equality checks in erasure.\r\n\r\nFor instance:\r\n\r\n    class C { object X; X.isInstanceOf[X.type] }\r\n\r\nResults in:\r\n\r\n    class C { object X; X eq X }\r\n\r\nBut, the term tree created to refer to the object behind the\r\nSingleType was constructed without being explicit about outer\r\npointers.\r\n\r\nAfter typer:\r\n\r\n    class C { object X; class Inner { X.isInstanceOf[X.type] } }\r\n\r\nAfter explicitouter:\r\n\r\n    class C { object X; class Inner($outer: C) { $outer().X().isInstanceOf[X.type] } }\r\n\r\nAfter erasure:\r\n\r\n    class C { object X; class Inner($outer: C) { $outer().X() eq Outer.this.X() } }\r\n\r\nThat leads to a crash in icode.\r\n\r\nThis commit changes the explicit outer tree transformer to transform\r\nthe types of TypeTrees:\r\n\r\nAfter exlicitouter:\r\n\r\n    Inner.this.$outer().X().isInstanceOf[Inner.this.$outer.X.type](\r\n\r\nDo to this, we need versions of outerValue, outerSelect, and outerPath\r\nthat operate on types. I also refactored the term-level versions of\r\nthese to help emphasise the similarities and differences with the new\r\nversions.\r\n\r\nSome robustness is needed in the face of ill-scoped references left\r\nin the trees after extension methods and tail call elimination have\r\nleft a mess in pos/t6891.scala.\r\n\r\n\r\nThis is a resubmission of #3066 that addresses the problem at the source\r\n(explicitouter) rather than in erasure.\r\n\r\nReview by @gkossakowski / @odersky . '
3077,'adriaanm','Update description of explicitouter phase.\nPatern translation now happens earlier.'
3076,'adriaanm','SI-7605 Deprecate procedure syntax\nThis commit covers three cases:\r\n- constructor definitions      (def this {...})\r\n- concrete method definitions  (def foo {...})\r\n- abstract method declarations (def foo)\r\n\r\nThe deprecation is currently hidden behind -Xfuture pending IDE support\r\nfor migrating users from procedures to methods.'
3073,'adriaanm','SI-7928 Favour module accessors symbols in rebind\nThe Refchecks tree transformer transforms a nested modules that overrides a\nmethod into a pair of symbols: the module itself, and an module accessor that\nmatches the overridden symbol.\n\n    [[syntax trees at end of                     typer]] // test1.scala\n    package <empty> {\n      abstract trait C2 extends scala.AnyRef {\n        def O1: Any\n      };\n      class C1 extends AnyRef with C2 {\n        object O1 extends scala.AnyRef\n      }\n    }\n\n    [[syntax trees at end of                 refchecks]] // test1.scala\n    package <empty> {\n      abstract trait C2 extends scala.AnyRef {\n        def O1: Any\n      };\n      class C1 extends AnyRef with C2 {\n        object O1 extends scala.AnyRef\n        @volatile <synthetic> private[this] var O1$module: C1.this.O1.type = _;\n        <stable> def O1: C1.this.O1.type = {\n          C1.this.O1$module = new C1.this.O1.type();\n          C1.this.O1$module\n        }\n      }\n    }\n\nWhen constructing a TypeRef or SingleType with a prefix and and a symbol, the\nfactory methods internally use `rebind` to see if the provided symbol should\nbe replaced with an overriding symbol that is available in that prefix.\n\nTrying this out in the REPL is a bit misleading, because even if you change \nphase to `refchecks`, you won\'t get the desired results because the transform \nis not done in an InfoTransformer.\n\n    scala> val O1 = typeOf[C1].decl(TermName("O1"))\n    O1: $r.intp.global.Symbol = object O1\n\n    scala> typeRef(typeOf[C2], O1, Nil)\n    res13: $r.intp.global.Type = C2#O1\n\n    scala> res13.asInstanceOf[TypeRef].sym.owner\n    res14: $r.intp.global.Symbol = class C1\n\nBut debugging the test case, we get into `rebind` during an AsSeenFrom which\nis where we crashed when `suchThat` encountered the overloaded module and\nmodule accessor symbols:\n\n    typeOf[OuterObject.Inner.type].memberType(symbolOf[InnerTrait.Collection])\n    ...\n     singleTypeAsSeen(OuterTrait.this.Inner.type)\n       val SingleType(pre, sym) = tp\n       // pre = OuterTrait.this.type\n       // sym = OuterTrait.Inner\n\n        val pre1 = this(pre) // OuterObject.type\n\n        singleType(pre1, sym)\n         rebind(pre1, sym)  // was crashing, now OuterObject.Inner\n\nThis commit excludes the module symbol from symbol lookup in the prefix in\nrebind.'
3072,'adriaanm','[nomaster] SI-7519 Less brutal attribute resetting in adapt fallback\nPrefers `resetLocalAttrs` over `resetAllAttrs`. The latter loses track of\nwhich enclosing class of the given name is referenced by a `This` node which\nprefixes the an applied implicit view.\n\nThe code that `resetAllAttrs` originally landed in:\nhttps://github.com/scala/scala/commit/d4c63b#L6R804\n\nCherry picked from 433880e91cba9e1e926e9fcbf04ecd4aeb1d73eb\n\nConflicts:\nsrc/compiler/scala/tools/nsc/typechecker/Typers.scala'
3070,'retronym',"better macro impl shape errors\nWith the advent of quasiquotes, we allowed both arguments and return types\r\nof macro impls to be c.Tree's (as opposed to traditional c.Expr[T]'s).\r\n\r\nThis warrants an update of macro def <-> macro impl signature mismatch\r\nerrors that include a printout of suggested macro impl signatures. Now\r\nalong with a signature that contains exprs, we suggest another signature\r\nthat has all exprs replaced by trees"
3069,'cunei',"Rework build to allow publishing core to maven\n`ant publish-core-signed-opt-nodocs` creates and publishes the smallest\r\npossible set of jars (library/reflect/compiler) we can send to maven.\r\nIt uploads jars with class files and sources, but no docs\r\n(so that we don't need to build scaladoc or any other modules).\r\n\r\n`ant publish-core-signed-opt` is similar, but also publishes docs.\r\n\r\nFor local experimentation: `ant publish-core-local-nodocs`.\r\nWith a little bit more work, this can be used instead of `replacestarr`.\r\n\r\nThis should allow breaking cycles in a principled way in dbuild:\r\n1. build the Scala core (library/reflect/compiler), publish locally\r\nBuilding the core doesn't have any dependencies on the new modules (it's similar to locker.done).\r\n(Don't test --> no need for partest, skip docs -> ignore soon-to-be-module scaladoc.)\r\n2. Use this Scala core to build all modules (especially partest and scaladoc and all its dependencies)\r\n3. Use partest and scaladoc from step 2. to test and document the core and all modules\r\n4. Publish tested, documented Scala core and modules to maven.\r\n\r\nThe next step is to build and publish a modularized scaladoc in this build,\r\nand support using a maven-resolved scaladoc to generate docs.\r\n\r\nReview by everyone: @gkossakowski, @retronym, @cunei, @jsuereth, @xeno-by, @paulp."
3062,'retronym','hotfix for reflection tests on Windows\nRemoves the Unix-specific command-line sanity check put in place in recently\r\ncommitted reflection tests.\r\n\r\nOn Windows, something like `C:\\Java\\jdk1.6.0_24-x64\\jre\\bin\\java` might\r\nbe a valid command (pointing to `java.exe` or `java.bat`) even if\r\nthe eponymous file does not exist.'
3061,'adriaanm','Fix problem assembling sources and docs of modules.\nA recent commit added \'overwrite=true\' to all usages of the Ant copy task.\r\n\r\nThis was enough to show up a bug in our dist.src and dist.docs tasks, as was\r\nseen on the Windows build:\r\n\r\n    Failed to copy:\r\n     \r\nC:\\Users\\scala\\.m2\\repository\\org\\scala-lang\\modules\\scala-xml_2.11.0-M5\\1.0-RC4\\scala-xml_2.11.0-M5-1.0-RC4-javadoc.jar\r\nto\r\n     \r\nH:\\jenkins\\workspace\\scala-nightly-windows\\dists\\scala-2.11.0-20131019-064627-8848f24161\\doc\\scala-devel-docs\\C:\\Users\\scala\\.m2\\repository\\org\\scala-lang\\modules\\scala-xml_2.11.0-M5\\1.0-RC4\\scala-xml_2.11.0-M5-1.0-RC4-javadoc.jar\r\n...\r\n\r\nThis commit uses a "flattening" copy to put the JARs directly into \r\nscala-devel-docs.\r\n\r\nThe Ant docs note [1] this gotcha:\r\n\r\n> Note that some resources (for example the file resource) return\r\n> absolute paths as names and the result of using them without\r\n> using a nested mapper (or the flatten attribute) may not be what\r\n> you expect.\r\n\r\nThese appear to be the only places we fell into the trap:\r\n\r\n    % ack \'<file\\b\' --xml\r\n    build.xml\r\n    1948:      <file file="${scala-xml-javadoc}"/>\r\n    1949:      <file file="${scala-parser-combinators-javadoc}"/>\r\n    1992:        <file-sets/>\r\n    2007:      <file file="${scala-xml-sources}"/>\r\n    2008:      <file file="${scala-parser-combinators-sources}"/>\r\n\r\n[1] http://ant.apache.org/manual/Tasks/copy.html'
3058,'JamesIry','SI-7918 Use scala.util.DynamicVariable instead of ad hoc implementations\nhttps://issues.scala-lang.org/browse/SI-7918'
3057,'retronym',"fixes handling of fancy nested classes in runtime reflection\nReplaces the `jclazz.isMemberClass` check for whether we have an\r\ninner/nested class with `jclazz.getEnclosingClass != null`, because there\r\nexist classes produced by javac (see the attached jar file and the test log)\r\nwhich have the following properties:\r\n  * They are nested within a parent class\r\n  * getEnclosingClass returns a non-null value\r\n  * isMemberClass returns false\r\n\r\nPreviously such classes were incorrectly treated as non-nested, were\r\nincorrectly put into an enclosing package rather than an enclosing class,\r\nand had their names trimmed in the process, leading to situations when\r\na package has multiple declarations with the same name. This is now fixed.\r\n\r\nWhen changing the check, we need to be careful with interpretation of\r\nwhat Class.getEnclosingXXX methods return. If getEnclosingClass produces\r\na non-null result, this doesn't mean that the class is inner or nested,\r\nbecause getEnclosingClass is also not null for local classes (the ones\r\nwith getEnclosingMethod != null || getEnclosingConstructor != null).\r\nThis is expressed in the order of pattern match clauses in `sOwner`.\r\n\r\nNow when the bug is fixed, I also revert b18a2f8798b2, restoring a very\r\nimportant integrity check in runtime reflection, which I had to disable\r\na couple hours ago to fix a master breakage. More details at scala-internals:\r\nhttps://groups.google.com/forum/#!topic/scala-internals/hcnUFk75MgQ"
3056,'paulp','hotfix for runtime reflection on java7\n'
3054,'retronym','macro constructors\nreview @retronym'
3050,'adriaanm','Ant labour: osgi uptodate checking and better doc skipping \n'
3046,'gkossakowski','Make parameters to implicit value classes private\nSo that they aren\'t offered as an autocomplete suggestion:\r\n\r\n    implicit class Shouty(string: String) extends AnyVal {\r\n     def SHOUT_! = string.toUpperCase + "!"\r\n    }\r\n    "". // autocompletion offers `.string` here.\r\n\r\nThe original incarnation of value classes didn\'t allow this sort of\r\nencapsulation, so we either invented goofy names like\r\n`__thingToAdd` or just picked `x` or `self`. But SI-7859 has delivered us the\r\nfreedom to keep the accessor private.\r\n\r\nShould we keep any of these accessors around in a deprecated form?\r\n\r\nThe implicit classes in Predef were added in 2.11.0-M2\r\n(c26a8db067e4f), so they are okay.\r\n\r\nI think we can make reason that these APIs were both accidental and unlikely\r\nto be interpreted as public, so we can break them immediately.\r\n\r\n    scala> Left(1).x\r\n    res0: scala.util.Either[Int,Int] = Left(1)\r\n    \r\n    scala> import concurrent.duration._\r\n    import concurrent.duration._\r\n    \r\n    scala> 1.n\r\n    res1: Int = 1'
3042,'retronym','SI-7634 resurrect the REPL\'s :sh command\nProcessResult had a companion object in 2.10 that somehow disappeared in\r\n2.11. It only called "new ProcessResult(...)", so the REPL might just as\r\nwell do that.\r\n\r\n---\r\nThis regression happened because `:sh` isn\'t tested; but then, I am not sure how to write a test for this that isn\'t platform-dependent.\r\n\r\nReview by @som-snytt'
3037,'retronym',"[resubmit] Experimental Single Abstract Method support (sammy meets world)\n_This is resubmission of #3018 after merge conflict has been resolved._\r\n\r\nUnder `-Xexperimental`, `typedFunction` invokes `synthesizeSAMFunction` when the expected type for the function literal (`pt`) is not the built-in `FunctionN` type of the expected arity, but `pt` does have a SAM with the expected number of arguments.\r\n\r\n`synthesizeSAMFunction` expands the following tree:\r\n\r\n```\r\n{ (p1: T1, ..., pN: TN) => body } : S\r\n```\r\n\r\nto:\r\n\r\n```\r\n{\r\n def apply$body(p1: T1, ..., pN: TN): T = body\r\n\r\n new S { def apply(p1: T1, ..., pN: TN): T = apply$body(p1,..., pN) }\r\n}\r\n```\r\n\r\nThe expansion assumes `S` (the expected type) defines a single abstract method (let's call that method `apply` for simplicity).\r\n\r\n1. If `T` is not fully defined, it is inferred by type checking `def apply$body` without a result type before type checking the block. The method's inferred result type is used instead of `T`. [See test case](https://github.com/adriaanm/scala/blob/67062db57c1abef88e0049dac5d82d4f13375a48/test/files/pos/sammy_poly.scala)\r\n\r\n2. To more easily enforce that `S`'s members are not in scope in `body`, that tree goes to the `apply$body` method that's outside the anonymous subclass of S. (The separate `apply$body` method simplifies the implementation of 1&2.) [See test case](https://github.com/adriaanm/scala/blob/67062db57c1abef88e0049dac5d82d4f13375a48/test/files/pos/sammy_scope.scala)\r\n\r\n3. The following [restrictions](https://github.com/adriaanm/scala/commit/657e85fe2412cdadc5ee9dc348159b32dcdfcba7#diff-2b1bf15b53df94495f7155a69f822adeR727) apply to `S`:\r\n  1. Its primary constructor (if any) must be public, no-args, not overloaded.\r\n  2. S must have exactly one abstract member, its SAM\r\n  3. SAM must take exactly one argument list\r\n  4. SAM must be monomorphic\r\n\r\nWe may later relax these requirements to allow an implicit argument list, both on the constructor and the SAM. Could also let the SAM be polymorphic.\r\n\r\nPS: We'll require `import language.sam` instead of `-Xexperimental`, as soon as the SIP is ready and there are more tests."
3035,'JamesIry','Rewrites the parser stack reduction logic.\nReview by @densh.\r\n'
3030,'adriaanm',"SI-3346 implicit parameters can now guide implicit view inference\nThis simple patch makes it possible for implicit views to benefit from\r\nfundep-guided type inference, eliminating a nasty special case in\r\nimplicit inference.\r\n\r\nHere are the changes that I had to apply to the tests (they exposed\r\nquite a number of interesting questions that I was happy to answer):\r\n\r\n1) neg/t5845.scala now works, so I moved it to pos. That easily makes sense,\r\nbecause the test was just a canary to track previous state of things.\r\n\r\n2) neg/divergent_implicit.scala, neg/t5578.scala and neg/t7519.scala\r\nchanged their messages to less informative ones, because inapplicable\r\nimplicit views now get disqualified early and therefore don't display\r\ntheir error messages to the user. This is an unfortunate but necessary\r\nbyproduct of this change, and one can argue that the behavior is now\r\ncompletely consistent with implicit vals (that also don't explain why\r\nthis or that implicit val got disqualified, but rather display a generic\r\nimplicit value not found message).\r\n\r\n3) scaladoc/implicits-chaining.scala and scaladoc/implicits-base.scala.\r\nImmediate culling of apriori inapplicable implicit views messes things up\r\nfor Scaladoc, because it's interested in potentially applicable views,\r\nhaving infrastructure to track various constraints (type bounds, requirements\r\nfor implicit parameters, etc) that guide applicability of views and then\r\npresent it to the user. Therefore, when scaladoc is detected, implicit search\r\nreverts to the old behavior.\r\n\r\n4) We still cannot have Jason's workaround to type constructor inference\r\nmentioned in comments to SI-3346, because it's not really about implicit\r\nparameters of implicit views, but about type inference flowing from the\r\nimplicit parameter list to a preceding parameter list in order to affect\r\ninference of an implicit view. This is something that's still too ambitious."
3029,'retronym','reflection sync\nreview @retronym @adriaanm\r\n\r\nalso see https://docs.google.com/document/d/1GmHRmqahh1tTH_GOPsRlnGVRAFPe-x0iCu3BNMNXjf0/edit'
3025,'adriaanm',"SI-7902 Fix spurious kind error due to an unitialized symbol\nTracked down this error:\r\n\r\n    <none> is invariant, but type Y2 is declared covariant\r\n    <none>'s bounds<notype> are stricter than type X2's declared bounds >:\r\n    Nothing <: Any, <none>'s bounds<notype> are stricter than type Y2's declared\r\n    bounds >: Nothing <: Any\r\n\r\nto `Symbol#typeParams` returning `List(NoSymbol)` if the symbol was not\r\ninitialized.\r\n\r\nThis happends in the enclosed test for:\r\n\r\n    // checkKindBoundsHK()\r\n    hkArgs   = List(type M3)\r\n    hkParams = List(type M2)\r\n\r\nThis commit forces the symbol of the higher-kinded type argument before\r\nchecking kind conformance.\r\n\r\nA little backstory:\r\n\r\nThe `List(NoSymbol)` arises from:\r\n\r\n    class PolyTypeCompleter... {\r\n    // @M. If `owner` is an abstract type member, `typeParams` are all NoSymbol (see comment in `completerOf`),\r\n    // otherwise, the non-skolemized (external) type parameter symbols\r\n    override val typeParams = tparams map (_.symbol)\r\n\r\nThe variation that triggers this problem gets into the kind conformance checks\r\nquite early on, during naming of:\r\n\r\n    private[this] val x = ofType[InSeq]\r\n\r\nThe inferred type of which is forced during:\r\n\r\n    def addDerivedTrees(typer: Typer, stat: Tree): List[Tree] = stat match {\r\n     case vd @ ValDef(mods, name, tpt, rhs) if !noFinishGetterSetter(vd) =>\r\n       // If we don't save the annotations, they seem to wander off.\r\n       val annotations = stat.symbol.initialize.annotations\r\n\r\nReview by @adriaanm "
3024,'paulp','SI-7895 Error reporting: avoid cascading, truncation\n - Enter error symbols for pattern binders in erroneous constructor patterns.\r\n - issue all errors, rather than just the first, when coming out of the Cone of Silence (aka `Typer#silent`)\r\n - typecheck args with `pt = ErrorType` even if the function is erroneous\r\n - avoid cascading errors in `(x => 0): ErrorType`.\r\n\r\nIn total:\r\n\r\n```\r\n% scalac-hash v2.11.0-M5 sandbox/test.scala\r\n[info] v2.11.0-M5 => /Users/jason/usr/scala-v2.11.0-M5-0-gd6fe890\r\nsandbox/test.scala:2: error: not found: value bong\r\n  def booboo = bong + booble + bippity\r\n               ^\r\nsandbox/test.scala:3: error: not found: value Tuple\r\n  Tuple(wizzle, (x, y) => (x, wozzle))\r\n  ^\r\nsandbox/test.scala:5: error: not found: value Shmist\r\n    case Shmist(a, b) => a :: b :: Nil\r\n         ^\r\nsandbox/test.scala:5: error: not found: value a\r\n    case Shmist(a, b) => a :: b :: Nil\r\n                         ^\r\nsandbox/test.scala:5: error: not found: value b\r\n    case Shmist(a, b) => a :: b :: Nil\r\n                              ^\r\nsandbox/test.scala:6: error: not found: value Goop\r\n    case Goop(a)   => s"$a $b"\r\n         ^\r\nsandbox/test.scala:6: error: not found: value a\r\n    case Goop(a)   => s"$a $b"\r\n                         ^\r\n7 errors found\r\n\r\n% qbin/scalac sandbox/test.scala\r\nsandbox/test.scala:2: error: not found: value bong\r\n  def booboo = bong + booble + bippity\r\n               ^\r\nsandbox/test.scala:2: error: not found: value booble\r\n  def booboo = bong + booble + bippity\r\n                      ^\r\nsandbox/test.scala:2: error: not found: value bippity\r\n  def booboo = bong + booble + bippity\r\n                               ^\r\nsandbox/test.scala:3: error: not found: value Tuple\r\n  Tuple(wizzle, (x, y) => (x, wozzle))\r\n  ^\r\nsandbox/test.scala:3: error: not found: value wizzle\r\n  Tuple(wizzle, (x, y) => (x, wozzle))\r\n        ^\r\nsandbox/test.scala:3: error: not found: value wozzle\r\n  Tuple(wizzle, (x, y) => (x, wozzle))\r\n                              ^\r\nsandbox/test.scala:5: error: not found: value Shmist\r\n    case Shmist(a, b) => a :: b :: Nil\r\n         ^\r\nsandbox/test.scala:6: error: not found: value Goop\r\n    case Goop(a)   => s"$a $b"\r\n         ^\r\nsandbox/test.scala:6: error: not found: value b\r\n    case Goop(a)   => s"$a $b"\r\n                            ^\r\n9 errors found\r\n```\r\n\r\nReview by @paulp'
3023,'adriaanm',"SI-7901 Bump module versions.\nUpgrade to the latest releases of modules. This fixes OSGi\r\nclients, since previous module releases don't have correct\r\nMANIFEST files.\r\n\r\nFor consistency, I bumped the partest version as well."
3022,'adriaanm',"SI-7899 Don't infer by-name types during, e.g. eta-expansion\nGiven:\r\n\r\n    def id[A](a: A): A = a\r\n    def foo(f: (=> Int) => Int) = ()\r\n    foo(id)\r\n\r\nWe eta-expanded `id` and inferred `A` to be `=> Int` to satisfy the\r\nexpected type set forth by the formal parameter `f`.\r\n\r\nWe really shouldn't go about inferring types that we can't *write*.\r\nOur attempt to do so led promptly into a `ClassCastException` in the\r\nenclosed test.\r\n\r\nThis commit:\r\n\r\n  - drops by-name-ness during `inferExprInstance`\r\n  - tests that this results in a type error for the reported bug\r\n    (neg/t7899)\r\n  - tests that a method with a by-name parameter can still be\r\n    eta expanded to match function with a corresponding by-name\r\n    parameter (run/t7899)\r\n  - discovers the same latent CCE in pos/t7584\r\n     - now that would be a type error\r\n     - so we compensate by using placeholder functions rather than\r\n       eta-expansion.\r\n     - and move that that test to `run` for good measure.\r\n\r\nReview by @adriaanm.\r\n\r\n  - what about other uses of `inferExprInstance`\r\n  - can you suggest a test case to exercise `adjustTypeArgs(tparams, tvars, targsStrict)`, which isn't covered."
3006,'JamesIry',"SI-7883 - don't iterate over all keys in MapWrapper.containsKey()\nThis commit fixes SI-7883. I've checked that the new test fails without the changes in Wrappers.scala and passes with them."
3001,'adriaanm','blackbox and whitebox macros\nDocumentation: http://docs.scala-lang.org/overviews/macros/blackbox-whitebox.html\r\nDepends on: https://github.com/scala/scala/pull/2994. \r\nReview: @retronym @adriaanm'
2997,'adriaanm',"Merge 2.10.x to master\nThe conflicts were trivial.\r\n\r\nI manually reverted the `[nomaster] SI-7862: MANIFEST.MF file for Scala sources` during conflict resolution in build.xml (it was a backport), rather than merging in steps with `-Sours` as I usually do.\r\n\r\nSimilarly, `cb4b8eb update typesafe.artifactory-online.com to private-repo` was a trivial backport and git handled the merge as a no-op.\r\n\r\nReview by @adriaanm\r\n\r\n```\r\n% export MB=`git merge-base origin/2.10.x master`\r\n\r\n% git log --graph --oneline $MB...origin/2.10.x\r\n*   9f62900 Merge pull request #2983 from retronym/merge/2.10.3-to-2.10.x\r\n|\\\r\n| *   96a70e3 Merge remote-tracking branch 'origin/2.10.3' into merge/2.10.3-to-2.10.x\r\n| |\\\r\n|/ /\r\n| *   e2fec6b Merge pull request #2976 from retronym/backport/7862\r\n| |\\\r\n| | * 8e11dcb [nomaster] SI-7862: MANIFEST.MF file for Scala sources\r\n| |/\r\n| *   892aa93 Merge pull request #2969 from retronym/ticket/7861\r\n| |\\\r\n| | * 7f4b44b SI-7861 Don't execute internal callbacks on the user Executor\r\n| |/\r\n| *   e176a10 Merge pull request #2906 from retronym/merge/2.10.x-to-2.10.3\r\n| |\\\r\n| | *   d5ce3de Merge remote-tracking branch 'origin/2.10.x' into merge/2.10.x-to-2.10.\r\n| | |\\\r\n| | * | f4ccefe Merge remote-tracking branch 'origin/2.10.x' into merge/2.10.x-to-2.10.\r\n| |/ /\r\n| * | 502b9f0 Merge pull request #2878 from JamesIry/2.10.3\r\n| * | 682cf97 Merge branch '2.10.2' into 2.10.3\r\n|  /\r\n* |   f0ca5ae Merge pull request #2919 from retronym/ticket/7815\r\n|\\ \\\r\n| |/\r\n|/|\r\n| * 733b322 SI-7815 Dealias before deeming method type as dependent\r\n*   43dcfd0 Merge pull request #2893 from adriaanm/backport-2880-2.10.x\r\n|\\\r\n| * cb4b8eb update typesafe.artifactory-online.com to private-repo\r\n*   d3c8c4b Merge pull request #2882 from adriaanm/license-cleanup-2.10.x\r\n|\\\r\n| * bf93057 Change Scala license to unmodified 3-clause BSD.\r\n* c711828 Merge pull request #2923 from retronym/ticket/7825\r\n* a1796aa SI-7398 Enable test for Java 8 source parser under Java 8\r\n* bf0f9da SI-7825 Consider DEFAULTMETHOD when refchecking concreteness\r\n\r\n% git merge origin/2.10.x\r\nAuto-merging src/reflect/scala/reflect/internal/Types.scala\r\nCONFLICT (content): Merge conflict in src/reflect/scala/reflect/internal/Types.scala\r\nAuto-merging src/reflect/scala/reflect/internal/HasFlags.scala\r\nAuto-merging src/library/scala/concurrent/Future.scala\r\nCONFLICT (content): Merge conflict in src/library/scala/concurrent/Future.scala\r\nAuto-merging src/compiler/scala/tools/nsc/typechecker/RefChecks.scala\r\nCONFLICT (content): Merge conflict in src/compiler/scala/tools/nsc/typechecker/RefChecks.scala\r\nAuto-merging build.xml\r\nCONFLICT (content): Merge conflict in build.xml\r\nCONFLICT (modify/delete): bincompat-forward.whitelist.conf deleted in HEAD and modified in origin/2.10.x. Version origin/2.10.x of bincompat-forward.whitelist.conf left in tree.\r\nCONFLICT (modify/delete): bincompat-backward.whitelist.conf deleted in HEAD and modified in origin/2.10.x. Version origin/2.10.x of bincompat-backward.whitelist.conf left in tree.\r\nwarning: inexact rename detection was skipped due to too many files.\r\nwarning: you may want to set your merge.renamelimit variable to at least 1476 and retry the command.\r\nAutomatic merge failed; fix conflicts and then commit the result.\r\n```"
2993,'retronym','[master] assorted fixes for vampire macros\nRebased version of https://github.com/scala/scala/pull/2902'
2991,'retronym',"transformers no longer ignore UnApply.fun\nSecond time's the charm. I remember trying to do exactly the same somewhen\r\naround 2.10.0-M4, but then some continuations tests were failing.\r\nLuckily, today everything went smoothly.\r\n\r\nPlease note that this fix changes the way that SI-5465 manifests itself.\r\nPreviously it produced type errors, now it simply crashes the compiler.\r\nTherefore I had to attach the try/catch FatalError clause to invocations\r\nof toolbox methods, so that compiler crashes get caught and translated to\r\nToolBoxErrors.\r\n\r\nAlso fixes SI-7871, and that clears the way for implementing quasiquotes\r\nwith conventional macros rather than relying on a special case in typer."
2986,'adriaanm',"SI-6493 Fix existential type used to hide local classes\nIn:\r\n\r\n    def foo = { object O { class C }; new O.C }\r\n\r\nThe inferred return type of can't refer to the local\r\nsymbols; they must not leak out of the compilation unit.\r\n\r\nInstead, `packSymbols` is used to choose a less precise\r\nexistential type, `(AnyRef { type C <: AnyRef })#C)`.\r\n\r\nThis is implemented as a `TypeMap`, which is supposed to\r\ntakes care of rebinding `C` to something valid in the new\r\nprefix (`(AnyRef { type C <: AnyRef })`).\r\n\r\nIf `C` was orginally a type alias, and the original\r\nprefix was a refinement type, this was handled in\r\n`AliasTypeRef#coevolveSym`, which looks for a type\r\nin the new prefix with the name `C`. But for other\r\ntype refs (e.g. a class type ref, as in this case),\r\na no-op `coevolveSym` was used, deferring the rebinding\r\nof abstract classes until `typeRef`.\r\n\r\nBut our case falls between the cracks, and we end up\r\npropagating a type ref in which the prefix does not\r\ncontain the member.\r\n\r\nWith the help of `-uniqid`, this is clear:\r\n\r\n    <method> def foo#7445(): scala#21.this.AnyRef#2222{type Bar#12153 <: scala#21.this.AnyRef#2222}#Bar#12125\r\n\r\nNotice the reference to symbol `#12125`, rather than `#12153`.\r\n\r\nThis commit moves the `coevolveSym` logic up to `TypeRef`,\r\ngeneralizing it to work for any `pre1`. This example answered\r\nthe question in that code:\r\n\r\n> // TODO: is there another way a typeref's symbol can refer to a symbol defined in its pre?\r\n\r\nReview by @adriaanm. Found this patch in a dusty corner."
2985,'adriaanm',"SI-7783 Don't issue deprecation warnings for inferred TypeTrees\nDeprecation checks in RefChecks were looking into all TypeTrees\r\nto find references to deprecated type aliases. However, when the\r\ncompiler infers a type argument or type of a member it creates\r\na TypeTree (with a null original) that was also leading to warnings.\r\n\r\nI ran into this problem often when upgrading a build from SBT 0.12\r\nto 0.13: a plugin I was using used the deprecated type alias, and I\r\nsuffered transitively when I used methods from its API.\r\n\r\nThis commit disables the checks for inferred TypeTree-s.\r\n\r\nDiscussion: https://groups.google.com/d/msg/scala-internals/3nf9-X6Yfe4/yNiPl1foK6sJ\r\n"
2982,'adriaanm','SI-4742 Make -Xcheckinit aware of constants.\nMembers defined as `final val x = <literal>` are given\r\na ConstantType. The constant is folded into the accessor\r\nmethod `x`, and the field itself is never initialized.\r\n(Related discussion: SI-4605)\r\n\r\nAs such, -Xcheckinit spuriously warns when calling that\r\naccessor.\r\n\r\nThis commit disables the checks for constants.\r\n\r\nThis will also fix the checkinit build (failure tracked as SI-7839),\r\nwhich is the victim of this a spurious scolding.\r\n\r\nReview by @adriaanm'
2975,'adriaanm','SI-7868 Account for numeric widening in match translation\nPattern match translation was unprepared for trees of the shape:\r\n\r\n    (0: Short) match {\r\n      case A.unapply(<unapply-selector>.toInt) <unapply> (_) => ()\r\n      case _ => ()\r\n    }\r\n\r\nWhile a scrutinee is inelibigle for implicit views in order to\r\nconform to the type of the extractor call, it is allowed to\r\nweakly conform. In this case, the typechecker will add the\r\nnumeric widening with a `toInt` call.\r\n\r\nThis commit:\r\n\r\n - Changes treeInfo.Unapplied to recognize this tree shape\r\n - Changes spliceApply to recognize and preserve the widening\r\n   when substituting the unapply selector with the binder\r\n - Tests reification of such pattern matches, which also depends\r\n   on treeInfo.Unapplied.\r\n\r\nReview by @adriaanm'
2974,'paulp','SI-7864 Harden "looks like an interpolated String" warning\nWe can\'t rely on the qualifier of an `Apply` having a non-null\r\nsymbol in general.\r\n\r\nReview by @paulp'
2966,'retronym','Remove partiality of `+` method from SortedMap\n`SortedMap#+` threw an `AbstractMethodError` if it was not overridden. It should instead be a compile error.'
2965,'gkossakowski',"SI-7859 Value classes may wrap a non-public member\nWe allow value class constructors to be non-public, so to be regular,\r\nwe should also allow the same for the param accessor.\r\n\r\nThis commit uses the 'makeNotPrivate' machinery to ensure that\r\nthe backend can generate the requisite unboxing calls.\r\n\r\nThis commit:\r\n\r\n  - refactors the code that enforced the restrictions, improving\r\n    a few error messages and positions. The remaining restrictions\r\n    needed some rewording in light of this change.\r\n  - allows value classes to have non-public, val parameters.\r\n    private[this] / protected[this] are still disallowed as value\r\n    classes don't have a concept of `this`, and because trying to\r\n    accomdate then would complicate the implementation.\r\n\r\n    This means that `class C(x: Int) extends AnyVal` is not allowed,\r\n    the user still must write `private val x: Int` or `val x: Int`.\r\n  - Outlaw `class C()()(val x: Int) extends AnyVal` to curtail any\r\n    bugs that might lurk in such a formulation.\r\n\r\nThe tests:\r\n\r\n  - Show that the privacy is respected in the typer phase, under\r\n    joint and separate compilation. We don't want a repeat performance\r\n    of SI-6601.\r\n  - Show that code that needs compiler-generated unboxes works under\r\n    both compilation scenarios\r\n  - Checks that the remaining restrictions are enforced and well\r\n    communicated.\r\n\r\nReview by @gkossakowski"
2963,'gkossakowski',"Small refactorings giving hooks for Scala.js\nI have reviewed the ugliest parts of Scala.js, where I need to circumvent the lack of appropriate hooks in scalac, and I came up with these three small refactorings.\r\n\r\nEach one of these has its corresponding simplifying commit in Scala.js, in the following comparison:\r\nhttps://github.com/sjrd/scala-js/compare/scala-2.11...topic/what-if-scalac-was-nicer-to-us\r\n(in the same order).\r\n\r\nThere is no test accompanying this pull request, because there is absolutely no functionality change (it's only refactoring) and I don't quite see how to test that with partest. I'll be glad to add tests if someone can hint at me how.\r\n\r\n(In case you care:) Incidentally, these hooks are the only ones on which Scala.js relies, in addition to being able to manipulate the phase set. Which means that *if* they were (experimentally) overridable by plugins, then Scala.js could be implemented as a plugin, which would bring lots of advantages in terms of integration with our various tools (sbt and IDE mainly).\r\n\r\n(There are still two files with a non-negligible amount of code duplication in Scala.js, [JSSymbolLoaders.scala](https://github.com/sjrd/scala-js/blob/topic/what-if-scalac-was-nicer-to-us/compiler/src/main/scala/scala/tools/nsc/scalajs/JSSymbolLoaders.scala) and [JSTypefileParser.scala](https://github.com/sjrd/scala-js/blob/topic/what-if-scalac-was-nicer-to-us/compiler/src/main/scala/scala/tools/nsc/scalajs/JSTypefileParser.scala), but a proper fix to these two would require much bigger refactorings in scalac; and I don't care so much about these because they are not specifically the hooks I am relying on.)"
2954,'gkossakowski','Avoid null checks when emitting "".== and SomeModule.==\nAlthough the same the code would be later optimized by -Yconst-opt,\r\nwe can offer the same lean byte code to those compiling without that\r\noption by being more discerning when translating ==.\r\n\r\nThis helps people using bytecode based code coverage tools\r\nsuch as jacoco that would emit "branch not covered" warnings\r\nfor the impossible null check.\r\n\r\nBefore:\r\n```\r\nscala> class C { (null: Any) match { case Nil => case "" => case _ => } }\r\ndefined class C\r\n\r\nscala> :javap C\r\n\r\npublic C();\r\n  Code:\r\n   Stack=2, Locals=5, Args_size=1\r\n   0:\taload_0\r\n   1:\tinvokespecial\t#9; //Method java/lang/Object."<init>":()V\r\n   4:\taconst_null\r\n   5:\tastore_1\r\n   6:\tgetstatic\t#15; //Field scala/collection/immutable/Nil$.MODULE$:Lscala/collection/immutable/Nil$;\r\n   9:\taload_1\r\n   10:\tastore_2\r\n   11:\tdup\r\n   12:\tifnonnull\t23\r\n   15:\tpop\r\n   16:\taload_2\r\n   17:\tifnull\t30\r\n   20:\tgoto\t37\r\n   23:\taload_2\r\n   24:\tinvokevirtual\t#19; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z\r\n   27:\tifeq\t37\r\n   30:\tgetstatic\t#25; //Field scala/runtime/BoxedUnit.UNIT:Lscala/runtime/BoxedUnit;\r\n   33:\tastore_3\r\n   34:\tgoto\t74\r\n   37:\tldc\t#27; //String\r\n   39:\taload_1\r\n   40:\tastore\t4\r\n   42:\tdup\r\n   43:\tifnonnull\t55\r\n   46:\tpop\r\n   47:\taload\t4\r\n   49:\tifnull\t63\r\n   52:\tgoto\t70\r\n   55:\taload\t4\r\n   57:\tinvokevirtual\t#19; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z\r\n   60:\tifeq\t70\r\n   63:\tgetstatic\t#25; //Field scala/runtime/BoxedUnit.UNIT:Lscala/runtime/BoxedUnit;\r\n   66:\tastore_3\r\n   67:\tgoto\t74\r\n   70:\tgetstatic\t#25; //Field scala/runtime/BoxedUnit.UNIT:Lscala/runtime/BoxedUnit;\r\n   73:\tastore_3\r\n   74:\treturn\r\n  LocalVariableTable:\r\n   Start  Length  Slot  Name   Signature\r\n```\r\n\r\nAfter:\r\n```\r\npublic C();\r\n  Code:\r\n   Stack=2, Locals=3, Args_size=1\r\n   0:\taload_0\r\n   1:\tinvokespecial\t#9; //Method java/lang/Object."<init>":()V\r\n   4:\taconst_null\r\n   5:\tastore_1\r\n   6:\tgetstatic\t#15; //Field scala/collection/immutable/Nil$.MODULE$:Lscala/collection/immutable/Nil$;\r\n   9:\taload_1\r\n   10:\tinvokevirtual\t#19; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z\r\n   13:\tifeq\t23\r\n   16:\tgetstatic\t#25; //Field scala/runtime/BoxedUnit.UNIT:Lscala/runtime/BoxedUnit;\r\n   19:\tastore_2\r\n   20:\tgoto\t43\r\n   23:\tldc\t#27; //String\r\n   25:\taload_1\r\n   26:\tinvokevirtual\t#19; //Method java/lang/Object.equals:(Ljava/lang/Object;)Z\r\n   29:\tifeq\t39\r\n   32:\tgetstatic\t#25; //Field scala/runtime/BoxedUnit.UNIT:Lscala/runtime/BoxedUnit;\r\n   35:\tastore_2\r\n   36:\tgoto\t43\r\n   39:\tgetstatic\t#25; //Field scala/runtime/BoxedUnit.UNIT:Lscala/runtime/BoxedUnit;\r\n   42:\tastore_2\r\n   43:\treturn\r\n```\r\n\r\nReview by @gkossakowski or @JamesIry, /cc @dragos'
2951,'gkossakowski',"SI-7847 Static forwarders for case apply/unapply\nThese were excluded in f901816b3f because at the time they\r\nwere compiler fiction and translated to calls to the case\r\nclass constructor or accessors.\r\n\r\nBut since they are now bona-fide methods (albeit still occasionally\r\nbypassed as an optimization), we can expose them conveniently to our\r\nJava brethren.\r\n\r\nThe cut-and-pastiness of GenBCode starts to hinder maintenance.\r\nHere's a report of further duplication that we have to fix up\r\npost haste: https://gist.github.com/retronym/6334389\r\n\r\nReview by @gkossakowski"
2950,'gkossakowski','Damage control related to AnyRef specialization\n - Remove its use from `AbstractPartialFunction`\r\n - Reject `Name`-s with negative length or offset.\r\n - Harden and test `unspecializedName` / `splitSpecializedName`\r\n\r\nI stop short of removing this facility altogether. When we do, we should remember to touch the group `Specialized.All`.\r\n\r\nReview by @gkossakowski '
2939,'gkossakowski',"Deprecate -Yinfer-debug\nSince 4d6be05c2 it has been ignored, being subsumed by -Ytyper-debug.\r\n\r\nThis commit makes it an deprecated alias for -Ytyper-debug.\r\n\r\nWe'd be within our rights to remove it outright, but we've got\r\na nice deprecation mechanism for settings, so let's use that for\r\na release.\r\n\r\nReview by @gkossakowski"
2928,'gkossakowski',"merge 2.10.x to master\n... and a bonus commit: improve to the way partest-extras is built.\r\n\r\nOnly one conflict, which was in `ExtensionMethods` and was trivial to resolve.\r\n\r\n```\r\n% git log --graph --oneline `git merge-base master origin/2.10.x`...origin/2.10.x\r\n*   1015d12 Merge pull request #2916 from retronym/ticket/7818\r\n|\\\r\n| * cb028ba SI-7818 Cast our way out of extended existential angst\r\n*   7ecffb0 Merge pull request #2922 from huitseeker/issue/7767\r\n|\\\r\n| *   aa1bff8 Merge pull request #1 from retronym/ticket/7767-test\r\n| |\\\r\n| | * 2391887 SI-7767 Test case for Scaladoc on early initializers\r\n| |/\r\n| * 48283ca SI-7767 avoid rejecting Scaladoc comments in early initializers\r\n* |   6c431e6 Merge pull request #2866 from retronym/ticket/7269\r\n|\\ \\\r\n| * | fe9a3e9 SI-7269 Rework MapLike#retains to account for desugaring change\r\n|  /\r\n* |   d1cff20 Merge pull request #2911 from retronym/ticket/7814\r\n|\\ \\\r\n| |/\r\n|/|\r\n| * a19babc SI-7814 Updates the instrumented version of ScalaRuntime.\r\n| * fb43ec8 SI-7814 Avoid init cycle between Predef, `package`, ScalaRuntime\r\n* 7fa0e60 Merge pull request #2895 from som-snytt/issue/7652-tools-jar-backport\r\n* 7804cec [nomaster] SI-7652 REPL extended quest for tools\r\n* 8b10daf [nomaster] SI-7652 Bad tools fails loudly\r\n\r\n% /code/scala git merge -s ours 7fa0e60 --edit\r\nMerge made by the 'ours' strategy.\r\n\r\n% git merge origin/2.10.x\r\n```\r\n\r\nReview by @gkossakowski"
2925,'paulp',"Avoid needless Type stringification when logging is disabled.\nSince 4d6be05c28, we've been a tad wasteful in implicit searches.\r\n\r\nThis adds a by-name parameter to the local logging method to\r\navoid that.\r\n\r\nReview by @paulp"
2923,'gkossakowski',"SI-7825 Consider DEFAULTMETHOD when refchecking concreteness\nA class should not be required to implement a Java default method.\r\n\r\nThis commit uses `isDeferredNotDefault` in place of `isDeferred`\r\nwhen finding unimplemented methods.\r\n\r\nThe test itself does not depend on Java 8 as we use scalac's\r\nJava source parser to set things up.\r\n\r\nReview by @gkossakowski"
2919,'adriaanm',"SI-7815 Dealias before deeming method type as dependent\nTo enable eta-expansion of method types seen from a prefix that\r\nrenders the result type as independent from the parameter symbols.\r\n\r\nThe enclosed test shows that we dealias types before checking\r\ndependence, and that we do this deeply (e.g. type arguments are\r\nalso dealised.)\r\n\r\nAn existing test, neg/error_dependentMethodTpeConversionToFunction,\r\nconfirms that bona-fide dependent methods are still prohibited from\r\neta expansion.\r\n\r\nReview by @adriaanm. I think this is sufficiently localised and easy enough for us to reason about to consider inclusion in 2.10.4, but if you prefer I'll retarget at master."
2918,'adriaanm',"SI-7815 Dealias before deeming method type as dependent\nTo enable eta-expansion of method types seen from a prefix that\r\nrenders the result type as independent from the parameter symbols.\r\n\r\nThe enclosed test shows that we dealias types before checking\r\ndependence, and that we do this deeply (e.g. type arguments are\r\nalso dealised.)\r\n\r\nAn existing test, neg/error_dependentMethodTpeConversionToFunction,\r\nconfirms that bona-fide dependent methods are still prohibited from\r\neta expansion.\r\n\r\nReview by @adriaanm. I think this is sufficiently localised and easy enough for us to reason about to consider inclusion in 2.10.4, but if you prefer I'll retarget at master."
2916,'adriaanm','SI-7818 Cast our way out of extended existential angst\n`substituteSymbols` is not sophisticated enough to\r\noperate on `TypeSkolem`-s which are based on one of the\r\n"from" symbols.\r\n\r\nThe pertinant usage of `substituteSymbols` for this bug in\r\nin `Extender`. Recapping on that transform:\r\n\r\n    // orig\r\n    class C[T](...) extends AnyVal { def foo[U] = <rhs> }\r\n\r\n    // transform\r\n    class C[T] extends AnyVal { ... }\r\n    object C  { def foo$extension[T\', U\'] = <rhs\'> }\r\n\r\nWhere `<rhs\'>` has been subtituted with, among other things,\r\n`[T, U] ~> [T\', U\']`.\r\n\r\nIn this case our expected type contains a new type parameter\r\n(of the extension method), whereas the type of the RHS contains\r\nan existential skolem still pinned to the corresponding class type\r\nparameter.\r\n\r\n    tree.tpe         = Observable1#7037[_$1#12344]\r\n    <_$1#12344>.info =  <: T#7040\r\n    pt               = Observable1#7037[T#15644]\r\n\r\nThe limitation of substution is lamented in the comments\r\nof `adaptMismatchedSkolems`, which faces the harder version of\r\nthe issue where the skolems are in the expected type.\r\n\r\nBut, we\'re in the "easy" case with the skolems in the tree\'s type;\r\nwe can cast our way out of the problem.\r\n\r\nReview by @adriaanm, /cc @odersky'
2912,'adriaanm','SI-7643 Enable newPatternMatching in interactive.\nWithout it, the enclosed test fails with:\r\n\r\n    ArrayBuffer(Problem(RangePosition(partial-fun/src/PartialFun.scala, 62, 62, 77),type mismatch;\r\n     found   : Int => Int\r\n     required: PartialFunction[Int,Int],2))\r\n\r\nAnd with that, we can remove this option altogether.\r\n\r\nReview by @adriaanm'
2911,'paulp',"SI-7814 Avoid init cycle between Predef, `package`, ScalaRuntime\nNot every application will force these in a single thread; we\r\nhave to do our best to avoid cycles between them.\r\n\r\nThe enclosed test was failing every time before the change.\r\n\r\nThis commit breaks the cycle by avoiding computing `tupleNames`\r\nin the constructor of `ScalaRuntime`. The new version has the\r\nadded benefit of including specialized tuple subclasses, which\r\nis verified with a unit test for `isTuple`.\r\n\r\nAre there more of these lurking? It seems likely. I'm more than\r\na little concerned about the way the `ControlThrowable` fires up\r\n`scala.SystemProperties` to check whether or not to suppress\r\nstack traces; there is already an ugly hack in place:\r\n\r\n    object NoStackTrace {\r\n      final def noSuppression = _noSuppression\r\n\r\n      // two-stage init to make checkinit happy,\r\n      // since sys.SystemProperties.noTraceSupression.value\r\n      // calls back into NoStackTrace.noSuppression\r\n      final private var _noSuppression = false\r\n      _noSuppression = sys.SystemProperties.noTraceSupression.value\r\n    }\r\n\r\nReview by @paulp"
2910,'retronym',"Various bugfixes and improvements for the quasiquotes\nFixes the following bugs:\r\n\r\n* [SI-7196 type quasiquotes don't [fully] support type refinement inclusion](https://issues.scala-lang.org/browse/SI-7196)\r\n* [SI-7803 matching function literals with quasiquotes doesn't work](https://issues.scala-lang.org/browse/SI-7803)\r\n* [SI-7723 [..$tparams] in an anonymous class pattern doesn't match an anonymous class](https://issues.scala-lang.org/browse/SI-7723)\r\n\r\nImproves handling of the following language constructs:\r\n\r\n* new expressions \r\n* special handling of early definitions for classes, traits and objects\r\n* automatic setting of the flags appropriate for function and class parameters\r\n* better handling of class/case class/trait parents\r\n* valdefs and vardefs\r\n* type refinement\r\n* better support for handling of annotations \r\n* function types and literals\r\n* changes semantics of blocks, applied and typeapplied splicing and extraction\r\n\r\nAnd lastly:\r\n* makes the annoying postfixOps warning go away\r\n\r\nReview by @retronym \r\n\r\n[Some discussion on the previous version of the pr.](https://github.com/scala/scala/pull/2898)"
2897,'paulp','[backport] Commit .gitignore directly\nRather than relying on the cloner to copy the\r\nprovided gitignore.SAMPLE files.\r\n\r\nThis finishes the job started in c48509598, mostly\r\nby reverting that commit and moving the two existing\r\nSAMPLE files to the final destinations.\r\n\r\nUse `.git/info/exclude` to augment the list of patterns\r\nwith entries specific to your workflow.\r\n(cherry picked from commit b51cb581270da7021b2ea122dc059847101d56a7)\r\n\r\n==============================================\r\nParing back the scope of our shared .gitignore\r\n\r\nImportantly, limit the exclusion of build.properties\r\nto the file in the root directory, paving the way for\r\nthe return of an SBT build.\r\n\r\n  - Unignores .bak, .jar, and ~\r\n  - limit ignorance of qbin to the root directory\r\n\r\n.log files, generated by partest, are still ignored.\r\n\r\nTo see ignored files in your workspace, try:\r\n\r\n    git ls-files --others --ignored --exclude-standard -- test | grep log\r\n    git status --ignored -- test\r\n(cherry picked from commit f0bbd2ca32acb40be37dc382c1f95081deca3f22)'
2894,'adriaanm','Superior type inference\nThere are some long commit messages - I refer you to those. Review by @retronym, @adriaanm.'
2892,'JamesIry',"SI-7779 Account for class name compactification in reflection\nWe have to assume that the classes we are reflecting on were\r\ncompiled with the default value for -Xmax-classfile-name (255).\r\n\r\nWith this assumption, we can apply the same name compactification\r\nas done in the regular compiler.\r\n\r\nThe REPL is particularly prone to generating long class names\r\nwith the '$iw' prefixes, so this is an important fix for runtime\r\nreflection.\r\n\r\nAlso adds support for getting the runtime class of `O.type` if\r\n`O` is a module.\r\n\r\n(cherry picked from commit 5dbc37dfbe0e9a039da6744e45012abc3034cdf5)\r\n[backport from 2.10.x to 2.10.3]\r\n\r\nReview by @JamesIry"
2890,'paulp','Paring back the scope of our shared .gitignore\nImportantly, limit the exclusion of build.properties\r\nto the file in the root directory, paving the way for\r\nthe return of an SBT build.\r\n\r\n  - Unignores .bak, .jar, and ~\r\n  - limit ignorance of qbin to the root directory\r\n\r\n.log files, generated by partest, are still ignored.\r\n\r\nTo see ignored files in your workspace, try:\r\n\r\n    git ls-files --others --ignored --exclude-standard -- test | grep log\r\n    git status --ignored -- test\r\n\r\nReview by @paulp'
2889,'gkossakowski',"(2 of 2) of the rest of the new bytecode emitter\nThis PR completes the new bytecode emitter, including building and writing class files in parallel, by building upon https://github.com/scala/scala/pull/2863\r\n\r\nBefore writing class files, a modicum of code tightening transformations are necessary: unreachable code elimination, which in turn calls for cleanup of labels and exception entries made redundant by unreachable code elimination.\r\n\r\nIn this PR, each such transformation is introduced in a commit with tests for the transformation in isolation. Another commit also in this PR tests each such transformation in connection with the bytecode emitter.\r\n\r\nI'll suggest a reviewer once tests pass, comments and reviews welcome."
2885,'retronym','SI-7791 Line number table reflects underlying file\nSince positions ultimately know their ultimate\r\npositions in their ultimate source, use that line\r\nnumber, ultimately, when emitting line number\r\ntable entries.\r\n\r\nIt is possible, but possibly not useful, to emit\r\nboth the actual (ultimate) line number and the\r\nnominal one.\r\n\r\nThe `int`-valued line number of the `StackTraceElement`\r\nis "derived" from the attribute.\r\n\r\nnote: working on clever way to test it.  Since REPL and scripter do the same thing, i.e., wrap some code, it ought to be easy to test them the same way.  The wrapping mechanism is quite different, but maybe this is an opportunity to reconsider that, under the aegis of replating.\r\n\r\nI did see extempore\'s screed from 11/21/11, which you kind of wish had been backdated to 11/11/11:\r\n```\r\nThis is a fresh start for script tests.\r\n```\r\n'
2884,'JamesIry',"SI-1909 SI-3832 SI-7007 SI-7223 Improved handling of larval objects\nReclaims some ground lost in the first swing at SI-6666, and solves a few more issues to boot.\r\n\r\nI'm hopeful that I'll be able to knock off the residuals of SI-6666 too, so I might push one or two more commits.\r\n\r\nReview by @JamesIry"
2879,'adriaanm',"SI-7785 Preserve TypeVar suspension through TypeMaps\nDuring `findMember`, TypeVars in `this` are placed into suspended\r\nanimation. This is to avoid running into recursive types when\r\nmatching members to those in base classes.\r\n\r\nHowever, the mechanism used to do this is superficial, and doesn't\r\nwork when TypeVars are copied by TypeMaps. This seems to crop up\r\nwhen using `AppliedTypeVar` with higher-kinded type vars.\r\n\r\nIn the enclosed test case, the cyclic type led to a SOE in\r\nCommonOwnerMap.\r\n\r\nThis commit allows a TypeVar to delegate its `suspended` attribute\r\nto the TypeVar from which it was copied. This is done in\r\n`TypeVar#applyArgs`, which is called by:\r\n\r\n    // TypeMap#mapOver\r\n    case tv@TypeVar(_, constr) =>\r\n      if (constr.instValid) this(constr.inst)\r\n      else tv.applyArgs(mapOverArgs(tv.typeArgs, tv.params))\r\n\r\nWe should review the other places this is called to make sure\r\nthat it make sense to link in this way:\r\n\r\n    Types#appliedType\r\n    TypeVar#normalize\r\n\r\nReview by @adriaanm.\r\n\r\nEven though this was a regression in 2.10.1, I'm submitting this to 2.11 as the change isn't without risk, and the only reason this worked in 2.10.0 was because of another bug (`TypeVar` had a structural equals.)"
2878,'retronym',"Merge 2.10.2 into 2.10.3\nMerge branch '2.10.2' into 2.10.3\r\n\r\nConflicts:\r\n\tsrc/compiler/scala/tools/nsc/typechecker/NamesDefaults.scala\r\n\r\nThis is the merge that was missed before cutting 2.10.3-RC1\r\n\r\nreview by @retronym "
2877,'retronym','SI-7781 REPL stack trunc shows cause\n    \r\n   \r\nThe handy stack trace truncation in REPL doesn\'t show cause like a regular trace.\r\n    \r\nThis commit fixes that and also adds the usual indicator for truncation, viz, "... 33 more".\r\n    \r\nThe example from the ticket produces:\r\n    \r\n```\r\n    scala> rewrapperer\r\n    java.lang.RuntimeException: java.lang.RuntimeException: java.lang.RuntimeException: Point of failure\r\n      at .rewrapper(<console>:9)\r\n      at .rewrapperer(<console>:10)\r\n      ... 32 elided\r\n    Caused by: java.lang.RuntimeException: java.lang.RuntimeException: Point of failure\r\n      at .wrapper(<console>:8)\r\n      ... 34 more\r\n    Caused by: java.lang.RuntimeException: Point of failure\r\n      at .sample(<console>:7)\r\n      ... 35 more\r\n```\r\n    \r\nSuppressed exceptions on Java 7 are handled reflectively.\r\n    \r\n```\r\n    java.lang.RuntimeException: My problem\r\n      at scala.tools.nsc.util.StackTraceTest.repressed(StackTraceTest.scala:56)\r\n      ... 27 elided\r\n      Suppressed: java.lang.RuntimeException: Point of failure\r\n        at scala.tools.nsc.util.StackTraceTest.sample(StackTraceTest.scala:29)\r\n        at scala.tools.nsc.util.StackTraceTest.repressed(StackTraceTest.scala:54)\r\n        ... 27 more\r\n```\r\n\r\nReview by @qerub\r\n'
2876,'adriaanm','SI-7782 Derive type skolems at the ground level\nRather than at the current value of `skolemizationLevel`,\r\nwhich could be influenced by an in-flight existential\r\nsubtype computation.\r\n\r\nThis method is called in `PolyTypeCompleter`, which\r\ncould be constructed by the lazy type completer of the\r\nenclosing class. So currently it is closing over a mutable\r\nvariable; hence the Heisenbug.\r\n\r\nThis issue was exposed by the changes in b74c33e,\r\nwhich was introduced in Scala 2.10.1.\r\n\r\nReview by @adriaanm, /cc @lrytz'
2875,'xeno-by','Documentation 404 (macros guide)\nhttp://www.scala-lang.org/api/current/index.html#scala.reflect.macros.package\r\nrefers to Macros Guide: http://docs.scala-lang.org/overviews/macros.html, but that gives a 404'
2871,'xeno-by',"SI-7779 Account for class name compactification in reflection\nWe have to assume that the classes we are reflecting on were\r\ncompiled with the default value for -Xmax-classfile-name (255).\r\n\r\nWith this assumption, we can apply the same name compactification\r\nas done in the regular compiler.\r\n\r\nThe REPL is particularly prone to generating long class names\r\nwith the '$iw' prefixes, so this is an important fix for runtime\r\nreflection.\r\n\r\nAlso adds support for getting the runtime class of `O.type` if\r\n`O` is a module.\r\n\r\nReview by @xeno-by"
2866,'JamesIry',"SI-7269 Rework MapLike#retains to account for desugaring change\nSI-7269 Rework MapLike#retains to account for desugaring change\r\n\r\n`MapLike#retains` contains a for-comprehension that relied on the strict\r\n`filter` by its generator. You can't, in general, iterate a mutable map\r\nand remove items in the same pass.\r\n\r\nHere's the history of the desugaring of:\r\n\r\n    def retain[A, B](thiz: mutable.Map[A, B])(p: (A, B) => Boolean): thiz.type = {\r\n      thiz.foreach {\r\n        case (k, v) =>\r\n          if (p(k, v)) thiz -= k\r\n      }\r\n\r\nBefore regression (c82ecabad6~1):\r\n\r\n    thiz.filter(((check$ifrefutable$1) => check$ifrefutable$1: @scala.unchecked match {\r\n       case scala.Tuple2((k @ _), (v @ _)) => true\r\n       case _ => false\r\n    })).withFilter(((x$1) => x$1: @scala.unchecked match {\r\n       case scala.Tuple2((k @ _), (v @ _)) => p(k, v).unary_$bang\r\n    })).foreach(((x$2) => x$2: @scala.unchecked match {\r\n       case scala.Tuple2((k @ _), (v @ _)) => thiz.$minus$eq(k)\r\n    }));\r\n\r\nAfter regression (c82ecabad6, which incorrectly assumed in the parser that\r\nno filter is required for isInstanceOf[Tuple2])\r\n\r\n    thiz.withFilter(((x$1) => x$1: @scala.unchecked match {\r\n       case scala.Tuple2((k @ _), (v @ _)) => p(k, v).unary_$bang\r\n    })).foreach(((x$2) => x$2: @scala.unchecked match {\r\n      case scala.Tuple2((k @ _), (v @ _)) => thiz.$minus$eq(k)\r\n    }));\r\n\r\nAfter the reversion of c82ecabad6, v2.10.2\r\nThis is also after 365bb2b4e, which uses `withFilter` rather than `filter`.\r\n\r\n    thiz.withFilter(((check$q$1) => check$ifrefutable$1: @scala.unchecked match {\r\n       case scala.Tuple2((k @ _), (v @ _)) => true\r\n       case _ => false\r\n    })).withFilter(((x$1) => x$1: @scala.unchecked match {\r\n       case scala.Tuple2((k @ _), (v @ _)) => p(k, v).unary_$bang\r\n    })).foreach(((x$2) => x$2: @scala.unchecked match {\r\n      case scala.Tuple2((k @ _), (v @ _)) => thiz.$minus$eq(k)\r\n    }));\r\n\r\nThis commit does the same as `SetLike#retains`, and converts the map to\r\nan immutable list before the rest of the operation.\r\n\r\nReview by @JamesIry. /cc @paulp"
2864,'gkossakowski',"SI-6240 Synchronizes Names \nPreviously we didn't have all possible name creation facilities covered\r\nwith locks, so some of them silently misbehaved and caused much grief:\r\nhttp://groups.google.com/group/scala-internals/browse_thread/thread/ec1d3e2c4bcb000a.\r\n\r\nThis patch gets all the name factories under control.\r\n\r\nRather than relying on subclasses to override mutating methods\r\nand add synchronization, they should instead override `synchronizeNames`\r\nto return true and leave the placement of the locks up to\r\n`reflect.internal.Names`.\r\n\r\nThese locks are placed around sections that mutate `typeHashtable`\r\nand `termHashtable`.\r\n\r\nThis is done in the reflection universe, and in the interactive\r\ncompiler. The latter change will obviate an incomplete attempt\r\ndo to the same in `ScalaPresentationCompiler` in the scala-ide\r\nproject.\r\n\r\nReview by @xeno-by @gkossakowski"
2863,'gkossakowski','(1 of 2) of the rest of the new bytecode emitter + feedback\nSupersedes https://github.com/scala/scala/pull/2857 by incorporating feedback, in the form of more descriptive commit messages and code style changes (see diff below)\r\n\r\nreview by @gkossakowski'
2855,'gkossakowski',"Modularize: xml & parser-combinators\n[This PR depends on #2851]\r\n\r\nThese modules move to their own repositories:\r\n  - https://github.com/scala/scala-xml\r\n  - https://github.com/scala/scala-parser-combinators\r\n\r\nThe modularization depends on the new partest, as the old one's\r\nclasspath handling did not support a modularized scala.\r\n\r\nThe osgi tests take xml and parsers jars from the scaladoc dependencies,\r\nand osgi-fy them, as they are no longer built locally.\r\n"
2852,'JamesIry','SI-1980 A lint warning for by-name parameters in right assoc methods\nThe desugaring of right associative calls happens in the parser. This\r\neagerly evaluates the arguments (to preserve left-to-right evaluation\r\norder the arguments are evaluated before the qualifier).\r\n\r\nThis is pretty surprising if the method being called has a by-name\r\nparameter in the first parameter section.\r\n\r\nThis commit adds a warning under -Xlint when defining such a method.\r\n\r\nThe relevent spec snippets:\r\n\r\n> SLS 4.6.1 says that call-by-name argument "is not evaluated at the point of function application, but instead is evaluated at each use within the function".\r\n>\r\n> But 6.12.3 offers:\r\n> "If op is right- associative, the same operation is interpreted as { val x=e1; e2.op(x ) }, where x is a fresh name."\r\n\r\nReview by @JamesIry'
2849,'paulp',"SI-7763 Avoid dropping casts in erasure\n466b7d29f avoided quadratic complexity in Erasure's treatment\r\nof chained `asInstanceOf` calls. It did so by using the typechecked\r\nqualifier, rather than discarding it.\r\n\r\nHowever, that also dropped the cast altogether! In many cases this\r\nwas masked by later inclusion of a cast to the expected type\r\nby `adaptToType`:\r\n\r\n\t  at scala.tools.nsc.transform.Erasure$Eraser.cast(Erasure.scala:636)\r\n\t  at scala.tools.nsc.transform.Erasure$Eraser.scala$tools$nsc$transform$Erasure$Eraser$$adaptToType(Erasure.scala:665)\r\n\t  at scala.tools.nsc.transform.Erasure$Eraser.adapt(Erasure.scala:766)\r\n\t  at scala.tools.nsc.typechecker.Typers$Typer.runTyper$1(Typers.scala:5352)\r\n\r\nThis commit re-wraps the typechecked `qual` in its original\r\n`<qual>.asInstanceOf[T]` to preserve semantics while avoiding\r\nthe big-O blowup.\r\n\r\nReview by @paulp, @magarcia"
2847,'gkossakowski','SI-7501 Pickler: owner adjustment for param syms in annotation args\nPickling of trees within annotation arguments led to an unfortunate\r\nsituation: the MethodType of a symbol contained a value parameter\r\nsymbol that was pickled as though it were owned by the enclosing\r\nclass (the root symbol of the pickle.)\r\n\r\nUnder separate compilation, this would appear as a member of that\r\nclass.\r\n\r\nAnyone using `@deprecatedName(\'oldName)` was exposed to this problem,\r\nas the argument expands to `Symbol.apply("oldName")`.\r\n\r\nThis commit extends some similar treatment of local type parameters\r\nto also consider value parameters.\r\n\r\nReview by @gkossakowski'
2842,'JamesIry',"SI-7603 Fix thread safety of FlagTranslation \nThis is outside of the Global cake, so we can't assume single\r\nthreaded access. A var was introduced in af3daf6 that can lead\r\nto incorrect flag interpretation. The reported bug was triggered\r\nin a multi-project SBT build. Java Annotations read from classfiles\r\nwere occasionally conferred the TRAIT|INFERFACE|ABSTRACT flag set,\r\nleading to `@Foo is abstract, cannot be instatiated` later down the\r\nline.\r\n\r\nReview by @JamesIry. I could add a test to prod those functions for thread-safety, but I don't think an isolated test like that adds much value to our test suite.\r\n\r\n(This one will fix Typesafe tickets 2209 and 2323. I just got access to a build today that allowed the diagnosis, hence the eleventh hour submission for 2.10.3)\r\n"
2840,'adriaanm','SI-7756 Uncripple refchecks in case bodies\nIn 65340ed4ad2e, parts of RefChecks were disabled when\r\nwe traversed into the results of the new pattern matcher.\r\nSimilar logic existed for the old pattern matcher, but in\r\nthat case the Match / CaseDef nodes still existed in the tree.\r\n\r\nThe new approach was too broad: important checks no longer\r\nscrutinized the body of cases.\r\n\r\nThis commit turns the checks back on when it finds the remnants\r\nof a case body, which appears as an application to a label def.\r\n\r\nReview by @adriaanm'
2838,'adriaanm',"SI-7716 Exclude patmat synthetics from bounds checking\nConsider this pattern match translation, that occurs *before* refchecks:\r\n\r\n    scala> val e: java.lang.Enum[_] = java.util.concurrent.TimeUnit.SECONDS\r\n\r\n    scala> e match { case x => x }\r\n    <console>:9: error: type arguments [_$1] do not conform to class Enum's type parameter bounds [E <: Enum[E]]\r\n                  e match { case x => x }\r\n                  ^\r\n    [[syntax trees at end of                 refchecks]] // <console>\r\n    package $line5 {\r\n              case <synthetic> val x1: Enum[_$1] = $line3.$read.$iw.$iw.e;\r\n              case4(){\r\n                matchEnd3(x1)\r\n              };\r\n              matchEnd3(x: Enum[_$1]){\r\n                x\r\n              }\r\n\r\nRefChecks turns a blind eye to the non-conformant type `Enum[_$1]` in\r\nthe label defs because of 65340ed4ad2. (Incidentally, that is far\r\ntoo broad, as I've noted in SI-7756.)\r\n\r\nThis commit extends this exception to cover the synthetic ValDef `x1`.\r\n\r\nCommit log watchers might notice the similarities to SI-7694.\r\n\r\nReview by @adriaanm / @JamesIry. I think this one makes sense for 2.10.3. It was a regression from 2.9.x."
2826,'adriaanm','SI-7020 Determinism for pattern matcher warnings\nUse LinkedHashSet for the DPLL algorithm for determistic\r\ncounter example generation.\r\n\r\nBefore, the test compiled with:\r\n\r\n    [info] v2.10.2 => /Users/jason/usr/scala-v2.10.2-0-g60d462e\r\n    test/files/neg/t7020.scala:3: warning: match may not be exhaustive.\r\n    It would fail on the following inputs: List((x: Int forSome x not in (1, 2, 4, 5, 6, 7))), List(_, _)\r\n      List(5) match {\r\n          ^\r\n    test/files/neg/t7020.scala:10: warning: match may not be exhaustive.\r\n    It would fail on the following inputs: List((x: Int forSome x not in (1, 2, 4, 5, 6, 7))), List(_, _)\r\n      List(5) match {\r\n          ^\r\n    test/files/neg/t7020.scala:17: warning: match may not be exhaustive.\r\n    It would fail on the following inputs: List((x: Int forSome x not in (1, 2, 4, 6, 7)), _), List(1, _), List(2, _), List(4, _), List(5, _), List(6, _), List(7, _), List(??, _)\r\n      List(5) match {\r\n          ^\r\n    test/files/neg/t7020.scala:24: warning: match may not be exhaustive.\r\n    It would fail on the following input: List(_, _)\r\n      List(5) match {\r\n          ^\r\n\r\nReview by @adriaanm, /cc @gbasler'
2822,'adriaanm',"SI-3346 implicit parameters can now guide implicit view inference\nThis simple patch makes it possible for implicit views to benefit from\r\nfundep-guided type inference, eliminating a nasty special case in\r\nimplicit inference.\r\n\r\nHere are the changes that I had to apply to the tests (they exposed\r\nquite a number of interesting questions that I was happy to answer):\r\n\r\n1) neg/t5845.scala now works, so I moved it to pos. That easily makes sense,\r\nbecause the test was just a canary to track previous state of things.\r\n\r\n2) neg/divergent_implicit.scala and neg/t5578.scala changed their messages\r\nto less informative ones, because inapplicable implicit views now get\r\ndisqualified early and therefore don't display their error messages\r\nto the user. This is an unfortunate but necessary byproduct of this\r\nchange, and one can argue that the behavior is now completely consistent\r\nwith implicit vals (that also don't explain why this or that implicit val\r\ngot disqualified, but rather display a generic implicit value not found\r\nmessage).\r\n\r\n3) scaladoc/implicits-chaining.scala and scaladoc/implicits-base.scala.\r\nImmediate culling of apriori inapplicable implicit views messes things up\r\nfor Scaladoc, because it's interested in potentially applicable views,\r\nhaving infrastructure to track various constraints (type bounds, requirements\r\nfor implicit parameters, etc) that guide applicability of views and then\r\npresent it to the user. Therefore, when scaladoc is detected, implicit search\r\nreverts to the old behavior.\r\n\r\n4) We still cannot have Jason's workaround to type constructor inference\r\nmentioned in comments to SI-3346, because it's not really about implicit \r\nparameters of implicit views, but about type inference flowing from the \r\nimplicit parameter list to a preceding parameter list in order to affect \r\ninference of an implicit view. This is something that's still too ambitious.\r\n"
2821,'adriaanm',"SI-7470 implements fundep materialization\nThis fix provides implicit macros with an ability to affect type inference\r\nin a more or less sane manner. That's crucial for materialization of\r\nmulti-parametric type class instances (e.g. Iso's from shapeless).\r\nDetails of the technique can be found in comments."
2816,'retronym',"SI-3772 local companion objects no longer produce errors\nThe bug is caused by Namers.inCurrentScope preventing the namer from\r\noverwriting synthetic companion modules (created for case classes and\r\nclasses with default arguments) with companions explicitly declared by\r\nthe programmer, in case when these companions are written after their\r\ncorresponding classes.\r\n\r\nI tried to understand what the Namers.inCurrentScope method does, but\r\nthis wasn't particularly successful. Then I noticed that this method\r\nis used only when entering modules, so I simply removed it and ran\r\nthe test suite. Amazingly enough, nothing broke, and the test got fixed."
2814,'retronym',"[nomaster] macro expansions are now auto-duplicated\nThe fix still requires macro developers to be careful about sharing trees\r\nby references, because attributed DefTrees will still bring trouble.\r\n\r\nHowever this is an improvement, because it doesn't make matters worse\r\nand automatically fixes situations similar to one in the test.\r\n\r\nA much more thorough discussion with a number of open questions left:\r\nhttp://groups.google.com/group/scala-internals/browse_thread/thread/492560d941b315cc\r\n\r\nWas fixed ages ago in master in one of the paradise backports.\r\nNever got to 2.10.x, but it's very useful, so I'm backporting it now."
2810,'adriaanm','@compileTimeOnly: moved to scala-library.jar, got some fixes\nreview @retronym'
2805,'JamesIry','Constructors refactoring [Rebase of #2715]\n[Rebase of #2715]\r\n\r\nReview by @JamesIry before 2.11.0-M5 window closes. I consider merging this PR a blocker.\r\n\r\nThe `constructors` phase has grown over time, with sub-transformations being added to the all-encompassing `transformClassTemplate()` on an as-needed basis.\r\n\r\nThis PR breaks that method apart, encapsulating each sub-transformation in a trait dedicated to it. Documentation has been thrown in, too.\r\n\r\nThis PR essentially plays again the commits of https://github.com/scala/scala/pull/2599\r\nadapted to `Constructors.scala` in its current form.\r\n\r\nThose commits were once merged into master, but had an ephemeral existence:\r\nthey were inadvertently *overwritten* by the merge of 2.10.2 into master,\r\nsee commit 767a25fe2178b00f494d55bdaae53535cd7fb57d \r\n\r\nThis PR is a pre-requisite for an upcoming re-submission of https://github.com/scala/scala/pull/2665 ,\r\nto make anon-closures retain fewer heap objects (currently, in some cases, more objects are retained via outer-refs than really needed).\r\n\r\nPlease merge this PR before Constructors.scala drifts again.\r\n'
2799,'gkossakowski','Rebase #2727\nRebased #2727. Should be good to go, @gkossakowski.'
2796,'JamesIry',"SI-6582 Use Tseitin's algorithm for CNF conversion in pattern matching analysis.\nThis chops #2724 into smaller commits.\r\n\r\nI made Lit into a value class and encapsulated a bit more.\r\nPlease double check my refactorings were correctness-preserving.\r\n\r\nreview by @gbasler"
2795,'JamesIry',"SI-4829 the :load command now fails if the command ends with a space (Pre-port)\nThe :load command now tries to be smart by detecting the presence of trailing spaces that might be insignificant.\r\n\r\nOn certain file systems, files with trailing whitespaces are permitted which is why we don't naively trim the argument.\r\n\r\nPlease review @adriaanm"
2788,'adriaanm','SI-7747 Making scala repl\'s class generation customizable\nWe at spark, have to customize scala repl to support our way of "code wrapping" for input code. The reason we want it that way is spark needs code serializable so that it can be executed on a remote worker.\r\n\r\n I wish it was possible to configure rather than port scala repl code for every scala release migration. This pull request may *only* present my intention which is, we may not need a complete overhauling of scala REPL to support it and thus there should be a simpler solution to it.  It also has a sample customization which uses `class` instead of `object` for wrapping code to be executed. The sample customization is exactly what we would need for spark i.e. serializable. Actually there is more space for making things in the repl customizable, but then this is just a beginning. This has been done in this particular way only to achieve the goal in minimal code change at expense of elegance. Of course suggestions and reviews comments are welcomed for me being on lurker side trying to step into space that might not be welcoming for its technical depth. \r\n\r\nFor Example\r\n\r\n```scala\r\n\r\nscala> val a = 10\r\na: Int = 10\r\n\r\nscala> val b = a * 2 // show\r\nclass $read extends Serializable {\r\n  def <init>() = {\r\n    super.<init>;\r\n    ()\r\n  };\r\n  class $iwC extends Serializable {\r\n    def <init>() = {\r\n      super.<init>;\r\n      ()\r\n    };\r\n    val $VAL1 = $line3.$read.INSTANCE;\r\n    import $VAL1.$iw.$iw.a;\r\n    class $iwC extends Serializable {\r\n      def <init>() = {\r\n        super.<init>;\r\n        ()\r\n      };\r\n      val b = a * 2\r\n    };\r\n    val $iw = new $iwC.<init>\r\n  };\r\n  val $iw = new $iwC.<init>\r\n}\r\nobject $read extends scala.AnyRef {\r\n  def <init>() = {\r\n    super.<init>;\r\n    ()\r\n  };\r\n  val INSTANCE = new $read.<init>\r\n}\r\nb: Int = 20\r\n\r\nscala> \r\n\r\n```'
2786,'adriaanm',"New website has some links to files that get a 403 Forbidden message\nthe Older Documentation section at http://www.scala-lang.org/documentation/ has some 403 links:\r\ne.g. \r\nhttp://www.scala-lang.org/docu/files/ScalaTutorial.pdf\r\n\r\nwhich gets this message:\r\n\r\n> Forbidden\r\n\r\n> You don't have permission to access /old/website/doc/ScalaTutorial.pdf on this server.\r\n\r\n> Additionally, a 403 Forbidden error was encountered while trying to use an ErrorDocument to handle the request.\r\n\r\nOther docs that gets this message are:\r\n\r\nhttp://www.scala-lang.org/docu/files/ScalaByExample.pdf"
2781,'retronym','Merge 2.10.x into master\nMerge difficulty: moderate.\r\n\r\nThe biggest trouble was caused by 55decf733eb361c235ef1bd9039e5c6226202a96 because it overlaps with 30e2e3a78f9061ea93352427cb0ca205203041f0 Please refrain from introducing any non-mandatory changes to 2.10.x branch.\r\n\r\nReview by @retronym'
2775,'adriaanm',"No longer crash on NoSymbol.owner.\nHistorically calling NoSymbol.owner has crashed the compiler.\r\nWith this commit, NoSymbol owns itself. This is consistent with\r\nthe way ownership chains are handled elsewhere in the compiler\r\n(e.g. NoContext.owner is NoContext, NoSymbol.enclClass is\r\nNoSymbol, and so on) and frees every call site which handles\r\nsymbols from having to perform precondition tests against\r\nNoSymbol.\r\n\r\nSince calling NoSymbol.owner sometimes (not always) indicates\r\na bug which we'd like to catch sooner than later, I have\r\nintroduced a couple more methods for selected call sites.\r\n```\r\n  def owner: Symbol       // NoSymbol.owner is self, log if -Xdev\r\n  def safeOwner: Symbol   // NoSymbol.owner is self, ignore\r\n  def assertOwner: Symbol // NoSymbol.owner is fatal\r\n```\r\nThe idea is that everyone can call sym.owner without undue anxiety\r\nor paranoid null-like tests. When compiling under -Xdev calls to\r\n`owner` are logged with a stack trace, so any call sites for which\r\nthat is an expected occurrence should call safeOwner instead to\r\ncommunicate the intention and stay out of the log. Conversely, any\r\ncall site where crashing on the owner call was a desirable behavior\r\ncan opt into calling assertOwner.\r\n\r\nThis commit also includes all the safeOwner calls necessary to\r\ngive us a silent log when compiling scala."
2771,'adriaanm',"SI-7694 @uncheckedBounds, an opt-out from type bounds checking\nSynthetic defs introduced by transforms like named/default arguments,\r\nANF (in scala-async) often introduce a type tree (the tpt of the temporary)\r\nthat are based on the types of expressions. These types are scrutinized in\r\nRefChecks to check that type parameter bounds are satisfied.\r\n\r\nHowever, the type of the expression might be based on slack a LUB that\r\nfails to capture constraints between type parameters.\r\n\r\nThis slackness is noted in `mergePrefixAndArgs`:\r\n\r\n\t// Martin: I removed this, because incomplete. Not sure there is a\r\n\t// good way to fix it. For the moment we just err on the conservative\r\n\t// side, i.e. with a bound that is too high.\r\n\r\nThe synthesizer can now opt out of bounds by annotating the type as follows:\r\n\r\n   val temp: (<expr.tpe> @uncheckedBounds) = expr\r\n\r\nThis facility is now used in named/default arguments for the temporaries\r\nused for the reciever and arguments.\r\n\r\nThe annotation is hidden under scala.reflect.internal, rather than in\r\nthe more prominent scala.annotation.unchecked, to reflect the intention\r\nthat it should only be used in tree transformers.\r\n\r\nTargetting 2.10.3 as this fix is needed by a customer.\r\n\r\n**UPDATE** \r\n\r\nIt occurred to me that we should be robust against running the 2.10.3 compiler with the 2.10.2 library, so I've split this PR into two commits. More details in their comments."
2753,'gkossakowski','Change += to + in example for aggregate method\nSince Set used as accumulator is immutable, it does not have += method.'
2750,'paulp','SI-7455 Drop dummy param for synthetic access constructor\nJava synthesizes public constructors in private classes to\r\nallow access from inner classes. The signature of\r\nthat synthetic constructor (known as a "access constructor")\r\nhas a dummy parameter appended to avoid overloading clashes.\r\njavac chooses the type "Enclosing$1" for the dummy parameter\r\n(called the "access constructor tag") which is either an\r\nexisting anonymous class or a synthesized class for this purpose.\r\n\r\nIn OpenJDK, this transformation is performed in:\r\n\r\n  langtools/src/share/classes/com/sun/tools/javac/comp/Lower.java\r\n\r\n(Incidentally, scalac would just emits a byte-code public\r\nconstructor in this situation, rather than a private constructor /\r\naccess constructor pair.)\r\n\r\nScala parses the signature of the access contructor, and drops\r\nthe $outer parameter, but retains the dummy parameter. This causes\r\nhavoc when it tries to parse the bytecode for that anonymous class;\r\nthe class file parser doesn\'t have the enclosing type parameters\r\nof Vector in scope and crash ensues.\r\n\r\nIn any case, we shouldn\'t allow user code to see that constructor;\r\nit should only be called from within its own compilation unit.\r\n\r\nThis commit drops the dummy parameter from access constructor\r\nsignatures in class file parsing.\r\n\r\n\r\nReview by @paulp\r\n\r\nTargetting 2.10.x. I think this is high reward and relatively low risk.\r\n\r\nThis bug is often reported by Java 7 Swing users but is unrelated to scala-swing, raw types, or newly-generified Java standard library classes. It could pop up anytime. It is also usually only seen within SBT when its custom compiler phase captures API snapshots.\r\n'
2743,'adriaanm','Commit .gitignore directly\nRather than relying on the cloner to copy the\r\nprovided gitignore.SAMPLE files.\r\n\r\nThis finishes the job started in c48509598, mostly\r\nby reverting that commit and moving the two existing\r\nSAMPLE files to the final destinations.\r\n\r\nUse `.git/info/exclude` to augment the list of patterns\r\nwith entries specific to your workflow.\r\n\r\nReview by @adriaanm'
2742,'adriaanm','SI-7655 Enforce stable id patterns conform to scrutinee type\nThis was only being done if the stable id pattern was a direct\r\nreference to a module.\r\n\r\nThis commit distinguishes stable ID patterns with the recently\r\nadded facility in TreeInfo. (Actually, this might be overkill\r\nin adapt and we could probably get away with just checking for\r\n`_: Ident | _: Select`.)\r\n\r\nReview by @adriaanm.\r\n\r\nOpinions on the particular way to check for the stable ID pattern are welcome.'
2741,'adriaanm','Scrubbing up the IntelliJ Config\n\r\n- Add recently sprouted modules (xml and parser-combinators)\r\n - Replace some of the documentation with a setup script\r\n - Update Ant build to copy Maven sourced JARs to ./build/deps.\r\n   These are included in the IntelliJ classpath.\r\n - Define the library for Ant at the project level based on\r\n   ./lib, rather than asking the user to define global library.\r\n - Disable Type Aware Highlighting by default.\r\n\r\nIntelliJ now can build everything within the IDE with CTRL-F9.'
2739,'adriaanm','SI-7668 Better return type inheritance for dep. method types\nReturn type inheritance already handles substitution of\r\ntype parameters of the overriding method for those of the\r\noverriding.\r\n\r\nThis commit extends this to do the same for parameter symbols.\r\n\r\nReview by @adriaanm'
2737,'adriaanm',"SI-7669 Fix exhaustivity warnings for recursive ADTs.\nThe pattern matcher's analysis was correctly finding\r\nmodels under which the match in the enclosed test\r\ncould fail. But, when trying to render that model\r\nas a counter example, it ran into an internal inconsistency\r\nand gave up.\r\n\r\nThat inconsistency arose from VariableAssignment, which:\r\n\r\n> turn the variable assignments into a tree\r\n> the root is the scrutinee (x1), edges are labelled\r\n> by the fields that are assigned a node is a variable\r\n> example (which is later turned into a counter example)\r\n\r\nIn the process, it notes the unreachable case `V2 = NotHandled`,\r\nwhich can only arise if `V1 = Op`, ie the scrutinee is `Op(NotHandled())`.\r\nV2 is assosicated with the path `x1.arg`. The code then looked for\r\nany variable assosicated with the prefix `x1` and registered that its\r\nfield `arg` was assosicated with this variable assignment.\r\n\r\nHowever, the assignment for `V1 = NotHandled` (another missing case)\r\nis also associated with the path `x1`. Registering this field makes\r\nno sense here; we should only do that for `Op`.\r\n\r\nThis commit conditioanlly registers the fields based on the class\r\nof `VariableAssignment#cls`. We no longer hit the inconsistency in\r\n`VariableAssignment#allFieldAssignmentsLegal`.\r\n\r\nThis changes the results of an existing test, in what seems to be\r\na positive way.\r\n\r\nReview by @adriaanm"
2724,'adriaanm',"SI-6582 Use Tseitin transformation to convert propositional formulae into CNF.\nThis resolves the `AnalysisBudgetException` problem for big pattern matches.\r\n\r\nInitial experiments indicate that the problem is even simpler than initially thought: all formulae I got from the exhaustiveness check could be transformed directly into CNF by formula simplification, neither expansion not Tseitin transformation where needed.\r\nThus the framework introduced here might be overkill and a much simpler implementation could work as well.\r\n\r\nFor Scala 2.11 I'd suggest to replace the DPLL procedure with Sat4j. See separate branch.\r\n\r\nReview by @adriaanm "
2704,'gkossakowski','Separate jars for XML, Parser Combinators. Use released JLine.\nThe actual refactoring had already been done.\r\nThis changes the source directory layout and the produced jars.\r\n\r\nReview by @gkossakowski\r\n\r\n/cc @huitseeker, @harrah, @jsuereth'
2686,'adriaanm','Less noise on a partest failure.\nThrowing a BuildException is the polite way to fail the Ant build.\r\n\r\nBefore:\r\n\r\n\tBUILD FAILED\r\n\t/Users/jason/code/scala2/build.xml:1522: java.lang.RuntimeException: Test suite finished with 1 case failing:\r\n\t/Users/jason/code/scala2/test/files/pos/lub-dealias-widen.scala [FAILED]\r\n\t        at scala.sys.package$.error(package.scala:27)\r\n\t        [20 lines elided]\r\n\t        at org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\r\n\r\n\tTotal time: 2 minutes 35 seconds\r\n\r\nAfter:\r\n\r\n\tBUILD FAILED\r\n\t/Users/jason/code/scala2/build.xml:1522: Test suite finished with 1 case failing:\r\n\t/Users/jason/code/scala2/test/files/pos/lub-dealias-widen.scala [FAILED]\r\n\r\n\tTotal time: 2 minutes 34 seconds\r\n\r\nReview by @adriaanm'
2685,'adriaanm',"SI-7612 Fix SOE regression in lubs\nThe enclosed test case (whittled down lovingly from lift-mapper)\r\ntriggers the cycle in `elimSub`.\r\n\r\nRegressed in a06d31f6a. The change was dicussed\r\n<https://github.com/scala/scala/pull/2022#discussion_r2832997>.\r\n\r\nThis patch reverts to using `.underlying`.\r\n\r\nBelow, I've shown the different paths that are taken through\r\nthat method with before and after this patch. The key divergence\r\nis when `<refinement>.this.M.dealias` reveals a captured existential\r\ntype symbol.\r\n\r\nA more detailed look at how that happens:\r\n   <https://gist.github.com/retronym/5874775>\r\n\r\nReview by @adriaanm.\r\n\r\nTargetting 2.10.x on grounds of locality of the fix and regression from 2.10.0 -> 2.10.1.\r\n\r\n"
2682,'paulp','SI-7209 Another test for a fixed bug with Java generics\nErased types were being treated as raw types and incorrectly\r\nbeing cooked, this is visible in the REPL which reuses the symbol\r\ntable.\r\n\r\nThe fix for this came earlier in SI-7482.\r\n\r\nReview by @paulp'
2664,'gkossakowski',"SI-7596 Curtail overloaded symbols during unpickling\nIn code like:\r\n\r\n    object O { val x = A; def x(a: Any) = ... }\r\n    object P extends O.x.A\r\n\r\nThe unpickler was using an overloaded symbol for `x` in the\r\nparent type of `P`. This led to compilation failures under\r\nseparate compilation.\r\n\r\nThe code that leads to this is in `Unpicklers`:\r\n\r\n    def fromName(name: Name) = name.toTermName match {\r\n      case nme.ROOT     => loadingMirror.RootClass\r\n      case nme.ROOTPKG  => loadingMirror.RootPackage\r\n      case _            => adjust(owner.info.decl(name))\r\n    }\r\n\r\nThis commit filters the overloaded symbol based on the\r\nparameter list size when unpickling a singleton type.\r\nThat seemed a slightly safer place than in `fromName`.\r\n\r\nReview by @gkossakowski\r\n\r\nPoints for review:\r\n - where do you think the right place is to filter the symbol? \r\n - I chose `filter` over `suchThat` to defer errors in the case that the val no longer exists. But I didn't test that case, and don't really think the precise error mode is too important; things will blow up quickly either way.\r\n - is there a cleaner, flag-driven alternative to `paramss.isEmpty`?"
2660,'JamesIry','SI-7582 Only inline accessible calls to package-private Java code\nThe inliner was using `isPrivate` / `isProtected` to determine access.\r\nThe fallthrough considered things to be (bytecode) public. This is okay\r\nin practice for Scala code, which never emits package private code.\r\n\r\nThis commit turns the logic around to use `!isPublic && !isProtected` to\r\nequate to "don\'t inline". This alone is enough to pass `run/t7582`.\r\n\r\nSecondly, we must check accessibility of the called symbol *and* its\r\nowner.\r\n\r\nReview by @JamesIry\r\n\r\nThe change to `ClassFileParser` was reviewed in person by @odersky'
2659,'adriaanm','SI-7584 Fix typer regression with by-name parameter types\nIt regressed in https://github.com/scala/scala/commit/fada1ef#L4L614. Partially reverting just\r\nthis change restores the correct behaviour:\r\n\r\n```patch\r\n-        if (sym.isStable && pre.isStable && !isByNameParamType(tree.tpe) &&\r\n+        if (treeInfo.admitsTypeSelection(tree) &&\r\n```\r\n\r\nThis patch embeds the check for by-name parameter types into\r\n`TreeInfo.isStableIdentifier`. That code already checks for\r\n`Symbol#isStable`, which exludes direct references to by-name\r\nparameters. But the additional check is required to deal with\r\nby-name parameters in function types, e.g `(=> Int) => Any`.\r\n\r\nOpen question: should we go further and embed this check in `isStable`?\r\n\r\nCurrently:\r\n\r\n    final def isStable        = isTerm && !isMutable && !(hasFlag(BYNAMEPARAM)) && (!isMethod || hasStableFlag)\r\n\r\nReview by @adriaanm'
2653,'gkossakowski','SI-7433 Fix spurious warning about catching control throwable\nIn the same vein as SI-6994, such warnings should only be run\r\nin the typer phase, and not in later typechecking (usually in\r\nerasure.)\r\n\r\nWhy? After translation of pattern matching, we end up with:\r\n\r\n    case (ex8 @ _) => {\r\n    <synthetic> val x5: Throwable = ex8;\r\n    case11(){\r\n      if ({\r\n        case14(){\r\n          if (x5.$isInstanceOf[NullPointerException]())\r\n            matchEnd13(true)\r\n          else\r\n            case15()\r\n        };\r\n        case15(){\r\n          if (x5.$isInstanceOf[RuntimeException]())\r\n            matchEnd13(true)\r\n          else\r\n            case16()\r\n        };\r\n        case16(){\r\n          matchEnd13(false)\r\n        };\r\n        matchEnd13(x: Boolean){\r\n          x\r\n        }\r\n      })\r\n\r\nReview by @gkossakowski'
2648,'gkossakowski',"SI-7571 Allow nesting of anonymous classes in value classes\n5d9cde105e added deep prohibition of nested classes within\r\na value class. This has the undesirable side effect of\r\nprohibiting partial functions literals in method bodies\r\nof a value class.\r\n\r\nThe intention of that prohibition was to avoid problems\r\nin code using Type Tests, such as:\r\n\r\n    class C(val inner: A) extends AnyVal {\r\n      class D\r\n    }\r\n    def foo(a: Any, other: C) = a match { case _ : other.D }\r\n\r\nHere, the pattern usually checks that `a.$outer == other`.\r\nBut that is incongruent with the way that `other` is erased\r\nto `A`.\r\n\r\nHowever, not all nested classes could lead us into this trap.\r\nThis commit slightly relaxes the restriction to allow anonymou\r\nclasses, which can't appear in a type test.\r\nThe test shows that the translation generates working code.\r\n\r\nReview by @gkossakowski"
2639,'paulp','SI-2464 Resiliance against missing InnerClass attributes\nA classfile in the wild related to Vaadin lacked the InnerClasses\r\nattribute. As such, our class file parser treated a nested enum\r\nclass as top-level, which led to a crash when trying to find its\r\nlinked module.\r\n\r\nMore details of the investigation are available in the JIRA comments.\r\n\r\nThe test introduces a new facility to rewrite classfiles.\r\n\r\nThis commit turns this situation into a logged warning, rather\r\nthan crashing. Code by @paulp, test by yours truly.\r\n\r\nReview by @paulp'
2637,'paulp','SI-7439 Avoid NPE in `isMonomorphicType` with stub symbols. …\n`originalInfo` can return null for stub symbols; deal with that\r\nas we used to before a regression in 016bc3d.\r\n\r\nAfter this change, we can once again delete A_1.class and still compile\r\ncode instantiating B_1. (A_1 is only referred to in a method signature\r\nof B_1 which is not called from our code.)\r\n\r\n\tscala> new B_1\r\n\twarning: Class A_1 not found - continuing with a stub.\r\n\tres0: B_1 = B_1@5284b8f\r\n\r\nIn practice, this situation arises when someone uses a third\r\nparty class that was compiled against other libraries not avaialable\r\non the current compilation classpath.\r\n\r\nReview by @paulp'
2631,'adriaanm',"SI-5022 Retain precise existentials through pattern matching\nFrom the dawn of scalac's existentials, the typer widens\r\nexistentials pt-s by substituting wildcard types in places\r\nof existential quantifiers.\r\n\r\nIn this example:\r\n\r\n    class ForSomeVsUnapply {\r\n      def test {\r\n        def makeWrap: Wrap = ???\r\n        def useRep[e](rep: (e, X[e])) = ()\r\n\r\n        val rep = makeWrap match {\r\n          case Wrap(r) => r\r\n        };\r\n\r\n        useRep(rep) // error\r\n      }\r\n    }\r\n\r\nthe type of `r` is the result of typechecking:\r\n\r\n    Apply(\r\n     fun = TypeTree(\r\n       tpe = (rep#12037: (e#12038, X#7041[e#12038]) forSome { type e#12038 })\r\n     args = Bind(r @ _) :: Nil\r\n    }\r\n\r\nThis descends to type the `Bind` with:\r\n\r\n    pt = (e#12038, X#7041[e#12038]) forSome { type e#12038 }\r\n\r\n`dropExistential` clobbers that type to `Tuple2#1540[?, X#7041[?]]`,\r\nwhich doesn't express any relationship between the two instances\r\nof the wildcard type. `typedIdent` sort of reverses this with a call\r\nto `makeFullyDefined`, but only ends up with:\r\n\r\n    pt = (Any#3330, X#7041[_1#12227]) forSome { type _1#12227; type e#12038 }\r\n\r\nI suspect that this existential dropping only makes sense outside of\r\ntypechecking patterns. In pattern mode, type information flows from the\r\nexpected type onwards to the body of the case; we must not lose precision\r\nin the types.\r\n\r\nFor SIP-18 friendly existentials, one `dropExistential` is invertable with\r\n`makeFullyDefined`, so this hasn't been such a big problem.\r\n\r\nThe error message improvement conferred by SI-4515 took a hit.\r\nThat might be a good example to consider when reviewing this change:\r\nDoes it tell us anything interesting about this `dropExistential`\r\nbusiness?\r\n\r\nReview by @adriaanm.\r\n\r\nIf we go forward with this, I can address the two FIXME's introduced in this patch before merging."
2629,'xeno-by','SI-7558 Fix capture of free local vars in toolbox compiler\nIt was creating an `ObjectRef[<notype>]` because of a small\r\nbug in `capturedVariableType`.\r\n\r\nReview by @xeno-by'
2628,'xeno-by','SI-7364 Allow raw types in parent position in Java sources\nTo make this work, this commit simply restricts parent\r\ntype argument inference to Scala source files.\r\n\r\nThe surrounding code has also been refactored to avoid a var.\r\n\r\nReview by @xeno-by (last seen in this area in 40063b00)'
2627,'paulp','SI-7418 Avoid concurrent use of compiler in REPL startup\nEnable the tab completer *after* we\'re finished binding\r\n$intp and unleashing power mode on the asynchronous\r\nREPL startup thread.\r\n\r\nTested manually:\r\n - run qbin/scala\r\n - Paste "".toUp\r\n - Hit <TAB> like a maniac\r\n\r\nBefore this patch, the crash was reproducible almost every time.\r\nAfterwards, not the once.\r\n\r\nReview by @paulp'
2626,'xeno-by','SI-7556 Fix runtime reflection involving ScalaLongSignature\nScala type information is stored in classfiles in encoded in a String\r\nin the ScalaSignature annotation. When it is too big for a single\r\nString, it is split into an array of Strings in a different annotation,\r\nScalaLongSignature.\r\n\r\nThe enclosed test, with a class containing 3000 methods, uses the latter.\r\nIt exposes a bug in the way runtime reflection decodes that data.\r\n\r\nIt must concatentate and *then* decode, rather that the other way around.\r\n\r\nReview by @xeno-by'
2621,'paulp',"SI-7264 Initialize owner when searching for companion.\nFrom ClassSymbol:\r\n\r\n    protected final def companionModule0: Symbol =\r\n      flatOwnerInfo.decl(name.toTermName).suchThat(sym => sym.isModuleNotMethod && (sym isCoDefinedWith this))\r\n\r\n    protected final def flatOwnerInfo: Type = {\r\n      if (needsFlatClasses)\r\n        info\r\n      owner.rawInfo\r\n    }\r\n\r\nNote the call to `rawInfo`; in the enclosed test case, that gives\r\nus back an uninitialized type for the module class of `Foo`, and\r\nconsequently we don't find the companion for `Foo.Values`.\r\n\r\nThis commit forces the initialization of the owning symbol if it\r\nwas compiled in a prior run.\r\n\r\nIn addition, it adds a special case to `Run#compiles` for early\r\ninitialized symbols, which start out in life with the wrong owner.\r\nAs best as I can see, that complexity stems from allowing early\r\ninitialized members *without* return types to be used as value arguments\r\nto the super call, which in turn is needed to infer parent type arguments.\r\nThe situation is described a little further in existing comments of\r\n`typedPrimaryConstrBody`.\r\n\r\nThis bug is essentially another case of SI-6976. See the comments in pull\r\nrequest of that patch (https://github.com/scala/scala/pull/1910) for\r\ncommit archaeology that shows why we're reluctant to force the owner\r\ninfo more broadly than is done in this commit.\r\n\r\nReview by @paulp / @lrytz\r\n\r\nThis PR is more a suggestion, rather than a final proposal. I lack confidence that the cycles we're afraid of are tested, and the intuition to craft said tests retrospectively."
2618,'JamesIry',"Finalized math.E and math.Pi.\nWithout this treatment these constants will not be inlined or folded, bloating\nbytecode and inhibiting optimization. Marking them @inline doesn't have any\nadditional effect, but I did it to futurize them in light of SI-7542."
2617,'xeno-by','Eliminate needless Options.\nMany of our core types have dedicated sentinels which serve perfectly to\ncommunicate "no value", even more perfectly than None. Saving a billion\nallocations is gravy.'
2616,'adriaanm','SI-7505 Test case for pattern matcher + type alias bug\nProgressed along with SI-7214 in acd74cae09.\r\n\r\nReview by @adriaanm'
2615,'adriaanm',"SI-7517 type constructors too eagerly normalized.\nI think 403eadd0f1 was largely a symptomatic remedy (not that\r\nwe shouldn't harden against such outcomes) and that this commit\r\ngets closer to the root causes. The unanticipated change to\r\ntest/files/run/t6113.check is like a cry of support from the jury box.\r\n```diff\r\n-Foo[[X](Int, X)]\r\n+Foo[AnyRef{type l[X] = (Int, X)}#l]\r\n```\r\nWe should continue to look upon calls to normalize with grave suspicion."
2613,'JamesIry','SI-6309 Test case for early-init / private[this] crasher.\nThis has worked since 98daf03, "Overhauled local/getter/setter name logic.".\r\n\r\nI didn\'t narrow the progression down to a particular part of the patch.\r\n\r\nJubilant review from the overhauler himself, @paulp.'
2612,'retronym',"SI-7533 Adds Symbol.isAbstract\nAmazingly enough, we've missed the fact that non-type symbols can also\r\nbe abstract. Having been enlightened by this, I'm exposing isDeferred\r\nand merging it along with isAbstractType and isAbstractClass into the\r\nunified Symbol.isAbstract method."
2611,'paulp',"SI-6841 Fix bug at the intersection of DelayedInit and named args\nThe DelayedInit transformation analyses the constructor to partition\r\nregular initialization from calls to super constructors / trait\r\ninitializers.\r\n\r\nIt failed to find such super calls if they were nested in a Block,\r\nwhich can happens when using named or default arguments.\r\n\r\nThis commit makes that code peer into Blocks to correctly partition\r\nthe constructor statements.\r\n\r\nThis change doesn't affect the result of run/t4680.scala, which was\r\nmentioned in nearby comments and which chronicles bugs with DelayedInit\r\nwhen used in inheritance hierarchies.\r\n\r\nReview by @paulp (the author of said comments)"
2610,'retronym','SI-7498 ParTrieMap.foreach no longer crashes\nPreviously, the `split` method of the `ParTrieMap` iterator threw\r\nan exception when splitting a splitter that iterated over nodes\r\nwhose hash codes collide.\r\nThis was due to reusing the iterator of the list of colliding keys\r\nrather than creating a new splitter.\r\n\r\nThis commit changes the `subdivide` method to create a new\r\niterator using the factory method of the current trie map\r\niterator rather than returning a `LinearSeqLike` iterator.\r\n\r\nReview by @retronym '
2609,'paulp','SI-7507 Fix lookup of private[this] member in presence of self type.\nIn the following code:\r\n\r\n\ttrait Cake extends Slice\r\n\r\n\ttrait Slice { self: Cake =>    // must have self type that extends `Slice`\r\n\t  private[this] val bippy = () // must be private[this]\r\n\t  locally(bippy)\r\n\t}\r\n\r\n`ThisType(<Slice>).findMember(bippy)` excluded the private local member on\r\nthe grounds that the first class in the base type sequence, `Cake`, was\r\nnot contained in `Slice`.\r\n\r\n\tscala> val thisType = typeOf[Slice].typeSymbol.thisType\r\n\tthisType: $r.intp.global.Type = Slice.this.type\r\n\r\n\tscala> thisType.baseClasses\r\n\tres6: List[$r.intp.global.Symbol] = List(trait Cake, trait Slice, class Object, class Any)\r\n\r\nThis commit changes `findMember` to use the symbol of the `ThisType`, rather\r\nthan the first base class, as the location of the selection.\r\n\r\nReview by @paulp'
2608,'JamesIry',"SI-7532 Fix regression in Java inner classfile reader\n395e90a modified the detection of top-level classes in\r\nClassfileParser in two ways:\r\n  1. used `Name#containsChar` rather than `toString.indexOf ...` (good!)\r\n  2. decoded the name before doing this check (bad!)\r\n\r\nThat code is actually only run for non-Scala classfiles, whose\r\nnames don't need decoding. Attempting to do so converted `R$attr`\r\nto `R@tr`, which no longer contains a '$', and was wrongly treated\r\nas a top level class.\r\n\r\nThis commit reverts the use of `decodedName`, and inlines the method\r\nto its only call site for clarity.\r\n\r\nReview by @paulp and @JamesIry (for 2.10.2-RC2 inclusion)"
2607,'adriaanm',"SI-7517 Fix higher kinded type inference regression\n - Discovered in 2.10.2-RC1\r\n - Ostensibly regressed in 7e52fb910b, which conceptually reverted\r\n   part of 0cde930b so that (mutable) TypeVars don't use structural equality.\r\n - But, does *not* fail if 7e52fb910b is cherry-picked directly after 0cde930b,\r\n   suggesting that it shone a light on a behaviour change in some other commit\r\n   in between the two.\r\n - Indeed, the true regression came in https://github.com/scala/scala/commit/e5da30b843#L5L3176\r\n - A targeted revert of e5da30b843 is undesirable, as we'd like SI-6846 to stay fixed\r\n\r\nWhat's happening here? In the enclosed test case, higher kinded type\r\ninference explores two possibilities:\r\n\r\n    Composed.this.Split[A]\r\n    K[[T]A[B[T]]]           // `Split[A]` dealiased\r\n\r\nThe difference in the flow of type inference can be seen from the diff\r\nbelow. Notice how now we no longer register `?K.addBound(Composed.this.Split)`,\r\nwe instead only register `?K.addBound(K)`\r\n\r\nReview by @adriaanm @paulp\r\n\r\n```patch\r\n--- sandbox/old.log 2013-05-30 00:27:34.000000000 +0200\r\n+++ sandbox/new.log 2013-05-30 00:28:28.000000000 +0200\r\n@@ -1,55 +1,114 @@\r\n ?K.unifyFull(Composed.this.Split[A])\r\n   ?K.unifySpecific(Composed.this.Split[A])\r\n-  ?K.addBound(Composed.this.Split)\r\n     ?B.unifyFull(T)\r\n       ?B.unifySpecific(T)\r\n       `-> false\r\n     ?B.unifyFull(Any)\r\n       ?B.unifySpecific(Any)\r\n       `-> false\r\n   `-> false\r\n   ?K.unifySpecific(L[[T]A[B[T]]])\r\n-  ?K.addBound(L)\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n+  ?K.addBound(L)\r\n   `-> true\r\n ?K.unifyFull(Composed.this.Split[A])\r\n   ?K.unifySpecific(Composed.this.Split[A])\r\n-  ?K.addBound(Composed.this.Split)\r\n     ?B.unifyFull(x)\r\n       ?B.unifySpecific(x)\r\n       `-> false\r\n   `-> false\r\n   ?K.unifySpecific(L[[T]A[B[T]]])\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n   ?K.addBound(L)\r\n+  `-> true\r\n+?K.unifyFull(Composed.this.Split[A])\r\n+  ?K.unifySpecific(Composed.this.Split[A])\r\n+    ?B.unifyFull(T)\r\n+      ?B.unifySpecific(T)\r\n+      `-> false\r\n+    ?B.unifyFull(Any)\r\n+      ?B.unifySpecific(Any)\r\n+      `-> false\r\n+  `-> false\r\n+  ?K.unifySpecific(L[[T]A[B[T]]])\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n     ?B.unifyFull(B[T])\r\n       ?B.unifySpecific(B[T])\r\n       ?B.addBound(B)\r\n       `-> true\r\n+  ?K.addBound(L)\r\n+  `-> true\r\n+?K.unifyFull(Composed.this.Split[A])\r\n+  ?K.unifySpecific(Composed.this.Split[A])\r\n+    ?B.unifyFull(x)\r\n+      ?B.unifySpecific(x)\r\n+      `-> false\r\n+  `-> false\r\n+  ?K.unifySpecific(L[[T]A[B[T]]])\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+    ?B.unifyFull(B[T])\r\n+      ?B.unifySpecific(B[T])\r\n+      ?B.addBound(B)\r\n+      `-> true\r\n+  ?K.addBound(L)\r\n+  `-> true\r\n+?K.unifyFull(L[A])\r\n+  ?K.unifySpecific(L[A])\r\n+  ?K.addBound(L)\r\n+  `-> true\r\n+?K.unifyFull(L[A])\r\n+  ?K.unifySpecific(L[A])\r\n+  ?K.addBound(L)\r\n   `-> true\r\n```"
2606,'gkossakowski','Test for reading JDK 8 (classfile format 52) class files.\nThis commit includes a test for reading JDK 8 (classfile format 52)\r\nclass files, in particular default (aka defender) methods. It uses ASM\r\nto generate an interface with default methods then exercises that\r\ninterface from Scala.\r\n\r\nSurprisingly no changes are necessary to the Scala code base to support\r\nreading format 52 class files.\r\n\r\nBecause the test can only run under JDK 8, the JDK version is checked\r\nand the expected output is synthesized for previous versions.'
2605,'gkossakowski','SI-7149 Use a WeakHashSet for type uniqueness\nWe have an implementation of WeakHashSet in the compiler but it never cleans up its WeakReferences. The first commit in this PR replaces the implementation with one that does clean up. Along the way it modifies the interface to follow the standard scala.collection.mutable.Set interface so that it can eventually be moved into the main library should we choose to do so.\r\n\r\nCurrently type uniqueness is done via a HashSet[Type], but\r\nthat means the Types live through an entire compile session, even\r\nones that are used once. The result is a huge amount of unnecessarily\r\nretained memory. This commit uses a WeakHashSet instead so that Types\r\nand their WeakReferences are cleaned up when no longer in use.\r\n\r\nFinally, perRunCaches is also updated to use the WeakHashSet instead of a HashSet of WeakReferences because the former was never cleaning up unused WeakReferences.\r\n'
2604,'JamesIry','SI-7523 Deprecate abstract methods without result type\n'
2602,'JamesIry','Add Duration.toCoarsest method\n'
2601,'JamesIry','SI-7516 Revert "SI-7234 Make named args play nice w. depmet types"\nThis reverts commit 83c9c764b528a7a1c1d39c480d22c8e3a71d5a58.\r\n\r\nThe tests are shunted to \'pending\'.\r\n\r\nWhitespace fixes and identifier renaming were not reverted.\r\nWhy revert this seemingly innocous commit? 83c9c76 generates a ValDef whose\r\ntpt TypeTree has no original; this contains a reference to the symbol for `d`.\r\nresetAttrs and the retypecheck assigns a new symbol for d and leaves a the\r\nreference to the prior symbol dangling. The real bug is the resetAttrs concept.\r\n\r\nReview by @paulp'
2599,'JamesIry','constructors phase refactoring for readability\nRebase of #2586.'
2597,'adriaanm','SI-7520 bug in subtyping.\nisSubType, if given two SingleTypes, would check =:= and stop there. It is\nnecessary to continue with weakening the left hand side, because (for\ninstance) the singleton type on the left hand side could be a refinement\nclass carrying parents which are themselves single or constant types.'
2596,'xeno-by',"SI-7519 Less brutal attribute resetting in adapt fallback\nPrefers `resetLocalAttrs` over `resetAllAttrs`. The latter loses\r\ntrack of which enclosing class of the given name is referenced by\r\na `This` node which prefixes the an applied implicit view.\r\n\r\nThe code that `resetAllAttrs` originally landed in: https://github.com/scala/scala/commit/d4c63b#L6R804\r\n\r\nReview by @xeno-by. Let's run it by @odersky, too.\r\n\r\nI wonder: when would a `resetAllAttrs` *ever* be appropriate?"
2592,'retronym','SI-7088 Array crasher in erasure.\nThe usual business where half our pattern matches are missing half the\nnecessary cases.'
2582,'xeno-by','Cache the most recently created SubstTypeMap.\nI discovered that a 1-element cache for SubstTypeMaps gave a 75-90% hit rate.'
2580,'adriaanm','SI-7265 Buy some time to fix s.u.Properties.isJavaAtLeast\n'
2579,'JamesIry',"SI-7502 removing non-existent element from ListMap leaves it unchaged.\nCurrent imperative version constructs a new ListMap regardless of\r\nthe fact the map doesn't contain the element. Replace it with the\r\ntail-recursive variant that conserves. Also replace some usages with\r\nthe invariant now held."
2578,'adriaanm',"SI-6138 Centralize and refine detection of `getClass` calls\n`getClass` is special cased in the compiler; this is described\r\nin in the comments on `Definitions.Any_getClass`.\r\n\r\nPart of this happens in `Typer#stabilize`. This was trying to determine\r\nif an Ident or Select node was a call to `getClass` by merits of the name\r\nof the tree's symbol and by checking that the its type (if it was a\r\nMethodType or PolyType) had no parameters in the primary parameter list.\r\n\r\nOverloaded user defined `getClass` methods confused this check. In the\r\nenclosed test case, the tree `definitions.this.getClass` had an\r\n`OverloadedType`, and such types always report an empty list of `params`.\r\n\r\nThis commit:\r\n\r\n  - changes `stabilize` to use `isGetClass`, rather than the\r\n    homebrew check\r\n  - changes `isGetClass` to consider a `Set[Symbol]` containing all\r\n    `getClass` variants. This moves some similar code from `Erasure`\r\n    to `Definitions`\r\n  - keeps a fast negative path in `isGetClass` based on the symbol's name\r\n\r\nReview by @adriaanm"
2577,'paulp','Backport from paradise/macros\nreview @paulp @retronym'
2563,'JamesIry','SI-7474 Parallel collections: End the exception handling madness\n"What\'s wrong with an API which non-deterministically returns either\r\ntype A or type B(Set(A, ...))?"\r\n\r\nThis is pretty much what the exception handling behavior of the\r\nparallel collections does: If exceptions of type A occur, either an\r\nexception of type A or an exception of type B, wrapping multiple\r\nexceptions of A\'s, are returned.\r\n\r\nThis behavior is incredibly broken and so unintuitive, that even\r\npeople writing tests don\'t handle it correctly.\r\nSee files/run/t5375.scala.\r\n\r\nConcerning “non-deterministic”:\r\nHow many exceptions are observed before the operation is aborted\r\ndepends on the machine, the available cores and hyper-threading,\r\nthe operating system, the threadpool implementation and\r\nconfiguration, the size of the collection and the runtime itself.\r\n\r\nIn fact, files/run/t5375.scala is failing on both jdk7u and Avian\r\nbecause of this issue.\r\n\r\nWith this change, we just pass the "first" exception which occurs.\r\nThis seems to be what C# and Java both do, too.\r\n\r\n“Why don\'t we wrap everything in CompositeThrowables?”\r\nEven consistently returning CompositeThrowable doesn\'t make much\r\nsense (because we have fail-fast behaviour and don\'t wait until\r\nall tasks have finished or have thrown an exception).\r\nTherefore, there is no useful semantic in having a\r\nCompositeThrowable which returns "some" exceptions.\r\n\r\nEither\r\na) gather and return all the exceptions or\r\nb) just return one, instead of wrapping a non-deterministic\r\n   number of exceptions into a completely unrelated wrapper type.\r\n\r\nConsidering that changing the parallel collection semantics in\r\nsuch a profound way as described in a) is out of question, the\r\nsecond option is chosen.\r\n\r\nAs soon as Scala targets Java > 7 Throwable#addSurpressed can be\r\nused to add further exceptions to the one which gets returned.'
2561,'retronym','SI-7479 Make test/files/run/tailcalls.scala pass on Avian\n'
2558,'paulp','SI-5090: Expose the current size of ArrayBuilder\n'
2553,'paulp','SI-7486 regression in implicit resolution.\nWhat a touchy beast the compiler is.'
2546,'xeno-by','SI-7375 ClassTag for value class aliases\nDon\'t know how one could have a "ClassTag" for a type alias; I\'d have thought\nthey would be disallowed by construction.'
2534,'paulp','SI-3943 Test case for already-fixed Java interop bug\nConfirmed that this was fixed in edee27f59.\r\n\r\nReview by @paulp'
2533,'scala-jenkins','SI-6503 Fix doctype, remove processing instructions, ...\n... and add alt attributes to image tags.'
2511,'scala-jenkins','General SIP-14 Future method implementation cleanup\nCleaning up implementations of Future methods to try to keep method size down to allow for easier JIT-ing (smaller method sizes) and increasing code reuse.\r\n\r\nReview by: @adriaanm & @phaller'
2463,'paulp','SI-7429 Fix checkinit build failure in Contexts\nThe recent refactoring in Contexts resulted in an uninitialized\r\nfield access. This wasn\'t deadly, as it was already compensating\r\nfor this by expecting a null value for `outer` during in the body\r\nof the constructor of Contexts when extended by NoContext.\r\n\r\nThis commit reworks that code a little to avoid dereferencing the\r\noverriden `outer` field.\r\n\r\nA similar mistake in `ImportContext` is also corrected.\r\n\r\n```\r\nticket/7429 ~/code/scala find src/compiler/ | grep Contexts | xargs touch\r\nticket/7429 ~/code/scala ant -Dscalac.args="-Xcheckinit"\r\nBuildfile: /Users/jason/code/scala/build.xml\r\n\r\ndesired.jars.uptodate:\r\n\r\nboot:\r\n\r\ninit:\r\n[artifact:dependencies] [WARNING] POM for \'biz.aQute:bndlib:pom:1.43.0:compile\' is invalid.\r\n[artifact:dependencies]\r\n[artifact:dependencies] Its dependencies (if any) will NOT be available to the current build.\r\n     [echo]        build time: 28 April 2013, 12:53:44\r\n     [echo]      java version: Java HotSpot(TM) 64-Bit Server VM 1.6.0_37 (1.6)\r\n     [echo]         java args: -Xmx1612M -Xss2M -server -XX:MaxPermSize=180M\r\n     [echo]        javac args:\r\n     [echo]       scalac args:  -Xcheckinit\r\n     [echo] scalac quick args:  -Xcheckinit\r\n     [echo]          git date: 20130428-125245\r\n     [echo]          git hash: f59be7a783\r\n     [echo]     maven version: 2.11.0-SNAPSHOT\r\n     [echo]      OSGi version: 2.11.0.v20130428-125245-f59be7a783\r\n     [echo] canonical version: 2.11.0-20130428-125245-f59be7a783\r\n...\r\nquick.comp:\r\n[quick.compiler] Compiling 1 file to /Users/jason/code/scala/build/quick/classes/compiler\r\n[quick.compiler] warning: there were 1 feature warning(s); re-run with -feature for details\r\n[quick.compiler] one warning found\r\n[propertyfile] Updating property file: /Users/jason/code/scala/build/quick/classes/compiler/compiler.properties\r\n[stopwatch] [quick.compiler.timer: 11.834 sec]\r\n...\r\n\r\nBUILD SUCCESSFUL\r\nTotal time: 19 seconds\r\nticket/7429 ~/code/scala qbin/scala -e \' "".reverse \'\r\n```\r\n\r\nReview by @paulp.'
2439,'adriaanm',"SI-7369 Avoid spurious unreachable warnings in patterns\nUnreachability analysis draws on the enumerated domain of types\r\n(e.g sealed subclasses + null, or true/false), and also looks at all\r\nstable identifier patterns tested for equality against the same 'slot'\r\nin a pattern.\r\n\r\nIt was drawing the wrong conclusions about stable identifier patterns.\r\nUnlike the domain constants, two such values may hold the same value,\r\nso we can't assume that matching X precludes matching Y in the same\r\nslot in a subsequent case.\r\n\r\nFor example:\r\n\r\n    val X: Boolean = true; val Y: Boolean = true\r\n    def m1(t1: Tuple1[Boolean]) = t1 match {\r\n      case Tuple1(true) =>\r\n      case Tuple1(false) =>\r\n      case Tuple1(false) => // correctly unreachable\r\n    }\r\n    def m2(t1: Tuple1[Boolean]) = t1 match {\r\n      case Tuple1(X) =>\r\n      case Tuple1(Y) => // spurious unreachable warning\r\n    }\r\n\r\n    //\r\n    // Before\r\n    //\r\n    reachability, vars:\r\n    V2: Boolean ::= true | false// Set(false, Y, X, true) // = x1._1\r\n    V1: (Boolean,) ::= null | ... // = x1\r\n    equality axioms:\r\n      V2=true#4  \\/ V2=false#5  /\\\r\n     -V2=false#5 \\/  -V2=Y#3    /\\\r\n     -V2=false#5 \\/  -V2=X#2    /\\\r\n     -V2=false#5 \\/ -V2=true#4  /\\\r\n       -V2=Y#3   \\/  -V2=X#2    /\\\r\n       -V2=Y#3   \\/ -V2=true#4  /\\\r\n       -V2=X#2   \\/ -V2=true#4\r\n\r\n    //\r\n    // After\r\n    //\r\n    reachability, vars:\r\n    V2: Boolean ::= true | false// Set(false, Y, X, true) // = x1._1\r\n    V1: (Boolean,) ::= null | ... // = x1\r\n    equality axioms:\r\n      V2=true#4  \\/ V2=false#5  /\\\r\n     -V2=false#5 \\/ -V2=true#4\r\n\r\nReview by @adriaanm, who diagnosed the problem the other day by harnessing the emanations of the Scala Staircase. (Or was it the coffee?)"
2424,'JamesIry','SI-7399 : Take scala.concurrent.context.maxThreads into account\n'
2419,'paulp','Merge v2.10.1-245-g5147bb2 to master\n... and the 2.11 incarnation of SI-7377, 962f88e.\r\n\r\nReview by @paulp'
2402,'paulp','SI-7377 Fix retypechecking of patterns on case companion alias\nSome ancient code in Typers switches from PATTERNmode to\r\nEXPRmode when encountering `stableF(...)`. It just\r\ntypechecks `stableF` and discards the arguments.\r\n\r\nTo the best of Martin\'s recollection, this has something\r\nto do with the need to typecheck patterns rather late in\r\nthe compiler, after `a.b` had been translated to `a.b()`\r\nin `Uncurry`. I\'m not able to motivate this with tests\r\nusing `-Xoldpatmat`; was there ever an even older pattern\r\nmatcher that ran *after* uncurry?\r\n\r\nWhat changed in 2.10.1 to expose this wrinkle? dfbaaa17\r\nfixed `TypeTree.copyAttrs` to copy the original tree.\r\nDuring the descent of `ResetAttrs`, sub-trees are duplicated\r\nbefore begin further transformed. Duplicating the `Match`\r\nin 2.10.0 would forget that the original tree of:\r\n\r\n    pat = (a: Int)Foo(_)\r\n          `----------`\r\n               `- TypeTree((a: Int)Foo), with original Select(..., "FooAlias")\r\n\r\nThe retypechecking would operate on the `MethodType`, rather\r\nthan the `Select`, which was not considered a stable\r\napplication.\r\n\r\nFor 2.10.x, I\'ve just tightened up the condition to only\r\nhit this if `args` is empty. I\'m almost certain that the code\r\ncan be removed altogether, and I\'ll do that when this is merged\r\nto master.\r\n\r\nReview by @paulp'
2391,'adriaanm','Merge/v2.10.1 235 g4525e92 to master\nThe only notable conflict was from SI-6286 / 67c2d6d.\r\n\r\nReview by @adriaanm'
2383,'paulp','SI-6286 IllegalArgumentException handling specialized method.\nSpecialize assigns SpecialOverride info to a specialized method\r\neven when there is a further specialization that should be forwarded\r\nto.'
2382,'VladUreche','Remove scaladoc deprecated option.\nRemove -external-urls that had been previously deprecated in 2.10.'
2379,'scala-jenkins','SI-7350 Close all pipe threads when destroying a PipedProcess\nThis is a fix for issue 7350'
2374,'retronym','SI-6815 untangle isStable and hasVolatileType\n`Symbol::isStable` is now independent of `Symbol::hasVolatileType`,\r\nso that we can allow stable identifiers that are volatile in ident patterns.\r\n\r\nThis split is validated by SI-6815 and the old logic in RefChecks,\r\nwhich seems to assume this independence, and thus I don\'t think ever worked:\r\n\r\n```\r\nif (member.isStable && !otherTp.isVolatile) {\r\n  if (memberTp.isVolatile)\r\n    overrideError("has a volatile type; cannot override a member with non-volatile type")\r\n```\r\n\r\nIntroduces `admitsTypeSelection` and `isStableIdentifierPattern` in treeInfo,\r\nand uses them instead of duplicating that logic all over the place.\r\n\r\nSince volatility only matters in the context of type application,\r\n`isStableIdentifierPattern` is used to check patterns (resulting in `==` checks)\r\nand imports.\r\n\r\nreview by @retronym & @paulp\r\n\r\nI decided not to backport this to 2.10.x as it may introduce new errors.'
2370,'paulp','SI-7319 Avoid unflushed error/warning buffers in startContext\nWhich can render a REPL inoperable, or doubly report errors in regular compilation.\r\n\r\nI plan to invest some much needed TLC into this area over on master as SI-7345; this PR tries to tread lightly.\r\n\r\nReview by the P-s: @hubertp / @paulp'
2369,'paulp','Read-eval-print : sometimes we do not need print so make it lazy\n'
2368,'lrytz','SI-7335 Simpler bootstrapping the standard library\n - mandate that Predef parents are defined in Predef.scala\r\n - fix bugs / add logging in related code\r\n\r\nReview by @namin (for confirmation that this will be okay for scala-virtualized), and @lrytz'
2366,'gkossakowski',"Merge branch 'master' into java7\n\r\nConflicts:\r\n\tbuild.xml\r\n\r\nAlso removed the warning about Java7 not being able to\r\nbuild the distribution, which doesn't apply to this branch.\r\n\r\nReview by @gkossakowski"
2364,'paulp',"SI-7329 duplicate default getters for specialized parameters.\nThe default getter is generated with @specialized annotation if the\r\ntype parameter corresponding to the type of the parameter is\r\nspecialized. Consequently specialize pass tries to generate overloads.\r\n\r\nRather than pruning overloads to exclude duplicates, let's notice\r\nthat default getter specialization is not needed at all:\r\n  - The dynamic scope of default getter doesn't include specialized\r\n    method or class constructor.\r\n  - generic default getter is called even when calling specialized\r\n    method.\r\n"
2362,'retronym','SI-4695, package object separate compilation.\nThe mechanism being used to notice when a package object\r\nis being compiled from source does not appear to work at all.\r\nI applied a different mechanism, which does appear to.'
2361,'paulp','SI-7337 Error out on missing -d directory.\nThis check was removed without comment in 3a30af154, the addition\r\nof JSR-223 support for the interpreter.\r\n\r\nAfter this commit, I manually tested that JSR-223 support works.\r\n\r\n    scala> import javax.script._, collection.JavaConverters._; val manager = new ScriptEngineManager; manager.getEngineByName("scala").eval("List(1)")\r\n    import javax.script._\r\n    import collection.JavaConverters._\r\n    manager: javax.script.ScriptEngineManager = javax.script.ScriptEngineManager@4418f61b\r\n    res1: Object = List(1)\r\n\r\n3a30af154 did not include a test case, so I don\'t know whether I\'ve\r\nbroken some other aspect of it. I tried the above as a `run` test,\r\nbut hit two problems, one of them seemingly our fault, and the other\r\na MacOS JDK wrinkle.\r\n\r\n  1. scala.reflect.internal.MissingRequirementError: object scala.runtime in compiler mirror not found.\r\n  2. java.lang.UnsatisfiedLinkError: no AppleScriptEngine in java.library.path\r\n\r\nI can\'t find my way to fix these, so JSR-223 remains untested. I don\'t\r\nthink that #2238 was really up to standard; it could handle additional\r\nreview, documentation, and testing. It might even be modularized so as\r\nnot to pollute the REPL itself.\r\n\r\nReview by @paulp'
2360,'phaller','SI-7080 improve boundary value checking for BitSet\nWhen BitSet accepts a very large integer such as Integer.MAX_VALUE,\r\ninteger overflow possibly occurs in the calculation of boundary value\r\n"nwords * WordLength". This faulty boundary condition causes\r\nempty-iterator problem like following:\r\n\r\nscala> import collection.mutable.BitSet\r\nimport collection.mutable.BitSet\r\n\r\nscala> val x = BitSet(Integer.MAX_VALUE)\r\nx: scala.collection.mutable.BitSet = BitSet()\r\n\r\nscala> x.iterator\r\nres0: Iterator[Int] = empty iterator'
2358,'retronym',"SI-7330 better error when pattern's not a value\nSomehow an applied type managed to sneak past the type checker in pattern mode.\r\nPatterns must be values, though.\r\n\r\n`case C[_] =>` was probably meant to be `case _: C[_] =>`\r\nAdvice is dispensed accordingly. (Generalizing the existing advice machinery.)\r\n\r\nreview by @retronym"
2357,'paulp','SI-7331 importers now import tree positions\nThis fixes the problem with toolbox-parsed trees not having positions.'
2344,'dragos',"SI-7147 Diagnostic for unexplained assertion in presentation compiler.\nWe don't have a reproducible test for this, so the best we can\r\ndo is beef up the assertion to shine a little light on the problem.\r\n\r\nReview by @dragos"
2343,'adriaanm','Merge 2.10.x to master\nThe main area of conflict was `build.xml` (refactorings/bug fixes from 2.10.x + modularization from master).\r\n\r\nI merged the MiMa targets into the master `build.xml`, but disabled their execution until 2.11.0.\r\n\r\nReview by @adriaanm'
2342,'adriaanm','SI-7292 Deprecate octal escape literals\n'
2340,'adriaanm','Added a :kind command to the REPL\n### Description\r\nBecause Scala supports working with higher kinded types, we might want to be able to inspects kinds as well as types. This pull request adds a simple `:kind` command, implemented by @eed3si9n in his ["Introduction to Scalaz: day 4"](http://eed3si9n.com/learning-scalaz-day3) post, to the Scala REPL. Here is an example output:\r\n```scala\r\nscala> :kind scala.Option\r\nOption\'s kind is * -> *\r\n\r\nscala> :k scalaz.Unapply\r\nUnapply\'s kind is ((* -> *) -> *) -> * -> *\r\n\r\nscala> import scalaz._\r\nimport scalaz._\r\n\r\nscala> :k Monad // Finds locally imported types.\r\nMonad\'s kind is (* -> *) -> *\r\nThis is a type constructor that takes type constructor(s): a higher-kinded type.\r\n\r\nscala> :k Nonexisting\r\n<console>:14: error: not found: value Nonexisting\r\n              Nonexisting\r\n              ^\r\n\r\nscala> class Foo\r\ndefined class Foo\r\n\r\nscala> new Foo { def empty = true }\r\nres0: Foo{def empty: Boolean} = $anon$1@786aceba\r\n\r\nscala> :k res0\r\nFoo{def empty: Boolean}\'s kind is *\r\n```\r\n### Future improvements\r\nAs pointed out by @retronym [here](https://twitter.com/retronym/status/318343952942125057), variance and type bounds are also part of the kind and we might want to include them in command\'s output.\r\n### Acknowledgements\r\nThe function for `:kind` feature is originally implemented by @eed3si9n \r\nI got a lot of help from @xeno-by and @retronym while working on this feature, thank you for that.\r\n\r\nHappy Easter everyone!'
2338,'paulp','SI-7314 Partest locates tools.jar and javac\nThis commit lets partest locate tools.jar the way REPL does, with\r\nthe addition that java.home.parent is also tried.\r\n\r\nThe partest script will use JAVAC_CMD if set, or else JAVA_HOME, and\r\nwill try the sibling of JAVACMD if set (on the theory that if you specify\r\njava, you are avoiding the path lookup and javac may also be in\r\nthat special place), or else query the path for javac.\r\n\r\nThe use cases are: no env vars, look around java.home; JDK or JAVA_HOME is\r\nset; JAVACMD is set; and finally tools.jar can live in jre/lib/ext and\r\nthe fallback deep search will find it.\r\n\r\nThese cases have been tried on cygwin with Java installed under\r\ns"Program${space}Files", which is usually the most brittle environment.\r\nThat means tested with bash.\r\n\r\nThe windows partest.bat has not been upgraded or side-graded.\r\n\r\nReview by @paulp because he doesn\'t have enough to do already, plus he\'s a pretty snazzy shell scripter'
2337,'JamesIry',"SI-7110 Warn about naked try without catch/finally\nBefore, this was allowed:\r\n\r\n    scala> try ( 1 / 0 )\r\n    java.lang.ArithmeticException: / by zero\r\n\r\nBut since the advent of util.Try, the subtle difference to the\r\nfollowing seems dangerous:\r\n\r\n    scala> import util.Try\r\n    import util.Try\r\n\r\n    scala> Try ( 1 / 0 )\r\n    res4: scala.util.Try[Int] = Failure(java.lang.ArithmeticException: / by zero)\r\n\r\nDiscussion: https://groups.google.com/d/topic/scala-language/fy2vXD_3fF8/discussion\r\n\r\nThere was some concern that this curtails a handy, temporary\r\nway to remove the exception handlers from some code. But after\r\nthinking about this, I contend that:\r\n\r\n a) those people can easily stomach the warning temporarily\r\n    (modulo, of course, those with -Xfatal-warnings.)\r\n b) putting this warning behind Xlint will disable it for those\r\n    who need it most: beginners.\r\n\r\nI also chose not to refer to 'scala.util.Try' in the error message\r\nas I think that has as much potential to confuse as it does to clarify.\r\n\r\nResubmission of #2108; review by @JamesIry, "
2336,'JamesIry','SI-7312 @deprecatedInheritance now ignores same-file subclasses\nThis allows us to deprecate external inheritances as a prelude\r\nto sealing a class, without enduring the warnings ourselved in\r\ninterlude.\r\n\r\nThe `neg` test from SI-6162 has been split into a pos test (subclasses in the same compilation unit), and a neg test (subclasses in a different compilation unit.)\r\n\r\nThis will also silence these recently introduced spurious warnings (SI-7315):\r\n\r\n```\r\nqbin/scalac -deprecation src/library/scala/Tuple*.scala\r\nsrc/library/scala/Tuple1.scala:19: warning: inheritance from class Tuple1 in package scala is deprecated: Tuples will be made final in a future version.\r\ncase class Tuple1[@specialized(Int, Long, Double) +T1](_1: T1)\r\n```\r\n\r\nReview by @JamesIry.'
2335,'paulp','Optimize file metadata access\nBackground: When profiling an application that was using the interpreter to compile\r\na script, a lot of time was reported in `exists`/`isDirectory`/`isFile`. I happened to be profiling on Windows. \r\n\r\nTurns out some of these calls are redundant, this PR eliminate two such places.\r\n\r\nHere\'s an example of how it helps:\r\n\r\nTaking a Hello, Akka! application, and compiling it with the compiler\r\nand library on a directory classpath (ie, using build/quick):\r\n\r\n    class HelloActor extends Actor {\r\n      def receive = {\r\n        case "hello" => println("hello back at you")\r\n        case _       => println("huh?")\r\n      }\r\n    }\r\n\r\n    object Main extends App {\r\n      val system = ActorSystem("HelloSystem")\r\n      // default Actor constructor\r\n      val helloActor = system.actorOf(Props[HelloActor], name = "helloactor")\r\n      helloActor ! "hello"\r\n      helloActor ! "buenos dias"\r\n    }\r\n\r\n    % qbin/scalac -Ystatistics -classpath ~/.ivy2/cache/com.typesafe.akka/akka-actor_2.10/jars/akka-actor_2.10-2.1.1.jar:/Users/jason/.ivy2/cache/com.typesafe/config/bundles/config-1.0.0.jar sandbox/test.scala 2>&1 | grep File\r\n\r\n```\r\nBefore\r\n----------------------------------\r\nFile.isFile calls           : 7620\r\nFile.isDirectory calls      : 8348\r\nFile.exists calls           : 5770\r\n\r\nAfter\r\n----------------------------------\r\nFile.isFile calls           : 7620\r\nFile.isDirectory calls      : 2319\r\nFile.exists calls           : 345\r\n```'
2334,'paulp',"SI-7202 tighten name mangling.\nFollowing the discussion at https://groups.google.com/forum/?fromgroups=#!searchin/scala-internals/mangling/scala-internals/GHC3HJTegmw/5py5GH7Rrm8J\r\nI'm re-submitting the change against master.\r\n\r\nWhen the compiler wants to make private symbol visible outside its\r\ndeclaring class, it also changes the name to make it unique to avoid\r\naccidental overriding.\r\n\r\nThe current scheme prepends fullName of the owner class, which could\r\nstill result in overriding if the derived class is nested in a value\r\ndefinition.\r\n\r\nTo avoid such scenario, name mangling prepends not only the names of\r\nthe enclosing classes, but also '$' characters for val owners that\r\naren't synthetic.\r\n\r\nThis scheme wouldn't be enough if the base class were local as well,\r\nand the derived class saw it with a non-trivial prefix type; however\r\nscala doesn't allow it.\r\n\r\nMaking this change required unification between normal 'fullName'\r\nand the one used for name mangling. Using the opportunity, I also\r\nclean the implementation of fullName to make recurring local, that\r\nis a speedup over the late-bound call currently."
2325,'gkossakowski',"SI-7186 Slim down some TypeRefs by 8 bytes.\nBy virtue of being defined in object TypeRef, they\r\nhad two outer pointers.\r\n\r\n    $outer  scala.reflect.internal.Types$TypeRef$\r\n    $outer  scala.tools.nsc.Global\r\n\r\nThis commit moves them out of that object. They also\r\nnow are no longer shrouded in anonymity, which is\r\npleasant when debugging and profiling.\r\n\r\nThe shallow size leaderboard now looks like:\r\n\r\n```\r\n   Class             % Shallow  % Objects\r\n                          Size\r\n-----------------------------------------\r\n1. ::                      14%        25%\r\n2. char[]                  10% a       5%\r\n3. ClassArgsTypeRef         6%         5%\r\n4. Object[]                 6% b       1%\r\n5. TypeHistory              5%         6%\r\n6. AbstractTypeSymbol       4%         2%\r\n7. AbsractNoArgsTypeRef     3%         2%\r\n8. j.l.Class                3%         2%\r\n9. TermSymbol               2%         1%\r\n10. HashEntry               1% c       1%\r\n```\r\na) 6% of the char[] by size is the name table.\r\n   Retained source code seems to be sizable => should we discard after parsing?\r\nb) Types.uniques\r\nc) ZipArchive#DirEntry.entries\r\n\r\nConfirmation of the slimmer size can be seen in:\r\n\r\n  https://github.com/retronym/scala/compare/ticket/7186\r\n\r\nIn that branch, I introduced infrastructure to query JVM\r\nobject size in instrumented tests, and the diff shows:\r\n\r\n```patch\r\n       size                class instance\r\n ========================================================================\r\n-  64 bytes  internal.Types$TypeRef$$anon$5 List[Int]\r\n-  64 bytes  internal.Types$TypeRef$$anon$6 String\r\n+  56 bytes  nternal.Types$ClassArgsTypeRef List[Int]\r\n+  56 bytes  ernal.Types$ClassNoArgsTypeRef String\r\n```\r\n\r\nI chose not to bring that test infrastructure across to master so as\r\nnot to burden us with brittle tests built on esoteric facilities.\r\n\r\nThis does not close the ticket which proposes a different\r\nspace optimization which is also explored in that branch,\r\nbut no a clear cut improvement.\r\n\r\nReview by @gkossakowski (if you're up to it) or @paulp"
2323,'JamesIry',"Iterator.++ no longer blows the stack.\nTo my chagrin we still hadn't gotten this one. I took a new\r\napproach which seems like a winner to me. Here's a benchmark:\r\n\r\n```\r\nobject Test {\r\n  def run(n: Int) = println((1 to n).foldLeft(Iterator.empty: Iterator[Int])((res, _) => res ++ Iterator(1)) sum)\r\n  def main(args: Array[String]): Unit = run(args(0).toInt)\r\n}\r\n```\r\n\r\nRuntime before this commit for various n:\r\n\r\n  500   0.403 real\r\n  1000  0.911 real\r\n  1500  2.351 real\r\n  2000  5.298 real\r\n  2500 10.184 real\r\n\r\nRuntime after this commit, same n:\r\n\r\n  500  0.346 real\r\n  1000 0.359 real\r\n  1500 0.368 real\r\n  2000 0.379 real\r\n  2500 0.390 real\r\n\r\nIn the test case I dial it up to 100000."
2322,'adriaanm','SI-7200 Test case for fixed type inference error.\nBroken in 2.9.2 and 2.10.0, but working in 2.10.1\r\n\r\n```patch\r\n--- sandbox/2.10.0.log\r\n+++ sandbox/2.10.1.log\r\n       def coflatMap[A >: Nothing <: Any, B >: Nothing <: Any](f: Test.Nel[A] => B): Test.Nel[A] => Test.Nel[B] = ((l: Test.Nel[A]) => Test.this.Nel.apply[B](f.apply(l), l.tail match {\r\n         case immutable.this.Nil => immutable.this.Nil\r\n-        case (hd: A, tl: List[A])scala.collection.immutable.::[A]((h @ _), (t @ _)) => {\r\n-          val r: Test.Nel[Nothing] = NelFoo.this.coflatMap[A, Nothing](f).apply(Test.this.Nel.apply[A](h, t));\r\n+        case (hd: A, tl: List[A])scala.collection.immutable.::[?A1]((h @ _), (t @ _)) => {\r\n+          val r: Test.Nel[B] = NelFoo.this.coflatMap[A, B](f).apply(Test.this.Nel.apply[A](h, t));\r\n           {\r\n-            <synthetic> val x$1: Nothing = r.head;\r\n-            r.tail.::[Nothing](x$1)\r\n+            <synthetic> val x$1: B = r.head;\r\n+            r.tail.::[B](x$1)\r\n           }\r\n         }\r\n       }))\r\n```\r\n\r\nb74c33eb86 represents the exact moment of progression. Comments\r\nin pos/t7200b.scala, a minimal test that demonstrates the problem\r\nwithout type constructors or code execution, pinpoint the line of\r\ncode responsible for the fix.\r\n\r\nIncidentally, I\'m currently on a train somewhere between Solothurn\r\nand Biel, and am consequently without the power of scala-bisector.\r\nUndeterred, and inspired by a line I saw in Skyfall last night\r\n("sometimes the olds ways are better"), I just pulled off a two-hop\r\nbisection. Take that, O(log N)!\r\n\r\nThe one remaining worry is the appearance of the type variable\r\n?A1 in the output of -Xprint:typer for run/t7200.scala.\r\n\r\nReview by @lrytz'
2319,'paulp','SI-6793 Don\'t use super param accessors if inaccessible.\n"Alias replacement" has been with us since 2005 (13c59adf9).\r\n\r\nGiven:\r\n\r\n    package a {\r\n      class C1(val v0: String)\r\n      class C2(v1: String) extends a.C1(v1) { v1 }\r\n    }\r\n\r\nThe reference to `v1` is rewritten as `C2.super.v0()`, and\r\nno field is generated in `C2`.\r\n\r\n(Oddly, this optimization doesn\'t seem to kick in if\r\nthese classes are in the empty package. That\'s probably\r\na distinct bug.)\r\n\r\nHowever, this rewriting is done without consideration of\r\nthe accessibility of `v0` from `C2`.\r\n\r\nThis commit disables this optimization if there if `v0` is\r\nnot accessible.\r\n\r\nReview by @paulp. The accessibility checking mechanism is a bit clunky, any better suggestions.'
2318,'adriaanm','[forward port] SI-7259 Fix detection of Java defined Selects\nThe fix for SI-3120, 3ff7743, introduced a fallback within\r\n`typedSelect` that accounted for the ambiguity of a Java\r\nselection syntax. Does `A.B` refer to a member of the type `A`\r\nor of the companion object `A`? (The companion object here is a\r\nfiction used by scalac to group the static members of a Java\r\nclass.)\r\n\r\nThe fallback in `typedSelect` was predicated on\r\n`context.owner.enclosingTopLevelClass.isJavaDefined`.\r\nHowever, this was incorrectly including Select-s in top-level\r\nannotations in Scala files, which are owned by the enclosing\r\npackage class, which is considered to be Java defined. This\r\nled to nonsensical error messages ("type scala not found.")\r\n\r\nInstead, this commit checks the compilation unit of the context,\r\nwhich is more direct and correct. (As I learned recently,\r\n`currentUnit.isJavaDefined` would *not* be correct, as a lazy type\r\nmight complete a Java signature while compiling some other compilation\r\nunit!)\r\n\r\nA bonus post factum test case is included for SI-3120.\r\n\r\n**Manual forward port of f046853 which was not merged as\r\npart of the routine 2.10.x to master merge.** The test case\r\nuncovered a NullPointerExceptiion crasher in annotation\r\ntypechecking introduced in 5878099c; this has been prevented\r\nwith a null check.\r\n\r\nConflicts:\r\n\tsrc/compiler/scala/tools/nsc/typechecker/Typers.scala\r\n\r\nReview by @adriaanm'
2317,'adriaanm','[forward-port] SI-7232 Fix Java import vs defn. binding precendence\nJava Spec:\r\n> A single-type-import declaration d in a compilation unit c\r\n> of package p that imports a type named n shadows, throughout\r\n> c, the declarations of:\r\n>   - any top level type named n declared in another compilation\r\n>     unit of p\r\n>   - any type named n imported by a type-import-on-demand\r\n>     declaration in c\r\n>   - any type named n imported by a static-import-on-demand\r\n>     declaration in c\r\n\r\nScala Spec:\r\n> Bindings of different kinds have a precedence deﬁned on them:\r\n>   1. Deﬁnitions and declarations that are local, inherited, or made\r\n>      available by a package clause in the same compilation unit where\r\n>      the deﬁnition occurs have highest precedence.\r\n>   2. Explicit imports have next highest precedence.\r\n\r\n**This is a forward port of 6e79370, which did not merge cleanly\r\nand was omitted in the regular merge from 2.10.x to master.**\r\n\r\nConflicts:\r\n\tsrc/compiler/scala/tools/nsc/typechecker/Typers.scala\r\n\r\nReview by @adriaanm'
2312,'adriaanm','SI-6815 Loosen definition of stability in stable ID patterns\nBefore, a stable identifier pattern was vetted by `isStable`,\r\nwhich delegates to `isExprSafeToInline`. This requires that\r\nthe result type of the expression is non-volatile.\r\n\r\nBut, according to @adriaanm, while "it\'s unsound to select\r\ntypes on a prefix with a volatile type", it "should be fine\r\nto compare it for equality."\r\n\r\nThe infrastructure to perform the looser check was already\r\nin place for reporting stability errors; this commit employs\r\nit when checking stability of patterns.\r\n\r\nThe enclosed `neg` test shows that this doesn\'t overreach:\r\ntype selections are still disallowed.\r\n\r\nReview by @adriaanm'
2311,'adriaanm','An IntelliJ Module for the recently modularized REPL.\nReview by @adriaanm'
2310,'dragos',"SI-6168 Retain prefix when parsing types in JVM signatures\nWhen reading Java classfiles, the generic signatures are\r\nused to construct the corresponding Scala type signatures.\r\n\r\nIn the enclosed test case, the field `SomeClass.f` had\r\nthe JVM signature:\r\n\r\n    LContext<LSomeClass;>.Field<Ljava.lang.Integer;>;\r\n\r\nThe parser first (correctly) parsed the prefix as `Context[SomeClass]`.\r\nIt then looked up the type symbol for `Field` in that that type. It then\r\ndiscarded the parsed prefix, and instead used the prefix from the\r\ninfo of the type symbol: `Context[ParentType]`.\r\n\r\nThis commit changes the signature parser after the first `.` to\r\nuse the result of prior parsing as the prefix.\r\n\r\nI've also included a test case with Java static inner classes,\r\nwhich don't require any special treatment.\r\n\r\nReview by @dragos (picked on account of earlier work in the area 2ea6916)\r\n\r\nNote that partest exercises both the java source parser and classfile reader.\r\n\r\n```\r\nIn practice, this happens in 3 steps:                                                                         \r\nSTEP1: Feed all the files to scalac if there are also non-Scala sources.                                      \r\n       It will parse java files and obtain their expected signatures and generate bytecode for scala files    \r\nSTEP2: Feed the java files to javac if there are any.                                                         \r\n       It will generate the bytecode for the java files and link to the scalac-generated bytecode for scala   \r\nSTEP3: (Re-)compile the scala sources so they link to the correct                                             \r\n       java signatures, in case the signatures deduced by scalac from the source files were wrong. Since the  \r\n       bytecode for java is already in place, we only feed the scala files to scalac so it will take the      \r\n       java signatures from the existing javac-generated bytecode.                                            \r\n       Note that no artifacts are deleted before this step.                                                   \r\n```\r\n\r\nTargeting at `master` rather than `2.10.x` as there is a (small) chance that this improvement will silently change the meaning of some existing code; we will now infer the correct specific types for calls to such methods, which could affect subsequent overload resolution etc."
2309,'retronym','Use AnyVal to optimize TailCalls.scala \nNow there is no more indirect reference.'
2308,'JamesIry','SI-6654 & SI-7005 - Map#filterKeys and Map#mapValues not serializable\nFixes SI-6654\r\nFixes SI-7005\r\n\r\nReview by @axel22\r\nReview by @rkuhn'
2306,'scala-jenkins','SI-7299 Improve error message for eta-expanding 23+ param method\nBefore, we got `error: missing arguments for method f`.\r\n\r\nReview by @szeiger'
2304,'retronym','Fix typos in build.xml\nfollow up on #2290/#2295'
2303,'JamesIry','Correct sorting example for Ordering in scaladoc\n### Sorting example for Ordering in scaladoc corrected\r\n\r\n\r\nOrdering example code for\r\n```scala\r\nSorting.quickSort(pairs)(Ordering.by[(String, Int, Int), Int](_._2)\r\n```\r\n\r\nshould be fixed like below    \r\n```scala\r\nSorting.quickSort(pairs)(Ordering.by[(String, Int, Int), Int](_._2))\r\n```'
2299,'lrytz',"SI-7294 Towards finality for TupleN\n - Treat TupleN as final under -Xfuture for static analysis\r\n - Deprecate inheritance from TupleN.\r\n\r\nReview by @lrytz @paulp (it's a change to a core class, so a few opinions are needed.)"
2298,'paulp','SI-6900 Tail call elimination + dependent method type crasher\nOnly the last commit is behaviour changing.\r\n\r\nAttempted to fix this with finesse, but ended up using a localised sledgehammer.\r\n\r\nReview by @paulp'
2297,'paulp',"SI-7261 BooleanSetting to Boolean conversion\nAdd an implicit for BooleanSetting to Boolean, since while we never expect the Spanish Inquisition, we do expect a boolean in an if clause.\r\n\r\nThe first cut put the implicit at AbsScalaSettings, but the more general case is at reflect/internal's MutableSettings. There was no particular desire to privilege mutability.\r\n\r\nThere is an additional implicit to convert BooleanSetting to BooleanFlag, in the second commit. Maybe you knew there was a BooleanFlag.\r\n\r\nThe second commit tries to be minimalist, just to 6x the .value. There are two or three spots where an expression has been restructured, but no intentional changes in behavior.\r\n\r\nThis PR is a rebase and resubmit of https://github.com/scala/scala/pull/2272.\r\n\r\nReview by @paulp who liked the idea and @retronym who has already egged on.\r\n"
2294,'adriaanm','SI-7289 Discard ill-kinded type constraints during inference\nLet\'s disect the reported test case.\r\n\r\nDefine the first implicit:\r\n\r\n    scala> trait Schtroumpf[T]\r\n    defined trait Schtroumpf\r\n\r\n    scala> implicit def schtroumpf[T, U <: Coll[T], Coll[X] <: Traversable[X]]\r\n         |     (implicit minorSchtroumpf: Schtroumpf[T]): Schtroumpf[U] = ???\r\n    schtroumpf: [T, U <: Coll[T], Coll[X] <: Traversable[X]](implicit minorSchtroumpf: Schtroumpf[T])Schtroumpf[U]\r\n\r\nCall it explicitly => kind error during type inference reported.\r\n\r\n    scala> schtroumpf(null): Schtroumpf[Int]\r\n    <console>:10: error: inferred kinds of the type arguments (Nothing,Int,Int) do not conform to the expected kinds of the type parameters (type T,type U,type Coll).\r\n    Int\'s type parameters do not match type Coll\'s expected parameters:\r\n    class Int has no type parameters, but type Coll has one\r\n                  schtroumpf(null): Schtroumpf[Int]\r\n                  ^\r\n    <console>:10: error: type mismatch;\r\n     found   : Schtroumpf[U]\r\n     required: Schtroumpf[Int]\r\n                  schtroumpf(null): Schtroumpf[Int]\r\n                            ^\r\n\r\nAdd another implicit, and let implicit search weigh them up.\r\n\r\n    scala> implicitly[Schtroumpf[Int]]\r\n    <console>:10: error: diverging implicit expansion for type Schtroumpf[Int]\r\n    starting with method schtroumpf\r\n                  implicitly[Schtroumpf[Int]]\r\n                            ^\r\n\r\n    scala> implicit val qoo = new Schtroumpf[Int]{}\r\n    qoo: Schtroumpf[Int] = $anon$1@c1b9b03\r\n\r\n    scala> implicitly[Schtroumpf[Int]]\r\n    <crash>\r\n\r\nImplicit search compares the two in-scope implicits in `isStrictlyMoreSpecific`,\r\nwhich constructs an existential type:\r\n\r\n  type ET = Schtroumpf[U] forSome { type T; type U <: Coll[T]; type Coll[_] <: Traversable[_] }\r\n\r\nA subsequent subtype check `ET <:< Schtroumpf[Int]` gets to `withTypeVars`, which\r\nreplaces the quantified types with type variables, checks conformance of that\r\nsubstitued underlying type against `Schtroumpf[Int]`, and then tries to solve\r\nthe collected type constraints. The type var trace looks like:\r\n\r\n    [    create] ?T                       ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [    create] ?U                       ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [    create] ?Coll                    ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [   setInst] Nothing                  ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], T=Nothing )\r\n    [   setInst] scala.collection.immutable.Nil.type( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], U=scala.collection.immutable.Nil.type )\r\n    [   setInst] =?scala.collection.immutable.Nil.type( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], Coll==?scala.collection.immutable.Nil.type )\r\n    [    create] ?T                       ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [   setInst] Int                      ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], T=Int )\r\n    [    create] ?T                       ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [    create] ?U                       ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [    create] ?Coll                    ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]] )\r\n    [   setInst] Nothing                  ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], T=Nothing )\r\n    [   setInst] Int                      ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], U=Int )\r\n    [   setInst] =?Int                    ( In Test#schtroumpf[T,U <: Coll[T],Coll[_] <: Traversable[_]], Coll==?Int )\r\n\r\nThe problematic part is when `?Int` (the type var originated from `U`) is registered\r\nas a lower bound for `Coll`. That happens in `solveOne`:\r\n\r\n    for (tparam2 <- tparams)\r\n      tparam2.info.bounds.hi.dealias match {\r\n        case TypeRef(_, `tparam`, _) =>\r\n          log(s"$tvar addLoBound $tparam2.tpeHK.instantiateTypeParams($tparams, $tvars)")\r\n          tvar addLoBound tparam2.tpeHK.instantiateTypeParams(tparams, tvars)\r\n        case _ =>\r\n      }\r\n\r\nThis commit changes `addHiBound` and `addLoBound` to discard non higher-kinded\r\nbounds for higher-kinded type variables.\r\n\r\nReview by @adriaanm\r\n\r\nThis is more of a review request than a pull request, I think more test cases are needed, and would appreciate your ideas there.\r\n\r\nThis didn\'t crash prior to c800d1fec (implicit search failure was correctly reported), but I don\'t know exactly why.'
2293,'adriaanm','SI-6210 Test case for already-fixed pattern matcher bug\nThe fix arrived in SI-6022 / #1100 / 2.10.0-M7.\r\n\r\nReview by @adriaanm.\r\n\r\n```\r\n% RUNNER=scalac scala-hash v2.10.0-M7~26 -Xfatal-warnings test/files/pos/t6210.scala\r\n[warn] v2.10.0-M7 failed, using closest available\r\n[info] 07f942971a => /Users/jason/usr/scala-v2.10.0-M6-214-g07f9429\r\ntest/files/pos/t6210.scala:15: error: unreachable code\r\n      case AConstBool(v: Boolean) => TBool()\r\n                                          ^\r\none error found\r\n% RUNNER=scalac scala-hash v2.10.0-M7~25 -Xfatal-warnings test/files/pos/t6210.scala\r\n[info] v2.10.0-M7 => /Users/jason/usr/scala-v2.10.0-M6-219-gd1bdafa\r\n```'
2292,'adriaanm','SI-7285 Fix match analysis with nested objects\nThe fix for SI-6146 introduced `nestedMemberType` to\r\nfigure out set of the sealed subtypes based on the\r\n(prefixed) type of the scrutinee and the symbols of its\r\nsealed subclasses. That method needed to widen\r\n`ThisType(modSym)`s to `ModuleTypeRef(modSym)` before\r\ncalling `asSeenFrom`.\r\n\r\nHowever, this could lead to the sealed subtypes being\r\n`ModuleTypeRef`s were not =:= to the singleton type on the module.\r\nThe pattern matcher analysis treated them as distinct, and spurious\r\nwarnings ensued.\r\n\r\nThis commit makes two changes:\r\n\r\n - conditionally re-narrow the result of `asSeenFrom` in `nestedMemberType`.\r\n - present `a.b.SomeModule.type` as `SomeModule` in warnings emitted\r\n   by the pattern matcher.\r\n\r\nReview by @adriaanm'
2291,'adriaanm','SI-7290 Discard duplicates in switchable alternative patterns.\nThe pattern matcher must not allow duplicates to hit the\r\nbackend when generating switches. It already eliminates then\r\nif they appear on different cases (with an unreachability warning.)\r\n\r\nThis commit does the same for duplicated literal patterns in an\r\nalternative pattern: discard and warn.\r\n\r\nReview by @adriaanm'
2289,'adriaanm','Name logic consistency\nReview by @adriaanm'
2288,'scala-jenkins',"SI-6387 Clones accessor before name expansion\nWhen a symbol's name is expanded due to a conflict during mixin\r\ncomposition (e.g. multiple traits with same-named members, but\r\nwhich are not both visible at the language level in the concrete\r\nclass) the compiler renames some symbols with expanded names which\r\nembed the name of the declaring class to avoid clashes.\r\n\r\nIn the rare cases when the accessor overrides the member in base\r\nclass, such expansion either results in AbstractMethodError when\r\nthe base method is abstract, or, even worse, can change the\r\nsemantics of the program.\r\n\r\nTo avoid such issues, we clone the accessor symbol, clear its\r\nACCESSOR flag and enter the symbol with an unchanged name."
2287,'JamesIry','SI-7102 Override isEmpty for bitsets with an efficient implementation \nrather than use default checking for size == 0.'
2285,'adriaanm','Remove unrecognized doc comments\nDoc -> C-style comments for local symbols to avoid "discarding unmoored doc comment" warning when building distribution for scala itself.'
2284,'retronym','SI-6898 Document AnyVal box and unbox implemention by BoxesRunTime\n* Added `@boxRunTimeDoc@` and `@unboxRunTimeDoc@` tokens to `AnyVals`\r\n* Doc comments refer to [BoxesRunTime.java](https://github.com/scala/scala/blob/master/src/library/scala/runtime/BoxesRunTime.java) in the Scala repo\r\n* No comment for `Unit`'
2283,'retronym',"fixes the craziness in JavaUniverse.log\nThis long-standing, but trivial to fix nuisance in the implementation of\r\nruntime reflection actively avoided being fixed in both 2.10.0 and 2.10.1.\r\n\r\nIt's finally the time to put it to a rest."
2282,'paulp','SI-7271 fixes positions of string interpolation parts\nPositions of static parts are now set explicitly during parsing rather\r\nthan filled in wholesale during subsequent atPos after parsing.\r\n\r\nI also had to change the offsets that scanner uses for initial static\r\nparts of string interpolations so that they no longer point to the\r\nopening double quote, but rather to the actual beginning of the part.'
2281,'paulp','SI-6715 Scaladoc: Use an encoded name if a decoded name is ""\nIn Scala, we can define a method named "$$" but Scaladoc couldn\'t treat\r\nthe method correctly because the decoded name of the method was "".'
2279,'heathermiller',"SI-7013 Scaladoc: Fix StackOverflowError\nNo one see the result value of parse and if so, it's tail-recursive."
2278,'heathermiller','SI-6580 Scaladoc: Should not close void elements\nBecause it will generate a useless element like "\\</img>".\r\n\r\nTo made matters worse, Scaladoc used to generate the element with\r\nattributes (like \\</img src="...">). That\'s why we had SI-6580.'
2276,'paulp','an amazing discovery made by Iulian\nTraces were stalling macro expansions by evaluating messages even when\r\n-Ymacro-debug-* flags were disabled.'
2275,'adriaanm','SI-7265 Future-proof Properties.isJavaAtLeast\n'
2274,'JamesIry','SI-5699 correct java parser for annotation defs.\nCorrect java source parser not to insert a constructor with the type of its <b>value</b> method.\r\n\r\nTarget 2.10.x since the current behavior affects java interop in e.g. scaladoc, see\r\nhttps://issues.scala-lang.org/browse/SI-5684.'
2273,'paulp','SI-6387 Copy overriding accessor when expanding its name\nWhen the compiler wants to make certain symbol accessible, it elevates the symbol \r\nwith otherwise private visibility and expands its name to append the full name of \r\ncontaining class to avoid clashes.\r\n\r\nIn the rare cases when the accessor overrides the member in base class, such \r\nexpanding either results in AbstractMethodError when the base method is abstract, or, \r\neven worse, can change the semantics of the program.\r\n\r\nTo avoid such issues, we clone the accessor symbol, clear its ACCESSOR flag and enter the symbol with an unchanged name.\r\n\r\nThis change only adds lost overridden methods, so the PR targets 2.10.x'
2272,'retronym',"SI-7261 BooleanSetting to Boolean conversion\nAdd an implicit for BooleanSetting to Boolean, since while we never expect the Spanish Inquisition, we do expect a boolean in an if clause.\r\n\r\nThe first cut put the implicit at AbsScalaSettings, but the more general case is at reflect/internal's MutableSettings.  There was no particular desire to privilege mutability.\r\n\r\nThere is an additional implicit to convert BooleanSetting to BooleanFlag, in the second commit.  Maybe you knew there was a BooleanFlag.\r\n\r\nThe second commit tries to be minimalist, just to 6x the `.value`.  There are two or three spots where an expression has been restructured, but no intentional changes in behavior.\r\n\r\nReview by @paulp who liked the idea and @retronym who has already egged on."
2271,'adriaanm',"Reduce duplication and increase verbosity in MiMa execution.\nThis helps to see whether we've broken forward or backward\r\nbinary compatibility.\r\n\r\nFurther duplication could be eradicated with Ant 1.8.0 [`local`](http://ant.apache.org/manual/Tasks/local.html) properties, but we currently only require 1.7.0.\r\n\r\nReview by @JamesIry"
2270,'scala-jenkins',"SI-7246 Make $outer pointer elision Java aware\nIn e0853b3, a space-saving optimization elided the outer pointer\r\nof inner classes if the the (protected) outer pointer of the\r\nimmediate parent class was guaranteed to point to the same instance.\r\n\r\nBut, this check failed to account for Java parent classes, which\r\ndon't follow the Scala scheme. This commit disables the optimization\r\nin that case.\r\n\r\nThe original test case in e0853b3 was anemic, I've fleshed it out to:\r\n\r\n  - test the presense or absense of $outer pointers with Java reflection\r\n  - test the optimization works in the presense of aliased and annotated\r\n    aliased types. (The former worked already, the latter required a\r\n    change to the implementation.)\r\n  - Test the negative case when the prefixes don't line up and the\r\n    subclass in fact needs its own $outer.\r\n\r\nThis patch is based on work by Euguene Vigdorchik with some\r\nadditions by Jason Zaugg.\r\n\r\nTargeted at 2.10.x because this the change is binary compatible other than the rare case of extending an annotated type. We don't do that ourselves, and could rely on MiMa to tell us if we do. (For a Java defined parent class, as shown in the enclosed test, the compiler used to crash.)\r\n\r\nReview by @vigdorchik\r\n\r\nSupersedes #2256"
2269,'JamesIry','SI-7259 Fix detection of Java defined Selects\nThe fix for SI-3120, 3ff7743, introduced a fallback within\r\n`typedSelect` that accounted for the ambiguity of a Java\r\nselection syntax. Does `A.B` refer to a member of the type `A`\r\nor of the companion object `A`? (The companion object here is a\r\nfiction used by scalac to group the static members of a Java\r\nclass.)\r\n\r\nThe fallback in `typedSelect` was predicated on\r\n`context.owner.enclosingTopLevelClass.isJavaDefined`.\r\nHowever, this was incorrectly including Select-s in top-level\r\nannotations in Scala files, which are owned by the enclosing\r\npackage class, which is considered to be Java defined. This\r\nled to nonsensical error messages ("type scala not found.")\r\n\r\nInstead, this commit checks the compilation unit of the context,\r\nwhich is more direct and correct. (As I learned recently,\r\n`currentUnit.isJavaDefined` would *not* be correct, as a lazy type\r\nmight complete a Java signature while compiling some other compilation\r\nunit!)\r\n\r\nA bonus post factum test case is included for SI-3120.\r\n\r\nReview by @JamesIry'
2268,'paulp','removes duplication in FreeDef extractors\n'
2266,'retronym','SI-7251, compiler crash with $.\nWe don\'t need to assert our way out of tight spots, we can issue\r\nan error. Or so I once thought.\r\n\r\nIt turns out lots of assertions have been disappearing before\r\nbeing heard thanks to "case t: Throwable". Under such conditions,\r\na failed assertion is a no-op, but an error is an error.\r\n\r\nThe crash associated with SI-7251 is best avoided by removing the\r\nassertion, which allows an error to be issued in the normal course\r\nof events.\r\n\r\nIn the course of trying to figure out the above, I cleaned up\r\nClassfileParser somewhat.'
2265,'paulp','script engine : better binding mechanism + reflexive access through bound variable "engine"\n'
2264,'adriaanm','SI-7253: respect binary compatibility constraints\nFrom the JLS one can prove that moving a method to a superclass is a binary\r\ncompatible change, both forward and backward. That\'s because when compiling a\r\nmethod call `c.foo()`, where c: C, the output descriptor *must* refer to `C` and\r\nnot to the class where `foo()` is actually defined.\r\n\r\nThis patch just ensures that, and adds a test comparing generated descriptors\r\nagainst the Javac output.\r\n\r\nThe sample code is from Paul Philipps, the fix and the bytecode comparison code\r\nfrom me.\r\n\r\nFrom 2006 (9954eafffd5e60676238369ab0ed5797c92b4a7b, a fix for bug 455 in the\r\nold bug tracker, http://www.scala-lang.org/sites/default/files/aladdin/displayItem.do%3Fid=455.html) until 2.9, Scalac has followed this rule "often" (that is, when C is *not* an interface).\r\n\r\nThis behavior was wrong, but the bug was hard to trigger. AFAICS, this can\r\ncreate problems only when moving a method to a super interface in a library and\r\nexpecting forward binary compatibility - that is, compiling some Scala client\r\ncode against the new version of the library, and trying to run this code against\r\nthe old version of the library. This change grows an interface, so it is valid\r\nonly if clients are supposed to *not* implement the library.  Apparently, this\r\nis so rare that nobody noticed.\r\n\r\nSince 2.10 (0bea2ab5f6b211a83bbf14ea46fe57b8163c6334), Scalac follows this rule\r\n*only* when C is an interface (I assume by oversight, since the main change was\r\nan accessibility check), so the bug was finally triggered.\r\n\r\nThe new code will have to emit INVOKEINTERFACE instead of INVOKEVIRTUAL a bit\r\nmore often, compared to 2.9 (but not to 2.10). I don\'t know whether\r\nINVOKEINTERFACE is noticeably slower (it shouldn\'t be); but this is the safest\r\nfix since this behavior is mandated by the JLS.\r\nIf somebody disagrees and believes the 2.9 is significantly faster, IMHO he\r\nshould send a separate pull request (although ProGuard is probably a better\r\nplace for the change).\r\n\r\nPlease let me know if I missed some other duplicated backend - the code I changed is identical in GenASM and GenJVM.\r\n\r\nReview by @paulp, @JamesIry (who discussed the bug) or @dragos (who wrote the original code in 2005-2006 and is responsible for the backend).'
2262,'JamesIry','removed a redundant var in JavaWriter.flagsToStr\nthe variable x was assigned to, but was never used.'
2261,'scala-jenkins',"SI-7258 Don't assume order of reflection values in t6223\ntest/files/run/t6223's check file expects a specific\r\nordering of the reflected values. The ordering is not\r\nguaranteed by the runtime/reflection API and can change.\r\n\r\nTherefore, sort the values before comparing them."
2260,'paulp','SI-5717 error when bytecode cannot be written\nIf there\'s an existing file foo when emitting a class file for foo.Bar,\r\nthen emit an error at foo.Bar, similar to what javac does.\r\n\r\nThe error message looks something like:\r\n\r\nfoo.scala:4: error: error writing object Foo: ./mypkg/Foo.class: ./mypkg is not a directory\r\n\r\nThis is a non-destructive version of https://github.com/scala/scala/pull/1746\r\n\r\nIt\'s worth quoting https://github.com/scala/scala/pull/2258\r\n\r\n"We don\'t need to assert our way out of tight spots, we can issue an error."\r\n\r\nReview by @paulp who went this way before.\r\n'
2259,'paulp','SI-6123: -explaintypes should not explain errors which won\'t be reported, new attempt\n-explainTypes means that only type tests which fail should be reported in more\r\ndetail by using explainTypes. Hence, callers of explainTypes should check if\r\ntype errors are being ignored, by checking context.reportErrors. Hence, this\r\ncheck is added to Inferencer, and another call site is redirected to that\r\nmethod.\r\n\r\nNote that this patch does not fix all occurrences, but only the ones which\r\nshowed up during debugging. The other ones never cause problems, maybe because\r\nthey occur when contextErrors is in fact guaranteed to be true. We might want to\r\nfix those ones anyway.\r\n\r\nCompared to the old request (https://github.com/scala/scala/pull/1940), I added some tests. However, these tests will become fully effective only once SI-7003 is finally fixed - right now there\'s no way of testing this, especially not of saying "for a compiling program, `-explaintypes` should add no extra output".\r\n\r\nReview by @hubertp.\r\nRefs #6123\r\nbackport to 2.10.x'
2257,'paulp',"Read version 51 (JDK 7) class files.\nThis commit makes the ClassFileReader/ICodeReader parse class files\r\nfrom JDK 7 (class file version 51). It does that by skipping over\r\nthe method handle related entries in the constant pool and by doing\r\nsome dummy processing on invoke dynamic instructions. The inliner\r\nis updated to not try to inline a method with an invoke dynamic\r\ninstruction. A place holder INVOKE_DYNAMIC instruction is added to ICode\r\nbut it is designed to create an error if there's ever any attempt to\r\nanalyze it. Because the inliner is the only phase that ever tries\r\nto analyze ICode instructions not generated from Scala source and\r\nbecause Scala source will never emit an INVOKE_DYNAMIC, the place\r\nholder INVOKE_DYNAMIC should never cause any errors.\r\n\r\nA test is included that generates a class file with INVOKE_DYNAMIC\r\nand then compiles Scala code that depends on it."
2256,'retronym',"SI-7246: javac doesn't add $outer field.\n"
2255,'JamesIry','SI-7249 Reign in overzealous Function0 optimization.\nThe fix for SI-1247 went too far, and could result in\r\npremature evaluation of the expression that yields the\r\nFunction0.\r\n\r\nThis commit checks that said expression is safe to inline.\r\nIf not, a wrapper `() => ....` is still required.\r\n\r\nThe optimization is still enabled in sitations like the\r\noriginal test case, run/t1247.scala.\r\n\r\nReview by @JamesIry'
2253,'lrytz',"SI-6921 SI-7239 Tread lightly during exploratory typing\nWhen deciding whether an Assign is a named argument or\r\nand assignment expression, or when looking at arguments\r\nthat the current selection is applied to in order to\r\nevaluate candidate implicit views, we risk polluting\r\nthe tree by setting error types. This happens even\r\nif we are in 'silent' mode; that mode does silence the\r\nerror report, but not the side effect on the tree.\r\n\r\nThis commit adds strategic `duplicate` calls to\r\naddress the problem symptomatically.\r\n\r\nDuplicating trees and retyping in general reach into\r\nthe domain of bugs umbrella-ed under SI-5464, but in\r\nthese places we should be safe because the tree is in\r\nthe argument position, not somewhere where, for example,\r\na case class-es synthetic companion object might be\r\ntwice entered into the same scope.\r\n\r\nLonger term, we'd like to make type checking side effect\r\nfree, so we wouldn't need to play whack-a-mole like this.\r\nThat idea is tracked under SI-7176.\r\n\r\nReview by @lrytz"
2252,'adriaanm','[backport] SI-7237 Always choose ForkJoinTaskSupport\nForkJoinTaskSupport works on Hotspot, Avian and J9,\r\nwhile ThreadPoolTaskSupport causes the test\r\ntest/files/scalacheck/parallel-collections\r\nto reliably hang on all three.'
2251,'adriaanm','SI-7236 Deprecate ThreadPoolTaskSupport and friends\n'
2247,'adriaanm','SI-7232 Fix Java import vs defn. binding precendence\nJava Spec:\r\n> A single-type-import declaration d in a compilation unit c\r\n> of package p that imports a type named n shadows, throughout\r\n> c, the declarations of:\r\n>   - any top level type named n declared in another compilation\r\n>     unit of p\r\n>   - any type named n imported by a type-import-on-demand\r\n>     declaration in c\r\n>   - any type named n imported by a static-import-on-demand\r\n>     declaration in c\r\n\r\nScala Spec:\r\n> Bindings of different kinds have a precedence deﬁned on them:\r\n>   1. Deﬁnitions and declarations that are local, inherited, or made\r\n>      available by a package clause in the same compilation unit where\r\n>      the deﬁnition occurs have highest precedence.\r\n>   2. Explicit imports have next highest precedence.\r\n\r\nReview by @vigdorchik'
2245,'paulp','SI-7242 Fix crash when inner object mixes in its companion\nGiven:\r\n\r\n    class C {\r\n      trait T { C.this }            // C$T$$$outer$ : C\r\n      object T extends T { C.this } // C$T$$$outer$ : C.this.type\r\n    }\r\n\r\nobject T ended up with a definitions for both of the accessors.\r\nThese cannot co-exist, as they have the same erased type. A crash\r\nensued almost immediately in explitouter.\r\n\r\nFortunately, the solution is straightforward: we can just omit\r\nthe mixin outer accessor altogether, the objects own outer accessor\r\nis compatible with it.\r\n\r\n    scala> :javap C.T\r\n    Compiled from "<console>"\r\n    public interface C$T{\r\n        public abstract C C$T$$$outer();\r\n    }\r\n\r\n    scala> :javap C.T$\r\n    Compiled from "<console>"\r\n    public class C$T$ extends java.lang.Object implements C$T{\r\n        public C C$T$$$outer();\r\n        public C$T$(C);\r\n    }\r\n\r\nI also added an assertion to give a better error message in\r\ncase we find ourselves here again.\r\n\r\nReview by @paulp. I can\'t find any duplicates of the bug in JIRA, but it seems so easy to step into that I\'m sure they must be in there. Can you summon any?'
2244,'adriaanm','SI-7247, deprecate NotNull.\nBrought the steamroller to bear on NotNull; fired up the Zamboni afterward to smooth things over.'
2243,'adriaanm',"Read version 51 (JDK 7) class files.\nThis commit makes the ClassFileReader/ICodeReader parse class files\r\nfrom JDK 7 (class file version 51). It does that by skipping over\r\nthe method handle related entries in the constant pool and by doing\r\nsome dummy processing on invoke dynamic instructions. The inliner\r\nis updated to not try to inline a method with an invoke dynamic\r\ninstruction. A place holder INVOKE_DYNAMIC instruction is added to ICode\r\nbut it is designed to create an error if there's ever any attempt to\r\nanalyze it. Because the inliner is the only phase that ever tries\r\nto analyze ICode instructions not generated from Scala source and\r\nbecause Scala source will never emit an INVOKE_DYNAMIC, the place\r\nholder INVOKE_DYNAMIC should never cause any errors.\r\n\r\nA test is included that generates a class file with INVOKE_DYNAMIC\r\nand then compiles Scala code that depends on it."
2240,'JamesIry','Warn about locally identifiable init order issues.\nThis warns about a subset of initialization order issues which\r\ncan easily be identified by inspection, such as\r\n\r\n  val x = y\r\n  val y = 5\r\n\r\nThe likelihood of this formulation being intentional is miniscule.'
2239,'adriaanm','Warnings removal and other cleanup.\n'
2238,'adriaanm',"[rebase of #2206] SI-874 JSR-223 compliance for the interpreter\nreview by @rjolly to make sure I didn't butcher anything during the rebase"
2236,'paulp',"SI-6601 Close access loophole for value class constructors\nExtensionMethods marks private constructors of value classes as\r\nnotPRIVATE before pickling. When the pickler reads the flags of this\r\nsymbol, the anti-shift mechanism folds this into the regular PRIVATE\r\nflag, so the class is pickled as though it was public all along. A\r\nseprately compiled client can then call this constructor.\r\n\r\nTo remedy this, we must:\r\n\r\n - pickle `rawFlags`, rather than `flags`. This is symmetric with\r\n   unpickling, which sets `rawFlags` with the value it reads.\r\n - Add `notPRIVATE` to the flagset `PickledFlags`.\r\n\r\nWe cannot make this change in a minor version, as the pickler\r\nand unpickler must agree on `PickledFlags`.\r\n\r\nI believe that this won't change the size of pickled flags\r\nfor the majority of symbols (ie, those without the notPRIVATE flag)\r\ndue to the variable length encoding in `writeLongNat`.\r\n\r\nThis also improves the situation for SI-6608. Reflection and\r\nscalap (and, by extension, IntelliJ), no longer will see\r\nas public methods that have had their access widened in\r\nSuperAccessors (which is done selectively to support inlining\r\nunder separate compilation.)\r\n\r\nReview by @gkossakowski"
2235,'JamesIry','SI-5513: add inplace set-theoretic operations for mutable bitsets.\n'
2234,'retronym','SI-7240 fixes language feature lookup\nAs I discovered today, Definitions.getMember have a fallback clause,\r\nwhich accounts for the phases which have inner classes flattened.\r\n\r\nThis fallback uses nme.flattenedName to compute a flattened name, but\r\nunfortunately nme.flattenedName produces a TermName, not a TypeName,\r\nwhich means that the fallback will commence search in a wrong namespace\r\nwith predictable results.'
2230,'JamesIry',"SI-7233 Account for aliased imports in EtaExpansion / Erasure \nBuggy:\r\n\r\n    treeCopy.Select(sel, sel.qual, sel.name) setSymbol null\r\n    Select(sel, sel.qual, sel.name)\r\n\r\nOkay:\r\n\r\n    treeCopy.Select(sel, sel.qual, sel.name)\r\n    Select(sel, sel.qual, sel.symbol.name) // but doesn't copyAttrs!\r\n\r\nReview by @JamesIry"
2228,'adriaanm',"SI-7226 Fix inference regression caused by TypeVar equality\nTypeVars, being mutable creatures, mustn't have structural\r\nequality/hashing, otherwise TypeRefs that differ only by\r\nhaving distinct TypeVars as components get wrongly uniqued\r\ntogether.\r\n\r\nThe reported bug showed the disaterous consequences: constraints\r\nfrom the `C?[Int]` in the return type applied to the `?C[?A]` in\r\nthe parameter list.\r\n\r\nThis commit overrides `equals` and `hashCode` in `TypeVar`\r\nto use reference equality. An alternative fix would be to drop\r\nthe `case`-ness of the class, as was the case before 0cde930b\r\nwhen this regressed.\r\n\r\nReview by @adriaanm"
2227,'paulp',"SI-7132 - don't discard Unit type in interpreter\nbackport from previous pull request #2191. review @paulp"
2226,'paulp','[rework] Modularized scaladoc and presentation compiler.\nThey are now separately built targets and are not privileged from the standpoint of the rest of the compiler. There is no change to build products: they are still bundlled into scala-compiler.jar, but it would now be easy to create a scaladoc.jar and an interactive.jar should we be so inclined.\r\n\r\nrework of #2208'
2225,'lrytz','SI-7234 Make named args play nice with dep. method types\nSome care is needed to avoid interaction with constant\r\ntypes (e.g pos/z1730.scala) and with existentials\r\n(e.g. t3507-old.scala).\r\n\r\nReview by @lrytz'
2224,'lrytz','SI-7328 Bail out of names/defaults when args are error typed\nTo avoid a crasher later on with a null type inside a\r\nsequence argument.\r\n\r\nReview by @lrytz'
2222,'paulp',"SI-6725 `f` interpolator now supports %n tokens\nCurrently the `f` interpolator supports format specifiers which\r\nspecify conversions for formatted arguments. However Java formatting\r\nis not limited to argument-related conversions as explained in:\r\nhttp://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html#detail.\r\n\r\nConversions which don't correspond to any arguments are `%` (used to\r\nemit verbatim `'%'` characters) and `n` (used to emit platform-specific\r\nline separators). Of those only the former is supported, and this patch\r\nfixes the oversight."
2221,'retronym','SI-5710 has fixed itself\nMy job here is only to submit tests.'
2220,'adriaanm',"SI-7226 Fix inference regression caused by TypeVar equality.\nTypeVars, being mutable creatures, mustn't have structural\r\nequality/hashing, otherwise TypeRefs that differ only by\r\nhaving distinct TypeVars as components get wrongly uniqued\r\ntogether.\r\n\r\nThe reported bug showed the disaterous consequences: constraints\r\nfrom the `C?[Int]` in the return type applied to the `?C[?A]` in\r\nthe parameter list.\r\n\r\nThis commit overrides `equals` and `hashCode` in `TypeVar`\r\nto use reference equality. An alternative fix would be to drop\r\nthe `case`-ness of the class, as was the case before 0cde930b\r\nwhen this regressed.\r\n\r\nReview by @adriaanm . Do the other conversions to case classes in that commit look safe?\r\n\r\nI consider this to be a serious enough regression to consider yet another RC for 2.10.1."
2219,'JamesIry','Optimize RedBlackTree rebalance method by using null optimized list implementation.\nrebalance method relies heavily on s.c.i.List. By replacing List with null\r\noptimized version, NList, rebalance operation is significantly more faster.\r\nTest indicate +10 % performance improvement for tree sizes >= 100.'
2215,'retronym','SI-7228, bug in subtyping.\nMake isWeakSubType more frequently correct. Simplify widening logic.'
2214,'retronym','Analyze constants to remove unnecessary branches\nThis commit adds analysis and optimization of constants to remove\r\nunnecessary branches. It uses abstract interpretation to determine\r\nwhat constant(s) a particular stack slot or variable might or might not\r\nhold at a given spot and uses that knowledge to eliminate branches that\r\ncannot be taken. Its primary goal is null check removal, but it also\r\nworks for other constants.\r\n\r\nSeveral tests are modified to include the new optimization phase.\r\n\r\nTwo new tests are added. One verifies that branching still works as\r\nexpected. The other verifies that branches are removed.'
2212,'scala-jenkins',"Fix SI-7224.\nDon't focus positions assigned to the TypeTree of a parent of a Template\r\nwhen the parent exists in the source. A focused position (instance\r\nof `OffsetPosition`) makes it invisible to the presentation compiler\r\nwhen it looks for the innermost enclosing tree of a given position\r\n(breaking hyperlinking, for example). See [IDE ticket #1001553](https://scala-ide-portfolio.assembla.com/spaces/scala-ide/tickets/1001553).\r\n\r\n(I couldn't find a way to reproduce the pr-ragepos build locally, as I couldn't find the definition of the corresponding Jenkins job)\r\n\r\nreview by @huitseeker, @hubertp"
2206,'adriaanm','SI-874 JSR-223 compliance for the interpreter\n'
2203,'paulp',"Name boolean arguments (rebased)\nRebased version of #2164 since I took long enough to review it that it started conflicting with retronym's later patches. Supersedes #2164."
2201,'lrytz','Carve up Types.scala\nStep one of a plan to bring some order and thread\r\nsafety to this neck of the woods.\r\n\r\nMore info:\r\n\r\n  https://gist.github.com/retronym/5081754\r\n  https://groups.google.com/forum/?fromgroups=#!topic/scala-internals/MOvmcnbyb_g\r\n\r\nReview by @lrytz @paulp'
2199,'adriaanm',"SI-7214 outer check based on dealiased pattern type.\nA Typed Pattern (`_: T`) is more than `.isInstanceOf`: if `T` is a\r\npath dependent type, the scrutinee's $outer reference is also\r\ncompared against the prefix of `T`.\r\n\r\nThe code that synthesises this is split into two places.\r\n`needsOuterCheck` determines whether to add this check, based on\r\nthe type `T`, and the type of the scrutinee. If it gives the\r\ngo-ahead, `treeCondStrategy.outerCheck` synthesizes the check.\r\n\r\nThe new test case demonstrates the problems caused by the failure\r\nto dealias in `needsOuterCheck`: it could either wrongly lead to\r\nsynthesis of an outer test (which would crash), or wrongly omit\r\nthe outer test (meaning overly liberal matching.)\r\n\r\nA simple `dealias` remedies this. `dealiasWiden` is *not*\r\nappropriate here; we need to keep hold of singleton types.\r\n\r\nI'll also note that there is already a little slack between these\r\nmethods, as commented:\r\n\r\n> ExplicitOuter replaces `Select(q, outerSym) OBJ_EQ expectedPrefix`\r\n> by `Select(q, > outerAccessor(outerSym.owner)) OBJ_EQ expectedPrefix`\r\n> if there's an outer accessor, otherwise the condition becomes `true`\r\n> TODO: can we improve needsOuterTest so there's always an outerAccessor?\r\n\r\nSo this is probably a fragile area that warrants a careful review\r\nwith a view to design improvements.\r\n\r\nReview by @adriaanm"
2198,'JamesIry','SI-7215 Fix transpose of an empty Array[Array[T]].\nReview by @JamesIry'
2197,'retronym','Integrate range positions.\n'
2193,'retronym','merge 2.10.1 into 2.10.x\nIncludes a couple of commits that clean up the patmat refactoring a bit,\r\nand a separate forwardport (in 2cf6c5d) of the fix for SI-7183 (original in 0303e64).\r\n\r\nreview by @retronym '
2191,'paulp',"SI-7132 - don't discard Unit type in interpreter\nThis is my first pull request here, so apologies in advance if I've (likely) screwed something up.\r\n\r\nThis is to fix a bug in the REPL, apparently introduced in 4a6f54b, in which the `:type` command fully evaluates expressions of type `Unit`, rather than just printing the type name `Unit`.\r\n\r\n@paulp I think I'm supposed to ask you to review..."
2190,'JamesIry','test.done again checks bin compat (using mima 0.1.5)\n'
2189,'JamesIry',"[nomaster] SI-7195 minor version mustn't introduce warnings\nWe want 2.10.1 to be a drop-in replacement for 2.10.0,\r\nso we can't start warning where we weren't warning in 2.10.0.\r\n\r\nSee SI-5954 (#1882, #2079) for when it was an implementation restriction,\r\nwhich was then weakened to a warning. It's now hidden behind -Ydebug.\r\n\r\nreview by @jamesiry"
2188,'JamesIry',"test.done again checks bin compat (using  mima 0.1.5)\nWe can again check binary compatibility as part of PR validation thanks to @gkossakowski's https://github.com/typesafehub/migration-manager/pull/30.\r\n\r\n(Mad props to @jsuereth for speeding up the release process!)\r\n\r\nReview by @jamesiry."
2187,'paulp','SI-6816 Deprecate -Yeta-expand-keeps-star\nThis commit deprecates the -Yeta-expand-keeps-star flag. It was created\r\nin 2.10 to help in the transition from 2.9 but by the time 2.11 comes\r\nout it should no longer be necessary.'
2186,'odersky',"SI-6725 `f` interpolator now supports %n tokens\nCurrently the `f` interpolator supports format specifiers which\r\nspecify conversions for formatted arguments. However Java formatting\r\nis not limited to argument-related conversions as explained in:\r\nhttp://docs.oracle.com/javase/6/docs/api/java/util/Formatter.html#detail.\r\n\r\nConversions which don't correspond to any arguments are `%` (used to\r\nemit verbatim `'%'` characters) and `n` (used to emit platform-specific\r\nline separators). Of those only the former is supported, and this patch\r\nfixes the oversight."
2185,'gkossakowski','SI-7006 Prevent unreachable blocks in GenICode\nThis commit makes GenICode prevent the generation of\r\nmost unreachable blocks. The new unreachable block prevention code can\r\nbe disabled with a compiler flag.\r\n\r\nBecause full unreachable analysis is no longer necessary for\r\nnormal code it makes the unreachable block analysis run only under\r\n-optimise.\r\n\r\nA test is included to make sure unreachable code doesn\'t cause issues\r\nin code gen.\r\n\r\nA concrete example will help.\r\n\r\n  def foo(): X = {\r\n   try\r\n     return something()\r\n   catch {\r\n     case e: Throwable =>\r\n        println(e)\r\n        throw e\r\n   }\r\n   unreachableCode()\r\n  ]\r\n\r\nHere unreachableCode() is unreachable but GenICode would create ICode\r\nfor it and then ASM would turn it into a pile of NOPS.\r\n\r\nA previous commit added a reachability analysis step to eliminate\r\nthat unreachable code but that added a bit of time to the\r\ncompilation process even when optimization was turned off.\r\nThis commit avoids generating most unreachable\r\nICode in the first place so that full reachability analysis is\r\nonly needed after doing other optimization work.\r\n\r\nThe new code works by extending a mechanism that was already in place.\r\nWhen GenICode encountered a THROW or RETURN it would put the\r\ncurrent block into "ignore" mode so that no further instructions\r\nwould be written into the block. However, that ignore mode flag\r\nwas itself ignored when it came to figuring out if follow on blocks\r\nshould  be written. So this commit goes through places like try/catch\r\nand if/else and uses the ignore mode of the current block to decide\r\nwhether to create follow on blocks, or if it already has, to kill by\r\nputting them into ignore mode and closing them where they\'ll be\r\nremoved from the method\'s list of active blocks.\r\n\r\nIt\'s not quite as good as full reachability analysis. In particular\r\nbecause a label def can be emitted before anything that jumps to it,\r\nthis simple logic is forced to leave label defs alone and that means\r\nsome of them may be unreachable without being removed. However, in\r\npractice it gets close the the benefit of reachability analysis at\r\nvery nearly no cost.'
2183,'JamesIry','Require firstKey and lastKey on IntMap tail-recursive.\n'
2181,'JamesIry','Tone down a soft-warning to only show under -Ydebug.\nSI-6191 remains open and can lead to incomplete debug\r\nscope information. In 2.10.0, the backend detected when\r\nthis happend, and warned the user. But there is little\r\nthe user can do about the warning. We have a few test\r\ncases for the problem now, so we should not pollute\r\nthe compile output.\r\n\r\nReview by @JamesIry'
2178,'retronym',"SI-7190 macros no longer give rise to bridges\nAmazingly enough, this got through all the testing we performed. But now\r\nerasure knows that it shouldn't generate bridges for macro methods."
2177,'gkossakowski',"SI-7159 Distinguish between assignability and subtyping in TypeKinds\nGenICode#adapt had some unreachable code. That's removed.\r\n\r\nAnother commit cleans up several spots in the back end related to adapting types.\r\n\r\nTypeKinds said INT <:< LONG. But that's not true on the JVM, you need\r\na coercion to move up. And GenICode#adapt was checking for just that\r\nspecial case. One commit fixes that up.\r\n\r\nTypeKinds also said that BOOL, BYTE, CHAR, and SHORT were also subtypes of INT. That's not quite right. They're assignable to INT, but they aren't subtypes. Another commit fixes that."
2176,'retronym','SI-6605: extract TagKeys and other cleanup.\n'
2175,'xeno-by',"SI-7185 Avoid NPE in TreeInfo.isExprSafeToInline\nWe got there typechecking code with a redundant\r\nlayer of Block.\r\n\r\nWe can't express that in source code, so we test\r\nthis with manual tree construction and with XML\r\nliterals, which as reported produce such trees.\r\n\r\nReview by @xeno-by"
2174,'JamesIry','add to Enumaration withNameOpt returning Option\n'
2172,'retronym','SI-6609, eliminate special case in pattern matcher.\n'
2171,'retronym','Reconcile definitions of stability.\n'
2170,'adriaanm','relax time constraint in duration-tck.scala (for Windows)\nIt seems that on Windows Thread.sleep can actually return early even if it does not throw an exception.\r\n\r\nreview-by: @phaller @adriaanm'
2169,'gkossakowski','SI-7181 Eliminate unnecessary duplicates of finally blocks\nThe main body of a try and each exception handler were getting a copy of\r\nthe finally block for the "normal" flow case (i.e. where they don\'t\r\nthrow an uncaught exception or use "return" to exit early). But that\'s\r\n not necessary.\r\n\r\nWith this commit the try body and each exception handler can all jump\r\nto the same copy of the finally block on a normal exit.\r\n\r\nTwo tests are included. One is a run style test that shows that\r\ntry/catch/finally logic remains unchanged. The other is a byte code\r\ntest that ensures we\'re getting fewer copies of the finally.\r\n'
2168,'adriaanm',"SI-7183 Disable unreachability for withFilter matches.\nThis avoids spurious unreachable warnings on code\r\nthat the user didn't write.\r\n\r\nThe parser desugars for-comprehensions such as:\r\n\r\n    for (A(a) <- List(new A)) yield a\r\n\r\nTo:\r\n\r\n    List(new A()).withFilter(((check$ifrefutable$2) =>\r\n      check$ifrefutable$2: @scala.unhecked match {\r\n       case A((a @ _)) => true\r\n       case _ => false\r\n      })\r\n    )\r\n\r\nBut, if `A.unapply` returns `Some[_]`, the last case is dead code.\r\n(Matching against a regular case class *would* fall through in\r\nthe caes of a null scrutinee.)\r\n\r\nIn SI-6902, we enabled unreachability warnings, even if the\r\nscrutinee was annotated as @unchecked. That was consistent\r\nwith the 2.9.2 behaviour, it was only disabled temporarily\r\n(actually, accidentally) in 2.10.0. But, the old pattern matcher\r\ndidn't warn about this code.\r\n\r\nThis commit makes the pattern matcher recognise the special\r\nscrutinee based on its name and disables both exhaustivity\r\n*and* unreachability analysis.\r\n\r\nTo do so, the we generalize the boolean flag `unchecked` to\r\nthe class `Suppression`.\r\n\r\nReview by @adriaanm. \r\n\r\nThis one shows up on typical usage of Slick, so I think its a fairly important regression. We need to get better at internal testing of new Scala releases; we had a regression from each of SBT, Akka, and Slick show up very late in the cycle.\r\n\r\n```\r\n/Users/jason/code/slick/slick-testkit/src/main/scala/com/typesafe/slick/testkit/tests/NestingTest.scala:20: warning: unreachable code\r\n      a ~ b <- mapped\r\n```"
2167,'adriaanm',"SI-7126 Account for the alias types that don't dealias.\nAfter this change:\r\n\r\n    qbin/scalac -Ydebug test/files/pos/t7126.scala 2>&1 | grep warning\r\n    warning: dropExistential did not progress dealiasing Test.this.T[Test.this.T], see SI-7126\r\n    one warning found\r\n\r\n`T[T]`? Really? The true bug lies somewhere else; the comments of\r\nthe ticket illuminate the general areas of concern.\r\n\r\nThis is a shallow fix intended for 2.10.1. I'll keep investigating the deeper issue, to help inform the decision about whether we are comfortable releasing 2.10.1 with only this bandaid.\r\n\r\nReview by @paulp"
2165,'paulp',"Spring cleaning\nGetting in before the thaw.\r\n\r\n - Don't override empty-paren methods as paren-less.\r\n - Be explicit about empty param list calls.\r\n - Banish needless semicolons\r\n - Omit redundant val in case class params\r\n - Don't call `someArray.size`\r\n - Modernize legacy quoting in scaladoc\r\n - Address general scaladocrot.\r\n\r\nThese were a few of my least favourite things.\r\n\r\nReview by @paulp"
2164,'paulp','Name boolean arguments\nWhat would you prefer?\r\n\r\n    adaptToMemberWithArgs(tree, qual, name, mode, false, false)\r\n\r\nOr:\r\n\r\n    adaptToMemberWithArgs(tree, qual, name, mode, reportAmbiguous = false, saveErrors = false)\r\n\r\ncompiler, reflect, and library have been swept.\r\n\r\nA sanity check is included to show that using named args for clarity incurs no bytecode penalty.\r\n\r\nReview by @paulp. Minor chuckles here: https://github.com/retronym/scala/pull/new/topic/bool-arg#L62L15'
2163,'retronym','Refactors AsSeenFromMap to expose extension point.\nThe extension point was the initial motivation but I also tried to\r\nbring some clarity to the internals. This is a setup commit for\r\nscaladoc and interactive modularization, and also will be followed\r\nby a fix for abstract types losing their prefixes (SI-6161.)'
2161,'JamesIry','fixes the test for SI-7112\nresubmission of https://github.com/scala/scala/pull/2159 against `master`'
2160,'JamesIry','fixes the test for SI-7112\nresubmission of https://github.com/scala/scala/pull/2159 against `2.10.1`'
2159,'JamesIry','fixes the test for SI-7112\nFreshly released Java 1.6.0_41 for OSX fails with "IllegalAccessError:\r\ntried to access class JavaSimpleEnumeration_1 from class sun.proxy.$Proxy6",\r\nand rightfully so, because that class isn\'t public.\r\n\r\nI think I will avoid the usual "how could this even work before" in this\r\ncommit message.'
2158,'gkossakowski','SI-7006 Eliminate NOPs and unreachable code\nWe were generating NOPs in two cases\r\n\r\n1) If jump elision failed to eliminate a JUMP-only block that happened to JUMP to its next block then the code emitter would spit out a NOP. The answer was to fix jump elision to catch more jump-only blocks. Along the way a O(N*M) method was reduced to O(N)\r\n\r\n2) Partly from jump elision and partly from other sources we were leaving behind unreachable code. ASM turned that into NOPs. The answer here was to get rid of the unreachable exception handler elision that would leave behind other unreachable code and replace it with full blown (and simpler) unreachable block elision.\r\n\r\nPR is broken into several commits to make review a bit easier.\r\n'
2157,'JamesIry',"SI-7171 Consider prefix when assessing type finality.\n`Type#isFinalType` determines if a type could have a\r\nnon-bottom subtype. This property is exploited by\r\nthe pattern matcher to flag impossible patterns.\r\n\r\nThis check was ignoring the type's prefix, and\r\nincorrectly deemed that `T#A` in `trait T { final class A }`\r\nwas a final type. But it could have been subtyped by\r\n`U#A` where `U` <:< `T`, or, more simply, by `T.this.A`.\r\n\r\nNow, type finality requires that the prefix is stable.\r\n\r\nThe existing test cases inneg/patmat-type-check.scala\r\nstill correctly flag incompatiblities.\r\n\r\n`isFinalType` is also used by some code that massages\r\npattern matches post specialization. That is actually\r\neither broken or obsolete under virtpatmat, I've opened\r\nSI-7172 to invesigate that.\r\n\r\nIt's also used by GenICode to determine whether to emit\r\nthe appropriate equality checks that are correct in the\r\nface of boxing. It is possible that this change will force\r\nthe slow path in some rare cases, but it won't affect\r\ncorrectness.\r\n\r\nReview by @adriaanm and @JamesIry"
2156,'scala-jenkins',"SI-7109 SI-7153 Generalize the API to get docComments: allow to force do...\n...cTrees\r\n\r\nfor given fragments. Don't type-check when forcing doc comments, but rather\r\n do it directly. Test the new functionality as well as better tests for\r\nthe old one."
2153,'paulp','SI-874 JSR-223 compliance for the interpreter\nUsage:\r\n\r\nscala/bin/jarlister -o scala-library-listed.jar scala/lib/scala-library.jar\r\n\r\njrunscript -classpath scala/lib/scala-compiler.jar:scala/lib/scala-reflect.jar:scala-library-listed.jar -l scala'
2152,'adriaanm','SI-7163 backport of annotated retyping to 2.10.1\nBackport of #2118 to 2.10.1.\r\n\r\nTracking this with a retrospective ticket SI-7163\r\n\r\nReview by @JamesIry\r\n'
2151,'paulp','Merge 2.10.x into master\nreview by @paulp'
2150,'adriaanm','[nomaster] nightly tests binary compat and osgi\nTogether with af0da51e1b, this reenables testing binary compatibility\r\nas part of PR validation, on check-in of every commit, and during the nightly.\r\n\r\nNOTE: depends on https://github.com/typesafehub/migration-manager/pull/30 and a new migration manager release'
2149,'gkossakowski','SI-7074 Fix xml attribute sorting\n'
2148,'paulp',"SI-107 Adds test for problematic byte to long conversion\nWhile working on another issue I found some questionable looking code\r\nin GenICode#adapt. A bit of code spelunking found that it fixed\r\nissue 107, but that commit didn't include a test. So this commit adds\r\na test and a comment so the next person doesn't break it.\r\n\r\nThe code still looks questionable so I've created issue\r\nhttps://issues.scala-lang.org/browse/SI-7159 to track it."
2147,'gkossakowski',"SI-7015 Removes redundant aconst_null; pop; aconst_null creation\nIn an effort to adapt methods and field accesses of type Null to\r\nother types, we were always emitting\r\n\r\n    aconst_null\r\n    pop\r\n    aconst_null\r\n\r\nThe problem is we were doing that even when the JVM was in a position\r\nto know it had null value, e.g. when the user had written a null\r\nconstant. This commit fixes that and includes a test to show that the\r\nresulting byte code still works even without repeating ourselves and/or\r\nrepeating ourselves.\r\n\r\nThis commit also makes the scala.runtim.Null$ constructor private. It\r\nwas a sealed abstract class which prevented subclassing in Scala, but\r\nit didn't prevent subclassing in Java. A private constructor takes care\r\nof that hole so now the only value of type Null$ should be null.\r\n\r\nAlong the way I found some other questionable things in adapt and I've\r\nadded TODO's and issue https://issues.scala-lang.org/browse/SI-7159 to\r\ntrack."
2144,'dragos','SI-7109 SI-7153 Generalize the API to get docComments: allow to force do...\n...cTrees\r\n\r\nfor allOverriddenSymbols. Test the new functionality as well as better tests for\r\nthe old one.'
2143,'xeno-by','Fixed error in reflection API docs about linearization order on method baseClasses\nDoc comment for method `baseClasses` in `SymbolAPI` and `TypeAPI` incorrectly claims that the method returns a list of base classes in reverse linearization order, when the list returned is actually in linearization order (not in reverse).\r\n\r\nFor fun, the spec (ignore references to `ScalaObject`):\r\n![](http://f.cl.ly/items/1v1l2y1v3v1A3U0B3m35/Screen%20Shot%202013-02-19%20at%2010.34.25%20PM.png)\r\n\r\nreview by @retronym, @xeno-by'
2142,'xeno-by','Extracted abstract implicit vals from Types.\nThese should be considered plumbing and not blended in with the\r\nrest of the api.'
2141,'retronym','Fix and optimization in overriding logic.\nGiven:\r\n\r\n  trait Foo { def f: Int = 5 }\r\n  trait Bar extends Foo { def f: Int }\r\n\r\nI noticed allOverriddenSymbols for the abstract f defined in Bar\r\nwas returning the method from Foo, even though an abstract method\r\ncannot override a concrete one. There were other bits of code\r\nwhich accidentally depended on this outcome. Now allOverriddenSymbols\r\nfor Bar is empty.\r\n\r\nThe optimization is that whether or not a symbol overrides\r\nany other symbols is known at creation time and does not change.\r\nWe now spend a lot less time looking for overridden symbols in\r\nbase classes by storing that value, "isOverridingSymbol".'
2134,'retronym',"resetAttrs now always erases This.tpe\nThe symbol of This, if it points to a package class, isn't touched, just\r\nas usual, so that our Select(Select(Select(...))) => This(...) optimization\r\nworks fine with attr reset.\r\n\r\nHowever the tpe is now erased, so that subsequent reflective compilation\r\ndoesn't spuriously fail when seeing that some subtrees of a tree being\r\ncompiled are typed.\r\n\r\nErasing the tpe doesn't pose even a tiniest problem, because, as it can\r\nbe seen in typedThis, type is trivially reconstructed from the symbol."
2125,'paulp','SI-7120 Erasure must honor typeref prefixes\nErasure was discarding these, which led to unnecessarily\r\nwide types in quite particular circumstances. This showed\r\nup as a double definition error in the reported bug when the\r\nbridge method clashed with the erased signature.\r\n\r\nTargeted at 2.11 rather than 2.10.2 on grounds of binary compatibility.\r\n\r\nReview by @odersky, @paulp (should we use `dealiasWiden` here?)'
2121,'gkossakowski','merge the patmat refactoring into master\nsee #2120 -- nothing to see here but the merge commits:\r\n\r\n```patch\r\n -  def newTransformer(unit: CompilationUnit): Transformer =\r\n -    if (opt.virtPatmat) new MatchTransformer(unit)\r\n -    else noopTransformer\r\n++  def newTransformer(unit: CompilationUnit): Transformer = new MatchTransformer(unit)\r\n```\r\n\r\n```patch\r\n+   // 2.10/2.11 compatibility\r\n -  protected final def dealiasWiden(tp: Type)   = tp.dealias                       // 2.11: dealiasWiden\r\n -  protected final def mkTRUE                   = CODE.TRUE_typed                  // 2.11: CODE.TRUE\r\n -  protected final def mkFALSE                  = CODE.FALSE_typed                 // 2.11: CODE.FALSE\r\n -  protected final def hasStableSymbol(p: Tree) = p.hasSymbol && p.symbol.isStable // 2.11: p.hasSymbolField && p.symbol.isStable\r\n -  protected final def devWarning(str: String)  = global.debugwarn(str)            // 2.11: omit\r\n++  protected final def dealiasWiden(tp: Type)   = tp.dealiasWiden\r\n++  protected final def mkTRUE                   = CODE.TRUE\r\n++  protected final def mkFALSE                  = CODE.FALSE\r\n++  protected final def hasStableSymbol(p: Tree) = p.hasSymbolField && p.symbol.isStable\r\n```'
2120,'retronym',"refactor the pattern matcher into smaller files\n- align the 2.11 and 2.10 pattern matcher implementations, factoring out their differences as compatibility stubs (the difference was mostly code cleanup)\r\n- split the monster into 7 smaller monsters [*] and subsequent minor refactors\r\n- drop `Cond` in favor of `Prop` and sweep up around the area\r\n\r\nreview by @paulp, @retronym and anyone else who'd like to split the monster (merge into master following once tests pass)\r\n\r\n[*] To verify the split in smaller files (it doesn't change any behavior, I promise), may I suggest:\r\n\r\n```\r\ngit checkout e14846b\r\n\r\ncat                                                                     \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/PatternMatching.scala     \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/MatchTranslation.scala    \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/MatchTreeMakers.scala     \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/MatchCodeGen.scala        \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/MatchAnalysis.scala       \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/Logic.scala               \\\r\nsrc/compiler/scala/tools/nsc/transform/patmat/MatchOptimization.scala   > /tmp/patmat.scala\r\n\r\ngit checkout e14846b^\r\n\r\nopendiff src/compiler/scala/tools/nsc/typechecker/PatternMatching.scala /tmp/patmat.scala\r\n```"
2117,'gkossakowski',"Fix SI-7107: scala now thinks every exception is polymorphic\nWe need to force info of the `throwableSym` in `addThrowsAnnotation`\r\nbecause we call `Symbol.isMonomorphicType` that relies on a symbol\r\nbeing initialized to give right answers.\r\n\r\nIn the future we should just clean up implementation of\r\n`isMonomorphicType` method to not rely on a symbol being initialized\r\nas there's no inherent reason for that in most cases. In cases where\r\nthere's reason for that we should just force the initialization."
2098,'paulp',"SI-6225 Fix import of inherited package object implicits\nThe prefix in the ImplicitInfo must be com.acme.`package`.type,\r\nrather than com.acme.\r\n\r\nReview by @paulp. It could easily wait until 2.10.2 unless you're feeling lucky."
2088,'adriaanm','SI-6146 More accurate prefixes for sealed subtypes.\nWhen analysing exhaustivity/reachability of type tests\r\nand equality tests, the pattern matcher must construct\r\na set of sealed subtypes based on the prefix of the\r\nstatic type of and the set of sealed descendent symbols\r\nof that type.\r\n\r\nPreviously, it was using `memberType` for this purpose.\r\nIn simple cases, this is sufficient:\r\n\r\n    scala> class C { class I1; object O { class I2 } }; object D extends C\r\n    defined class C\r\n    defined module D\r\n\r\n    scala> typeOf[D.type] memberType typeOf[C#I1].typeSymbol\r\n    res0: u.Type = D.I1\r\n\r\nBut, as reported in this bug, it fails when there is an\r\nadditional level of nesting:\r\n\r\n    scala> typeOf[D.type] memberType typeOf[c.O.I2 forSome { val c: C }].typeSymbol\r\n    res5: u.Type = C.O.I2\r\n\r\nThis commit introduces `nestedMemberType`, which uses `memberType`\r\nrecursively up the prefix chain prefix chain.\r\n\r\n    scala> nestedMemberType(typeOf[c.O.I2 forSome { val c: C }].typeSymbol, typeOf[D.type], typeOf[C].typeSymbol)\r\n    res6: u.Type = D.O.Id\r\n\r\n\r\nReview by @adriaanm + @odersky (two heads are better than one, given the lateness of the hour in the 2.10.1 cycle)\r\n\r\nAdditional test cases would be welcome. Note that existing tests cover Java enums, which required some logic in the new function (e.g. pos/t6942).'
2083,'adriaanm','SI-6240 synchronization for runtime reflection\nUnlike its predecessors, this pull request is for realz! \r\n\r\nI have several stress tests for reflection, and I also have successfully run parallel tests in a couple of projects, whose authors reported crashes when using runtime reflection.\r\n\r\nreview @paulp @adriaanm @retronym'
2082,'adriaanm','SI-6807 Deprecating the Actors library.\nAll public classes, traits and objects marked as deprecated.\r\nAdded deprecation note on the package object.\r\nEmbedded external libraries (ThreadPool etc.) are not deprecated as they are intended for internal use only.\r\n\r\nReview by: @phaller'
2079,'adriaanm',"SI-7070 Turn restriction on companions in pkg objs into warning\nThe implementation restriction created from SI-5954 in\r\n3ef487ecb6733bfe3c13d89780ebcfc81f9a5ea0 has two problems.\r\n\r\n1) The problematic code works fine if compile with sbt. That means the\r\nrestriction is breaking some people needlessly.\r\n\r\n2) It's not binary compatible.\r\n\r\nTo fix all that this commit changes the error into a warning and removes\r\nthe setting used to get around the restriction."
2035,'retronym','SI-6989 privateWithin is now populated in reflect\nRuntime reflection in JavaMirrors previously forgot to fill in\r\nprivateWithin when importing Java reflection artifacts. Now this is fixed.'
2017,'paulp',"Booking more progress on SI-6666\n - Avoids unneeded outer pointers for classes nested indirectly in self/super calls\r\n - Expands implementation restriction to prevent verify errors in early initializers\r\n\r\nCloses SI-6259 and SI-6506; a bit more work is needed on SI-6666/SI-6957.\r\n\r\nReview by @paulp / @JamesIry.\r\n\r\nI'll warn you up front that there is some less than beautiful code in `ExplicitOuter` to communicate these errors as implementation restrictions, rather than crashes."
2011,'adriaanm',"SI-6187 Make partial functions re-typable\n - `New(tpe)` doesn't survive a `resetAttrs` / typecheck; use\r\n   a name instead.\r\n - Abandon the tree attachment that passed the default\r\n   case from `typer` to `patmat`; this tree eluded the\r\n   attribute reset performed in the macro. Instead, add it\r\n   to the match. Apart from making the tree re-typable, it\r\n   also exposes the true code structure to macros, which\r\n   is important if they need to perform other code\r\n   transformations.\r\n - Install original trees on the declared types of the\r\n   parameters of the `applyOrElse` method to ensure that\r\n   references to them within the method pick up the correct\r\n   type parameter skolems upon retypechecking.\r\n - Propagate `TypeTree#original` through `copyAttrs`,\r\n   which is called during tree duplication / `TreeCopiers`.\r\n   Without this, the original trees that we installed were\r\n   not visible anymore during `ResetAttrs`.\r\n\r\nWe are not able to reify partial functions yet -- the\r\nparticular sticking point is reification of the parentage\r\nwhich is only available in the `ClassInfoType`.\r\n\r\nReview by @adriaanm / @xeno-by \r\n\r\nI'm using `typedCase` now, based on your prior review. The `asInstanceOf` is also gone."
1997,'paulp','SI-7035 Centralize case field accessor sorting.\nIt is both burdensome and dangerous to expect callers\r\nto reorder these. This was seen in the field permutation\r\nin the unapply method; a regression in 2.10.0.\r\n\r\nReview by @paulp'
1992,'paulp','SI-7033 Be symful when creating factory methods.\nImplicit class factory methods were synthesizing the\r\nreference to the class as `Ident(classDef.name)`, which\r\nwas unhygienic in case of `implicit class X[X]`.\r\n\r\nTo use symbols without causing a cycle, I switched from\r\n`REF(symbol)` to `Ident(symbol)`. The former calls into:\r\n\r\n    at scala.reflect.internal.TreeGen.mkAttributedSelect(TreeGen.scala:184)\r\n    at scala.reflect.internal.TreeGen.mkAttributedRef(TreeGen.scala:124)\r\n    at scala.reflect.internal.TreeGen.mkAttributedRef(TreeGen.scala:130)\r\n    at scala.tools.nsc.ast.TreeDSL$CODE$.REF(TreeDSL.scala:307)\r\n\r\nwhich seems to force the enclosing module and blow up.\r\n\r\nReview by @paulp\r\n\r\n - have I lost something by using `Ident(classSym)` here.\r\n - in general, when would one choose `REF(_)` over `Ident(_)`?'
1977,'dragos',"SI-7018 Fix memory leak in Attachments.\nMakes NonEmptyAttachments a top level class so that\r\nit doesn't accidentally accumulate history via the\r\n$outer field.\r\n\r\nNo test is included because I think the fix is\r\nself evident.\r\n\r\nReview by @dragos"
1975,'paulp','Revert "SI-6601 Publicise derived value contstructor after pickler"\nThis reverts commit b07228aebe7aa620af45a681ef60d945ffc65665.\r\n\r\nThe remedy was far worse than the disease:\r\n\r\n    % cat sandbox/test.scala\r\n    class V private (val a: Any) extends AnyVal\r\n\r\n    % RUNNER=scalac scala-hash b07228aebe sandbox/test.scala\r\n    [info] b07228aebe => /Users/jason/usr/scala-v2.10.0-256-gb07228a\r\n\r\n    % scala-hash b07228aebe\r\n    [info] b07228aebe => /Users/jason/usr/scala-v2.10.0-256-gb07228a\r\n    Welcome to Scala version 2.10.1-20130116-230935-b07228aebe (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_27).\r\n    Type in expressions to have them evaluated.\r\n    Type :help for more information.\r\n\r\n    scala> def foo(v: V) = v.a == v.a\r\n    exception when typing v.a().==(v.a())/class scala.reflect.internal.Trees$Apply\r\n    constructor V in class V cannot be accessed in object $iw in file <console>\r\n    scala.reflect.internal.Types$TypeError: constructor V in class V cannot be accessed in object $iw\r\n\r\nReview by @paulp'
1946,'gkossakowski','SI-6231 Report unsupported free var capture by a trait.\n_Does not close the ticket, merely advances a crasher to an implementation restriction._\r\n\r\nIf a class nested in a trait captures a free variable from\r\nthe enclosing scope of the trait, the transformation to\r\nadd that variable to the `init` method of the trait\r\nimplementation class happens *after* the abstract trait\r\ninterface has been extracted. This would lead to a crash\r\nwhen trying to find the corresponding interface method.\r\n\r\nThis commit detects this situation and reports an\r\nimplementation restriction. The enclosed test case\r\nshows a workaround.\r\n\r\nTo lift this restriction, LambdaLifter should add the getters\r\nand make sure they end up in the trait interface. Looks like\r\nMartin tried this once:\r\n\r\n    // LambdaLift.scala\r\n    //\r\n    // Disabled attempt to to add getters to freeParams\r\n    // this does not work yet. Problem is that local symbols need local names\r\n    // and references to local symbols need to be transformed into\r\n    // method calls to setters.\r\n    // def paramGetter(param: Symbol): Tree = {\r\n    //   val getter = param.newGetter setFlag TRANS_FLAG resetFlag PARAMACCESSOR // mark because we have to add them to interface\r\n    //   sym.info.decls.enter(getter)\r\n    //   val rhs = Select(gen.mkAttributedThis(sym), param) setType param.tpe\r\n    //   DefDef(getter, rhs) setPos tree.pos setType NoType\r\n    // }\r\n    // val newDefs = if (sym.isTrait) freeParams ::: (ps map paramGetter) else freeParams\r\n\r\nReview by @gkossakowski'
1938,'paulp',"SI-6666 Restrict hidden `this` access in self/super calls.\nDetect when classes (user authored or compiler generated)\r\nlocal to a self or super constructor argument would require\r\npremature access to the in-construction instance.\r\n\r\nThe same restriction applies for classes and objects; for objects,\r\nthe premature access would result in a null via MODULE$ field.\r\n\r\nA residual error has been lodged as SI-6997.\r\n\r\nI'd like to remove calls to `Symbol#outerClass` (which relies on\r\nthe flaky flag INCONSTRUCTOR, see my comments in the JIRA issue\r\nfor more discussion) from `LambdaLift` and `ExplicitOuter`, and\r\ninstead use the stack of active self/super calls to know when to\r\nskip an enclosing class. That will obviate that flag.\r\n\r\nReview by @paulp"
1936,'paulp',"SI-6891 Fix value class + tailrec crasher.\nrhs.substituteSymbols(old, new) leaves us with:\r\n\r\n    def loop#12225(x#12226: A#15491): scala#21.this.Unit#1615 =\r\n      loop#12225(x#12226)\r\n\r\nIn which the TermSymbol x#12226 has a stale info, pointing at\r\nthe A#7274, the class type parameter, rather than A#15491,\r\nthe corresponding type parameter of the synthetic backing\r\nmethod.\r\n\r\nI've improved `TreeSymSubstituter` to substitute not\r\nonly `Tree#{tpe, symbol}`, but also `DefTree#sym.info`.\r\n\r\nThe `pos` test that triggered the new code path are\r\nlisted here: https://gist.github.com/4575687\r\n\r\nScathing review, please, by @paulp + @adriaanm; it's a small patch, but touches some fundamental machinery.\r\n\r\nObviously I could limit the scope of the new code to the `substituteSymbols` calls in `ExtensionMethods`, but I don't see how its correctness is context sensitive.\r\n\r\nIt seems to me that `substituteSymbols` was a breeding ground for inconsistencies between `tree.tpe` and `tree.symbol.info`, and I'm at a loss as to why that doesn't cause more problems.\r\n\r\nI'm currently trying to add a new check to `TreeCheckers` to find references to type parameters and method parameters (to start with, but what else?) that don't respect scoping, ie their owner chain doesn't include the owner of the parameter. This check would have diagnosed this bug other like it. Any  and all suggestions for this line of investigation are most welcome. (Such checks will also be useful, nay, vital, for folks doing serious macro development)"
1928,'adriaanm','SI-6902 Check unreachability under @unchecked\nOnly exhaustiveness checking should be disabled if the\r\nscrutinee of a match as annotated as `: @unchecked`.\r\nThis was the pre-2.10.x behaviour.\r\n\r\nThis also fixes a variation of the closed ticket,\r\nSI-6011. The exhaustiveness check is needed to\r\nsafely fallback from emitting a table switch if\r\nduplicate cases are detected.\r\n\r\nReview by @adriaanm'
1914,'gkossakowski',"SI-6601 Publicise derived value contstructor after pickler\nOtherwise the access restrictions are not enforced under\r\nseparate compilation.\r\n\r\nSee also SI-6608.\r\n\r\nReview by @gkossakowski\r\n\r\nWe don't ship any value classes with private constructors in the standard library, so perhaps we can ship this fix in 2.10.x."
1912,'paulp','SI-6651 Extension methods types may depend on the typed of the wrapped value\nThis allows for the likes of:\r\n\r\n    class A[X](val x: X) extends AnyVal {\r\n      def foo(xy: x.Y) {}\r\n    }\r\n\r\nWe have to do this in both directions, when synthesizing\r\nthe extension method in `Extender#transform`, and later on\r\nwhen Erasure tries to find the corresponding extension\r\nmethods by backing out the original signatures from\r\nthe signatures of the synthesized methods in the companion.\r\n\r\nIn the first case, we have to be careful to use a stable\r\nreference to the `self` parameter, which can satisfy the\r\ndependent types.\r\n\r\nReview by @paulp'
1910,'paulp',"SI-6976 Fix value class separate compilation crasher.\nWe can't guarantee that the owner of the value class\r\nis initialized, and if it isn't, the search for the\r\ncompanion module will turn up bubkis.\r\n\r\nThis is a localized fix, but I'd be suprised if there\r\nweren't other places that suffered from the same problem.\r\n\r\nWouldn't it be nicer to have something like:\r\n\r\n    // doesn't force info\r\n    sym.raw.info\r\n    sym.raw.companionModule\r\n\r\n    // forces info\r\n    sym.info\r\n    sym.companionModule\r\n\r\nReview by @paulp. \r\n\r\n/cc @JamesIry for consideration of SI-5954"
1908,'adriaanm',"SI-6979 Small optimization in lub\nIf a member of `lubBase` is final, it cannot be\r\nrefined in the types we're lubbing.\r\n\r\nReview by @adriaanm."
1892,'dragos',"SI-6479 Don't lift try exprs in label arguments.\nThe new pattern matcher uses label jumps to GOTO\r\nthe next case. Uncurry treated these like regular\r\nmethod arguments, and performed the liftedTree()\r\ntransformation, which ensures that try expressions\r\nare only used in a statement position. Even try\r\nin statement position of a block used as such an argument\r\nare subject to the same transform.\r\n\r\nThis transform stems from the JVM limitation,\r\nthat try/catch does not leave a value on the stack.\r\nSee b194446.\r\n\r\nThis commit changes Uncurry to avoid this transform\r\nfor arguments to label jumps. This avoids needlessly\r\nindirect code, and enables tail call elimination in\r\nmore cases.\r\n\r\nAs an example, Scala 2.10.0 transforms the last\r\nmethod of the enclosed test case to:\r\n\r\n      try {\r\n        case <synthetic> val x1: Int = 1;\r\n        case5(){\r\n          if (2.==(x1))\r\n            {\r\n              val x2: Int = x1;\r\n              matchEnd4({\r\n                {\r\n                  def liftedTree2(): Unit = try {\r\n                    throw new scala.runtime.NonLocalReturnControl[Unit](nonLocalReturnKey1, ())\r\n                  } catch {\r\n                    case (e @ (_: ClassNotFoundException)) => ()\r\n                  };\r\n                  liftedTree2()\r\n                };\r\n                TailrecAfterTryCatch.this.bad()\r\n              })\r\n            }\r\n          else\r\n            case6()\r\n        };\r\n        case6(){\r\n          matchEnd4(throw new MatchError(x1))\r\n        };\r\n        matchEnd4(x: Unit){\r\n          x\r\n        }\r\n      } catch {\r\n        case (ex @ (_: scala.runtime.NonLocalReturnControl[Unit @unchecked])) => if (ex.key().eq(nonLocalReturnKey1))\r\n          ex.value()\r\n        else\r\n          throw ex\r\n      }\r\n\r\nAfter this patch:\r\n\r\n    @scala.annotation.tailrec final def bad(): Unit = {\r\n      case <synthetic> val x1: Int = 1;\r\n      case5(){\r\n        if (2.==(x1))\r\n          {\r\n            <synthetic> val x2: Int = x1;\r\n            matchEnd4({\r\n              try {\r\n                return ()\r\n              } catch {\r\n                case (e @ (_: ClassNotFoundException)) => ()\r\n              };\r\n              TailrecAfterTryCatch.this.bad()\r\n            })\r\n          }\r\n        else\r\n          case6()\r\n      };\r\n      case6(){\r\n        matchEnd4(throw new MatchError(x1))\r\n      };\r\n      matchEnd4(x: Unit){\r\n        x\r\n      }\r\n    }\r\n\r\nReview by @dragos"
1868,'paulp',"SI-6556 Remove unneeded workaround in erasure.\nIn fb6e687, a workaround was added, described as:\r\n\r\n> See SI-6556. It seems in some cases the result constructor\r\n> type of an anonymous class is a different version of the class.\r\n> This has nothing to do with value classes per se.\r\n> We simply used a less discriminating transform before, that\r\n> did not look at the cases in detail.\r\n> It seems there is a deeper problem here, which needs\r\n> following up to. But we will not risk regressions\r\n> in 2.10 because of it.\r\n\r\nI was expecting an arduous investigation into this,\r\nbut happilly the underlying problem was already solved\r\nin the fix for SI-6648 (1587a77e). (Chalk up another\r\nwin for libscala's scala-hash!)\r\n\r\nThis commit escalates the logging to an assertion.\r\nIt _doesn't_ revert the other change in fb6e687,\r\nwhich introduced a case for RefinedType. Those lines\r\nare not needed to pass pos/t6556.scala, but I'll\r\ntake the decision to remove those lines under advisement\r\nof a reviewer.\r\n\r\nReview by @odersky\r\n\r\n  - Is this case now redundant? If not, what test case could we add to exercise it? https://github.com/retronym/scala/blob/cced84a3/src/reflect/scala/reflect/internal/transform/Erasure.scala#L217\r\n\r\nAnd by @adriaanm for a call on `2.10.x` vs `master`."
1864,'paulp','SI-4859 Step back from mis-optimizations in qualifiers\nRetargetting #1710 to master.\r\n\r\nWidespread, invalid qualifier discarding in the apparent name of performance led to a variety of problems:\r\n\r\nThe compiler would crash in case of:\r\n\r\n    OuterCaseClass().InnerCaseClass()\r\n\r\nAnd the side effect would be elided in:\r\n\r\n    { println("!!"); Outer}.Inner\r\n\r\nThis change fixes these problems but stops short of fixing the last problem:\r\n\r\n    Outer.Inner.foo // module load of Outer is still elided.\r\n\r\nThis could be fixed use a stronger condition than `isExprSafeToInline` throughout this patch. (It would be `isExprSafeToElide` or `isPure`.)\r\n\r\nThoughts? Should that change be tackled in this ticket or separately?\r\n\r\nLast time, @paulp [opined](https://github.com/scala/scala/pull/1710#discussion_r2458429):\r\n\r\n> I don\'t see how we can fail to initialize Outer here if we wish to have at all predictable semantics.\r\n\r\nReview by @paulp @magarcia'
1863,'adriaanm','SI-6641 Deprecate SwingWorker\nSee discussion: #1862\r\n\r\nReview by @adriaanm'
1862,'adriaanm',"SI-6641 Cull scala.swing.SwingWorker\nIt appears to do nothing much at all, refers to the now-deprecated\r\nscala.actor package, and has a name clash with an important class\r\nfrom java.swing.\r\n\r\nNote that the POM for scala-swing does not declare the dependency.\r\n\r\nThe final nail in the coffin is it aides and abets the crash in\r\nthe crash in SI-6440.\r\n\r\nAttempts to remove or even deprecate this in 2.10.0 were\r\nmissed the boat.\r\n\r\nThis commit removes them for 2.11.0, in contravention of\r\nthe deprecation policy. Given that they rely on the\r\nscala-actors module which _is_ deprecated in 2.10.0,\r\nand will likely be removed in 2.11.0, I contend that\r\nthis is a reasonable exception.\r\nActor.scala\r\n\r\nAnother shot at #1603. \r\n\r\nI will submit another PR (#1863) to deprecate in 2.10.1, which doesn't absolve us of our sins, but seems like the right thing to do.\r\n\r\nReview by @adriaanm."
1857,'adriaanm','SI-6443 Widen dependent param types in uncurry\nBridge building operates on unusual method signatures:\r\nafter uncurry, so parameter lists are collapsed; but before\r\nerasure, so dependently typed parameters are still around.\r\n\r\nOriginal:\r\n\r\n    def foo(a: T)(b: a.type, c: a.U): Unit\r\n\r\nDuring computeBridges:\r\n\r\n    (a: T, b: a.type, c: a.U)Unit\r\n\r\nThis signature no longer appears to override the corresponding\r\none in a superclass, because the types of `b` and `c` are dependent\r\non method parameters.\r\n\r\nThe root of the problem is uncurry, which leaves the trees in\r\na poor state. This commit changes uncurry to remedy this.\r\n\r\nAn example illustrates it best:\r\n\r\n    // source\r\n    def foo(a: A)(b: a.type): b.type = b\r\n\r\n    // post uncurry before this patch.\r\n    // not well typed code!\r\n    def foo(a: A, b: a.type): b.type = {\r\n\r\n    // post uncurry after this patch\r\n    def foo(a: A, b: A): b.type = {\r\n       val b$1 = b.asInstanceOf[a.type]\r\n       b$1\r\n    }\r\n\r\nThis PR replaces #1696, and also closes SI-6135\r\n\r\nReview by @adriaanm'
1856,'jsuereth','sbt-git-plugin has moved.\nWe need to eliminate these sort of shifting sands to make\r\nthe SBT build a viable option.\r\n\r\nReview by @jsuereth. Should we switch to dependencies on binary releases of these plugins?'
1758,'adriaanm','When we strip tvars we should also recursively strip their instantiation...\n...s\r\n\r\nas they can be tvars as well.\r\nOtherwise our list of lub base types can be empty.\r\nAfter this fix value x3 in the test case compiles.\r\n\r\nreview by @adriaanm'
1738,'paulp',"DRYer crash reports.\n - Add the supplementary message only once per run, so we don't\n   output the same information as we bubble up through a sequence\n   of well-intentioned exception handlers.\n - In Driver, don't report message of a `FatalException`\n   immediately after reporting the message and stack trace.\n    - Rename `logThrowable` to `reportThrowable`, which is what it\n      actually does.\n\nThe difference in output is visible:\n\n  https://gist.github.com/4242138\n\nReview by @paulp.\n"
1737,'dragos','SI-6555 Better parameter name retention\nWe were losing track of parameter names in two places:\n\n  1. Uncurry was using fresh names for the apply method\n     parameters during Function expansion. (The parameter names\n     in the tree were actually correct, they just had synthetic\n     symbols with "x$1" etc.)\n  2. When adding specialized overrides, the parameter names\n     of the overriden method were used, rather than the parameter\n     names from the overriding method in the class to which we are\n     adding methods.\n\nThe upshot of this is that when you\'re stopped in the debugger in\nthe body of, say, `(i: Int) => i * i`, you see `v1` rather than `i`.\n\nThis commit changes Uncurry and SpecializeTypes to remedy this.\n\nReview by @dragos'
1711,'dragos','SI-1672 Catches are in tail position without finally.\nSo we can eliminate tail calls within.\n\nReview by @dragos, who once opined "I think this is safe as long as there is no `finally`".'
1710,'paulp','SI-4859 Don\'t rewrite CC().CC2() to new CC2\nWhere CC and CC2 are case classes. Attempting to do so leads to\r\na "no legal prefix" error.\r\n\r\nNow, we restrict this optimization (living in RefChecks ?!) to\r\ncase class applies with a "safe to inline" qualifier.\r\n\r\nReview by @paulp\r\n  - is `isExprSafeToInline` the right check here? I wasn\'t sure about that.\r\n  - I didn\'t go as far as adding a test to show that some rewriting still works. But via manual inspection: here\'s how the enclosed test case looks after `refchecks`.\r\n\r\n```scala\r\n  object O extends scala.AnyRef {\r\n    def <init>(): O.type = {\r\n      O.super.<init>();\r\n      ()\r\n    };\r\n    new C().CC.apply();\r\n    new D().DD.apply()\r\n  };\r\n```\r\n\r\n*Update*\r\n\r\nI also had to modify `Flatten` and `GenICode` to make sure we throw in:\r\n\r\n```scala\r\n{???; Predef}.DummyImplicit.dummyImplicit\r\n```\r\n\r\nand `DeadCodeElimination` to initialize object `Outer` in `Outer.Inner.foo`.'
1709,'adriaanm',"SI-3995 Exclude companions with an existential prefix.\nIn `(qual: Q).apply(expr)` where `expr` must be implictily\nconverted to a path dependent type `T` defined in `qual`,\nwe were looking for companion implicits via a path prefixed\nby an existential skolem `_1`. These aren't much good to us,\nas when we try to feed them into `mkAttributedQualifer`, a\ncrash rightly ensues.\n\nThis commit excludes companions prefixed by an existentially\nbound path.\n\nReview by @adriaanm"
1707,'adriaanm','SI-5390 Detect forward reference of case class apply\nRefchecks performs (among others) two tasks at once:\n\n  - detecting forward references\n  - translating `qual.Case(...)` to `new qual.Case(...)`\n\nAs is often the case with such multi-tasking tree traversals,\ncompletion of one task precluded the other.\n\nReview by @adriaanm\n\nOne question: should this also be a forward reference?\n\n```scala\nclass A {\n  case class B[A](s: String)\n}\n\nobject X {\n  def foo {\n    val a = new A\n    val b = new a.B[c.type]("")\n    val c = ""\n  }\n}\n```'
1706,'adriaanm','SI-5361 Avoid cyclic type with malformed refinement\nThe statement `val x = this` in the refinment type:\n\n    (new {}): {val x = this}\n\nis lazily typechecked, in order to, according to the comment\nin `typedRefinment, "avoid cyclic reference errors".\n\nBut the approximate type used ends up with:\n\n    Refinment@1(\n      parents = [...]\n      decls = { val x: Refinement@1 })\n\nThis commit eagerly checks that there is no term definitions\nin type refinments, rather than delaying this.\n\nThis changes the error message for SI-3614.\n\nReview by @adriaanm'
1704,'adriaanm',"Fix for rangepos crasher.\nwrapClassTagUnapply was generating an unpositioned tree\nwhich would crash under -Yrangepos.  See SI-6338 / SI-6754\n\nReview by @adriaanm (I've bumped this to a 2.10.0 blocker\nafter the reports or problems in the IDE with Akka.)\n\nCherry-pick from #1447."
1703,'adriaanm','SI-6528 Avoid loop in getClassParts.\nCarefully crafted types can lead to an endless stream of\ndistinct parts, differing only in different instantiations\nof an abstract type.\n\nThis commit substitutes abstract types with their upper bounds\nbefore determining if a type has already been seen.\n\nReview for correctness, completeness, and performance by @adriaanm.'
1701,'paulp','SI-5877 Support implicit classes in package objects\nThis used to crash, as both the package and the package object\nhad the synthetic method in `decls`, and the typer tried to add\nthe tree to both places.\n\nNow, synthetics in the package object are excluded from the pacakge\nitself.\n\nReview by @paulp'
1700,'paulp','SI-6535 Step back from the precipice of a cycle\nAdding any non-local parent to WrapAsScala will trigger a valid\ncyclic reference error. By moving the import of `Wrapper._`\ninside `WrapAsScala` and `WrapAsJava`, it is not in scope when\ntyping the parents of those, and we avoid the cycle.\n\nAdds a test case to show the essense of the promiscious mutual\nimports that triggers this.\n\nReview by @paulp'
1699,'paulp','SI-6549 Improve escaping in REPL codegen.\n- Escape the LHS of an assign when printing results\n   - e.g. X("").foo = bar\n - Escape val names\n   - e.g. val `"` = 0`\n\nReview by @paulp'
1697,'paulp',"Don't return unimportables from importedSymbol.\nHardening against the symptom of SI-6745, which yielded:\n\n    wat.scala:4: error: too many arguments for constructor Predef: ()object Predef\n      def this() = this(0)\n               ^\nThe fix for the underlying problem in that bug\nhas been targetted at branch 2.10.x.\n\nReview by @paulp.\n\nI was tempted to add a `devWarning` for this one, but before I did that I would need to check if we hit that code path under non-warnable circumstances."
1696,'odersky','SI-6135 SI-6443 Bridges for dependent method types\nBridge building operates on unusual method signatures:\nafter uncurry, so parameter lists are collapsed; but before\nerasure, so dependently typed parameters are still around.\n\nOriginal:\n\n    def foo(a: T)(b: a.type, c: a.U): Unit\n\nDuring computeBridges:\n\n    (a: T, b: a.type, c: a.U)Unit\n\nThis signature no longer appears to override the corresponding\none in a superclass, because the types of `b` and `c` are dependent\non method parameters.\n\nThis commit instead checks for overriding pairs with fully\ncurried signatures, such as:\n\n    (a: T)(b: a.type)(c: a.U)Unit\n\nExisting logic in [`matchesQuantified`](https://github.com/retronym/scala/blob/8e8aa4b1d/src/reflect/scala/reflect/internal/Types.scala#L6175), a local method in\n`matchesType`, then correctly substitutes the superclass signature\nparameter symbol into the subclass signature.\n\nReview by @odersky'
1695,'dragos','SI-6751 macroContext factory is now public\nIn order to make macro contexts customizable by the embedding environment\nsuch as an IDE.\n\nThe motivation for this commit was a request to expose an IDE-friendly\ndebug log API for macros. With macroContext being overridable (see the\ninstructions in the comments), we can recommend people to use c.info\nand then the IDE could override it and present it conveniently.'
1694,'jsuereth',"SI-6742 undeprecates certain manifest methods\nMakes sure all manifest-related (but not classmanifest-exclusive) APIs\nare undeprecated in 2.10. Let's hope we'll get them deprecated back\nagain in 2.11."
1689,'adriaanm','SI-6745 Skip refinements in the search for <init>\nThese arise in the base class sequence when a self type\nis annotated. This prevented an auxillary constructor from\ncalling the primary constructor.'
1676,'paulp','Adds a margin stripping string interpolator.\nJust for compiler internal use for now, despite some interest in a wider release on scala-internals. Let\'s take it for a spin internally before releasing it to the world.\n\nUnlike the previous incarnation, this now emulates `raw""` semantics -- string escape sequences are not processed. It doesn\'t make sense to use this interpolator with single quoted strings, so I think that\'s the correct way to go here.\n\nReview by @paulp'
1675,'odersky','SI-6667 Abort after any ambiguous in-scope implicit\nRather than continuing on to a search of implicits\nof the expected type.\n\nPreviously, the companion implicits were searched if the\nthe caller was running the implicit search in silent\nmode, for example if searching for an implicit parameter\nin an application which has an expected type.\n\nAfter this commit, the behaviour is consistent, regardless\non silent/non-silent typing.\n\nResubmission of #1659\n\nReview by @odersky\n\n/cc @xeno-by, who can perhaps shed light on why when I tried to shield `materializeImplicit` behind the same condition I got:\n\n```\nticket/6667 ~/code/scala ./test/partest test/files/run/macro-expand-tparams-prefix-c1 || cat test/files/run/macro-expand-tparams-prefix-c1-run.log \n\nTesting individual files\ntesting: [...]/files/run/macro-expand-tparams-prefix-c1               [FAILED]\n1 of 1 tests failed (elapsed time: 00:00:02)\nImpls_1.scala:7: error: ambiguous implicit values:\n both value V of type c.WeakTypeTag[V]\n and value T of type c.WeakTypeTag[T]\n match expected type c.WeakTypeTag[T]\n    c.Expr(Block(List(\n          ^\n```'
1659,'retronym',"SI-6667 Abort after any ambiguous in-scope implicit\nRather than continuing on to a search of implicits\nof the expected type, which used to happen if\nthe caller was running the implicit search in silent\nmode.\n\nI've discussed the change with @odersky.\n\nReview of the implementation by @adriaanm\n\n/cc @xeno-by: Note that tag generation is also now\nuniformly suppressed after any ambiguity error."
1655,'paulp','Margin stripping interpolator\nReview by the originator of the idea, @paulp'
1653,'jsuereth','SI-6695 Test case for fixed Array match bug\nAlready fixed for 2.10.0 by virtpatmat.\n\nReview by @jsuereth'
1643,'odersky','SI-6677 Insert required cast in `new qual.foo.T`\nShort version: we sometimes need to rewrite this as:\n\n    new T(qual.asInstanceOf[OwnerOfFoo].foo)\n\nLong version:\n\n`adaptMember` in Erasure performs a few tasks, among them:\n\n1. adding an empty argument list qualifiers in `new qual.T`\n    for which `qual` is a val template member that has\n    (post uncurry) a MethodType with an empty parameter list.\n\n    The same rewriting was already applied in uncurry for such\n    qualifiers appearing in other context, e.g. `qual.foo` was\n    already rewritten to `qual().foo`.\n2. casting, if necessary, the qualifier in `Select(qual, name)`\n    to the type of owner of the symbol that this selection\n    references.\n\n    This can be neccesary with compound types:\n     - some val class member has type `A with B`;\n     - we instantiate `new ab.valMemberOfB.T`\n     - we must pass `ab.valMemberOfB` to the constructor of `T`\n       as the `$outer` pointer\n     - we must cast `ab` to `B` before calling `valMemberOfB`.\n\n    Failure to insert this cast can lead to a LinkageError or\n    a VerifyError.\n\nHowever, if 1) was performed, 2) was not.\n\nThe error is pretty easy to trigger with the new reflection\nAPI:\n\n    class Test {\n      val cm: reflect.runtime.universe.Mirror\n          = reflect.runtime.currentMirror\n      def error {\n        new cm.universe.Traverser // java.lang.VerifyError\n      }\n\n      def okay1 {\n        val cm: reflect.runtime.universe.Mirror = reflect.runtime.currentMirror\n        new cm.universe.Traverser\n      }\n    }\n\nThe fix applied here to `adaptMember` mirrors the existing\nimplementation of `adaptType`.\n\nReview by @odersky'
1603,'jsuereth',"SI-6441 Cull scala.swing.SwingWorker\nIt appears to do nothing much at all, refers to the now-deprecated\r\nscala.actor package, and has a name clash with an important class\r\nfrom java.swing.\r\n\r\nNote that the POM for scala-swing does not declare the dependency.\r\n\r\nThe final nail in the coffin is it aides and abets the crash in\r\nthe crash in SI-6440.\r\n\r\nObviously removal of a class isn't binary compatible with 2.10.0.\r\nThings could play out a few ways:\r\n\r\n  - RC3 is required for some other reason, and this change is\r\n    admitted to 2.10.0\r\n  - Or, an exeption to the binary/source compatibility policy\r\n    is made for this class\r\n  - Or, this is deferred until 2.11.0, or at least until the\r\n    spin-off of scala-swing to a standalone repo.\r\n\r\nFor now, I'll submit this to 2.10.x for now and leave those\r\nchoices up to the release managers.\r\n\r\nReview by @ingoem, @jsuereth"
1595,'retronym',"Remove hostile code from explicitouter.\nIf that's the $outer accessor, what's that being created\r\nin newOuterAccessor? Sketchy, sketchy business."
1386,'gkossakowski','Better unchecked warnings.\n'
1193,'heathermiller',"SI-6280 Scaladoc: Reloading preserves anchors\nScaladoc redirects from */package.html pages to index.html with the\nqualified package name as the anchor. This is done to pop up the left\nnavigation panel whenever someone links directly to the page. (so\nusers may navigate the rest of the scaladoc pages)\n\nWhen linking members directly, one can use */package.html#<signature>,\nwhich translates to index.html#*.package@<signature>. The problem was\nthat the redirection javascript did not take the <signature> into\naccount, so it would redirect to the top of the package page instead\nof scrolling to the member.\n\nNote: this is a layout change, so there's no test for it."
1101,'adriaanm',"SI-5940 impls are no longer in macro def pickles\nThe first officially released version of macros persisted\nmacro def -> impl bindings across compilation runs using a neat trick.\n\nThe right-hand side of macro definition (which contains a reference to an impl)\nwas typechecked and then put verbatim into an annotation on macro definition.\n\nThis solution is very simple, but unfortunately it's also lacking. If we use it\nthen signatures of macro defs become transitively dependent on scala-reflect.jar\n(because they refer to macro impls, and macro impls refer to\nscala.reflect.macros.Context defined in scala-reflect.jar).\nMore details can be found in https://issues.scala-lang.org/browse/SI-5940.\n\nTherefore we have to avoid putting macro impls into binding pickles and\ncome up with our own serialization format. Situation is further complicated\nby the fact that it's not enough to just pickle impl's class and method names,\nbecause macro expansion needs knowledge about the shape of impl's signature\n(which we can't pickle). Hence we precompute necessary stuff (e.g. the layout\nof type parameters) when compiling macro defs."
1082,'paulp',"Removes AnyRef specialization from library\nAs discussed in #999, #1025 and\nhttps://groups.google.com/forum/?hl=en&fromgroups#!topic/scala-internals/5P5TS9ZWe_w\n\ninstrumented.jar is generated from the current source, there's no need\nfor a bootstrap commit.\n\nReview by @paulp."
1025,'paulp',"Hiding AnyRef specialization under a flag\nThe current AnyRef specialization is still fragile, so we'll let the\nusers choose whether to use it or not via the -Xanyref-specialization\ncompiler flag. Source code can always be compiled against a previously\nAnyRef-specialized classes, but will only be AnyRef-specialized itself\nif the flag is set.\n\nIn this patch, an anti-annotation is introduced to mark the fact that\nAnyRef specialization should be excluded (@specializedExcludeAnyRef).\nThis anti-specialization annotation is added automatically by the\ncompiler to all @specialized type parameters, iregardless of whether\nthe type parameter is going to be specialized on AnyRef or not. The\nreason is that the logic necessary to decode the types involved in the\nspecialization should not be moved outside SpecializeTypes.scala.\n\nOnce @specializedExcludeAnyRef is set (in superaccessors) and pickled\ninto the class file, all further scalac runs will specialize the\nsignature for all given types except AnyRef.\n\nThe instrument.jar archive is generated from the current source, thus\nthere's no need for an extra bootstrapping commit.\n\nReview by @paulp and @non."
1019,'lrytz','Fix failing nightly build on java7\nReview by @lrytz'
990,'heathermiller','SI-6140 Scaladoc infinite recursion in wiki parser\nintroduced by dc70d1b7.\n\nReview by @heathermiller.'
972,'jsuereth',"SI-6089 test file for pt2\ntest that matchEnd that's an argument of || that's in tail position is in tail position\n\nreview by @jsuereth"
963,'jsuereth','SI-6089 pt2: _ is tailpos in `_ || _` and `_ && _`\npull #939 made tail position detection for matches more strict to fix SI-6089,\nbut became too strict: need to include the tail positions `_` in `_ || _` and `_ && _`.\n\nreview by @jsuereth'
951,'odersky','SI-4440 phase constructors cannot drop outer accessors\nreview by @odersky, as this affects the constructors phase\n\nbefore, we would drop outer accessors from nested final classes if the outer-accessor wasn\'t accessed anywhere (for some limited definition of "accessed")\nhowever, for the sake of separate compilation and the outer checks inserted by the pattern matcher,\nwe need to assume they might be accessed anywhere\n\nthe alternative would be to omit the outer checks when the outer accessors aren\'t available\nthis is what the old pattern matcher did\n\npart 2:\ndon\'t check super-type args after erasure (parentTypes)\nthis is mostly to appease pos/z1730 (which runs with -Ycheck:all)\nafter fixing SI-4440, running parentTypes after constructors would fail\nnot running this check after erasure doesn\'t lose any precision\nsince all constructors will be type checked for real in typedTemplate anyway\n\nmore precisely, after constructors, can\'t type check primary ctor body in the ad-hoc context used in parentTypes, since it will have inserted assignments to the private[this] outer accessor,\nwhich will only type check when the ctor is type checked in the proper context\nhere, it\'s type checked in a context outside the class to avoid circular dependency errors'
925,'heathermiller',"Fixing a bunch of scaladoc issues\ncloses SI-3314, SI-4888, SI-5235, SI-5558, SI-4324, SI-5780, SI-4887, SI-3695, SI-4224, SI-4497, SI-5079, SI-6073, SI-5533, SI-5784\n\nand prepares scaladoc to properly handle reflection. Btw, this patch introduces good support for scaladoc links, so we shouldn't miss it for 2.10 ;)\n\nReview by @heathermiller and @cvogt"
906,'odersky',"Optimize findmember\nresubmission of #905\n\nFrom its description:\n\nfindMember takes about 30% of typechecking aggregate, 20% if we discount nested calls to asSeenFrom.\nI have tried ten different things to make it faster. The end result is less impressive than I had hoped for. I get about 16% reduction in wall-clock time for findMember, but my timings might be off. Still, every small improvement is worth it.\n\nI left all 10 changes as separate commits, so that we have a chance of measuring what works and what doesn't when Greg's benchmarking code is done.\n\nreview by @odersky "
901,'odersky','Removed AestheticSettings.\nReview by @odersky.'
888,'odersky','critical fixes to reflection\nreview by @odersky '
885,'heathermiller','Fix doc about specialized subclasses of c.i.HashMap/HashSet.\nThe documentation was wrong and judging from the “TODO: add HashMap2,\nHashMap3, ...” in the source file I refrained from mentioning any\nspecific number, so overall it has gotten a bit less precise, but\nhopefully more correct.\n\nReview: @heathermiller'
878,'odersky',"polymorphic value classes\nreview by @odersky, please, to ensure I didn't mess up the rebase of his original pull request"
876,'dragos',"SI-6011 switches: unreachability, guard-free form\nA complete overhaul. The original implementation in SI-5830 (#821) was pretty buggy.\n\nCollapse guarded cases that switch on the same constant (the last case may be unguarded).\n\nCases with patterns A and B switch on the same constant iff for all values x that match A also match B and vice versa.\n(This roughly corresponds to equality on trees modulo alpha renaming and reordering of alternatives.)\n\nThe rewrite only applies if some of the cases are guarded (this must be checked before invoking this method).\n\nThe rewrite proceeds by grouping the cases into subsequences of overlapping cases\n(since for any input, and when disregarding their guards, they either all match or they don't).\nThey are then merged into one case with their guards pushed into the body as follows (with P representing the overlapping pattern):\n\n`{case P if(G_i) => B_i }*` is rewritten to `case P => {if(G_i) B_i}*`\n\nThe rewrite fails (and returns Nil) when:\n  1. there is a subsequence of overlapping cases that has an unguarded case in the middle;\n     only the last case may be un-guarded\n\n  2. there are overlapping cases that differ (tested by `caseImplies`)\n     cases with patterns A and B are overlapping if for SOME value x, A matches x implies B matches y OR vice versa  <-- note the difference with case equality defined above\n     for example `case 'a' | 'b' =>` and `case 'b' =>` are different and overlapping (overlapping and equality disregard guards)\n\nAlso closes SI-6048 (duplicate)."
862,'jsuereth','SI-6052 - fix groupBy on parallel collections\nA critical patch.\n\nhttps://scala-webapps.epfl.ch/jenkins/job/scala-checkin-manual/202/console\n\nReview by @jsuereth'
859,'jsuereth',"moved cloneable to annotation package\nrequires new starr.\n\nreview by @jsuereth\n\nthe first commit allows building the new starr: just run the script `tools/new-starr` (i didn't have time to do that in ant right now..)\n\nthe second commit is the new starr and removes the temporary files in `src/starr`\n\n"
852,'paulp',"Shorter flattened names for nested $anons\n[scala-internals thread](https://groups.google.com/d/topic/scala-internals/M852v50Rrik/discussion)\n\nThe effect of the change is best described by the diff of [flatten.check](https://github.com/retronym/scala/commit/968909#diff-1)\n\nReview by @paulp, @odersky\n\n - Can you suggest additional interesting cases for test/files/run/flatten.scala?\n - Do we care that by unnesting the names we make it harder to mentally link the mangled name to its source code? (Incidentally, it would be great if we could teach YourKit to do this for us automatically, to save us either guessing / messing around with javap to figure it out).\n - I've done this for `$anonFun`, `$anon`: is there anything else that could have the same treatment?\n - The code to walk the `rawowner` chain was a bit fiddly to write and should be scrutinized. I didn't find an existing method on `Symbol` that did what I needed.\n\nReferences SI-3623."
851,'dragos',"Added a HIDDEN flag.\n[Still not a fan of the massive overlap between GenJVM and GenASM. I do\nnot think such duplication should be allowed into master at all, neither\nin experimental backends nor anywhere else. Putting us in the position\nthat we have to actually switch to stop incurring the duplication is\nengineering-by-prayer.]\n\nThe SYNTHETIC flag was long ago discovered to be inadequately specific\nto allow for emitting ACC_SYNTHETIC in bytecode. In this commit is born\na HIDDEN flag, which signals the flagged symbol as implementation detail\nwhich should not be considered during typechecking, and which will\nreceive ACC_SYNTHETIC during code generation.\n\nUnsure what should be hidden, I conservatively marked a few things which\nseem safely hidable.\n\n - $outer fields and accessors\n - classes whose classfile has the jvm Synthetic attribute\n   (not to be confused with the SYNTHETIC flag)\n\nI leave additional choices to those who have a better idea how\nthis will materialize (i.e. IDE guys.)\n\nIt is easy to selectively introduce this flag; but the SYNTHETIC flag\nis set or checked for in so many places, it is very difficult to alter\nthe logic around it (either by setting it less, or checking for HIDDEN\nonly) with much confidence. So right now HIDDEN is only used to help\nACC_SYNTHETIC make it into bytecode - it is only set in conjunction with\nSYNTHETIC, and it doesn't help anyone hide from the typechecker.\n\nReview by @dragos, @odersky."
847,'lrytz','SI-6028 Avoid needless symbol renaming in lambdalift\nPreserve names of all referenced free vars. This is achieved\nin a slightly roundabout manner:\n\n 1. they are renamed (as before this change)\n 2. the code that references them is lifted\n 3. the original names are restored.\n\nThe resulting natural beauty is evident in the [diff of t6028.check](https://github.com/retronym/scala/commit/22f2e355#diff-3).\n\nThis subsumes the treatment in 0e170e4 that ensured named parameter\ncalls cannot see mangled names; pos/t6028 confirms as much.\n\nReview by @lrytz'
837,'paulp',"SI-6022 model type-test-implication better -- review by @paulp\nwe use subtyping as a model for implication between instanceof tests\ni.e., when S <:< T we assume x.isInstanceOf[S] implies x.isInstanceOf[T]\nunfortunately this is not true in general.\n\nSI-6022 expects instanceOfTpImplies(ProductClass.tpe, AnyRefClass.tpe), but\nProductClass.tpe <:< AnyRefClass.tpe does not hold because Product extends Any\n\nhowever, if x.isInstanceOf[Product] holds, so does x.isInstanceOf[AnyRef],\nand that's all we care about when modeling type tests"
834,'adriaanm','Fix SI-3836 not-really-ambiguous import detection.\nNormalize types before declaring that two imports are ambiguous,\nbecause they might be the same thing.  Review by @adriaanm.'
816,'heathermiller','Scaladoc diagrams (again)\nReview by:\n@kzys, @heathermiller '
811,'adriaanm','Closes SI-5687.\nRecover from early ErrorType assignment and\ndelay error reporting until refchecks,\nwhere it belongs. Review by @adriaanm.'
757,'lrytz',"Don't just swallow `Throwables` while parsing bytecode. Print a warning\n..and go on.\n\nThis has caused hours of debugging, only to find out that 'package X does not have a member Y' were caused by a `NullPointerException`."
743,'dragos','Fix SI-4541.\nCatch type errors when duplicating trees.\nIn this case, to access a protected member from a specialized\nclass is an error, so we would have to make the member public\nanyway.\nBetter it is then to report an error and have the user make the\nfield public explicitly.\n\nReview by @dragos.'
723,'dragos','Fix for java parser edge case.\nEmpty statements are A-OK.  Closes SI-5910.  Review by @dragos.'
712,'odersky','Issue/hardening compiling with newer sources\nA bunch of changes to make the compiler more robust when sources in the Scala library are newer than the corresponding classfiles.\n\nMost changes affect the presentation compiler, but they would help in normal builds as well. I broke it down in several small self-contained commits.\n\nreview by @odersky.'
711,'TiarkRompf',"Don't crash if cpsParam is not on the classpath.\nWhen checking if a piece of code needs the continuations plugin, the cpsParam classes may not be on the class path. Assume it does not need it in that case."
702,'adriaanm','Fix for reflection.  Review/Use by @adriaanm\n'
687,'lrytz',"SI-5892 Don't apply implicit class members in class type param annots\n - Abuse `Context#inSelfSuperCall` for this purpose.\n - Inline `createNamer` into `completerOf(tree, typeParams)`, remove impossible case,\n   and tweak inSelfSuperCall.\n\nI originally tried this change in `Typers#typedClassDef`. Perhaps that also needs\nto be addressed, but I couldn't motivate that with a failing test.\n\nThis problem can lead to cyclic inheritance errors, as was seen in Scalala.\n\nReview by @lrytz"
631,'odersky',"SI-5652 Mangle names of potentially public lambda lifted methods.\nThis can happen if they are accessed from an inner class. If a\nsubclass is happens to lift a public method to the same name,\na VerifyError ensues.\n\nThe enclosed tests:\n - demonstrate the absense of the VerifyError\n - show the names generated for the lifted methods (which are\n   unchanged if not called from an inner class, or if lifted\n   into a trait implementation class.)\n - ensure that the callers are rewritten to call the correct\n   method when multiple with the same name are lifted.\n\nIt's not ideal that this phase needs a priori knowledge of the\nlater phases to perform this mangling. A better fix would defer\nthis until the point when the methods are publicised, and leave\nthe unmangled private method in place and install an public,\nmangled forwarder.\n\nResubmission of #628; review by @paulp or @odersky."
595,'odersky','SI-3761: Overload resolution fails on by-name parameter\nMinimized. This version should help in review for correctness. No attempt is made to address holes in the spec or to correct indentation.\n\nWe saw Yellow Submarine over the weekend and I must have got carried away by the lyric, "There\'s nothing you can do that can\'t be done."\n\nWhen isAsSpecific checks if method m applies to args of types of\nformal params of m1, a by-name parameter was converted to its\nunderlying result type for the params (of m) but not the args (of m1).\nThis had the useful effect of making m(A) more specific than m(=>A),\nwhich is the specified prioritization for implicit views,\nbut also made m(=>A) and m(=>A, B*) ambiguous.  To handle this edge\ncase, the isCompatible test for A and =>A is made explicit, and\nby-name params are no longer converted.'
594,'odersky','Fixes SI-5603.\n'
585,'lrytz','SI-3761: Overload resolution fails on by-name parameter\nPreamble: passes ant test and ant nightly.  Build time is not slower. Tie-break by cbn is behind a -Yoption.\n\nFootnote: I tried retaining by-name during type inference, but that breaks a bound (in json.Parser, "null" ^^^ null becomes Parser[Nothing] instead of Parser[Null].  I don\'t see to the bottom there.  Continuing education.\n\nWhen isAsSpecific checks if method m applies to args of types of\nformal params of m1, a by-name parameter was converted to its\nunderlying result type for the params (of m) but not the args (of m1).\nThis had the useful effect of making m(A) more specific than m(=>A),\nbut also made m(=>A) and m(=>A, B*) ambiguous.  To handle this edge\ncase, the isCompatible test for A and =>A is made explicit, and\nby-name params are no longer converted.\n\nAn option -Yresolve-by-name is provided for the purpose of\nfavoring m(=>A) over m(A) when applied to (=>A).  This only happens\nfor "pass-by-name", when f(x: =>A) invokes g(x).  Because overload\nresolution does not normally consider the call site, this optional\nbehavior is not specified. (An analogous case under discussion,\nwhich is more specified: f(x: A) and f(y: B, C*) where B <: A,\nfor f(b) chooses the fixed-arity method, even though f(B) is more\nspecific than f(A); that is, the number of actual arguments is not\nan input to overload resolution.)\n\nThe mechanism for resolve-by-name is to convert cbn params to the\nunderlying type, which results in ties between m(A) and m(=>A),\nand then pick the method which exactly matches the call site with\nrespect to by-namedness.\n\nThe specified workaround for selecting overloaded f(=>A) is to\nput the definition in an interface (where it is not overloaded).'
4122,'adriaanm','SI-7459 Handle pattern binders used as prefixes in TypeTrees.\nMatch translation was incorrect for:\n\n    case t => new t.C\n    case D(t) => new d.C\n\nWe would end up with Types in TypeTrees referring to the wrong\nsymbols, e.g:\n\n    // t7459a.scala\n    ((x0$1: this.LM) => {\n      case <synthetic> val x1: this.LM = x0$1;\n      case4(){\n       matchEnd3(new tttt.Node[Any]())\n      };\n      matchEnd3(x: Any){\n        x\n    }\n\nOr:\n    // t7459b.scala\n     ((x0$1: CC) => {\n       case <synthetic> val x1: CC = x0$1;\n       case4(){\n         if (x1.ne(null))\n           matchEnd3(new tttt.Node[Any]())\n         else\n           case5()\n       };\n\nThis commit:\n\n  - Changes `bindSubPats` to traverse types, as well as terms,\n    in search of references to bound symbols\n  - Changes `Substitution` to reuse `Tree#substituteSymbols` rather\n    than the home-brew substitution from `Tree`s to `Tree`s, if the\n    `to` trees are all `Ident`s\n\nI had to dance around the awkward handling of "swatches" (exception\nhandlers that can be implemented with JVM native type switches) by\nduplicating trees to avoid seeing the results of `substituteSymbols`\nin `caseDefs` after we abandon that approach if we detect the\npatterns are too complex late in the game.\n\nI also had to add an escape hatch for the "type selection from\nvolatile type" check in the type checker. Without this, the\ntranslation of `pos/t7459c.scala`:\n\n    case <synthetic> val x1: _$1 = (null: Test.Mirror[_]).universe;\n    case5(){\n      if (x1.isInstanceOf[Test.JavaUniverse])\n        {\n          <synthetic> val x2: _$1 with Test.JavaUniverse = (x1.asInstanceOf[_$1 with Test.JavaUniverse]: _$1 with Test.JavaUniverse);\n          matchEnd4({\n            val ju1: Test.JavaUniverse = x2;\n            val f: () => x2.Type = (() => (null: x2.TypeTag[Nothing]).tpe);\n\n.. triggers that error at `x2.TypeTag`.\n\nReview by @adriaanm. I think we can do better for 2.12 as we discussed in #3490.\nBut we should consider booking this progress.'
4112,'gkossakowski',"SI-8502 Improve resiliance to absent packages\nWhen unpickling a class, we create stub symbols for references\nto classes absent from the current classpath. If these references\nonly appear in method signatures that aren't called, we can\nproceed with compilation. This is in line with javac.\n\nWe're getting better at this, but there are still some gaps.\nThis bug is about the behaviour when a package is completely\nmissing, rather than just a single class within that package.\n\nTo make this work we have to add two special cases to the unpickler:\n\n  - When unpickling a `ThisType`, convert a `StubTermSymbol` into\n    a `StubTypeSymbol`. We hit this when unpickling\n    `ThisType(missingPackage)`.\n  - When unpickling a reference to `<owner>.name` where `<owner>`\n    is a stub symbol, don't call info on that owner, but rather\n    allow the enclosing code in `readSymbol` fall through to\n    create a stub for the member.\n\nThe test case was distilled from an a problem that a Spray user\nencountered when Akka was missing from the classpath.\n\nTwo existing test cases have progressed, and the checkfiles are\naccordingly updated.\n\nReview by @gkossakowski"
4107,'adriaanm','SI-7784 Allow a singleton type over a constant value defn.\nWhen typechecking a `SingletonTypeTree`, we must `deconst`\nthe type of the typechecked reference tree to avoid collapsing\n`a.type` into a constant type if `a` is a constant value definition.\n\nReview by @adriaanm\n\nThought this might be worth consideration in light of your SIP-23\nwork.'
4098,'Ichoran','SI-7128  copyToArray(xs, 0, 0) should not fail\nFixed all copyToArray methods to do exactly what the docs say\nthey do, with the least-suprise behavior of not throwing an\nexception if you ask to copy nothing (but would have copied\nout of range).\n\nIterator had an undocumented requirement for the target index\nto be in range regardless if anything happened; this has been\nremoved.'
4085,'adriaanm',"Suppress match analysis under -Xno-patmat-analysis\nNoSuppression doesn't suppress. FullSuppression does.\r\nNow using the latter when running under `-Xno-patmat-analysis`.\r\n\r\nI should really have tested. /me hides under a rock"
4078,'adriaanm','Avoid the `CNF budget exceeded` exception via smarter translation into CNF.\nThe exhaustivity checks in the pattern matcher build a propositional\r\nformula that must be converted into conjunctive normal form (CNF) in\r\norder to be amenable to the following DPLL decision procedure.\r\nHowever, the simple conversion into CNF via negation normal form and\r\nShannon expansion that was used has exponential worst-case complexity\r\nand thus even simple problems could become untractable.\r\n\r\nA better approach is to use a transformation into an _equisatisfiable_\r\nCNF-formula (by generating auxiliary variables) that runs with linear\r\ncomplexity. The commonly known Tseitin transformation uses bi-\r\nimplication. I have choosen for an enhancement: the Plaisted\r\ntransformation which uses implication only, thus the resulting CNF\r\nformula has (on average) only half of the clauses of a Tseitin\r\ntransformation.\r\n\r\nThe Plaisted transformation uses the polarities of sub-expressions to\r\nfigure out which part of the bi-implication can be omitted. However,\r\nif all sub-expressions have positive polarity (e.g., after\r\ntransformation into negation normal form) then the conversion is\r\nrather simple and the pseudo-normalization via NNF increases chances\r\nonly one side of the bi-implication is needed.\r\n\r\nI implemented only optimizations that had a substantial\r\neffect on formula size:\r\n- formula simplification, extraction of multi argument operands\r\n- if a formula is already in CNF then the Tseitin/Plaisted\r\n  transformation is omitted\r\n- Plaisted via NNF\r\n- omitted: (sharing of sub-formulas is also not implemented)\r\n- omitted: (clause subsumption)\r\n\r\nReview by @adriaanm '
3934,'lrytz','FSC server port selected by argument\nDiscussed for example in https://issues.scala-lang.org/browse/SI-4504\r\n\r\nLogic is following: If the existing -server argument has form localhost:port and there is no server running, then a new server is started at the given port. Therefore fsc can be used as without the server argument but fixing the port where to connect and start. If server argument points to another host server is not started.'
